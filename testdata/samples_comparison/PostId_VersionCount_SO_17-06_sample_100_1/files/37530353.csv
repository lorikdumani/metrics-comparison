Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
119279513;37530353;113216;2;3752cc87-d24d-4182-a2c4-8332f4cfe63f;2016-05-30 16:41:01.0;"I want to create custom request manager for crawler with dynamic waiting.  &#xD;&#xA;My crawler need to make requests to sites which prohibit parallel requests from same ip address. If such blocking occurs requests returns with HTTP error codes 403, 503, 429, etc.  &#xD;&#xA;In case of error I want to wait some time and repeat request. But for simplicity of parsers they just call get and receive correct page.  &#xD;&#xA;I want to use **aiohttp** and new **async with** syntax of **Python 3.5** so my parsers classes can use **async with** for my **requester** class same way if they used **aiohttp.ClientSession** like this:  &#xD;&#xA;<!-- language: python -->  &#xD;&#xA;&#xD;&#xA;    # somewhere in a parser&#xD;&#xA;    async def get_page(self, requester, page_index):&#xD;&#xA;      async with requester.get(URL_FMT.format(page_index)) as response:&#xD;&#xA;        html_content = await response.read()&#xD;&#xA;        result = self.parsing_page(html_content)&#xD;&#xA;        return result&#xD;&#xA;&#xD;&#xA;if **requester** is **aiohttp.ClientSession**, then **response** is **aiohtpp.ClientResponse** which have **__aenter__** and **__aexit__** methods, so **async with** working as expected.  &#xD;&#xA;But if I put my **requester** class in the middle it is not working anymore. It is looking like this.  &#xD;&#xA;&#xD;&#xA;    class Requester:&#xD;&#xA;       def __init__(self, session: aiohttp.ClientSession):&#xD;&#xA;         self.session = session&#xD;&#xA;      &#xD;&#xA;       async def get(self, *args, **kwargs):&#xD;&#xA;         is_result_successful = False&#xD;&#xA;         while not is_result_successful:&#xD;&#xA;           response = await self.session.get(*args, **kwargs)&#xD;&#xA;           if response.status in [503, 403, 429]:&#xD;&#xA;              await self.wait_some_time()&#xD;&#xA;           else:&#xD;&#xA;              is_result_successful = True&#xD;&#xA;         return response&#xD;&#xA;              &#xD;&#xA;From my understanding **self.session.get** is coroutine function so I will **await** it. Result is **aiohttp.ClientResponse** which have **__aenter__** or **__aexit__**. But if return it **parser**'s code of **async with** block return odd error.  &#xD;&#xA;  &#xD;&#xA;Can you say what I need to replace to with my **requester** class as with **aiohttp.ClientSession**?";;
119280556;37530353;113216;5;f2053ee2-e05d-49a5-9533-019310380fe5;2016-05-30 17:00:41.0;"I want to create custom request manager for crawler with dynamic waiting.  &#xD;&#xA;My crawler need to make requests to sites which prohibit parallel requests from same ip address. If such blocking occurs requests returns with HTTP error codes 403, 503, 429, etc.  &#xD;&#xA;In case of error I want to wait some time and repeat request. But for simplicity of parsers they just call get and receive correct page.  &#xD;&#xA;I want to use **aiohttp** and new **async with** syntax of **Python 3.5** so my parsers classes can use **async with** for my **requester** class same way if they used **aiohttp.ClientSession** like this:  &#xD;&#xA;<!-- language: python -->  &#xD;&#xA;&#xD;&#xA;    # somewhere in a parser&#xD;&#xA;    async def get_page(self, requester, page_index):&#xD;&#xA;      async with requester.get(URL_FMT.format(page_index)) as response:&#xD;&#xA;        html_content = await response.read()&#xD;&#xA;        result = self.parsing_page(html_content)&#xD;&#xA;        return result&#xD;&#xA;&#xD;&#xA;if **requester** is **aiohttp.ClientSession**, then **response** is **aiohtpp.ClientResponse** which have **__aenter__** and **__aexit__** methods, so **async with** working as expected.  &#xD;&#xA;But if I put my **requester** class in the middle it is not working anymore. &#xD;&#xA;&#xD;&#xA;    Traceback (most recent call last):&#xD;&#xA;      File ""/opt/project/api/tornado_runner.py"", line 6, in <module>&#xD;&#xA;        from api import app&#xD;&#xA;      File ""/opt/project/api/api.py"", line 20, in <module>&#xD;&#xA;        loop.run_until_complete(session.login())&#xD;&#xA;      File ""/usr/local/lib/python3.5/asyncio/base_events.py"", line 337, in run_until_complete&#xD;&#xA;        return future.result()&#xD;&#xA;      File ""/usr/local/lib/python3.5/asyncio/futures.py"", line 274, in result&#xD;&#xA;        raise self._exception&#xD;&#xA;      File ""/usr/local/lib/python3.5/asyncio/tasks.py"", line 239, in _step&#xD;&#xA;        result = coro.send(None)&#xD;&#xA;      File ""/opt/project/api/viudata/session.py"", line 72, in login&#xD;&#xA;        async with self.get('https://www.viudata.com') as resp:&#xD;&#xA;    AttributeError: __aexit__&#xD;&#xA;    Unclosed client session&#xD;&#xA;    client_session: <aiohttp.client.ClientSession object at 0x7f44f61ef240>&#xD;&#xA;&#xD;&#xA;It is looking like this.  &#xD;&#xA;&#xD;&#xA;    class Requester:&#xD;&#xA;       def __init__(self, session: aiohttp.ClientSession):&#xD;&#xA;         self.session = session&#xD;&#xA;      &#xD;&#xA;       async def get(self, *args, **kwargs):&#xD;&#xA;         is_result_successful = False&#xD;&#xA;         while not is_result_successful:&#xD;&#xA;           response = await self.session.get(*args, **kwargs)&#xD;&#xA;           if response.status in [503, 403, 429]:&#xD;&#xA;              await self.wait_some_time()&#xD;&#xA;           else:&#xD;&#xA;              is_result_successful = True&#xD;&#xA;         return response&#xD;&#xA;              &#xD;&#xA;From my understanding **self.session.get** is coroutine function so I will **await** it. Result is **aiohttp.ClientResponse** which have **__aenter__** or **__aexit__**. But if return it **parser**'s code of **async with** block return odd error.  &#xD;&#xA;  &#xD;&#xA;Can you say what I need to replace to with my **requester** class as with **aiohttp.ClientSession**?";;added 873 characters in body
