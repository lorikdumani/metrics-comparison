Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
137993917;42139774;7540445;2;d236c2ee-4219-40d4-8da9-35431dec0b93;2017-02-09 14:50:09.0;"I am doing a sample program with wait and notify but when notify is called more than one thread is wakes up instead of one.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;public class MyQueue<T> {&#xD;&#xA;&#xD;&#xA;	Object[] entryArr;&#xD;&#xA;	private volatile int addIndex;&#xD;&#xA;&#xD;&#xA;	private volatile int pending = -1;&#xD;&#xA;	private final Object lock = new Object();&#xD;&#xA;&#xD;&#xA;	private volatile long notifiedThreadId;&#xD;&#xA;	private int capacity;&#xD;&#xA;&#xD;&#xA;	public MyQueue(int capacity) {&#xD;&#xA;		entryArr = new Object[capacity];&#xD;&#xA;		this.capacity = capacity;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	public void add(T t) {&#xD;&#xA;		synchronized (lock) {&#xD;&#xA;			if (pending >= 0) {&#xD;&#xA;				try {&#xD;&#xA;					pending++;&#xD;&#xA;					lock.wait();&#xD;&#xA;					System.out.println(notifiedThreadId + "":"" + Thread.currentThread().getId());&#xD;&#xA;				} catch (InterruptedException e) {&#xD;&#xA;					e.printStackTrace();&#xD;&#xA;				}&#xD;&#xA;			} else if (pending == -1) {&#xD;&#xA;				pending++;&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		if (addIndex == capacity) { // its ok to replace existing value&#xD;&#xA;			addIndex = 0;&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		try {&#xD;&#xA;			entryArr[addIndex] = t;&#xD;&#xA;		} catch (ArrayIndexOutOfBoundsException e) {&#xD;&#xA;			System.out.println(""ARRAYException:"" + Thread.currentThread().getId() + "":"" + pending + "":"" + addIndex);&#xD;&#xA;			e.printStackTrace();&#xD;&#xA;		}&#xD;&#xA;&#xD;&#xA;		addIndex++;&#xD;&#xA;&#xD;&#xA;		synchronized (lock) {&#xD;&#xA;			if (pending > 0) {&#xD;&#xA;				pending--;&#xD;&#xA;				notifiedThreadId = Thread.currentThread().getId();&#xD;&#xA;				lock.notify();&#xD;&#xA;			} else if (pending == 0) {&#xD;&#xA;				pending--;&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;public class TestMyQueue {&#xD;&#xA;&#xD;&#xA;	public static void main(String args[]) {&#xD;&#xA;		final MyQueue<String> queue = new MyQueue<>(2);&#xD;&#xA;&#xD;&#xA;		for (int i = 0; i < 200; i++) {&#xD;&#xA;			Runnable r = new Runnable() {&#xD;&#xA;				@Override&#xD;&#xA;				public void run() {&#xD;&#xA;					for (int i = 0; i < Integer.MAX_VALUE; i++) {&#xD;&#xA;						queue.add(Thread.currentThread().getName() + "":"" + i);&#xD;&#xA;					}&#xD;&#xA;				}&#xD;&#xA;			};&#xD;&#xA;			Thread t = new Thread(r);&#xD;&#xA;			t.start();&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;After some time i see two threads being wake up by single thread.&#xD;&#xA;output:&#xD;&#xA;-----------&#xD;&#xA;91:114&#xD;&#xA;114:124&#xD;&#xA;124:198&#xD;&#xA;198:106&#xD;&#xA;106:202&#xD;&#xA;202:121&#xD;&#xA;121:40&#xD;&#xA;40:42&#xD;&#xA;42:83&#xD;&#xA;83:81&#xD;&#xA;81:17&#xD;&#xA;17:189&#xD;&#xA;189:73&#xD;&#xA;73:66&#xD;&#xA;66:95&#xD;&#xA;95:199&#xD;&#xA;199:68&#xD;&#xA;68:201&#xD;&#xA;201:70&#xD;&#xA;70:110&#xD;&#xA;110:204&#xD;&#xA;204:171&#xD;&#xA;171:87&#xD;&#xA;87:64&#xD;&#xA;64:205&#xD;&#xA;205:115&#xD;&#xA;&#xD;&#xA;Here i see 115 thread notified two thread and 84 thread notified two thread because of this we are seeing the ArrayIndexOutOfBoundsException. &#xD;&#xA;&#xD;&#xA;115:84&#xD;&#xA;&#xD;&#xA;115:111&#xD;&#xA;&#xD;&#xA;84:203&#xD;&#xA;&#xD;&#xA;84:200&#xD;&#xA;&#xD;&#xA;ARRAYException:200:199:3&#xD;&#xA;&#xD;&#xA;ARRAYException:203:199:3&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Could you please let me know what is the issue in the program?&#xD;&#xA;Thanks in advance";;
137997062;42139774;3700798;5;c2ddd3c2-e0be-401b-b40e-0f27363f636f;2017-02-09 15:23:03.0;"I am doing a sample program with wait and notify but when notify is called more than one thread is wakes up instead of one.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    public class MyQueue<T> {&#xD;&#xA;    &#xD;&#xA;    	Object[] entryArr;&#xD;&#xA;    	private volatile int addIndex;&#xD;&#xA;    &#xD;&#xA;    	private volatile int pending = -1;&#xD;&#xA;    	private final Object lock = new Object();&#xD;&#xA;    &#xD;&#xA;    	private volatile long notifiedThreadId;&#xD;&#xA;    	private int capacity;&#xD;&#xA;    &#xD;&#xA;    	public MyQueue(int capacity) {&#xD;&#xA;    		entryArr = new Object[capacity];&#xD;&#xA;    		this.capacity = capacity;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	public void add(T t) {&#xD;&#xA;    		synchronized (lock) {&#xD;&#xA;    			if (pending >= 0) {&#xD;&#xA;    				try {&#xD;&#xA;    					pending++;&#xD;&#xA;    					lock.wait();&#xD;&#xA;    					System.out.println(notifiedThreadId + "":"" + Thread.currentThread().getId());&#xD;&#xA;    				} catch (InterruptedException e) {&#xD;&#xA;    					e.printStackTrace();&#xD;&#xA;    				}&#xD;&#xA;    			} else if (pending == -1) {&#xD;&#xA;    				pending++;&#xD;&#xA;    			}&#xD;&#xA;    		}&#xD;&#xA;    &#xD;&#xA;    		if (addIndex == capacity) { // its ok to replace existing value&#xD;&#xA;    			addIndex = 0;&#xD;&#xA;    		}&#xD;&#xA;    &#xD;&#xA;    		try {&#xD;&#xA;    			entryArr[addIndex] = t;&#xD;&#xA;    		} catch (ArrayIndexOutOfBoundsException e) {&#xD;&#xA;    			System.out.println(""ARRAYException:"" + Thread.currentThread().getId() + "":"" + pending + "":"" + addIndex);&#xD;&#xA;    			e.printStackTrace();&#xD;&#xA;    		}&#xD;&#xA;    &#xD;&#xA;    		addIndex++;&#xD;&#xA;    &#xD;&#xA;    		synchronized (lock) {&#xD;&#xA;    			if (pending > 0) {&#xD;&#xA;    				pending--;&#xD;&#xA;    				notifiedThreadId = Thread.currentThread().getId();&#xD;&#xA;    				lock.notify();&#xD;&#xA;    			} else if (pending == 0) {&#xD;&#xA;    				pending--;&#xD;&#xA;    			}&#xD;&#xA;    		}&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public class TestMyQueue {&#xD;&#xA;    &#xD;&#xA;    	public static void main(String args[]) {&#xD;&#xA;    		final MyQueue<String> queue = new MyQueue<>(2);&#xD;&#xA;    &#xD;&#xA;    		for (int i = 0; i < 200; i++) {&#xD;&#xA;    			Runnable r = new Runnable() {&#xD;&#xA;    				@Override&#xD;&#xA;    				public void run() {&#xD;&#xA;    					for (int i = 0; i < Integer.MAX_VALUE; i++) {&#xD;&#xA;    						queue.add(Thread.currentThread().getName() + "":"" + i);&#xD;&#xA;    					}&#xD;&#xA;    				}&#xD;&#xA;    			};&#xD;&#xA;    			Thread t = new Thread(r);&#xD;&#xA;    			t.start();&#xD;&#xA;    		}&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;After some time i see two threads being wake up by single thread.&#xD;&#xA;output:&#xD;&#xA;&#xD;&#xA;    -----------&#xD;&#xA;    91:114&#xD;&#xA;    114:124&#xD;&#xA;    124:198&#xD;&#xA;    198:106&#xD;&#xA;    106:202&#xD;&#xA;    202:121&#xD;&#xA;    121:40&#xD;&#xA;    40:42&#xD;&#xA;    42:83&#xD;&#xA;    83:81&#xD;&#xA;    81:17&#xD;&#xA;    17:189&#xD;&#xA;    189:73&#xD;&#xA;    73:66&#xD;&#xA;    66:95&#xD;&#xA;    95:199&#xD;&#xA;    199:68&#xD;&#xA;    68:201&#xD;&#xA;    201:70&#xD;&#xA;    70:110&#xD;&#xA;    110:204&#xD;&#xA;    204:171&#xD;&#xA;    171:87&#xD;&#xA;    87:64&#xD;&#xA;    64:205&#xD;&#xA;    205:115&#xD;&#xA;&#xD;&#xA;Here I see 115 thread notified two thread and 84 thread notified two thread because of this we are seeing the `ArrayIndexOutOfBoundsException`.&#xD;&#xA;&#xD;&#xA;    115:84&#xD;&#xA;    &#xD;&#xA;    115:111&#xD;&#xA;    &#xD;&#xA;    84:203&#xD;&#xA;    &#xD;&#xA;    84:200&#xD;&#xA;    &#xD;&#xA;    ARRAYException:200:199:3&#xD;&#xA;    &#xD;&#xA;    ARRAYException:203:199:3&#xD;&#xA;&#xD;&#xA;Could you please let me know what is the issue in the program?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;Fixed code makup
137997064;42139774;4850040;5;b2006017-5266-4fb6-bfa3-239b39f2ed2a;2017-02-09 15:23:03.0;"I am doing a sample program with `wait()` and `notify()`, but when `notify()` is called, more than one thread is wakes up instead of one.&#xD;&#xA;&#xD;&#xA;The code is:&#xD;&#xA;&#xD;&#xA;    public class MyQueue<T> {&#xD;&#xA;    &#xD;&#xA;    	Object[] entryArr;&#xD;&#xA;    	private volatile int addIndex;&#xD;&#xA;    &#xD;&#xA;    	private volatile int pending = -1;&#xD;&#xA;    	private final Object lock = new Object();&#xD;&#xA;    &#xD;&#xA;    	private volatile long notifiedThreadId;&#xD;&#xA;    	private int capacity;&#xD;&#xA;    &#xD;&#xA;    	public MyQueue(int capacity) {&#xD;&#xA;    		entryArr = new Object[capacity];&#xD;&#xA;    		this.capacity = capacity;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	public void add(T t) {&#xD;&#xA;    		synchronized (lock) {&#xD;&#xA;    			if (pending >= 0) {&#xD;&#xA;    				try {&#xD;&#xA;    					pending++;&#xD;&#xA;    					lock.wait();&#xD;&#xA;    					System.out.println(notifiedThreadId + "":"" + Thread.currentThread().getId());&#xD;&#xA;    				} catch (InterruptedException e) {&#xD;&#xA;    					e.printStackTrace();&#xD;&#xA;    				}&#xD;&#xA;    			} else if (pending == -1) {&#xD;&#xA;    				pending++;&#xD;&#xA;    			}&#xD;&#xA;    		}&#xD;&#xA;    &#xD;&#xA;    		if (addIndex == capacity) { // its ok to replace existing value&#xD;&#xA;    			addIndex = 0;&#xD;&#xA;    		}&#xD;&#xA;    &#xD;&#xA;    		try {&#xD;&#xA;    			entryArr[addIndex] = t;&#xD;&#xA;    		} catch (ArrayIndexOutOfBoundsException e) {&#xD;&#xA;    			System.out.println(""ARRAYException:"" + Thread.currentThread().getId() + "":"" + pending + "":"" + addIndex);&#xD;&#xA;    			e.printStackTrace();&#xD;&#xA;    		}&#xD;&#xA;    &#xD;&#xA;    		addIndex++;&#xD;&#xA;    &#xD;&#xA;    		synchronized (lock) {&#xD;&#xA;    			if (pending > 0) {&#xD;&#xA;    				pending--;&#xD;&#xA;    				notifiedThreadId = Thread.currentThread().getId();&#xD;&#xA;    				lock.notify();&#xD;&#xA;    			} else if (pending == 0) {&#xD;&#xA;    				pending--;&#xD;&#xA;    			}&#xD;&#xA;    		}&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    public class TestMyQueue {&#xD;&#xA;    &#xD;&#xA;    	public static void main(String args[]) {&#xD;&#xA;    		final MyQueue<String> queue = new MyQueue<>(2);&#xD;&#xA;    &#xD;&#xA;    		for (int i = 0; i < 200; i++) {&#xD;&#xA;    			Runnable r = new Runnable() {&#xD;&#xA;    				@Override&#xD;&#xA;    				public void run() {&#xD;&#xA;    					for (int i = 0; i < Integer.MAX_VALUE; i++) {&#xD;&#xA;    						queue.add(Thread.currentThread().getName() + "":"" + i);&#xD;&#xA;    					}&#xD;&#xA;    				}&#xD;&#xA;    			};&#xD;&#xA;    			Thread t = new Thread(r);&#xD;&#xA;    			t.start();&#xD;&#xA;    		}&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;After some time, I see two threads being wake up by single thread.  The output looks like:&#xD;&#xA;&#xD;&#xA;    91:114&#xD;&#xA;    114:124&#xD;&#xA;    124:198&#xD;&#xA;    198:106&#xD;&#xA;    106:202&#xD;&#xA;    202:121&#xD;&#xA;    121:40&#xD;&#xA;    40:42&#xD;&#xA;    42:83&#xD;&#xA;    83:81&#xD;&#xA;    81:17&#xD;&#xA;    17:189&#xD;&#xA;    189:73&#xD;&#xA;    73:66&#xD;&#xA;    66:95&#xD;&#xA;    95:199&#xD;&#xA;    199:68&#xD;&#xA;    68:201&#xD;&#xA;    201:70&#xD;&#xA;    70:110&#xD;&#xA;    110:204&#xD;&#xA;    204:171&#xD;&#xA;    171:87&#xD;&#xA;    87:64&#xD;&#xA;    64:205&#xD;&#xA;    205:115&#xD;&#xA;&#xD;&#xA;Here I see 115 thread notified two threads, and 84 thread notified two threads; because of this we are seeing the `ArrayIndexOutOfBoundsException`.&#xD;&#xA;&#xD;&#xA;    115:84&#xD;&#xA;    &#xD;&#xA;    115:111&#xD;&#xA;    &#xD;&#xA;    84:203&#xD;&#xA;    &#xD;&#xA;    84:200&#xD;&#xA;    &#xD;&#xA;    ARRAYException:200:199:3&#xD;&#xA;    &#xD;&#xA;    ARRAYException:203:199:3&#xD;&#xA;&#xD;&#xA;What is the issue in the program?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;Spelling and markdown
