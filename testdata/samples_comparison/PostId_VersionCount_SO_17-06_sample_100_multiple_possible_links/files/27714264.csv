Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
80693095;27714264;383904;2;7aa64320-0bf0-4791-93f7-ad15550290ae;2014-12-30 23:48:29.0;"You're running into a ***sub-pixel*** issue. Round your floated result&#xD;&#xA;&#xD;&#xA;This will fix your issue:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    var newHeight = Math.floor($ele.height() * scale);&#xD;&#xA;&#xD;&#xA;or this:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    var newHeight = parseInt($ele.height() * scale , 10);&#xD;&#xA;&#xD;&#xA;or this:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    var newHeight = $ele.height() * scale << 0;&#xD;&#xA;&#xD;&#xA;or this:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    var newHeight = $ele.height() * scale | 0;";;
80693374;27714264;383904;5;896c4462-c3b2-4cf3-b2f0-15e28bf5590d;2014-12-30 23:55:31.0;"You're running into a ***sub-pixel*** issue. Round your floated result&#xD;&#xA;&#xD;&#xA;Some examples:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    var newHeight = Math.floor($ele.height() * scale);&#xD;&#xA;&#xD;&#xA;or this:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    var newHeight = parseInt($ele.height() * scale , 10);&#xD;&#xA;&#xD;&#xA;or this:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    var newHeight = $ele.height() * scale << 0;&#xD;&#xA;&#xD;&#xA;or this:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    var newHeight = $ele.height() * scale | 0;";;deleted 11 characters in body
80693812;27714264;383904;5;164644e9-5dfc-4056-b66f-3140dedbcf39;2014-12-31 00:14:22.0;"You're running into a ***sub-pixel*** issue for your animated sprite.  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;You need to round your result to always match a single-sprite-frame-cell to a perfect ratio that will not lead to a (resized background-image) subpixel flaw between the frames. The resulting height should also be applied logically to the container.&#xD;&#xA;&#xD;&#xA;So always take into accound the number of frames and the total sprite height while doing your math.&#xD;&#xA;&#xD;&#xA;Or simply open your sprite in your editor and add 2 transparent pixels between every frame.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;deleted 25 characters in body
80694312;27714264;383904;5;fcea9835-5ef5-4303-b520-4be2a1c578e5;2014-12-31 00:30:48.0;"You're running into a ***sub-pixel*** issue for your (resized) animated sprite.  &#xD;&#xA;Here's the issue:*&#xD;&#xA;&#xD;&#xA;    // 25(frames) / 6025px(sprite-height) = 241px height&#xD;&#xA;    // now let's scale&#xD;&#xA;    var scale = 0.8;&#xD;&#xA;    console.log( (6025/25)*scale );     // 168.7px&#xD;&#xA;    // We cannot have subpixel values so let's floor the result:&#xD;&#xA;    console.log( (6025/25)*scale | 0 ); // 168px&#xD;&#xA;    // Now the main problem is: if we resize the background to 0.8 scale,&#xD;&#xA;    // will every frame's first pixel line inherit the previous frame (lower line)&#xD;&#xA;    // subpixel data?&#xD;&#xA;    // Most likely.&#xD;&#xA;&#xD;&#xA;Simply open your sprite in your editor and add 2 transparent pixels between every frame.  &#xD;&#xA;Otherwise...&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;You need to round your result to always match a sprite-frame to a perfect ratio that will not lead to a (resized background-image) sub-pixel flaw between the frames. The resulting height should also be applied logically to the container.&#xD;&#xA;&#xD;&#xA;So always take into accound the number of frames and the total sprite height while doing your math.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added 494 characters in body
80694638;27714264;383904;5;654f70b8-a295-460d-a3ba-568faccc473f;2014-12-31 00:40:51.0;"You're running into a ***sub-pixel*** issue for your (resized) animated sprite.  &#xD;&#xA;Here's the issue:*&#xD;&#xA;&#xD;&#xA;    // 25(frames) / 6025px(sprite-height) = 241px height&#xD;&#xA;    // now let's scale&#xD;&#xA;    var scale = 0.8;&#xD;&#xA;    console.log( (6025/25)*scale );     // 168.7px&#xD;&#xA;    // We cannot have subpixel values so let's floor the result:&#xD;&#xA;    console.log( (6025/25)*scale | 0 ); // 168px&#xD;&#xA;    // Now the main problem is: if we resize the background to 0.8 scale,&#xD;&#xA;    // will every frame's first pixel line inherit the previous frame (lower line)&#xD;&#xA;    // subpixel data?&#xD;&#xA;    // Most likely.&#xD;&#xA;&#xD;&#xA;Simply open your sprite in your editor and add `(round even) 2*expected-min-scale` transparent pixels between every frame.  &#xD;&#xA;Otherwise...&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;You need to round your result to always match a sprite-frame to a perfect ratio that will not lead to a (resized background-image) sub-pixel flaw between the frames. The resulting height should also be applied logically to the container.&#xD;&#xA;&#xD;&#xA;So always take into accound the number of frames and the total sprite height while doing your math.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;edited body
80695218;27714264;383904;5;43202fa5-fd5b-4ed2-90af-a29c44467aa4;2014-12-31 01:03:34.0;"You're running into a ***sub-pixel*** issue for your (resized) animated sprite.  &#xD;&#xA;Here's the issue:*&#xD;&#xA;&#xD;&#xA;    // 25(frames) / 6025px(sprite-height) = 241px frame height&#xD;&#xA;    // now let's scale&#xD;&#xA;    var scale = 0.8;&#xD;&#xA;    console.log( (6025/25)*scale );     // 168.7px&#xD;&#xA;    // We cannot have subpixel values so let's floor the result:&#xD;&#xA;    console.log( (6025/25)*scale | 0 ); // 168px&#xD;&#xA;    // Still, the main problem is: if we resize the background to 0.8 scale,&#xD;&#xA;    // will every frame's first pixel line inherit the &#xD;&#xA;    // previous frame (lower line) sub-pixel data?&#xD;&#xA;    // Most likely.&#xD;&#xA;&#xD;&#xA;Simply open your sprite in your editor and add `2 * expected-min-scale (round to even)` transparent pixels between every frame.  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;deleted 358 characters in body
80697951;27714264;383904;5;fddcbecd-9fbf-46de-9e4c-d475b09ad7d6;2014-12-31 02:52:45.0;"You're running into a ***sub-pixel*** issue for your (resized) animated sprite due to floated number.  &#xD;&#xA;&#xD;&#xA;*Floor* the result value: ***[jsFiddle demo][1]***&#xD;&#xA;&#xD;&#xA;    var sprite_height_scaled = (animation.originalHeight * scale) << 0;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;(the above `<<` is the fastest one; you can also use one of this:)&#xD;&#xA;&#xD;&#xA;<!&#xD;&#xA;&#xD;&#xA;    (animation.originalHeight * scale) | 0&#xD;&#xA;&#xD;&#xA;<!&#xD;&#xA;&#xD;&#xA;    parseInt(animation.originalHeight * scale, 10)&#xD;&#xA;&#xD;&#xA;<!&#xD;&#xA;&#xD;&#xA;    Math.floor(animation.originalHeight * scale, 10)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;If it still appears here's another aspect of the issue:*&#xD;&#xA;&#xD;&#xA;    // 25(frames) / 6025px(sprite-height) = 241px frame height&#xD;&#xA;    // now let's scale&#xD;&#xA;    var scale = 0.8;&#xD;&#xA;    console.log( (6025/25)*scale );     // 168.7px&#xD;&#xA;    // We cannot have subpixel values so let's floor the result:&#xD;&#xA;    console.log( (6025/25)*scale | 0 ); // 168px&#xD;&#xA;    // Still, the main problem is: if we resize the background to 0.8 scale,&#xD;&#xA;    // will every frame's first pixel line inherit the &#xD;&#xA;    // previous frame (lower line) sub-pixel data?&#xD;&#xA;    // Most likely.&#xD;&#xA;&#xD;&#xA;Than simply open your sprite in your editor and add `2 * expected-min-scale (round to even)` transparent pixels between every frame.  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://jsfiddle.net/0twovu8x/";;added 572 characters in body
