Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
78978358;27271962;778876;2;1a179978-8c38-4ebd-887e-df9aeb3ee410;2014-12-03 12:37:43.0;"I'm trying to consume a service (built and hosted in Java) using WCF which has the following XSD contained&#xD;&#xA;`    <xs:simpleType name=""SimpleByteType"">&#xD;&#xA;	<xs:restriction base=""xs:unsignedByte""/>&#xD;&#xA;</xs:simpleType>&#xD;&#xA;<xs:complexType name=""ArrayOfBytes"">&#xD;&#xA;	<xs:sequence>&#xD;&#xA;		<xs:element name=""SimpleByteType-item"" type=""tns:SimpleByteType"" />&#xD;&#xA;	</xs:sequence>&#xD;&#xA;</xs:complexType>	&#xD;&#xA;<xs:element name=""ArrayOfBytes"" nillable=""true"" type=""tns:ArrayOfBytes""/>`&#xD;&#xA;&#xD;&#xA;When I request data from this service I get the following error:&#xD;&#xA;> ""Base64 sequence length (1) not valid. Must be a multiple of 4.""&#xD;&#xA;&#xD;&#xA;This is odd as the xml that is returned is something like this:&#xD;&#xA;&#xD;&#xA;    <ArrayOfBytes>&#xD;&#xA;      <SimpleByteType-item>0</SimpleByteType-item>&#xD;&#xA;      <SimpleByteType-item>1</SimpleByteType-item>&#xD;&#xA;      <SimpleByteType-item>2</SimpleByteType-item>&#xD;&#xA;    </ArrayOfBytes>&#xD;&#xA;&#xD;&#xA;So, it is not Base64 encoded at all. Apparently dotnet, consumes this xsd and makes it a byte[] which should contain base64 encoded data resulting in the error.&#xD;&#xA;&#xD;&#xA;Am I doing something wrong here, or is this a bug in the way WCF interprets the XSD? The proper identifier for base64 encode data would be a type base64Binary see: http://www.w3.org/2002/ws/databinding/examples/6/09/Base64BinaryElement/&#xD;&#xA;&#xD;&#xA;Another thing which leads me to think this is a bug is that changing the XSD (the restriction in it) from &#xD;&#xA;&#xD;&#xA;    &#xD;&#xA;	<xs:restriction base=""xs:unsignedByte""/>&#xD;&#xA;to&#xD;&#xA;&#xD;&#xA;    &#xD;&#xA;	<xs:restriction base=""unsignedInt""/>&#xD;&#xA;&#xD;&#xA;fixes the issue. Which obviously should have nothing to do with the content being base64 encoded or not.";;
78987758;27271962;778876;5;751ee941-92d6-4e99-9eaa-2aa2ab463028;2014-12-03 14:41:33.0;"I'm trying to consume a service (built and hosted in Java) using WCF which has the following XSD contained&#xD;&#xA;&#xD;&#xA;`<xs:simpleType name=""SimpleByteType"">&#xD;&#xA;	<xs:restriction base=""xs:unsignedByte""/>&#xD;&#xA;</xs:simpleType>&#xD;&#xA;<xs:complexType name=""ArrayOfBytes"">&#xD;&#xA;	<xs:sequence>&#xD;&#xA;		<xs:element name=""SimpleByteType-item"" type=""tns:SimpleByteType"" />&#xD;&#xA;	</xs:sequence>&#xD;&#xA;</xs:complexType>	&#xD;&#xA;<xs:element name=""ArrayOfBytes"" nillable=""true"" type=""tns:ArrayOfBytes""/>`&#xD;&#xA;&#xD;&#xA;When I request data from this service I get the following error:&#xD;&#xA;> ""Base64 sequence length (1) not valid. Must be a multiple of 4.""&#xD;&#xA;&#xD;&#xA;This is odd as the xml that is returned is something like this:&#xD;&#xA;&#xD;&#xA;    <ArrayOfBytes>&#xD;&#xA;      <SimpleByteType-item>0</SimpleByteType-item>&#xD;&#xA;      <SimpleByteType-item>1</SimpleByteType-item>&#xD;&#xA;      <SimpleByteType-item>2</SimpleByteType-item>&#xD;&#xA;    </ArrayOfBytes>&#xD;&#xA;&#xD;&#xA;So, it is not Base64 encoded at all. Apparently dotnet, consumes this xsd and makes it a byte[] which should contain base64 encoded data resulting in the error.&#xD;&#xA;&#xD;&#xA;Am I doing something wrong here, or is this a bug in the way WCF interprets the XSD? The proper identifier for base64 encode data would be a type base64Binary see: http://www.w3.org/2002/ws/databinding/examples/6/09/Base64BinaryElement/&#xD;&#xA;&#xD;&#xA;Another thing which leads me to think this is a bug is that changing the XSD (the restriction in it) from &#xD;&#xA;&#xD;&#xA;    &#xD;&#xA;	<xs:restriction base=""xs:unsignedByte""/>&#xD;&#xA;to&#xD;&#xA;&#xD;&#xA;    &#xD;&#xA;	<xs:restriction base=""unsignedInt""/>&#xD;&#xA;&#xD;&#xA;fixes the issue. Which obviously should have nothing to do with the content being base64 encoded or not.";;deleted 2 characters in body
