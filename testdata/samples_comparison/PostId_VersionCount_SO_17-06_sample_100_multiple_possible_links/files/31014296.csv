Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
93516705;31014296;256970;2;bc327a88-9cdd-4ade-b8b1-64571f46540d;2015-06-23 22:01:23.0;"For:&#xD;&#xA;&#xD;&#xA;    class A; end&#xD;&#xA;&#xD;&#xA;    A.instance_eval do&#xD;&#xA;      puts ""self=#{self}""&#xD;&#xA;      def m; puts ""hi""; end&#xD;&#xA;      define_method(:n) {puts ""ho"" }&#xD;&#xA;    end&#xD;&#xA;      #=> ""self=A""&#xD;&#xA;&#xD;&#xA;we find that:&#xD;&#xA;&#xD;&#xA;    A.methods(false)          #=> [:m] &#xD;&#xA;    A.instance_methods(false) #=> [:n] &#xD;&#xA;    A.m                       # hi&#xD;&#xA;    A.n                       # NoMethodError:...&#xD;&#xA;    A.new.m                   # NoMethodError:...&#xD;&#xA;    A.new.n                   # ho&#xD;&#xA;&#xD;&#xA;`A.instance_eval` opens class `A` and method `m` is defined on `A`. It then executes [define_method](http://ruby-doc.org/core-2.2.0/Module.html#method-i-define_method) which creates the instance method `:n` on it's receiver, `A`.&#xD;&#xA;";;
93517106;31014296;256970;5;f098190e-445c-437c-8151-570c4b44fb92;2015-06-23 22:10:37.0;"For:&#xD;&#xA;&#xD;&#xA;    class A; end&#xD;&#xA;&#xD;&#xA;    A.instance_eval do&#xD;&#xA;      puts ""self=#{self}""&#xD;&#xA;      def m; puts ""hi""; end&#xD;&#xA;      define_method(:n) {puts ""ho"" }&#xD;&#xA;    end&#xD;&#xA;      #=> ""self=A""&#xD;&#xA;&#xD;&#xA;we find that:&#xD;&#xA;&#xD;&#xA;    A.methods(false)          #=> [:m] &#xD;&#xA;    A.instance_methods(false) #=> [:n] &#xD;&#xA;    A.m                       # hi&#xD;&#xA;    A.n                       # NoMethodError:...&#xD;&#xA;    A.new.m                   # NoMethodError:...&#xD;&#xA;    A.new.n                   # ho&#xD;&#xA;&#xD;&#xA;`A.instance_eval` opens class `A` and method `m` is defined on `A`. It then executes the method [define_method](http://ruby-doc.org/core-2.2.0/Module.html#method-i-define_method) which creates the instance method `:n` on it's receiver, `A`.&#xD;&#xA;&#xD;&#xA;Suppose we were to use [Module#class_eval](http://ruby-doc.org/core-2.2.0/Module.html#method-i-class_eval) rather than [BasicObject#instance_eval](http://ruby-doc.org/core-2.2.0/BasicObject.html#method-i-instance_eval):&#xD;&#xA;&#xD;&#xA;    A.class_eval do&#xD;&#xA;      puts ""self=#{self}""&#xD;&#xA;      def m; puts ""hi""; end&#xD;&#xA;      define_method(:n) {puts ""ho"" }&#xD;&#xA;    end&#xD;&#xA;      #=> ""self=A""&#xD;&#xA;&#xD;&#xA;we find that:&#xD;&#xA;&#xD;&#xA;    A.methods(false)          #=> [] &#xD;&#xA;    A.instance_methods(false) #=> [:m, :n] &#xD;&#xA;    A.m                       # NoMethodError:...&#xD;&#xA;    A.n                       # NoMethodError:...&#xD;&#xA;    A.new.m                   # hi&#xD;&#xA;    A.new.n                   # ho&#xD;&#xA;&#xD;&#xA;so you see that this behaviour is the same as:&#xD;&#xA;&#xD;&#xA;    class A&#xD;&#xA;      puts ""self=#{self}""&#xD;&#xA;      def m; puts ""hi""; end&#xD;&#xA;      define_method(:n) {puts ""ho"" }&#xD;&#xA;    end&#xD;&#xA;";;added 608 characters in body
93517345;31014296;256970;5;1a7c2f49-fad7-41bc-949a-058d4bccdf14;2015-06-23 22:16:41.0;"For:&#xD;&#xA;&#xD;&#xA;    class A; end&#xD;&#xA;&#xD;&#xA;    A.instance_eval do&#xD;&#xA;      puts ""self=#{self}""&#xD;&#xA;      def m; puts ""hi""; end&#xD;&#xA;      define_method(:n) {puts ""ho"" }&#xD;&#xA;    end&#xD;&#xA;      #=> ""self=A""&#xD;&#xA;&#xD;&#xA;we find that:&#xD;&#xA;&#xD;&#xA;    A.methods(false)          #=> [:m] &#xD;&#xA;    A.instance_methods(false) #=> [:n] &#xD;&#xA;    A.m                       # hi&#xD;&#xA;    A.n                       # NoMethodError:...&#xD;&#xA;    A.new.m                   # NoMethodError:...&#xD;&#xA;    A.new.n                   # ho&#xD;&#xA;&#xD;&#xA;`A.instance_eval` opens class `A` and the method `m` is defined on `A`. Next, the method [define_method](http://ruby-doc.org/core-2.2.0/Module.html#method-i-define_method) is then invoked, which creates the instance method `:n` on it's receiver, `A`.&#xD;&#xA;&#xD;&#xA;Suppose we were to use [Module#class_eval](http://ruby-doc.org/core-2.2.0/Module.html#method-i-class_eval) rather than [BasicObject#instance_eval](http://ruby-doc.org/core-2.2.0/BasicObject.html#method-i-instance_eval):&#xD;&#xA;&#xD;&#xA;    A.class_eval do&#xD;&#xA;      puts ""self=#{self}""&#xD;&#xA;      def m; puts ""hi""; end&#xD;&#xA;      define_method(:n) {puts ""ho"" }&#xD;&#xA;    end&#xD;&#xA;      #=> ""self=A""&#xD;&#xA;&#xD;&#xA;we find that:&#xD;&#xA;&#xD;&#xA;    A.methods(false)          #=> [] &#xD;&#xA;    A.instance_methods(false) #=> [:m, :n] &#xD;&#xA;    A.m                       # NoMethodError:...&#xD;&#xA;    A.n                       # NoMethodError:...&#xD;&#xA;    A.new.m                   # hi&#xD;&#xA;    A.new.n                   # ho&#xD;&#xA;&#xD;&#xA;so you see that this behaviour is the same as:&#xD;&#xA;&#xD;&#xA;    class A&#xD;&#xA;      puts ""self=#{self}""&#xD;&#xA;      def m; puts ""hi""; end&#xD;&#xA;      define_method(:n) {puts ""ho"" }&#xD;&#xA;    end&#xD;&#xA;";;deleted 1 character in body
93517601;31014296;256970;5;067c8966-71ae-483a-ba75-6328f63afa90;2015-06-23 22:23:07.0;"For:&#xD;&#xA;&#xD;&#xA;    class A; end&#xD;&#xA;&#xD;&#xA;    A.instance_eval do&#xD;&#xA;      puts ""self=#{self}""&#xD;&#xA;      def m; puts ""hi""; end&#xD;&#xA;      define_method(:n) {puts ""ho"" }&#xD;&#xA;    end&#xD;&#xA;      #=> ""self=A""&#xD;&#xA;&#xD;&#xA;we find that:&#xD;&#xA;&#xD;&#xA;    A.methods(false)          #=> [:m] &#xD;&#xA;    A.instance_methods(false) #=> [:n] &#xD;&#xA;    A.m                       # hi&#xD;&#xA;    A.n                       # NoMethodError:...&#xD;&#xA;    A.new.m                   # NoMethodError:...&#xD;&#xA;    A.new.n                   # ho&#xD;&#xA;&#xD;&#xA;`A.instance_eval` opens class `A` and the method `m` is defined on `A`. Next, the method [define_method](http://ruby-doc.org/core-2.2.0/Module.html#method-i-define_method) is then invoked, which creates the instance method `:n` on it's receiver, `A`.&#xD;&#xA;&#xD;&#xA;Suppose we were to use [Module#class_eval](http://ruby-doc.org/core-2.2.0/Module.html#method-i-class_eval) rather than [BasicObject#instance_eval](http://ruby-doc.org/core-2.2.0/BasicObject.html#method-i-instance_eval):&#xD;&#xA;&#xD;&#xA;    A.class_eval do&#xD;&#xA;      puts ""self=#{self}""&#xD;&#xA;      def m; puts ""hi""; end&#xD;&#xA;      define_method(:n) {puts ""ho"" }&#xD;&#xA;    end&#xD;&#xA;      #=> ""self=A""&#xD;&#xA;&#xD;&#xA;we find that:&#xD;&#xA;&#xD;&#xA;    A.methods(false)          #=> [] &#xD;&#xA;    A.instance_methods(false) #=> [:m, :n] &#xD;&#xA;    A.m                       # NoMethodError:...&#xD;&#xA;    A.n                       # NoMethodError:...&#xD;&#xA;    A.new.m                   # hi&#xD;&#xA;    A.new.n                   # ho&#xD;&#xA;&#xD;&#xA;so you see that this behaviour is the same as:&#xD;&#xA;&#xD;&#xA;    class A&#xD;&#xA;      puts ""self=#{self}""&#xD;&#xA;      def m; puts ""hi""; end&#xD;&#xA;      define_method(:n) {puts ""ho"" }&#xD;&#xA;    end&#xD;&#xA;&#xD;&#xA;and here instance methods can be defined with either `def` or `define_method`.";;added 80 characters in body
