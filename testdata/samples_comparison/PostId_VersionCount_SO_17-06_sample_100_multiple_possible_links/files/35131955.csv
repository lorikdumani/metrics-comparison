Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
109788353;35131955;1913824;2;cca8b8b0-163a-4011-9269-0d0f3808584b;2016-02-01 13:38:02.0;"Your examples are too simplistic. Consider this:&#xD;&#xA;&#xD;&#xA;    >>> nums = [1, 2, 3, 4, 5, 6]&#xD;&#xA;    >>> nums_it = (n for n in nums)&#xD;&#xA;&#xD;&#xA;`l1` is a generator that returns all items unmodified from `nums`. Clearly you do not have any advantage. But consider this:&#xD;&#xA;&#xD;&#xA;    >>> squares_it = (n ** 2 for n in nums)&#xD;&#xA;&#xD;&#xA;And compare it with:&#xD;&#xA;&#xD;&#xA;    >>> squares_lst = [n ** 2 for n in nums]&#xD;&#xA;&#xD;&#xA;With `squares_it`, we are generating the squares of `nums` on the fly only when requested. With `squares_lst`, we are generating all of them at once and storing them in a new list.";;
109788801;35131955;1913824;5;21a2db99-bee9-41fe-a1d7-0d392cebfa13;2016-02-01 13:44:21.0;"Your examples are too simplistic. Consider this:&#xD;&#xA;&#xD;&#xA;    nums = [1, 2, 3, 4, 5, 6]&#xD;&#xA;    nums_it = (n for n in nums)&#xD;&#xA;&#xD;&#xA;`nums_it` is a generator that returns all items unmodified from `nums`. Clearly you do not have any advantage. But consider this:&#xD;&#xA;&#xD;&#xA;    squares_it = (n ** 2 for n in nums)&#xD;&#xA;&#xD;&#xA;and compare it with:&#xD;&#xA;&#xD;&#xA;    squares_lst = [n ** 2 for n in nums]&#xD;&#xA;&#xD;&#xA;With `squares_it`, we are generating the squares of `nums` on the fly only when requested. With `squares_lst`, we are generating all of them at once and storing them in a new list.&#xD;&#xA;&#xD;&#xA;So, when you do:&#xD;&#xA;&#xD;&#xA;    for n in squares_it:&#xD;&#xA;        print(n)&#xD;&#xA;&#xD;&#xA;it's like if you were doing:&#xD;&#xA;&#xD;&#xA;    for n in nums:&#xD;&#xA;        print(n ** 2)&#xD;&#xA;&#xD;&#xA;But when you do:&#xD;&#xA;&#xD;&#xA;    for n in squares_lst:&#xD;&#xA;        print(n)&#xD;&#xA;&#xD;&#xA;it's like if you were doing:&#xD;&#xA;&#xD;&#xA;    squares_lst = []&#xD;&#xA;    for n in nums:&#xD;&#xA;        squares_lst.append(n ** 2)&#xD;&#xA;    for n in squares_lst:&#xD;&#xA;        print(n)&#xD;&#xA;&#xD;&#xA;Generators and iterators also provide another significant advantage (which may actually be a disadvantage, depending on the situation): they are evaluated lazily.&#xD;&#xA;&#xD;&#xA;Also, generators and iterators may yield an infinite number of elements. An example is [`itertools.count()`](https://docs.python.org/3/library/itertools.html#itertools.count) that yields 0, 1, 2, 3, ... without never ending.";;added 351 characters in body
109793972;35131955;1913824;5;0c86e111-2e13-4578-a6db-d47220a4f820;2016-02-01 14:45:21.0;"Your examples are too simplistic. Consider this:&#xD;&#xA;&#xD;&#xA;    nums = [1, 2, 3, 4, 5, 6]&#xD;&#xA;    nums_it = (n for n in nums)&#xD;&#xA;&#xD;&#xA;`nums_it` is a generator that returns all items unmodified from `nums`. Clearly you do not have any advantage. But consider this:&#xD;&#xA;&#xD;&#xA;    squares_it = (n ** 2 for n in nums)&#xD;&#xA;&#xD;&#xA;and compare it with:&#xD;&#xA;&#xD;&#xA;    squares_lst = [n ** 2 for n in nums]&#xD;&#xA;&#xD;&#xA;With `squares_it`, we are generating the squares of `nums` on the fly only when requested. With `squares_lst`, we are generating all of them at once and storing them in a new list.&#xD;&#xA;&#xD;&#xA;So, when you do:&#xD;&#xA;&#xD;&#xA;    for n in squares_it:&#xD;&#xA;        print(n)&#xD;&#xA;&#xD;&#xA;it's like if you were doing:&#xD;&#xA;&#xD;&#xA;    for n in nums:&#xD;&#xA;        print(n ** 2)&#xD;&#xA;&#xD;&#xA;But when you do:&#xD;&#xA;&#xD;&#xA;    for n in squares_lst:&#xD;&#xA;        print(n)&#xD;&#xA;&#xD;&#xA;it's like if you were doing:&#xD;&#xA;&#xD;&#xA;    squares_lst = []&#xD;&#xA;    for n in nums:&#xD;&#xA;        squares_lst.append(n ** 2)&#xD;&#xA;    for n in squares_lst:&#xD;&#xA;        print(n)&#xD;&#xA;&#xD;&#xA;If you don't need (or don't have) the list `nums`, then you can save even more space by using:&#xD;&#xA;&#xD;&#xA;    squares_it = (n ** 2 for n in xrange(1, 7))&#xD;&#xA;&#xD;&#xA;Generators and iterators also provide another significant advantage (which may actually be a disadvantage, depending on the situation): they are evaluated lazily.&#xD;&#xA;&#xD;&#xA;Also, generators and iterators may yield an infinite number of elements. An example is [`itertools.count()`](https://docs.python.org/3/library/itertools.html#itertools.count) that yields 0, 1, 2, 3, ... without never ending.";;added 149 characters in body
