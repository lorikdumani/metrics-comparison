Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
145873356;44095400;5705247;2;0c6a8ed4-62fb-435f-b71f-27102eeb5012;2017-05-21 09:48:13.0;"I'm trying to understand clojure `lazy-seq` keyword, and concept of lazy evaluation in general. I know the basic idea behind the concept: Evaluation of expression is delayed until the value is needed. In general, this is achievable in two ways:&#xD;&#xA;&#xD;&#xA;- At compile time using macros or special keywords&#xD;&#xA;- At runtime using lambda functions&#xD;&#xA;&#xD;&#xA;With lazy evaluation techniques, it is possible to construct infinite data structures, which are evaluated as consumed. These infinite sequences utilizes lambdas, closures and recursion. In clojure these infinite data structures are generated using `lazy-seq` and `cons` forms.&#xD;&#xA;&#xD;&#xA;I want to understand how `lazy-seq` does it's magic. I know it is actually a macro. Consider the following example.&#xD;&#xA;&#xD;&#xA;    (defn rep [n]&#xD;&#xA;      (lazy-seq (cons n (rep n))))&#xD;&#xA;&#xD;&#xA;Here `rep` function returns a lazily evaluated list of type `LazySeq`, which now can be transformed and consumed (thus evaluated) using seq API. This API provides functions `take`, `map`, `filter` and `reduce`.&#xD;&#xA;&#xD;&#xA;In the expanded form we can see how lambda is utilized to store the recipe for the cell without evaluating it immediately.&#xD;&#xA;&#xD;&#xA;    (defn rep [n]&#xD;&#xA;      (new clojure.lang.LazySeq (fn* [] (cons n (rep n))))) &#xD;&#xA;&#xD;&#xA;But how does the seq API actually works with `LazySeq`? What actually happens in the following expression?&#xD;&#xA;&#xD;&#xA;    (reduce + (take 3 (map inc (rep 5))))&#xD;&#xA;&#xD;&#xA;How is the intermediate operation `map` applied to seq, how `take` limits the seq and how terminal operation `reduce` evaluates the seq? Also how they work with either just a `Vector` and the `LazySeq`? &#xD;&#xA;&#xD;&#xA;Also, is it possible to generate nested infinite data structures? List containing lists, containing lists, containing lists... going infinitely wide and deep, evaluated as consumed with the seq API?&#xD;&#xA;&#xD;&#xA;And last question, is there any practical difference with this&#xD;&#xA;&#xD;&#xA;    (defn rep [n]&#xD;&#xA;      (lazy-seq (cons n (rep n))))&#xD;&#xA;&#xD;&#xA;and this?&#xD;&#xA;&#xD;&#xA;    (defn rep [n]&#xD;&#xA;      (cons n (lazy-seq (rep n))))";;
145964146;44095400;1562315;5;a1551e16-e097-49b0-862d-48995616096c;2017-05-22 16:49:44.0;"I'm trying to understand clojure's `lazy-seq` operator, and the concept of lazy evaluation in general. I know the basic idea behind the concept: Evaluation of an expression is delayed until the value is needed. &#xD;&#xA;&#xD;&#xA;In general, this is achievable in two ways:&#xD;&#xA;&#xD;&#xA;- at compile time using macros or special forms;&#xD;&#xA;- at runtime using lambda functions&#xD;&#xA;&#xD;&#xA;With lazy evaluation techniques, it is possible to construct infinite data structures that are evaluated as consumed. These infinite sequences utilizes lambdas, closures and recursion. In clojure, these infinite data structures are generated using `lazy-seq` and `cons` forms.&#xD;&#xA;&#xD;&#xA;I want to understand how `lazy-seq` does it's magic. I know it is actually a macro. Consider the following example.&#xD;&#xA;&#xD;&#xA;    (defn rep [n]&#xD;&#xA;      (lazy-seq (cons n (rep n))))&#xD;&#xA;&#xD;&#xA;Here, the `rep` function returns a lazily-evaluated sequence of type `LazySeq`, which now can be transformed and consumed (thus evaluated) using the sequence API. This API provides functions `take`, `map`, `filter` and `reduce`.&#xD;&#xA;&#xD;&#xA;In the expanded form, we can see how lambda is utilized to store the recipe for the cell without evaluating it immediately.&#xD;&#xA;&#xD;&#xA;    (defn rep [n]&#xD;&#xA;      (new clojure.lang.LazySeq (fn* [] (cons n (rep n))))) &#xD;&#xA;&#xD;&#xA; - But *how does the sequence API actually work with `LazySeq`*?&#xD;&#xA; - *What actually happens in the following expression*?&#xD;&#xA;&#xD;&#xA;`(reduce + (take 3 (map inc (rep 5))))`&#xD;&#xA;&#xD;&#xA; - *How is the intermediate operation `map` applied to the sequence*,&#xD;&#xA; - *how does `take` limit the sequence* and&#xD;&#xA; - *how does terminal operation `reduce` evaluate the sequence*?&#xD;&#xA;&#xD;&#xA;Also, *how do these functions work with either a `Vector` or a `LazySeq`*? &#xD;&#xA;&#xD;&#xA;Also, *is it possible to generate nested infinite data structures*?: list containing lists, containing lists, containing lists... going infinitely wide and deep, evaluated as consumed with the sequence API?&#xD;&#xA;&#xD;&#xA;And last question, *is there any practical difference between this*&#xD;&#xA;&#xD;&#xA;    (defn rep [n]&#xD;&#xA;      (lazy-seq (cons n (rep n))))&#xD;&#xA;&#xD;&#xA;*and this*?&#xD;&#xA;&#xD;&#xA;    (defn rep [n]&#xD;&#xA;      (cons n (lazy-seq (rep n))))&#xD;&#xA;";;Improve (I hope!) layout, grammar, and punctuation.
