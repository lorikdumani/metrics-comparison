Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
37600111;15461080;;2;92fdbf16-6753-44c3-893a-109e6fc010a4;2013-03-17 13:10:01.0;"Interesting problem. If you're interested in a 10 radix only `itoa()` then I have made one that is 3x the speed of the typical `itoa()` implementations, it uses a _single-pass non-reversal_ software design pattern and is based on the one found in _groff_.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock to get better precision that 15ms on Windows */&#xD;&#xA;    #define TIMER_INIT timeBeginPeriod(10);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char numbersIn10Radix[10] = {'0','1','2','3','4','5','6','7','8','9'};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char reverseNumbersIn10Radix[10] = {'9','8','7','6','5','4','3','2','1','0'};&#xD;&#xA;    const char *reverseArrayEndPtr = &reverseNumbersIn10Radix[9];&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen, 2013&#xD;&#xA;    \\note This file was originally a part of \\a groff, and refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	// Make room for a 32-bit signed integers digits and the '\\0'&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			*--p = numbersIn10Radix[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			*--p = reverseArrayEndPtr[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2909.84 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    991.726 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3119.6 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    1031.61 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;";user152949;
37600273;15461080;;5;bd1439f7-7a62-410a-bd1a-d7a7e9b8b674;2013-03-17 13:16:17.0;"Interesting problem. If you're interested in a 10 radix only `itoa()` then I have made one that is 3x the speed of the typical `itoa()` implementations, it uses a _single-pass non-reversal_ software design pattern and is based on the open source `itoa()` implementation found in _groff_.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock to get better precision that 15ms on Windows */&#xD;&#xA;    #define TIMER_INIT timeBeginPeriod(10);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char numbersIn10Radix[10] = {'0','1','2','3','4','5','6','7','8','9'};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char reverseNumbersIn10Radix[10] = {'9','8','7','6','5','4','3','2','1','0'};&#xD;&#xA;    const char *reverseArrayEndPtr = &reverseNumbersIn10Radix[9];&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen<inge@meronymy.com>, 2013&#xD;&#xA;    \\note This file was originally a part of \\a groff, and refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	// Make room for a 32-bit signed integers digits and the '\\0'&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			*--p = numbersIn10Radix[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			*--p = reverseArrayEndPtr[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2909.84 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    991.726 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3119.6 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    1031.61 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;";user152949;Added my e-mail address
37600933;15461080;;5;2d46653b-bc2f-46a3-8aa0-ba7862861232;2013-03-17 13:39:31.0;"Interesting problem. If you're interested in a 10 radix only `itoa()` then I have made one that is 3x the speed of the typical `itoa()` implementations, it uses a _single-pass non-reversal_ software design pattern and is based on the open source `itoa()` implementation found in _groff_.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT &#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast number character lookup */&#xD;&#xA;    const char numbersIn10Radix[10] = {'0','1','2','3','4','5','6','7','8','9'};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast reverse number character lookup */&#xD;&#xA;    const char reverseNumbersIn10Radix[10] = {'9','8','7','6','5','4','3','2','1','0'};&#xD;&#xA;    const char *reverseArrayEndPtr = &reverseNumbersIn10Radix[9];&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen<inge@meronymy.com>, 2013&#xD;&#xA;    \\note Function was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	// Make room for a 32-bit signed integers digits and the '\\0'&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			*--p = numbersIn10Radix[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			*--p = reverseArrayEndPtr[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2909.84 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    991.726 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3119.6 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    1031.61 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;";user152949;Spelling
37614282;15461080;;5;9be5be71-ac9f-420b-8b5d-d7d324c07739;2013-03-17 20:55:28.0;"Interesting problem. If you're interested in a 10 radix only `itoa()` then I have made a 10 times as fast example and a 3 times as fast example as the typical `itoa()` implementation. &#xD;&#xA;&#xD;&#xA;**First example (3x performance)**&#xD;&#xA;&#xD;&#xA;The first, which is 3 times as fast as `itoa(), uses a _single-pass non-reversal_ software design pattern and is based on the open source `itoa()` implementation found in _groff_.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT &#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast number character lookup */&#xD;&#xA;    const char numbersIn10Radix[10] = {'0','1','2','3','4','5','6','7','8','9'};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast reverse number character lookup */&#xD;&#xA;    const char reverseNumbersIn10Radix[10] = {'9','8','7','6','5','4','3','2','1','0'};&#xD;&#xA;    const char *reverseArrayEndPtr = &reverseNumbersIn10Radix[9];&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen<inge@meronymy.com>, 2013&#xD;&#xA;    \\note Function was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	// Make room for a 32-bit signed integers digits and the '\\0'&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			*--p = numbersIn10Radix[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			*--p = reverseArrayEndPtr[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2909.84 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    991.726 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3119.6 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    1031.61 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;**Second example (10x performace)**&#xD;&#xA;&#xD;&#xA;If you don't mind spending some time initializing some buffers then it's possible to optimize the function above to be **10x faster** than the typical `itoa()` implementation. What you need to do is to create string buffers rather than character buffers, like this:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 __int8&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 char&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock to get better precision that 15ms on Windows */&#xD;&#xA;    #define TIMER_INIT timeBeginPeriod(10);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;    /* Set this as large or small as you want, but has to be divisible by 10, setting it smaller will make the buffers smaller but the program larger. If you want to set it larger than 100000 then you must add some more cases to the switch blocks. Try to make it smaller to see the difference in performance*/&#xD;&#xA;    static const _INT32 numElem10Radix = 100000;&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *numbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 numbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *reverseNumbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 reverseNumbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    void InitBuffers()&#xD;&#xA;    {&#xD;&#xA;    	char intBuffer[20];&#xD;&#xA;    &#xD;&#xA;    	for (int i = 0; i < numElem10Radix; i++)&#xD;&#xA;    	{&#xD;&#xA;    		_itoa(i, intBuffer, 10);&#xD;&#xA;    		size_t numLen = strlen(intBuffer);&#xD;&#xA;    		char *intStr = new char[numLen + 1];&#xD;&#xA;    		strcpy(intStr, intBuffer);&#xD;&#xA;    		numbersIn10Radix[i] = intStr;&#xD;&#xA;    		numbersIn10RadixLen[i] = numLen;&#xD;&#xA;    		reverseNumbersIn10Radix[numElem10Radix - 1 - i] = intStr;&#xD;&#xA;    		reverseNumbersIn10RadixLen[numElem10Radix - 1 - i] = numLen;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen, 2013&#xD;&#xA;    \\note This file was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	/* Room for INT_DIGITS digits, - and '\\0' */&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    	_INT32 modVal;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(numbersIn10RadixLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		const char **reverseArray = &reverseNumbersIn10Radix[numElem10Radix - 1];&#xD;&#xA;    		const _UINT8 *reverseArrayLen = &reverseNumbersIn10RadixLen[numElem10Radix - 1];&#xD;&#xA;    &#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(reverseArrayLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = reverseArray[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = reverseArray[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = reverseArray[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = reverseArray[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = reverseArray[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	InitBuffers();&#xD;&#xA;    &#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2914.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    306.637 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is: &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3126.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    299.387 ms.&#xD;&#xA;    Done";user152949;Spelling
37614428;15461080;;5;4ad8cc29-5f20-4126-a861-0ed8745d21ae;2013-03-17 21:00:54.0;"Interesting problem. If you're interested in a 10 radix only `itoa()` then I have made a 10 times as fast example and a 3 times as fast example as the typical `itoa()` implementation. &#xD;&#xA;&#xD;&#xA;**First example (3x performance)**&#xD;&#xA;&#xD;&#xA;The first, which is 3 times as fast as `itoa()`, uses a _single-pass non-reversal_ software design pattern and is based on the open source `itoa()` implementation found in _groff_.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT &#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast number character lookup */&#xD;&#xA;    const char numbersIn10Radix[10] = {'0','1','2','3','4','5','6','7','8','9'};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast reverse number character lookup */&#xD;&#xA;    const char reverseNumbersIn10Radix[10] = {'9','8','7','6','5','4','3','2','1','0'};&#xD;&#xA;    const char *reverseArrayEndPtr = &reverseNumbersIn10Radix[9];&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen<inge@meronymy.com>, 2013&#xD;&#xA;    \\note Function was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	// Make room for a 32-bit signed integers digits and the '\\0'&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			*--p = numbersIn10Radix[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			*--p = reverseArrayEndPtr[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2909.84 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    991.726 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3119.6 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    1031.61 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;**Second example (10x performance)**&#xD;&#xA;&#xD;&#xA;If you don't mind spending some time initializing some buffers then it's possible to optimize the function above to be **10x faster** than the typical `itoa()` implementation. What you need to do is to create string buffers rather than character buffers, like this:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 __int8&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 char&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock to get better precision that 15ms on Windows */&#xD;&#xA;    #define TIMER_INIT timeBeginPeriod(10);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;    /* Set this as large or small as you want, but has to be divisible by 10, setting it smaller will make the buffers smaller but the program larger. If you want to set it larger than 100000 then you must add some more cases to the switch blocks. Try to make it smaller to see the difference in performance*/&#xD;&#xA;    static const _INT32 numElem10Radix = 100000;&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *numbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 numbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *reverseNumbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 reverseNumbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    void InitBuffers()&#xD;&#xA;    {&#xD;&#xA;    	char intBuffer[20];&#xD;&#xA;    &#xD;&#xA;    	for (int i = 0; i < numElem10Radix; i++)&#xD;&#xA;    	{&#xD;&#xA;    		itoa(i, intBuffer, 10);&#xD;&#xA;    		size_t numLen = strlen(intBuffer);&#xD;&#xA;    		char *intStr = new char[numLen + 1];&#xD;&#xA;    		strcpy(intStr, intBuffer);&#xD;&#xA;    		numbersIn10Radix[i] = intStr;&#xD;&#xA;    		numbersIn10RadixLen[i] = numLen;&#xD;&#xA;    		reverseNumbersIn10Radix[numElem10Radix - 1 - i] = intStr;&#xD;&#xA;    		reverseNumbersIn10RadixLen[numElem10Radix - 1 - i] = numLen;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen, 2013&#xD;&#xA;    \\note This file was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	/* Room for INT_DIGITS digits, - and '\\0' */&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    	_INT32 modVal;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(numbersIn10RadixLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		const char **reverseArray = &reverseNumbersIn10Radix[numElem10Radix - 1];&#xD;&#xA;    		const _UINT8 *reverseArrayLen = &reverseNumbersIn10RadixLen[numElem10Radix - 1];&#xD;&#xA;    &#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(reverseArrayLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = reverseArray[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = reverseArray[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = reverseArray[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = reverseArray[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = reverseArray[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	InitBuffers();&#xD;&#xA;    &#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2914.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    306.637 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is: &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3126.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    299.387 ms.&#xD;&#xA;    Done";user152949;Using deprecated itoa() now
37614699;15461080;;5;56e7e962-9387-4ea9-b0c9-0ebef5302548;2013-03-17 21:09:11.0;"Interesting problem. If you're interested in a 10 radix only `itoa()` then I have made a 10 times as fast example and a 3 times as fast example as the typical `itoa()` implementation. &#xD;&#xA;&#xD;&#xA;**First example (3x performance)**&#xD;&#xA;&#xD;&#xA;The first, which is 3 times as fast as `itoa()`, uses a _single-pass non-reversal_ software design pattern and is based on the open source `itoa()` implementation found in _groff_.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT &#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast number character lookup */&#xD;&#xA;    const char numbersIn10Radix[10] = {'0','1','2','3','4','5','6','7','8','9'};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast reverse number character lookup */&#xD;&#xA;    const char reverseNumbersIn10Radix[10] = {'9','8','7','6','5','4','3','2','1','0'};&#xD;&#xA;    const char *reverseArrayEndPtr = &reverseNumbersIn10Radix[9];&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen<inge@meronymy.com>, 2013&#xD;&#xA;    \\note Function was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	// Make room for a 32-bit signed integers digits and the '\\0'&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			*--p = numbersIn10Radix[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			*--p = reverseArrayEndPtr[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2909.84 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    991.726 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3119.6 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    1031.61 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;**Second example (10x performance)**&#xD;&#xA;&#xD;&#xA;If you don't mind spending some time initializing some buffers then it's possible to optimize the function above to be **10x faster** than the typical `itoa()` implementation. What you need to do is to create string buffers rather than character buffers, like this:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 __int8&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 char&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock to get better precision that 15ms on Windows */&#xD;&#xA;    #define TIMER_INIT timeBeginPeriod(10);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;   &#xD;&#xA;&#xD;&#xA;     /* Set this as large or small as you want, but has to be divisible by 10, setting it smaller will&#xD;&#xA;     make the buffers smaller but the performance slower. If you want to set it larger than 100000 then you &#xD;&#xA;    must add some more cases to the switch blocks. Try to make it smaller to see the difference in &#xD;&#xA;    performance*/&#xD;&#xA;    static const _INT32 numElem10Radix = 100000;&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *numbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 numbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *reverseNumbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 reverseNumbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    void InitBuffers()&#xD;&#xA;    {&#xD;&#xA;    	char intBuffer[20];&#xD;&#xA;    &#xD;&#xA;    	for (int i = 0; i < numElem10Radix; i++)&#xD;&#xA;    	{&#xD;&#xA;    		itoa(i, intBuffer, 10);&#xD;&#xA;    		size_t numLen = strlen(intBuffer);&#xD;&#xA;    		char *intStr = new char[numLen + 1];&#xD;&#xA;    		strcpy(intStr, intBuffer);&#xD;&#xA;    		numbersIn10Radix[i] = intStr;&#xD;&#xA;    		numbersIn10RadixLen[i] = numLen;&#xD;&#xA;    		reverseNumbersIn10Radix[numElem10Radix - 1 - i] = intStr;&#xD;&#xA;    		reverseNumbersIn10RadixLen[numElem10Radix - 1 - i] = numLen;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen, 2013&#xD;&#xA;    \\note This file was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	/* Room for INT_DIGITS digits, - and '\\0' */&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    	_INT32 modVal;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(numbersIn10RadixLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		const char **reverseArray = &reverseNumbersIn10Radix[numElem10Radix - 1];&#xD;&#xA;    		const _UINT8 *reverseArrayLen = &reverseNumbersIn10RadixLen[numElem10Radix - 1];&#xD;&#xA;    &#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(reverseArrayLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = reverseArray[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = reverseArray[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = reverseArray[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = reverseArray[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = reverseArray[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	InitBuffers();&#xD;&#xA;    &#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2914.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    306.637 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is: &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3126.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    299.387 ms.&#xD;&#xA;    Done";user152949;Code error
37614897;15461080;;5;b499e711-6b38-4e66-8d67-fc4f2e4a5173;2013-03-17 21:17:25.0;"Interesting problem. If you're interested in a 10 radix only `itoa()` then I have made a 10 times as fast example and a 3 times as fast example as the typical `itoa()` implementation. &#xD;&#xA;&#xD;&#xA;**First example (3x performance)**&#xD;&#xA;&#xD;&#xA;The first, which is 3 times as fast as `itoa()`, uses a _single-pass non-reversal_ software design pattern and is based on the open source `itoa()` implementation found in _groff_.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT &#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast number character lookup */&#xD;&#xA;    const char numbersIn10Radix[10] = {'0','1','2','3','4','5','6','7','8','9'};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast reverse number character lookup */&#xD;&#xA;    const char reverseNumbersIn10Radix[10] = {'9','8','7','6','5','4','3','2','1','0'};&#xD;&#xA;    const char *reverseArrayEndPtr = &reverseNumbersIn10Radix[9];&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen<inge@meronymy.com>, 2013&#xD;&#xA;    \\note Function was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	// Make room for a 32-bit signed integers digits and the '\\0'&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			*--p = numbersIn10Radix[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			*--p = reverseArrayEndPtr[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2909.84 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    991.726 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3119.6 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    1031.61 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;**Second example (10x performance)**&#xD;&#xA;&#xD;&#xA;If you don't mind spending some time initializing some buffers then it's possible to optimize the function above to be **10x faster** than the typical `itoa()` implementation. What you need to do is to create string buffers rather than character buffers, like this:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 __int8&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 char&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock to get better precision that 15ms on Windows */&#xD;&#xA;    #define TIMER_INIT timeBeginPeriod(10);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;   &#xD;&#xA;&#xD;&#xA;     /* Set this as large or small as you want, but has to be in the form 10^n where n >= 1, setting it smaller will&#xD;&#xA;     make the buffers smaller but the performance slower. If you want to set it larger than 100000 then you &#xD;&#xA;    must add some more cases to the switch blocks. Try to make it smaller to see the difference in &#xD;&#xA;    performance*/&#xD;&#xA;    static const _INT32 numElem10Radix = 100000;&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *numbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 numbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *reverseNumbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 reverseNumbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    void InitBuffers()&#xD;&#xA;    {&#xD;&#xA;    	char intBuffer[20];&#xD;&#xA;    &#xD;&#xA;    	for (int i = 0; i < numElem10Radix; i++)&#xD;&#xA;    	{&#xD;&#xA;    		itoa(i, intBuffer, 10);&#xD;&#xA;    		size_t numLen = strlen(intBuffer);&#xD;&#xA;    		char *intStr = new char[numLen + 1];&#xD;&#xA;    		strcpy(intStr, intBuffer);&#xD;&#xA;    		numbersIn10Radix[i] = intStr;&#xD;&#xA;    		numbersIn10RadixLen[i] = numLen;&#xD;&#xA;    		reverseNumbersIn10Radix[numElem10Radix - 1 - i] = intStr;&#xD;&#xA;    		reverseNumbersIn10RadixLen[numElem10Radix - 1 - i] = numLen;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen, 2013&#xD;&#xA;    \\note This file was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	/* Room for INT_DIGITS digits, - and '\\0' */&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    	_INT32 modVal;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(numbersIn10RadixLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		const char **reverseArray = &reverseNumbersIn10Radix[numElem10Radix - 1];&#xD;&#xA;    		const _UINT8 *reverseArrayLen = &reverseNumbersIn10RadixLen[numElem10Radix - 1];&#xD;&#xA;    &#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(reverseArrayLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = reverseArray[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = reverseArray[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = reverseArray[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = reverseArray[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = reverseArray[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	InitBuffers();&#xD;&#xA;    &#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2914.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    306.637 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is: &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3126.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    299.387 ms.&#xD;&#xA;    Done";user152949;Example text
37615142;15461080;;5;0832c425-d0f2-4af6-98b9-cb4b97e02e39;2013-03-17 21:27:15.0;"Interesting problem. If you're interested in a 10 radix only `itoa()` then I have made a 10 times as fast example and a 3 times as fast example as the typical `itoa()` implementation. &#xD;&#xA;&#xD;&#xA;**First example (3x performance)**&#xD;&#xA;&#xD;&#xA;The first, which is 3 times as fast as `itoa()`, uses a _single-pass non-reversal_ software design pattern and is based on the open source `itoa()` implementation found in _groff_.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT &#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast number character lookup */&#xD;&#xA;    const char numbersIn10Radix[10] = {'0','1','2','3','4','5','6','7','8','9'};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast reverse number character lookup */&#xD;&#xA;    const char reverseNumbersIn10Radix[10] = {'9','8','7','6','5','4','3','2','1','0'};&#xD;&#xA;    const char *reverseArrayEndPtr = &reverseNumbersIn10Radix[9];&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen<inge@meronymy.com>, 2013&#xD;&#xA;    \\note Function was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	// Make room for a 32-bit signed integers digits and the '\\0'&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			*--p = numbersIn10Radix[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			*--p = reverseArrayEndPtr[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2909.84 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    991.726 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3119.6 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    1031.61 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;**Second example (10x performance)**&#xD;&#xA;&#xD;&#xA;If you don't mind spending some time initializing some buffers then it's possible to optimize the function above to be **10x faster** than the typical `itoa()` implementation. What you need to do is to create string buffers rather than character buffers, like this:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 __int8&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 char&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock to get better precision that 15ms on Windows */&#xD;&#xA;    #define TIMER_INIT timeBeginPeriod(10);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;   &#xD;&#xA;&#xD;&#xA;     /* Set this as large or small as you want, but has to be in the form 10^n where n >= 1, setting it smaller will&#xD;&#xA;     make the buffers smaller but the performance slower. If you want to set it larger than 100000 then you &#xD;&#xA;    must add some more cases to the switch blocks. Try to make it smaller to see the difference in &#xD;&#xA;    performance. It does however seem to become slower than larger than 100000 */&#xD;&#xA;    static const _INT32 numElem10Radix = 100000;&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *numbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 numbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *reverseNumbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 reverseNumbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    void InitBuffers()&#xD;&#xA;    {&#xD;&#xA;    	char intBuffer[20];&#xD;&#xA;    &#xD;&#xA;    	for (int i = 0; i < numElem10Radix; i++)&#xD;&#xA;    	{&#xD;&#xA;    		itoa(i, intBuffer, 10);&#xD;&#xA;    		size_t numLen = strlen(intBuffer);&#xD;&#xA;    		char *intStr = new char[numLen + 1];&#xD;&#xA;    		strcpy(intStr, intBuffer);&#xD;&#xA;    		numbersIn10Radix[i] = intStr;&#xD;&#xA;    		numbersIn10RadixLen[i] = numLen;&#xD;&#xA;    		reverseNumbersIn10Radix[numElem10Radix - 1 - i] = intStr;&#xD;&#xA;    		reverseNumbersIn10RadixLen[numElem10Radix - 1 - i] = numLen;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm with string buffers and is 10x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen, 2013&#xD;&#xA;    \\note This file was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	/* Room for INT_DIGITS digits, - and '\\0' */&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    	_INT32 modVal;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(numbersIn10RadixLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		const char **reverseArray = &reverseNumbersIn10Radix[numElem10Radix - 1];&#xD;&#xA;    		const _UINT8 *reverseArrayLen = &reverseNumbersIn10RadixLen[numElem10Radix - 1];&#xD;&#xA;    &#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(reverseArrayLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = reverseArray[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = reverseArray[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = reverseArray[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = reverseArray[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = reverseArray[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	InitBuffers();&#xD;&#xA;    &#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2914.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    306.637 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is: &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3126.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    299.387 ms.&#xD;&#xA;    Done";user152949;More example text
37634134;15461080;;5;29131599-38ae-4b0f-874a-ba8544620d51;2013-03-18 09:16:38.0;"Interesting problem. If you're interested in a 10 radix only `itoa()` then I have made a 10 times as fast example and a 3 times as fast example as the typical `itoa()` implementation. &#xD;&#xA;&#xD;&#xA;**First example (3x performance)**&#xD;&#xA;&#xD;&#xA;The first, which is 3 times as fast as `itoa()`, uses a _single-pass non-reversal_ software design pattern and is based on the open source `itoa()` implementation found in _groff_.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT &#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast number character lookup */&#xD;&#xA;    const char numbersIn10Radix[10] = {'0','1','2','3','4','5','6','7','8','9'};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast reverse number character lookup */&#xD;&#xA;    const char reverseNumbersIn10Radix[10] = {'9','8','7','6','5','4','3','2','1','0'};&#xD;&#xA;    const char *reverseArrayEndPtr = &reverseNumbersIn10Radix[9];&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen<inge@meronymy.com>, 2013&#xD;&#xA;    \\note Function was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	// Make room for a 32-bit signed integers digits and the '\\0'&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			*--p = numbersIn10Radix[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			*--p = reverseArrayEndPtr[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2909.84 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    991.726 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3119.6 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    1031.61 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;**Second example (10x performance)**&#xD;&#xA;&#xD;&#xA;If you don't mind spending some time initializing some buffers then it's possible to optimize the function above to be **10x faster** than the typical `itoa()` implementation. What you need to do is to create string buffers rather than character buffers, like this:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 __int8&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 char&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock to get better precision that 15ms on Windows */&#xD;&#xA;    #define TIMER_INIT timeBeginPeriod(10);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;   &#xD;&#xA;&#xD;&#xA;     /* Set this as large or small as you want, but has to be in the form 10^n where n >= 1, setting it smaller will&#xD;&#xA;     make the buffers smaller but the performance slower. If you want to set it larger than 100000 then you &#xD;&#xA;    must add some more cases to the switch blocks. Try to make it smaller to see the difference in &#xD;&#xA;    performance. It does however seem to become slower if larger than 100000 */&#xD;&#xA;    static const _INT32 numElem10Radix = 100000;&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *numbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 numbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *reverseNumbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 reverseNumbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    void InitBuffers()&#xD;&#xA;    {&#xD;&#xA;    	char intBuffer[20];&#xD;&#xA;    &#xD;&#xA;    	for (int i = 0; i < numElem10Radix; i++)&#xD;&#xA;    	{&#xD;&#xA;    		itoa(i, intBuffer, 10);&#xD;&#xA;    		size_t numLen = strlen(intBuffer);&#xD;&#xA;    		char *intStr = new char[numLen + 1];&#xD;&#xA;    		strcpy(intStr, intBuffer);&#xD;&#xA;    		numbersIn10Radix[i] = intStr;&#xD;&#xA;    		numbersIn10RadixLen[i] = numLen;&#xD;&#xA;    		reverseNumbersIn10Radix[numElem10Radix - 1 - i] = intStr;&#xD;&#xA;    		reverseNumbersIn10RadixLen[numElem10Radix - 1 - i] = numLen;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm with string buffers and is 10x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen, 2013&#xD;&#xA;    \\note This file was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	/* Room for INT_DIGITS digits, - and '\\0' */&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    	_INT32 modVal;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(numbersIn10RadixLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		const char **reverseArray = &reverseNumbersIn10Radix[numElem10Radix - 1];&#xD;&#xA;    		const _UINT8 *reverseArrayLen = &reverseNumbersIn10RadixLen[numElem10Radix - 1];&#xD;&#xA;    &#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(reverseArrayLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = reverseArray[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = reverseArray[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = reverseArray[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = reverseArray[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = reverseArray[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	InitBuffers();&#xD;&#xA;    &#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2914.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    306.637 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is: &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3126.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    299.387 ms.&#xD;&#xA;    Done";user152949;Spelling
37637649;15461080;;5;a36fab21-6c3a-438a-b52a-8a42ed6afbae;2013-03-18 10:23:23.0;"Interesting problem. If you're interested in a 10 radix only `itoa()` then I have made a 10 times as fast example and a 3 times as fast example as the typical `itoa()` implementation. &#xD;&#xA;&#xD;&#xA;**First example (3x performance)**&#xD;&#xA;&#xD;&#xA;The first, which is 3 times as fast as `itoa()`, uses a _single-pass non-reversal_ software design pattern and is based on the open source `itoa()` implementation found in _groff_.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT &#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast number character lookup */&#xD;&#xA;    const char numbersIn10Radix[10] = {'0','1','2','3','4','5','6','7','8','9'};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast reverse number character lookup */&#xD;&#xA;    const char reverseNumbersIn10Radix[10] = {'9','8','7','6','5','4','3','2','1','0'};&#xD;&#xA;    const char *reverseArrayEndPtr = &reverseNumbersIn10Radix[9];&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen<inge@meronymy.com>, 2013&#xD;&#xA;    \\note Function was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	// Make room for a 32-bit signed integers digits and the '\\0'&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			*--p = numbersIn10Radix[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			*--p = reverseArrayEndPtr[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2909.84 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    991.726 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3119.6 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    1031.61 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;**Second example (10x performance)**&#xD;&#xA;&#xD;&#xA;If you don't mind spending some time initializing some buffers then it's possible to optimize the function above to be **10x faster** than the typical `itoa()` implementation. What you need to do is to create string buffers rather than character buffers, like this:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 __int8&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 char&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock to get better precision that 15ms on Windows */&#xD;&#xA;    #define TIMER_INIT timeBeginPeriod(10);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;   &#xD;&#xA;&#xD;&#xA;     /* Set this as large or small as you want, but has to be in the form 10^n where n >= 1, setting it smaller will&#xD;&#xA;     make the buffers smaller but the performance slower. If you want to set it larger than 100000 then you &#xD;&#xA;    must add some more cases to the switch blocks. Try to make it smaller to see the difference in &#xD;&#xA;    performance. It does however seem to become slower if larger than 100000 */&#xD;&#xA;    static const _INT32 numElem10Radix = 100000;&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *numbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 numbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *reverseNumbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 reverseNumbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    void InitBuffers()&#xD;&#xA;    {&#xD;&#xA;    	char intBuffer[20];&#xD;&#xA;    &#xD;&#xA;    	for (int i = 0; i < numElem10Radix; i++)&#xD;&#xA;    	{&#xD;&#xA;    		itoa(i, intBuffer, 10);&#xD;&#xA;    		size_t numLen = strlen(intBuffer);&#xD;&#xA;    		char *intStr = new char[numLen + 1];&#xD;&#xA;    		strcpy(intStr, intBuffer);&#xD;&#xA;    		numbersIn10Radix[i] = intStr;&#xD;&#xA;    		numbersIn10RadixLen[i] = numLen;&#xD;&#xA;    		reverseNumbersIn10Radix[numElem10Radix - 1 - i] = intStr;&#xD;&#xA;    		reverseNumbersIn10RadixLen[numElem10Radix - 1 - i] = numLen;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm with string buffers and is 10x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen, 2013&#xD;&#xA;    \\note This file was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	/* Room for INT_DIGITS digits, - and '\\0' */&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    	_INT32 modVal;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(numbersIn10RadixLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		const char **reverseArray = &reverseNumbersIn10Radix[numElem10Radix - 1];&#xD;&#xA;    		const _UINT8 *reverseArrayLen = &reverseNumbersIn10RadixLen[numElem10Radix - 1];&#xD;&#xA;    &#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(reverseArrayLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = reverseArray[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = reverseArray[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = reverseArray[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = reverseArray[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = reverseArray[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	InitBuffers();&#xD;&#xA;    &#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2914.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    306.637 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is: &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3126.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    299.387 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;It's possible to do this _without_ the reverse string lookup buffers (thus saving 1/2 the internal memory), but this makes it significantly slower(about 850 ms), to test this yourself you can change simply the following code:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #define _UINT32 unsigned _INT32&#xD;&#xA;    ...&#xD;&#xA;    static const _UINT32 numElem10Radix = 100000;&#xD;&#xA;    ...&#xD;&#xA;    void InitBuffers()&#xD;&#xA;    {&#xD;&#xA;    	char intBuffer[20];&#xD;&#xA;    &#xD;&#xA;    	for (int i = 0; i < numElem10Radix; i++)&#xD;&#xA;    	{&#xD;&#xA;    		_itoa(i, intBuffer, 10);&#xD;&#xA;    		size_t numLen = strlen(intBuffer);&#xD;&#xA;    		char *intStr = new char[numLen + 1];&#xD;&#xA;    		strcpy(intStr, intBuffer);&#xD;&#xA;    		numbersIn10Radix[i] = intStr;&#xD;&#xA;    		numbersIn10RadixLen[i] = numLen;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    ...&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    	_UINT32 modVal;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	_UINT32 j = i;&#xD;&#xA;    &#xD;&#xA;    	do &#xD;&#xA;    	{&#xD;&#xA;    		modVal = j % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    		switch(numbersIn10RadixLen[modVal])&#xD;&#xA;    		{&#xD;&#xA;    			case 5:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][4];&#xD;&#xA;    			case 4:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][3];&#xD;&#xA;    			case 3:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][2];&#xD;&#xA;    			case 2:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][1];&#xD;&#xA;    			default:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][0];&#xD;&#xA;    		}&#xD;&#xA;    &#xD;&#xA;    		j /= numElem10Radix;&#xD;&#xA;    	} while (j);&#xD;&#xA;    &#xD;&#xA;    	if (i < 0) *--p = '-';&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;";user152949;Fixed sign bug
37638025;15461080;;5;0574d632-133b-4581-9538-4e222d0978a0;2013-03-18 10:29:26.0;"Interesting problem. If you're interested in a 10 radix only `itoa()` then I have made a 10 times as fast example and a 3 times as fast example as the typical `itoa()` implementation. &#xD;&#xA;&#xD;&#xA;**First example (3x performance)**&#xD;&#xA;&#xD;&#xA;The first, which is 3 times as fast as `itoa()`, uses a _single-pass non-reversal_ software design pattern and is based on the open source `itoa()` implementation found in _groff_.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT &#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast number character lookup */&#xD;&#xA;    const char numbersIn10Radix[10] = {'0','1','2','3','4','5','6','7','8','9'};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast reverse number character lookup */&#xD;&#xA;    const char reverseNumbersIn10Radix[10] = {'9','8','7','6','5','4','3','2','1','0'};&#xD;&#xA;    const char *reverseArrayEndPtr = &reverseNumbersIn10Radix[9];&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen<inge@meronymy.com>, 2013&#xD;&#xA;    \\note Function was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	// Make room for a 32-bit signed integers digits and the '\\0'&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			*--p = numbersIn10Radix[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			*--p = reverseArrayEndPtr[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2909.84 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    991.726 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3119.6 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    1031.61 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;**Second example (10x performance)**&#xD;&#xA;&#xD;&#xA;If you don't mind spending some time initializing some buffers then it's possible to optimize the function above to be **10x faster** than the typical `itoa()` implementation. What you need to do is to create string buffers rather than character buffers, like this:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 __int8&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 char&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock to get better precision that 15ms on Windows */&#xD;&#xA;    #define TIMER_INIT timeBeginPeriod(10);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;   &#xD;&#xA;&#xD;&#xA;     /* Set this as large or small as you want, but has to be in the form 10^n where n >= 1, setting it smaller will&#xD;&#xA;     make the buffers smaller but the performance slower. If you want to set it larger than 100000 then you &#xD;&#xA;    must add some more cases to the switch blocks. Try to make it smaller to see the difference in &#xD;&#xA;    performance. It does however seem to become slower if larger than 100000 */&#xD;&#xA;    static const _INT32 numElem10Radix = 100000;&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *numbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 numbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *reverseNumbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 reverseNumbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    void InitBuffers()&#xD;&#xA;    {&#xD;&#xA;    	char intBuffer[20];&#xD;&#xA;    &#xD;&#xA;    	for (int i = 0; i < numElem10Radix; i++)&#xD;&#xA;    	{&#xD;&#xA;    		itoa(i, intBuffer, 10);&#xD;&#xA;    		size_t numLen = strlen(intBuffer);&#xD;&#xA;    		char *intStr = new char[numLen + 1];&#xD;&#xA;    		strcpy(intStr, intBuffer);&#xD;&#xA;    		numbersIn10Radix[i] = intStr;&#xD;&#xA;    		numbersIn10RadixLen[i] = numLen;&#xD;&#xA;    		reverseNumbersIn10Radix[numElem10Radix - 1 - i] = intStr;&#xD;&#xA;    		reverseNumbersIn10RadixLen[numElem10Radix - 1 - i] = numLen;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm with string buffers and is 10x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen, 2013&#xD;&#xA;    \\note This file was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	/* Room for INT_DIGITS digits, - and '\\0' */&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    	_INT32 modVal;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(numbersIn10RadixLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		const char **reverseArray = &reverseNumbersIn10Radix[numElem10Radix - 1];&#xD;&#xA;    		const _UINT8 *reverseArrayLen = &reverseNumbersIn10RadixLen[numElem10Radix - 1];&#xD;&#xA;    &#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(reverseArrayLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = reverseArray[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = reverseArray[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = reverseArray[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = reverseArray[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = reverseArray[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	InitBuffers();&#xD;&#xA;    &#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2914.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    306.637 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is: &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3126.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    299.387 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;It's possible to do this _without_ the reverse string lookup buffers (thus saving 1/2 the internal memory), but this makes it significantly slower (timed at about 850 ms on 64-bit and 380 ms on 32-bit systems), to test this yourself you can change simply the following code:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #define _UINT32 unsigned _INT32&#xD;&#xA;    ...&#xD;&#xA;    static const _UINT32 numElem10Radix = 100000;&#xD;&#xA;    ...&#xD;&#xA;    void InitBuffers()&#xD;&#xA;    {&#xD;&#xA;    	char intBuffer[20];&#xD;&#xA;    &#xD;&#xA;    	for (int i = 0; i < numElem10Radix; i++)&#xD;&#xA;    	{&#xD;&#xA;    		_itoa(i, intBuffer, 10);&#xD;&#xA;    		size_t numLen = strlen(intBuffer);&#xD;&#xA;    		char *intStr = new char[numLen + 1];&#xD;&#xA;    		strcpy(intStr, intBuffer);&#xD;&#xA;    		numbersIn10Radix[i] = intStr;&#xD;&#xA;    		numbersIn10RadixLen[i] = numLen;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    ...&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    	_UINT32 modVal;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	_UINT32 j = i;&#xD;&#xA;    &#xD;&#xA;    	do &#xD;&#xA;    	{&#xD;&#xA;    		modVal = j % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    		switch(numbersIn10RadixLen[modVal])&#xD;&#xA;    		{&#xD;&#xA;    			case 5:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][4];&#xD;&#xA;    			case 4:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][3];&#xD;&#xA;    			case 3:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][2];&#xD;&#xA;    			case 2:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][1];&#xD;&#xA;    			default:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][0];&#xD;&#xA;    		}&#xD;&#xA;    &#xD;&#xA;    		j /= numElem10Radix;&#xD;&#xA;    	} while (j);&#xD;&#xA;    &#xD;&#xA;    	if (i < 0) *--p = '-';&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;";user152949;Clarifying
37638452;15461080;;5;ca93bad5-e4f4-459e-9456-9932091c7ee0;2013-03-18 10:37:23.0;"Interesting problem. If you're interested in a 10 radix only `itoa()` then I have made a 10 times as fast example and a 3 times as fast example as the typical `itoa()` implementation. &#xD;&#xA;&#xD;&#xA;**First example (3x performance)**&#xD;&#xA;&#xD;&#xA;The first, which is 3 times as fast as `itoa()`, uses a _single-pass non-reversal_ software design pattern and is based on the open source `itoa()` implementation found in _groff_.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT &#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast number character lookup */&#xD;&#xA;    const char numbersIn10Radix[10] = {'0','1','2','3','4','5','6','7','8','9'};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast reverse number character lookup */&#xD;&#xA;    const char reverseNumbersIn10Radix[10] = {'9','8','7','6','5','4','3','2','1','0'};&#xD;&#xA;    const char *reverseArrayEndPtr = &reverseNumbersIn10Radix[9];&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen<inge@meronymy.com>, 2013&#xD;&#xA;    \\note Function was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	// Make room for a 32-bit signed integers digits and the '\\0'&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			*--p = numbersIn10Radix[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			*--p = reverseArrayEndPtr[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2909.84 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    991.726 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3119.6 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    1031.61 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;**Second example (10x performance)**&#xD;&#xA;&#xD;&#xA;If you don't mind spending some time initializing some buffers then it's possible to optimize the function above to be **10x faster** than the typical `itoa()` implementation. What you need to do is to create string buffers rather than character buffers, like this:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 __int8&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 char&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock to get better precision that 15ms on Windows */&#xD;&#xA;    #define TIMER_INIT timeBeginPeriod(10);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;   &#xD;&#xA;&#xD;&#xA;     /* Set this as large or small as you want, but has to be in the form 10^n where n >= 1, setting it smaller will&#xD;&#xA;     make the buffers smaller but the performance slower. If you want to set it larger than 100000 then you &#xD;&#xA;    must add some more cases to the switch blocks. Try to make it smaller to see the difference in &#xD;&#xA;    performance. It does however seem to become slower if larger than 100000 */&#xD;&#xA;    static const _INT32 numElem10Radix = 100000;&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *numbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 numbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *reverseNumbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 reverseNumbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    void InitBuffers()&#xD;&#xA;    {&#xD;&#xA;    	char intBuffer[20];&#xD;&#xA;    &#xD;&#xA;    	for (int i = 0; i < numElem10Radix; i++)&#xD;&#xA;    	{&#xD;&#xA;    		itoa(i, intBuffer, 10);&#xD;&#xA;    		size_t numLen = strlen(intBuffer);&#xD;&#xA;    		char *intStr = new char[numLen + 1];&#xD;&#xA;    		strcpy(intStr, intBuffer);&#xD;&#xA;    		numbersIn10Radix[i] = intStr;&#xD;&#xA;    		numbersIn10RadixLen[i] = numLen;&#xD;&#xA;    		reverseNumbersIn10Radix[numElem10Radix - 1 - i] = intStr;&#xD;&#xA;    		reverseNumbersIn10RadixLen[numElem10Radix - 1 - i] = numLen;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm with string buffers and is 10x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen, 2013&#xD;&#xA;    \\note This file was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	/* Room for INT_DIGITS digits, - and '\\0' */&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    	_INT32 modVal;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(numbersIn10RadixLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		const char **reverseArray = &reverseNumbersIn10Radix[numElem10Radix - 1];&#xD;&#xA;    		const _UINT8 *reverseArrayLen = &reverseNumbersIn10RadixLen[numElem10Radix - 1];&#xD;&#xA;    &#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(reverseArrayLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = reverseArray[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = reverseArray[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = reverseArray[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = reverseArray[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = reverseArray[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	InitBuffers();&#xD;&#xA;    &#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2914.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    306.637 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is: &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3126.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    299.387 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Why do you use reverse string lookup buffers?**&#xD;&#xA;&#xD;&#xA;It's possible to do this _without_ the reverse string lookup buffers (thus saving 1/2 the internal memory), but this makes it significantly slower (timed at about 850 ms on 64-bit and 380 ms on 32-bit systems), to test this yourself you can change simply the following code:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #define _UINT32 unsigned _INT32&#xD;&#xA;    ...&#xD;&#xA;    static const _UINT32 numElem10Radix = 100000;&#xD;&#xA;    ...&#xD;&#xA;    void InitBuffers()&#xD;&#xA;    {&#xD;&#xA;    	char intBuffer[20];&#xD;&#xA;    &#xD;&#xA;    	for (int i = 0; i < numElem10Radix; i++)&#xD;&#xA;    	{&#xD;&#xA;    		_itoa(i, intBuffer, 10);&#xD;&#xA;    		size_t numLen = strlen(intBuffer);&#xD;&#xA;    		char *intStr = new char[numLen + 1];&#xD;&#xA;    		strcpy(intStr, intBuffer);&#xD;&#xA;    		numbersIn10Radix[i] = intStr;&#xD;&#xA;    		numbersIn10RadixLen[i] = numLen;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    ...&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    	_UINT32 modVal;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	_UINT32 j = i;&#xD;&#xA;    &#xD;&#xA;    	do &#xD;&#xA;    	{&#xD;&#xA;    		modVal = j % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    		switch(numbersIn10RadixLen[modVal])&#xD;&#xA;    		{&#xD;&#xA;    			case 5:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][4];&#xD;&#xA;    			case 4:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][3];&#xD;&#xA;    			case 3:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][2];&#xD;&#xA;    			case 2:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][1];&#xD;&#xA;    			default:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][0];&#xD;&#xA;    		}&#xD;&#xA;    &#xD;&#xA;    		j /= numElem10Radix;&#xD;&#xA;    	} while (j);&#xD;&#xA;    &#xD;&#xA;    	if (i < 0) *--p = '-';&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;";user152949;Subtitle added
37639807;15461080;;5;5d342869-8466-427f-bb53-5b153e612923;2013-03-18 11:01:35.0;"Interesting problem. If you're interested in a 10 radix only `itoa()` then I have made a 10 times as fast example and a 3 times as fast example as the typical `itoa()` implementation. &#xD;&#xA;&#xD;&#xA;**First example (3x performance)**&#xD;&#xA;&#xD;&#xA;The first, which is 3 times as fast as `itoa()`, uses a _single-pass non-reversal_ software design pattern and is based on the open source `itoa()` implementation found in _groff_.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT &#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast number character lookup */&#xD;&#xA;    const char numbersIn10Radix[10] = {'0','1','2','3','4','5','6','7','8','9'};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast reverse number character lookup */&#xD;&#xA;    const char reverseNumbersIn10Radix[10] = {'9','8','7','6','5','4','3','2','1','0'};&#xD;&#xA;    const char *reverseArrayEndPtr = &reverseNumbersIn10Radix[9];&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm and is 3x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen<inge@meronymy.com>, 2013&#xD;&#xA;    \\note Function was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	// Make room for a 32-bit signed integers digits and the '\\0'&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			*--p = numbersIn10Radix[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			*--p = reverseArrayEndPtr[i % 10];&#xD;&#xA;    			i /= 10;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2909.84 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    991.726 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3119.6 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    1031.61 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;**Second example (10x performance)**&#xD;&#xA;&#xD;&#xA;If you don't mind spending some time initializing some buffers then it's possible to optimize the function above to be **10x faster** than the typical `itoa()` implementation. What you need to do is to create string buffers rather than character buffers, like this:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // itoaSpeedTest.cpp : Defines the entry point for the console application.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #pragma comment(lib, ""Winmm.lib"") &#xD;&#xA;    #include ""stdafx.h""&#xD;&#xA;    #include ""Windows.h""&#xD;&#xA;    &#xD;&#xA;    #include <iostream>&#xD;&#xA;    #include <time.h>&#xD;&#xA;    &#xD;&#xA;    using namespace std;&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 __int32&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 __int8&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #else&#xD;&#xA;    /** a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32 long int // Guess what a 32-bit integer is&#xD;&#xA;    &#xD;&#xA;    /** a signed 8-bit integer value type */&#xD;&#xA;    #define _INT8 char&#xD;&#xA;    &#xD;&#xA;    /** an unsigned 8-bit integer value type */&#xD;&#xA;    #define _UINT8 unsigned _INT8&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    /** minimum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MIN -2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed value in a signed 32-bit integer value type */&#xD;&#xA;    #define _INT32_MAX 2147483647&#xD;&#xA;    &#xD;&#xA;    /** maximum allowed number of characters in a signed 32-bit integer value type including a '-' */&#xD;&#xA;    #define _INT32_MAX_LENGTH 11&#xD;&#xA;    &#xD;&#xA;    #ifdef _WIN32&#xD;&#xA;    &#xD;&#xA;    /** Use to init the clock */&#xD;&#xA;    #define TIMER_INIT LARGE_INTEGER frequency;LARGE_INTEGER t1, t2;double elapsedTime;QueryPerformanceFrequency(&frequency);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START QueryPerformanceCounter(&t1);&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP QueryPerformanceCounter(&t2);elapsedTime=(t2.QuadPart-t1.QuadPart)*1000.0/frequency.QuadPart;wcout<<elapsedTime<<L"" ms.""<<endl;&#xD;&#xA;    #else&#xD;&#xA;    /** Use to init the clock to get better precision that 15ms on Windows */&#xD;&#xA;    #define TIMER_INIT timeBeginPeriod(10);&#xD;&#xA;    &#xD;&#xA;    /** Use to start the performance timer */&#xD;&#xA;    #define TIMER_START clock_t start;double diff;start=clock();&#xD;&#xA;    &#xD;&#xA;    /** Use to stop the performance timer and output the result to the standard stream. Less verbose than \\c TIMER_STOP_VERBOSE */&#xD;&#xA;    #define TIMER_STOP diff=(clock()-start)/(double)CLOCKS_PER_SEC;wcout<<fixed<<diff<<endl;&#xD;&#xA;    #endif&#xD;&#xA;   &#xD;&#xA;&#xD;&#xA;     /* Set this as large or small as you want, but has to be in the form 10^n where n >= 1, setting it smaller will&#xD;&#xA;     make the buffers smaller but the performance slower. If you want to set it larger than 100000 then you &#xD;&#xA;    must add some more cases to the switch blocks. Try to make it smaller to see the difference in &#xD;&#xA;    performance. It does however seem to become slower if larger than 100000 */&#xD;&#xA;    static const _INT32 numElem10Radix = 100000;&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *numbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 numbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    /** Array used for fast lookup number character lookup */&#xD;&#xA;    const char *reverseNumbersIn10Radix[numElem10Radix] = {};&#xD;&#xA;    _UINT8 reverseNumbersIn10RadixLen[numElem10Radix] = {};&#xD;&#xA;    &#xD;&#xA;    void InitBuffers()&#xD;&#xA;    {&#xD;&#xA;    	char intBuffer[20];&#xD;&#xA;    &#xD;&#xA;    	for (int i = 0; i < numElem10Radix; i++)&#xD;&#xA;    	{&#xD;&#xA;    		itoa(i, intBuffer, 10);&#xD;&#xA;    		size_t numLen = strlen(intBuffer);&#xD;&#xA;    		char *intStr = new char[numLen + 1];&#xD;&#xA;    		strcpy(intStr, intBuffer);&#xD;&#xA;    		numbersIn10Radix[i] = intStr;&#xD;&#xA;    		numbersIn10RadixLen[i] = numLen;&#xD;&#xA;    		reverseNumbersIn10Radix[numElem10Radix - 1 - i] = intStr;&#xD;&#xA;    		reverseNumbersIn10RadixLen[numElem10Radix - 1 - i] = numLen;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /*!&#xD;&#xA;    \\brief Converts a 32-bit signed integer to a string&#xD;&#xA;    \\param i [in] Integer&#xD;&#xA;    \\par Software design pattern&#xD;&#xA;    Uses a single pass non-reversing algorithm with string buffers and is 10x as fast as \\c itoa().&#xD;&#xA;    \\returns Integer as a string&#xD;&#xA;    \\copyright GNU General Public License&#xD;&#xA;    \\copyright 1989-1992 Free Software Foundation, Inc.&#xD;&#xA;    \\date 1989-1992, 2013&#xD;&#xA;    \\author James Clark<jjc@jclark.com>, 1989-1992&#xD;&#xA;    \\author Inge Eivind Henriksen, 2013&#xD;&#xA;    \\note This file was originally a part of \\a groff, and was refactored & optimized in 2013.&#xD;&#xA;    \\relates itoa()&#xD;&#xA;    */&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	/* Room for INT_DIGITS digits, - and '\\0' */&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    	_INT32 modVal;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	if (i >= 0) &#xD;&#xA;    	{&#xD;&#xA;    		do &#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(numbersIn10RadixLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = numbersIn10Radix[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		// Negative integer&#xD;&#xA;    		const char **reverseArray = &reverseNumbersIn10Radix[numElem10Radix - 1];&#xD;&#xA;    		const _UINT8 *reverseArrayLen = &reverseNumbersIn10RadixLen[numElem10Radix - 1];&#xD;&#xA;    &#xD;&#xA;    		do&#xD;&#xA;    		{&#xD;&#xA;    			modVal = i % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    			switch(reverseArrayLen[modVal])&#xD;&#xA;    			{&#xD;&#xA;    				case 5:&#xD;&#xA;    					*--p = reverseArray[modVal][4];&#xD;&#xA;    				case 4:&#xD;&#xA;    					*--p = reverseArray[modVal][3];&#xD;&#xA;    				case 3:&#xD;&#xA;    					*--p = reverseArray[modVal][2];&#xD;&#xA;    				case 2:&#xD;&#xA;    					*--p = reverseArray[modVal][1];&#xD;&#xA;    				default:&#xD;&#xA;    					*--p = reverseArray[modVal][0];&#xD;&#xA;    			}&#xD;&#xA;    &#xD;&#xA;    			i /= numElem10Radix;&#xD;&#xA;    		} while (i);&#xD;&#xA;    &#xD;&#xA;    		*--p = '-';&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int _tmain(int argc, _TCHAR* argv[])&#xD;&#xA;    {&#xD;&#xA;    	InitBuffers();&#xD;&#xA;    &#xD;&#xA;    	TIMER_INIT&#xD;&#xA;    &#xD;&#xA;    	// Make sure we are playing fair here&#xD;&#xA;    	if (sizeof(int) != sizeof(_INT32))&#xD;&#xA;    	{&#xD;&#xA;    		cerr << ""Error: integer size mismatch; test would be invalid."" << endl;&#xD;&#xA;    		return -1;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	const int steps = 100;&#xD;&#xA;    	{&#xD;&#xA;    		char intBuffer[20];&#xD;&#xA;    		cout << ""itoa() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			itoa(i, intBuffer, 10);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    	{&#xD;&#xA;    		cout << ""Int32ToStr() took:"" << endl;&#xD;&#xA;    		TIMER_START;&#xD;&#xA;    &#xD;&#xA;    		for (int i = _INT32_MIN; i < i + steps ; i += steps)&#xD;&#xA;    			Int32ToStr(i);&#xD;&#xA;    &#xD;&#xA;    		TIMER_STOP;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	cout << ""Done"" << endl;&#xD;&#xA;    	int wait;&#xD;&#xA;    	cin >> wait;&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On 64-bit Windows the result from running this example is:&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    2914.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    306.637 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On 32-bit Windows the result from running this example is: &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    itoa() took:&#xD;&#xA;    3126.12 ms.&#xD;&#xA;    Int32ToStr() took:&#xD;&#xA;    299.387 ms.&#xD;&#xA;    Done&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Why do you use reverse string lookup buffers?**&#xD;&#xA;&#xD;&#xA;It's possible to do this _without_ the reverse string lookup buffers (thus saving 1/2 the internal memory), but this makes it significantly slower (timed at about 850 ms on 64-bit and 380 ms on 32-bit systems). It's not clear to me exactly why it's so much slower - especially on 64-bit systems, to test this further yourself you can change simply the following code:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #define _UINT32 unsigned _INT32&#xD;&#xA;    ...&#xD;&#xA;    static const _UINT32 numElem10Radix = 100000;&#xD;&#xA;    ...&#xD;&#xA;    void InitBuffers()&#xD;&#xA;    {&#xD;&#xA;    	char intBuffer[20];&#xD;&#xA;    &#xD;&#xA;    	for (int i = 0; i < numElem10Radix; i++)&#xD;&#xA;    	{&#xD;&#xA;    		_itoa(i, intBuffer, 10);&#xD;&#xA;    		size_t numLen = strlen(intBuffer);&#xD;&#xA;    		char *intStr = new char[numLen + 1];&#xD;&#xA;    		strcpy(intStr, intBuffer);&#xD;&#xA;    		numbersIn10Radix[i] = intStr;&#xD;&#xA;    		numbersIn10RadixLen[i] = numLen;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    ...&#xD;&#xA;    const char *Int32ToStr(_INT32 i) &#xD;&#xA;    {	&#xD;&#xA;    	char buf[_INT32_MAX_LENGTH + 2];&#xD;&#xA;    	char *p = buf + _INT32_MAX_LENGTH + 1;&#xD;&#xA;    	_UINT32 modVal;&#xD;&#xA;    &#xD;&#xA;    	*--p = '\\0';&#xD;&#xA;    &#xD;&#xA;    	_UINT32 j = i;&#xD;&#xA;    &#xD;&#xA;    	do &#xD;&#xA;    	{&#xD;&#xA;    		modVal = j % numElem10Radix;&#xD;&#xA;    &#xD;&#xA;    		switch(numbersIn10RadixLen[modVal])&#xD;&#xA;    		{&#xD;&#xA;    			case 5:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][4];&#xD;&#xA;    			case 4:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][3];&#xD;&#xA;    			case 3:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][2];&#xD;&#xA;    			case 2:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][1];&#xD;&#xA;    			default:&#xD;&#xA;    				*--p = numbersIn10Radix[modVal][0];&#xD;&#xA;    		}&#xD;&#xA;    &#xD;&#xA;    		j /= numElem10Radix;&#xD;&#xA;    	} while (j);&#xD;&#xA;    &#xD;&#xA;    	if (i < 0) *--p = '-';&#xD;&#xA;    &#xD;&#xA;    	return p;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;";user152949;added 93 characters in body
