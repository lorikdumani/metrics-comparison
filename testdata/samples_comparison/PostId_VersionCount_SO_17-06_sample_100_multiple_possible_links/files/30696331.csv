Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
92272155;30696331;666818;2;022cfb03-61c1-4ea4-accd-44c389142ffd;2015-06-07 17:17:54.0;"Trying to use a struct from ObjC to Swift doesn't seem to be that easy. I end up getting a Unsafe pointer that I don't know if I can cast reliably.&#xD;&#xA;&#xD;&#xA;Here is the code:&#xD;&#xA;&#xD;&#xA;    //&#xD;&#xA;    // In OBJC land&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    // Type declared as a struct&#xD;&#xA;    &#xD;&#xA;    typedef struct node {&#xD;&#xA;        int children_count;&#xD;&#xA;    } node_t;&#xD;&#xA;    &#xD;&#xA;    // Super class has a property&#xD;&#xA;    &#xD;&#xA;    @property (nonatomic, assign, readonly) node_t *node;&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    //&#xD;&#xA;    // In SWIFT land&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    // Derived class tries to set the property inside the C struct&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    let n: UnsafeMutablePointer<node_t> = super.node // As swift compiler sees it&#xD;&#xA;    n.children_count = 0    // ERR!!! &#xD;&#xA;&#xD;&#xA;Do I really need to apply unsafeBitcast here or is there a simpler/safer and more elegant way to convert what seems to be a frequent scenario?";;
92277165;30696331;666818;5;2b302ae6-ce85-4f2f-9da2-e7ab52acffff;2015-06-07 19:36:01.0;"Trying to use a struct from ObjC to Swift doesn't seem to be that easy. I end up getting a Unsafe pointer that I don't know if I can cast reliably.&#xD;&#xA;&#xD;&#xA;Here is the code:&#xD;&#xA;&#xD;&#xA;    //&#xD;&#xA;    // In OBJC land&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    // Type declared as a struct&#xD;&#xA;    &#xD;&#xA;    typedef struct node {&#xD;&#xA;        int children_count;&#xD;&#xA;    } node_t;&#xD;&#xA;    &#xD;&#xA;    // Super class has a property&#xD;&#xA;    &#xD;&#xA;    @property (nonatomic, assign, readonly) node_t *node;&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    //&#xD;&#xA;    // In SWIFT land&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    // Derived class tries to set the property inside the C struct&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    let n: UnsafeMutablePointer<node_t> = super.node // As swift compiler sees it&#xD;&#xA;    n.children_count = 0    // ERR!!! &#xD;&#xA;&#xD;&#xA;Do I really need to apply unsafeBitcast here or is there a simpler/safer and more elegant way to convert what seems to be a frequent scenario?&#xD;&#xA;&#xD;&#xA;**UPDATE:** &#xD;&#xA;&#xD;&#xA;I tried using *memory* to access the elements of the struct and I am getting a EXC_BAD_INSTRUCTION &#xD;&#xA;&#xD;&#xA;    var node: node_t = self.node.memory&#xD;&#xA;    node.children_count = 42&#xD;&#xA;&#xD;&#xA;";;added 196 characters in body
92278719;30696331;666818;5;85a2d49c-5e33-47df-80b9-8345cf580c37;2015-06-07 20:19:15.0;"Trying to use a struct from ObjC to Swift doesn't seem to be that easy. I end up getting a Unsafe pointer that I don't know if I can cast reliably.&#xD;&#xA;&#xD;&#xA;Here is the code:&#xD;&#xA;&#xD;&#xA;    //&#xD;&#xA;    // In OBJC land&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    // Type declared as a struct&#xD;&#xA;    &#xD;&#xA;    typedef struct node {&#xD;&#xA;        int children_count;&#xD;&#xA;    } node_t;&#xD;&#xA;    &#xD;&#xA;    // Super class has a property&#xD;&#xA;    &#xD;&#xA;    @property (nonatomic, assign, readonly) node_t *node;&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    //&#xD;&#xA;    // In SWIFT land&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    // Derived class tries to set the property inside the C struct&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    let n: UnsafeMutablePointer<node_t> = super.node // As swift compiler sees it&#xD;&#xA;    n.children_count = 0    // ERR!!! &#xD;&#xA;&#xD;&#xA;Do I really need to apply unsafeBitcast here or is there a simpler/safer and more elegant way to convert what seems to be a frequent scenario?&#xD;&#xA;&#xD;&#xA;**UPDATE:** &#xD;&#xA;&#xD;&#xA;I tried using *memory* to access the elements of the struct and I am getting a EXC_BAD_INSTRUCTION &#xD;&#xA;&#xD;&#xA;    var node: node_t = self.node.memory&#xD;&#xA;    node.children_count = 42&#xD;&#xA;&#xD;&#xA;**UPDATE CONT'D & FINALE**&#xD;&#xA;&#xD;&#xA;I got it to work. Thanks to @matt's patience for making sure I groked 'memory' access completely. The other trick is to realize the assignment in one continuous statement like this:&#xD;&#xA;&#xD;&#xA;        var node: UnsafeMutablePointer<node_t> = self.node&#xD;&#xA;        node.memory.children_count = 42&#xD;&#xA;&#xD;&#xA;If I do the following, the change doesn't get committed passed the function call:&#xD;&#xA;&#xD;&#xA;    var node: node_t = self.node.memory&#xD;&#xA;    node.children_count = 42&#xD;&#xA;&#xD;&#xA;";;added 476 characters in body
