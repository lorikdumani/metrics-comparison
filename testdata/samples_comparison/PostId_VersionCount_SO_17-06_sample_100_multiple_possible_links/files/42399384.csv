Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
139039196;42399384;5014455;2;f6dbd6be-ab82-4a8a-9700-0c29d3f63f78;2017-02-22 18:23:07.0;"Here is a sketch of an approach. You can easily combine this with your own approach, the biggest change being for the `Card` class. Here, I've used `namedtuple` to make a `Card` class, but your current class can simply wrap a `tuple` value:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    import enum&#xD;&#xA;    from functools import total_ordering&#xD;&#xA;    from collections import namedtuple&#xD;&#xA;    &#xD;&#xA;    @total_ordering&#xD;&#xA;    class OrderedEnum(enum.Enum):&#xD;&#xA;        def __lt__(self, other):&#xD;&#xA;            if isinstance(other, type(self)):&#xD;&#xA;                return self.value < other.value&#xD;&#xA;            return NotImplemented&#xD;&#xA;    &#xD;&#xA;    Rank = OrderedEnum('Rank', ['one', 'two', 'three', 'four', 'five', 'six',&#xD;&#xA;                        'seven', 'eight', 'nine', 'jack', 'queen','king', 'ace'])&#xD;&#xA;    &#xD;&#xA;    Suit = OrderedEnum('Suit', ['clubs', 'diamonds', 'hearts', 'spades'])&#xD;&#xA;    &#xD;&#xA;    Card = namedtuple('Card', ['rank', 'suit'])&#xD;&#xA;    &#xD;&#xA;    c1 = Card(Rank.four, Suit.clubs)&#xD;&#xA;    c2 = Card(Rank.four, Suit.spades)&#xD;&#xA;    c3 = Card(Rank.ace, Suit.diamonds)&#xD;&#xA;&#xD;&#xA;Now, in action:&#xD;&#xA;&#xD;&#xA;    >>> c1&#xD;&#xA;    Card(rank=<Rank.four: 4>, suit=<Suit.clubs: 1>)&#xD;&#xA;    >>> c2&#xD;&#xA;    Card(rank=<Rank.four: 4>, suit=<Suit.spades: 4>)&#xD;&#xA;    >>> c1 < c2&#xD;&#xA;    True&#xD;&#xA;    >>> c1 > c3&#xD;&#xA;    False&#xD;&#xA;&#xD;&#xA;Tuple sorting is lexicographic! Nice!&#xD;&#xA;&#xD;&#xA;    >>> hand = [c2, c1, c3]&#xD;&#xA;    >>> hand&#xD;&#xA;    [Card(rank=<Rank.four: 4>, suit=<Suit.spades: 4>), Card(rank=<Rank.four: 4>, suit=<Suit.clubs: 1>), Card(rank=<Rank.ace: 13>, suit=<Suit.diamonds: 2>)]&#xD;&#xA;    >>> sorted(hand)&#xD;&#xA;    [Card(rank=<Rank.four: 4>, suit=<Suit.clubs: 1>), Card(rank=<Rank.four: 4>, suit=<Suit.spades: 4>), Card(rank=<Rank.ace: 13>, suit=<Suit.diamonds: 2>)]&#xD;&#xA;    >>>&#xD;&#xA;&#xD;&#xA;Note, I've used the `total_ordering` decorator, which is simply a shortcut, and indeed, I think it might be better to simply do the whole class by hand. [Here's](https://docs.python.org/3/library/enum.html#orderedenum) a recipe.";;
139041361;42399384;5014455;5;093bcbe4-5e03-41c7-995b-fda1e84d7cd2;2017-02-22 18:54:12.0;"Here is a sketch of an approach. You can easily combine this with your own approach, the biggest change being for the `Card` class. Here, I've used `namedtuple` to make a `Card` class, but your current class can simply wrap a `tuple` value:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    import enum&#xD;&#xA;    from functools import total_ordering&#xD;&#xA;    from collections import namedtuple&#xD;&#xA;    &#xD;&#xA;    @total_ordering&#xD;&#xA;    class OrderedEnum(enum.Enum):&#xD;&#xA;        def __lt__(self, other):&#xD;&#xA;            if isinstance(other, type(self)):&#xD;&#xA;                return self.value < other.value&#xD;&#xA;            return NotImplemented&#xD;&#xA;    &#xD;&#xA;    Rank = OrderedEnum('Rank', ['one', 'two', 'three', 'four', 'five', 'six',&#xD;&#xA;                        'seven', 'eight', 'nine', 'jack', 'queen','king', 'ace'])&#xD;&#xA;    &#xD;&#xA;    Suit = OrderedEnum('Suit', ['clubs', 'diamonds', 'hearts', 'spades'])&#xD;&#xA;    &#xD;&#xA;    Card = namedtuple('Card', ['rank', 'suit'])&#xD;&#xA;    &#xD;&#xA;    c1 = Card(Rank.four, Suit.clubs)&#xD;&#xA;    c2 = Card(Rank.four, Suit.spades)&#xD;&#xA;    c3 = Card(Rank.ace, Suit.diamonds)&#xD;&#xA;&#xD;&#xA;Now, in action:&#xD;&#xA;&#xD;&#xA;    >>> c1&#xD;&#xA;    Card(rank=<Rank.four: 4>, suit=<Suit.clubs: 1>)&#xD;&#xA;    >>> c2&#xD;&#xA;    Card(rank=<Rank.four: 4>, suit=<Suit.spades: 4>)&#xD;&#xA;    >>> c1 < c2&#xD;&#xA;    True&#xD;&#xA;    >>> c1 > c3&#xD;&#xA;    False&#xD;&#xA;&#xD;&#xA;Tuple sorting is lexicographic! Nice!&#xD;&#xA;&#xD;&#xA;    >>> hand = [c2, c1, c3]&#xD;&#xA;    >>> hand&#xD;&#xA;    [Card(rank=<Rank.four: 4>, suit=<Suit.spades: 4>), Card(rank=<Rank.four: 4>, suit=<Suit.clubs: 1>), Card(rank=<Rank.ace: 13>, suit=<Suit.diamonds: 2>)]&#xD;&#xA;    >>> sorted(hand)&#xD;&#xA;    [Card(rank=<Rank.four: 4>, suit=<Suit.clubs: 1>), Card(rank=<Rank.four: 4>, suit=<Suit.spades: 4>), Card(rank=<Rank.ace: 13>, suit=<Suit.diamonds: 2>)]&#xD;&#xA;    >>>&#xD;&#xA;&#xD;&#xA;Note, I've used the `total_ordering` decorator, which is simply a shortcut, and indeed, I think it might be better to simply do the whole class by hand. [Here's](https://docs.python.org/3/library/enum.html#orderedenum) a recipe.&#xD;&#xA;&#xD;&#xA;**EDIT**&#xD;&#xA;So, to elaborate, here is how I would implement your `Card` and `Deck` classes. Notice how much more readable your code becomes when you use the `enum` and `namedtuple`. &#xD;&#xA;&#xD;&#xA;    import enum&#xD;&#xA;    from functools import total_ordering&#xD;&#xA;    from collections import namedtuple&#xD;&#xA;    from random import shuffle &#xD;&#xA;    &#xD;&#xA;    @total_ordering&#xD;&#xA;    class OrderedEnum(enum.Enum):&#xD;&#xA;        def __lt__(self, other):&#xD;&#xA;            if isinstance(other, type(self)):&#xD;&#xA;                return self.value < other.value&#xD;&#xA;            return NotImplemented&#xD;&#xA;    &#xD;&#xA;    Rank = OrderedEnum('Rank', ['one', 'two', 'three', 'four', 'five', 'six',&#xD;&#xA;                        'seven', 'eight', 'nine', 'jack', 'queen','king', 'ace'])&#xD;&#xA;    Suit = OrderedEnum('Suit', ['clubs', 'diamonds', 'hearts', 'spades'])&#xD;&#xA;    CardValue = namedtuple('CardValue', ['rank', 'suit'])&#xD;&#xA;    &#xD;&#xA;    @total_ordering&#xD;&#xA;    class Card(object):&#xD;&#xA;        def __init__(self, rank, suit):&#xD;&#xA;            self.value = CardValue(rank, suit)&#xD;&#xA;        def __repr__(self):&#xD;&#xA;            return ""Card({:s}, {:s})"".format(self.value.rank, self.value.suit)&#xD;&#xA;        def __lt__(self, other):&#xD;&#xA;            if isinstance(other, type(self)):&#xD;&#xA;                return self.value < other.value&#xD;&#xA;            return NotImplemented&#xD;&#xA;        def __eq__(self, other):&#xD;&#xA;            if isinstance(other, type(self)):&#xD;&#xA;                return self.value == other.value&#xD;&#xA;            return NotImplemented&#xD;&#xA;            &#xD;&#xA;    class Deck(object):&#xD;&#xA;        def __init__(self):&#xD;&#xA;            self.cards = []&#xD;&#xA;            for rank in Rank:&#xD;&#xA;                for suit in Suit:&#xD;&#xA;                    self.cards.append(Card(rank, suit))&#xD;&#xA;            shuffle(self.cards)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Now, in action:&#xD;&#xA;&#xD;&#xA;    >>> deck = Deck()&#xD;&#xA;    >>> c1 = deck.cards.pop()&#xD;&#xA;    >>> c2 = deck.cards.pop()&#xD;&#xA;    >>> c1&#xD;&#xA;    Card(Rank.queen, Suit.hearts)&#xD;&#xA;    >>> c2&#xD;&#xA;    Card(Rank.king, Suit.clubs)&#xD;&#xA;    >>> c1 == c2&#xD;&#xA;    False&#xD;&#xA;    >>> c1 > c2&#xD;&#xA;    False&#xD;&#xA;    >>> c1 < c2&#xD;&#xA;    True&#xD;&#xA;    >>> c1.value&#xD;&#xA;    CardValue(rank=<Rank.queen: 11>, suit=<Suit.hearts: 3>)&#xD;&#xA;    >>> c2.value&#xD;&#xA;    CardValue(rank=<Rank.king: 12>, suit=<Suit.clubs: 1>)&#xD;&#xA;&#xD;&#xA;Also, notice that `__repr__` should try to *represent* the object, if you want a pretty message, use `__str__`. See [this question](http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python)&#xD;&#xA;";;added 2344 characters in body
146409038;42399384;-1;5;80d78225-df18-46e4-a5f5-41db54748778;2017-05-23 11:46:12.0;"Here is a sketch of an approach. You can easily combine this with your own approach, the biggest change being for the `Card` class. Here, I've used `namedtuple` to make a `Card` class, but your current class can simply wrap a `tuple` value:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    import enum&#xD;&#xA;    from functools import total_ordering&#xD;&#xA;    from collections import namedtuple&#xD;&#xA;    &#xD;&#xA;    @total_ordering&#xD;&#xA;    class OrderedEnum(enum.Enum):&#xD;&#xA;        def __lt__(self, other):&#xD;&#xA;            if isinstance(other, type(self)):&#xD;&#xA;                return self.value < other.value&#xD;&#xA;            return NotImplemented&#xD;&#xA;    &#xD;&#xA;    Rank = OrderedEnum('Rank', ['one', 'two', 'three', 'four', 'five', 'six',&#xD;&#xA;                        'seven', 'eight', 'nine', 'jack', 'queen','king', 'ace'])&#xD;&#xA;    &#xD;&#xA;    Suit = OrderedEnum('Suit', ['clubs', 'diamonds', 'hearts', 'spades'])&#xD;&#xA;    &#xD;&#xA;    Card = namedtuple('Card', ['rank', 'suit'])&#xD;&#xA;    &#xD;&#xA;    c1 = Card(Rank.four, Suit.clubs)&#xD;&#xA;    c2 = Card(Rank.four, Suit.spades)&#xD;&#xA;    c3 = Card(Rank.ace, Suit.diamonds)&#xD;&#xA;&#xD;&#xA;Now, in action:&#xD;&#xA;&#xD;&#xA;    >>> c1&#xD;&#xA;    Card(rank=<Rank.four: 4>, suit=<Suit.clubs: 1>)&#xD;&#xA;    >>> c2&#xD;&#xA;    Card(rank=<Rank.four: 4>, suit=<Suit.spades: 4>)&#xD;&#xA;    >>> c1 < c2&#xD;&#xA;    True&#xD;&#xA;    >>> c1 > c3&#xD;&#xA;    False&#xD;&#xA;&#xD;&#xA;Tuple sorting is lexicographic! Nice!&#xD;&#xA;&#xD;&#xA;    >>> hand = [c2, c1, c3]&#xD;&#xA;    >>> hand&#xD;&#xA;    [Card(rank=<Rank.four: 4>, suit=<Suit.spades: 4>), Card(rank=<Rank.four: 4>, suit=<Suit.clubs: 1>), Card(rank=<Rank.ace: 13>, suit=<Suit.diamonds: 2>)]&#xD;&#xA;    >>> sorted(hand)&#xD;&#xA;    [Card(rank=<Rank.four: 4>, suit=<Suit.clubs: 1>), Card(rank=<Rank.four: 4>, suit=<Suit.spades: 4>), Card(rank=<Rank.ace: 13>, suit=<Suit.diamonds: 2>)]&#xD;&#xA;    >>>&#xD;&#xA;&#xD;&#xA;Note, I've used the `total_ordering` decorator, which is simply a shortcut, and indeed, I think it might be better to simply do the whole class by hand. [Here's](https://docs.python.org/3/library/enum.html#orderedenum) a recipe.&#xD;&#xA;&#xD;&#xA;**EDIT**&#xD;&#xA;So, to elaborate, here is how I would implement your `Card` and `Deck` classes. Notice how much more readable your code becomes when you use the `enum` and `namedtuple`. &#xD;&#xA;&#xD;&#xA;    import enum&#xD;&#xA;    from functools import total_ordering&#xD;&#xA;    from collections import namedtuple&#xD;&#xA;    from random import shuffle &#xD;&#xA;    &#xD;&#xA;    @total_ordering&#xD;&#xA;    class OrderedEnum(enum.Enum):&#xD;&#xA;        def __lt__(self, other):&#xD;&#xA;            if isinstance(other, type(self)):&#xD;&#xA;                return self.value < other.value&#xD;&#xA;            return NotImplemented&#xD;&#xA;    &#xD;&#xA;    Rank = OrderedEnum('Rank', ['one', 'two', 'three', 'four', 'five', 'six',&#xD;&#xA;                        'seven', 'eight', 'nine', 'jack', 'queen','king', 'ace'])&#xD;&#xA;    Suit = OrderedEnum('Suit', ['clubs', 'diamonds', 'hearts', 'spades'])&#xD;&#xA;    CardValue = namedtuple('CardValue', ['rank', 'suit'])&#xD;&#xA;    &#xD;&#xA;    @total_ordering&#xD;&#xA;    class Card(object):&#xD;&#xA;        def __init__(self, rank, suit):&#xD;&#xA;            self.value = CardValue(rank, suit)&#xD;&#xA;        def __repr__(self):&#xD;&#xA;            return ""Card({:s}, {:s})"".format(self.value.rank, self.value.suit)&#xD;&#xA;        def __lt__(self, other):&#xD;&#xA;            if isinstance(other, type(self)):&#xD;&#xA;                return self.value < other.value&#xD;&#xA;            return NotImplemented&#xD;&#xA;        def __eq__(self, other):&#xD;&#xA;            if isinstance(other, type(self)):&#xD;&#xA;                return self.value == other.value&#xD;&#xA;            return NotImplemented&#xD;&#xA;            &#xD;&#xA;    class Deck(object):&#xD;&#xA;        def __init__(self):&#xD;&#xA;            self.cards = []&#xD;&#xA;            for rank in Rank:&#xD;&#xA;                for suit in Suit:&#xD;&#xA;                    self.cards.append(Card(rank, suit))&#xD;&#xA;            shuffle(self.cards)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Now, in action:&#xD;&#xA;&#xD;&#xA;    >>> deck = Deck()&#xD;&#xA;    >>> c1 = deck.cards.pop()&#xD;&#xA;    >>> c2 = deck.cards.pop()&#xD;&#xA;    >>> c1&#xD;&#xA;    Card(Rank.queen, Suit.hearts)&#xD;&#xA;    >>> c2&#xD;&#xA;    Card(Rank.king, Suit.clubs)&#xD;&#xA;    >>> c1 == c2&#xD;&#xA;    False&#xD;&#xA;    >>> c1 > c2&#xD;&#xA;    False&#xD;&#xA;    >>> c1 < c2&#xD;&#xA;    True&#xD;&#xA;    >>> c1.value&#xD;&#xA;    CardValue(rank=<Rank.queen: 11>, suit=<Suit.hearts: 3>)&#xD;&#xA;    >>> c2.value&#xD;&#xA;    CardValue(rank=<Rank.king: 12>, suit=<Suit.clubs: 1>)&#xD;&#xA;&#xD;&#xA;Also, notice that `__repr__` should try to *represent* the object, if you want a pretty message, use `__str__`. See [this question](https://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python)&#xD;&#xA;";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
