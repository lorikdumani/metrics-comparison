Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
141675777;43054688;3832970;2;9a5c2a42-7e94-48d4-a8fb-ef4f69769752;2017-03-27 19:18:00.0;"I believe you want to match a string that may contain any of the alternatives you defined in the `MY_TOKENS`, then  0+ whitespaces and then 1 or more digits up to the end of the string.&#xD;&#xA;&#xD;&#xA;Then you need to use&#xD;&#xA;&#xD;&#xA;    Regexp.new(""\\\\A#{Regexp.union(MY_TOKENS)}?[[:space:]]*\\\\d+\\\\z"").match?(s)&#xD;&#xA;&#xD;&#xA;or&#xD;&#xA;&#xD;&#xA;    /\\A#{Regexp.union(MY_TOKENS)}?[[:space:]]*\\d+\\z/.match?(s)&#xD;&#xA;&#xD;&#xA;When you use a `Regexp.new`, you should rememeber to double escape backslashes to define a literal backslash (e.g. ""\\\\d"" is a digit matching pattern). In a regex literal notation, you may use a single backslash (`/\\d/`).&#xD;&#xA;&#xD;&#xA;Do not forget to match the start of a string with `\\A` and end of string with `\\z` anchors.&#xD;&#xA;&#xD;&#xA;Note that `[...]` creates a character class that matches any char that is defined inside it: `[ab]` matches an `a` or `b`, `[program]` will match one char, either `p`, `r`, `o`, `g`, `r`, `a` or `m`. If you have multicharacter *sequences* in the `MY_TOKENS`, you need to remove `[...]` from the pattern.";;
141677911;43054688;3832970;5;5bf002b2-9df6-416d-ad50-7d82b019c91c;2017-03-27 19:48:20.0;"I believe you want to match a string that may contain any of the alternatives you defined in the `MY_TOKENS`, then  0+ whitespaces and then 1 or more digits up to the end of the string.&#xD;&#xA;&#xD;&#xA;Then you need to use&#xD;&#xA;&#xD;&#xA;    Regexp.new(""\\\\A#{Regexp.union(MY_TOKENS)}?[[:space:]]*\\\\d+\\\\z"").match?(s)&#xD;&#xA;&#xD;&#xA;or&#xD;&#xA;&#xD;&#xA;    /\\A#{Regexp.union(MY_TOKENS)}?[[:space:]]*\\d+\\z/.match?(s)&#xD;&#xA;&#xD;&#xA;When you use a `Regexp.new`, you should rememeber to double escape backslashes to define a literal backslash (e.g. ""\\\\d"" is a digit matching pattern). In a regex literal notation, you may use a single backslash (`/\\d/`).&#xD;&#xA;&#xD;&#xA;Do not forget to match the start of a string with `\\A` and end of string with `\\z` anchors.&#xD;&#xA;&#xD;&#xA;Note that `[...]` creates a character class that matches any char that is defined inside it: `[ab]` matches an `a` or `b`, `[program]` will match one char, either `p`, `r`, `o`, `g`, `r`, `a` or `m`. If you have multicharacter *sequences* in the `MY_TOKENS`, you need to remove `[...]` from the pattern.&#xD;&#xA;&#xD;&#xA;To make the regex case insensitive, pass a case insensitive modifier to the pattern and make sure you use `.source` property of the `Regex.union` created regex to remove flags (thanks, [Eric][1]):&#xD;&#xA;&#xD;&#xA;    Regexp.new(""(?i)\\\\A#{Regexp.union(MY_TOKENS).source}?[[:space:]]*\\\\d+\\\\z"")&#xD;&#xA;&#xD;&#xA;or&#xD;&#xA;&#xD;&#xA;    /\\A#{Regexp.union(MY_TOKENS).source}?[[:space:]]*\\d+\\z/i&#xD;&#xA;&#xD;&#xA;The regex created is `/(?i-mx:\\Aa|b?[[:space:]]*\\d+\\z)/` where `(?i-mx)` means the case insensitive mode is on and multiline (dot matches line breaks and verbose modes are off).&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/43054542/in-ruby-why-isnt-regexp-union-matching-a-character-at-the-beginning-of-my-stri/43054688?noredirect=1#comment73194782_43054688";;added 336 characters in body
146840153;43054688;-1;5;ed7897e4-a188-40e2-996b-319b488c9eb9;2017-05-23 12:02:04.0;"I believe you want to match a string that may contain any of the alternatives you defined in the `MY_TOKENS`, then  0+ whitespaces and then 1 or more digits up to the end of the string.&#xD;&#xA;&#xD;&#xA;Then you need to use&#xD;&#xA;&#xD;&#xA;    Regexp.new(""\\\\A#{Regexp.union(MY_TOKENS)}?[[:space:]]*\\\\d+\\\\z"").match?(s)&#xD;&#xA;&#xD;&#xA;or&#xD;&#xA;&#xD;&#xA;    /\\A#{Regexp.union(MY_TOKENS)}?[[:space:]]*\\d+\\z/.match?(s)&#xD;&#xA;&#xD;&#xA;When you use a `Regexp.new`, you should rememeber to double escape backslashes to define a literal backslash (e.g. ""\\\\d"" is a digit matching pattern). In a regex literal notation, you may use a single backslash (`/\\d/`).&#xD;&#xA;&#xD;&#xA;Do not forget to match the start of a string with `\\A` and end of string with `\\z` anchors.&#xD;&#xA;&#xD;&#xA;Note that `[...]` creates a character class that matches any char that is defined inside it: `[ab]` matches an `a` or `b`, `[program]` will match one char, either `p`, `r`, `o`, `g`, `r`, `a` or `m`. If you have multicharacter *sequences* in the `MY_TOKENS`, you need to remove `[...]` from the pattern.&#xD;&#xA;&#xD;&#xA;To make the regex case insensitive, pass a case insensitive modifier to the pattern and make sure you use `.source` property of the `Regex.union` created regex to remove flags (thanks, [Eric][1]):&#xD;&#xA;&#xD;&#xA;    Regexp.new(""(?i)\\\\A#{Regexp.union(MY_TOKENS).source}?[[:space:]]*\\\\d+\\\\z"")&#xD;&#xA;&#xD;&#xA;or&#xD;&#xA;&#xD;&#xA;    /\\A#{Regexp.union(MY_TOKENS).source}?[[:space:]]*\\d+\\z/i&#xD;&#xA;&#xD;&#xA;The regex created is `/(?i-mx:\\Aa|b?[[:space:]]*\\d+\\z)/` where `(?i-mx)` means the case insensitive mode is on and multiline (dot matches line breaks and verbose modes are off).&#xD;&#xA;&#xD;&#xA;  [1]: https://stackoverflow.com/questions/43054542/in-ruby-why-isnt-regexp-union-matching-a-character-at-the-beginning-of-my-stri/43054688?noredirect=1#comment73194782_43054688";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
