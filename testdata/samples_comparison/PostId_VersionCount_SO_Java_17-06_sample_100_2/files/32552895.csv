Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
99546880;32552895;179850;2;6d656e26-6bb9-44b0-9ccc-efc0eb7ff9cd;2015-09-13 18:09:21.0;"> I call my ContentParser.queueExecutor from another class, so after all jobs are submitted I do:&#xD;&#xA;&#xD;&#xA;It sounds like you are saying that someone is calling `cachedThreadPool.shutdown()` but jobs are still being submitted to the pool.  That should never happen.  `shutdown()` should be called only after you `poll()` loop completes.&#xD;&#xA;&#xD;&#xA;I'd recommend doing something like the following in your `queueExecutor(...)` method:&#xD;&#xA;&#xD;&#xA;    while ((url = queue.poll()) != null){&#xD;&#xA;        LOG.info(""Picked url "" + url);&#xD;&#xA;        cachedThreadPool.submit(new ParserCallable(content, url));&#xD;&#xA;    }&#xD;&#xA;    // shutdown _after_ all jobs have been submitted&#xD;&#xA;    cachedThreadPool.shutdown();&#xD;&#xA;&#xD;&#xA;Also, in general, it is a bad practice to make fields public -- especially in this case your `cachedThreadPool` field.  You can't control how (or in this case when) external classes call critical methods on your pool.  I'd make it private then have an await method on your `ContentParser` class:&#xD;&#xA;&#xD;&#xA;    private static ExecutorService cachedThreadPool = Executors.newCachedThreadPool();&#xD;&#xA;    ...&#xD;&#xA;    public static void awaitPoolTermination(/* maybe timeout args here */) {&#xD;&#xA;        cachedThreadPool.awaitTermination(5l, TimeUnit.MINUTES);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This better controls your thread-pool and doesn't allow the shutdown at the improper place.  So then the caller of the `ContentParser` methods would first call `queueExecutor(...)` and then call `awaitPoolTermination(...)`.";;
99554748;32552895;179850;5;edff0598-02a1-4bb8-a7c2-348b70e8d6ef;2015-09-13 21:51:44.0;"> I call my ContentParser.queueExecutor from another class, so after all jobs are submitted I do:&#xD;&#xA;&#xD;&#xA;It sounds like you are saying that someone is calling `cachedThreadPool.shutdown()` but jobs are still being submitted to the pool.  That should never happen.  `shutdown()` should be called only after you `poll()` loop completes.&#xD;&#xA;&#xD;&#xA;I'd recommend doing something like the following in your `queueExecutor(...)` method:&#xD;&#xA;&#xD;&#xA;    while ((url = queue.poll()) != null){&#xD;&#xA;        LOG.info(""Picked url "" + url);&#xD;&#xA;        cachedThreadPool.submit(new ParserCallable(content, url));&#xD;&#xA;    }&#xD;&#xA;    // shutdown _after_ all jobs have been submitted&#xD;&#xA;    cachedThreadPool.shutdown();&#xD;&#xA;&#xD;&#xA;Also, in general, it is a bad practice to make fields public -- especially in this case your `cachedThreadPool` field.  You can't control how (or in this case when) external classes call critical methods on your pool.  I'd make it private then have an await method on your `ContentParser` class:&#xD;&#xA;&#xD;&#xA;    private static ExecutorService cachedThreadPool = Executors.newCachedThreadPool();&#xD;&#xA;    ...&#xD;&#xA;    public static void awaitPoolTermination(/* maybe timeout args here */) {&#xD;&#xA;        cachedThreadPool.awaitTermination(5l, TimeUnit.MINUTES);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This better controls your thread-pool and doesn't allow the shutdown at the improper place.  So then the caller of the `ContentParser` methods would first call `contentParser.queueExecutor(...)` and then call `contentParser.awaitPoolTermination(...)`.";;added 28 characters in body
