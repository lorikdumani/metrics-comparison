Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
56064242;21238830;2952464;2;0880f0fb-163d-4355-840d-830fb8d035a5;2014-01-20 16:11:55.0;"&#xD;&#xA;Maybe if you use `while` instead of `if` on `doInBackground()` method of `Worker` class you will solve your problem. You must to put out of the `while` loop the `mapp()`, because you only want to invoke it one time. You should do something like this:&#xD;&#xA;&#xD;&#xA;    class Worker extends SwingWorker<Void, Void> {&#xD;&#xA;    &#xD;&#xA;        @Override&#xD;&#xA;        protected Void doInBackground() throws Exception {&#xD;&#xA;&#xD;&#xA;        mapp();    &#xD;&#xA;        while(!isCancelled()){&#xD;&#xA;            Thread.sleep(60);&#xD;&#xA;        }&#xD;&#xA;         System.out.println(""SwingWorker - isCancelled"");    &#xD;&#xA;            return null;       &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This [link][1] could be useful to understanding how to use `SwingWorker`.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/6/docs/api/javax/swing/SwingWorker.html";;
56073480;21238830;2952464;5;1d92e65d-9507-492a-b519-ed5794ecf409;2014-01-20 18:28:05.0;"Maybe if you use `while` instead of `if` on `doInBackground()` method of `Worker` class you will solve your problem. You must to put out of the `while` loop the `mapp()`, because you only want to invoke it one time. You should do something like this:&#xD;&#xA;&#xD;&#xA;    class Worker extends SwingWorker<Void, Void> {&#xD;&#xA;    &#xD;&#xA;        @Override&#xD;&#xA;        protected Void doInBackground() throws Exception {&#xD;&#xA;&#xD;&#xA;        mapp();    &#xD;&#xA;        while(!isCancelled()){&#xD;&#xA;            Thread.sleep(60);&#xD;&#xA;        }&#xD;&#xA;         System.out.println(""SwingWorker - isCancelled"");    &#xD;&#xA;            return null;       &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This [link][1] could be useful to understanding how to use `SwingWorker`.&#xD;&#xA;&#xD;&#xA;**EDIT:**&#xD;&#xA;&#xD;&#xA;As you can see on another questions like [this][2] or [this][3], using `SwingWorker` has some problems to manage the `cancel` method, because this method *Attempts to cancel execution of this task. This attempt will fail if the task has already completed, has already been cancelled, **or could not be cancelled for some other reason***, like [Oracle][4] explains, and those ""some other reasons"" are discussed on the links I've posted.&#xD;&#xA;&#xD;&#xA;You can do solve your problem using directly `Threads`. Your code would be something like this:&#xD;&#xA;&#xD;&#xA;        public class MainWindow extends JFrame implements ActionListener, WindowListener&#xD;&#xA;        {&#xD;&#xA;         // Some code, like generating JFrame, JButtons and other stuff not affencting the task.&#xD;&#xA;        &#xD;&#xA;            final Thread th1 = new Thread(new Runnable() {&#xD;&#xA;            &#xD;&#xA;            			@Override&#xD;&#xA;            			public void run() {&#xD;&#xA;            				mapp();					&#xD;&#xA;            				&#xD;&#xA;            			}&#xD;&#xA;            		});	&#xD;&#xA;            public void actionPerformed(ActionEvent e)&#xD;&#xA;            {       &#xD;&#xA;            boolean isStarted = false;&#xD;&#xA;    &#xD;&#xA;        // Start Button&#xD;&#xA;        if (e.getSource() == this.buttonStart)&#xD;&#xA;        {&#xD;&#xA;            if(!isStarted)&#xD;&#xA;            {&#xD;&#xA;            System.out.println(""start"");&#xD;&#xA;            labelSuccess.setText(""Mapping started!"");&#xD;&#xA;            this.setEnabled(true);&#xD;&#xA;            th1.start();&#xD;&#xA;            isStarted = false;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        // Stop Button&#xD;&#xA;        if (e.getSource() == this.buttonStop)&#xD;&#xA;            {&#xD;&#xA;            labelSuccess.setText(""Mapping stopped!"");&#xD;&#xA;            th1.stop();&#xD;&#xA;            }&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;This solutions uses the method `stop()`, which is deprecated, but it works (tested on my own code). I recommend you to learn more about `SwingWorker`, `Thread` and `Task` to find the best solution to your problem.&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/6/docs/api/javax/swing/SwingWorker.html&#xD;&#xA;  [2]: http://stackoverflow.com/questions/8083768/stop-cancel-swingworker-thread?rq=1&#xD;&#xA;  [3]: http://stackoverflow.com/questions/6113944/how-cancel-the-execution-of-a-swingworker&#xD;&#xA;  [4]: http://docs.oracle.com/javase/7/docs/api/javax/swing/SwingWorker.html#cancel%28boolean%29&#xD;&#xA;";;added 2135 characters in body
56128508;21238830;2952464;5;29f7f23c-e04e-429f-91ac-ebd8d5096d8d;2014-01-21 11:30:33.0;"Maybe if you use `while` instead of `if` on `doInBackground()` method of `Worker` class you will solve your problem. You must to put out of the `while` loop the `mapp()`, because you only want to invoke it one time. You should do something like this:&#xD;&#xA;&#xD;&#xA;    class Worker extends SwingWorker<Void, Void> {&#xD;&#xA;    &#xD;&#xA;        @Override&#xD;&#xA;        protected Void doInBackground() throws Exception {&#xD;&#xA;&#xD;&#xA;        mapp();    &#xD;&#xA;        while(!isCancelled()){&#xD;&#xA;            Thread.sleep(60);&#xD;&#xA;        }&#xD;&#xA;         System.out.println(""SwingWorker - isCancelled"");    &#xD;&#xA;            return null;       &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This [link][1] could be useful to understanding how to use `SwingWorker`.&#xD;&#xA;&#xD;&#xA;**EDIT:**&#xD;&#xA;&#xD;&#xA;As you can see on another questions like [this][2] or [this][3], using `SwingWorker` has some problems to manage the `cancel` method, because this method *Attempts to cancel execution of this task. This attempt will fail if the task has already completed, has already been cancelled, **or could not be cancelled for some other reason***, like [Oracle][4] explains, and those ""some other reasons"" are discussed on the links I've posted.&#xD;&#xA;&#xD;&#xA;You can do solve your problem using directly `Threads`. Your code would be something like this:&#xD;&#xA;&#xD;&#xA;        public class MainWindow extends JFrame implements ActionListener, WindowListener&#xD;&#xA;        {&#xD;&#xA;         // Some code, like generating JFrame, JButtons and other stuff not affencting the task.&#xD;&#xA;        &#xD;&#xA;            final Thread th1 = new Thread(new Runnable() {&#xD;&#xA;            &#xD;&#xA;            			@Override&#xD;&#xA;            			public void run() {&#xD;&#xA;            				mapp();					&#xD;&#xA;            				&#xD;&#xA;            			}&#xD;&#xA;            		});	&#xD;&#xA;            public void actionPerformed(ActionEvent e)&#xD;&#xA;            {       &#xD;&#xA;            boolean isStarted = false;&#xD;&#xA;    &#xD;&#xA;        // Start Button&#xD;&#xA;        if (e.getSource() == this.buttonStart)&#xD;&#xA;        {&#xD;&#xA;            if(!isStarted)&#xD;&#xA;            {&#xD;&#xA;            System.out.println(""start"");&#xD;&#xA;            labelSuccess.setText(""Mapping started!"");&#xD;&#xA;            this.setEnabled(true);&#xD;&#xA;            th1.start();&#xD;&#xA;            isStarted = false;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        // Stop Button&#xD;&#xA;        if (e.getSource() == this.buttonStop)&#xD;&#xA;            {&#xD;&#xA;            labelSuccess.setText(""Mapping stopped!"");&#xD;&#xA;            th1.stop();&#xD;&#xA;            }&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;This solutions uses the method `stop()`, which is deprecated, but it works. I've tried using `interrupt()`, but I don't know why the thread ran till finish the execution of `mapp()`. Obviously, using `stop()` is not the best method but it works stopping the `mapp()` execution before it finishes.&#xD;&#xA;&#xD;&#xA;**I recommend you to learn more about `SwingWorker`, `Thread` and `Task` to find the best solution to your problem.**&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/6/docs/api/javax/swing/SwingWorker.html&#xD;&#xA;  [2]: http://stackoverflow.com/questions/8083768/stop-cancel-swingworker-thread?rq=1&#xD;&#xA;  [3]: http://stackoverflow.com/questions/6113944/how-cancel-the-execution-of-a-swingworker&#xD;&#xA;  [4]: http://docs.oracle.com/javase/7/docs/api/javax/swing/SwingWorker.html#cancel%28boolean%29";;added 202 characters in body
146083346;21238830;-1;5;4e2ba93c-7acd-41a8-b295-8b171e9b36b9;2017-05-23 10:25:55.0;"Maybe if you use `while` instead of `if` on `doInBackground()` method of `Worker` class you will solve your problem. You must to put out of the `while` loop the `mapp()`, because you only want to invoke it one time. You should do something like this:&#xD;&#xA;&#xD;&#xA;    class Worker extends SwingWorker<Void, Void> {&#xD;&#xA;    &#xD;&#xA;        @Override&#xD;&#xA;        protected Void doInBackground() throws Exception {&#xD;&#xA;&#xD;&#xA;        mapp();    &#xD;&#xA;        while(!isCancelled()){&#xD;&#xA;            Thread.sleep(60);&#xD;&#xA;        }&#xD;&#xA;         System.out.println(""SwingWorker - isCancelled"");    &#xD;&#xA;            return null;       &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This [link][1] could be useful to understanding how to use `SwingWorker`.&#xD;&#xA;&#xD;&#xA;**EDIT:**&#xD;&#xA;&#xD;&#xA;As you can see on another questions like [this][2] or [this][3], using `SwingWorker` has some problems to manage the `cancel` method, because this method *Attempts to cancel execution of this task. This attempt will fail if the task has already completed, has already been cancelled, **or could not be cancelled for some other reason***, like [Oracle][4] explains, and those ""some other reasons"" are discussed on the links I've posted.&#xD;&#xA;&#xD;&#xA;You can do solve your problem using directly `Threads`. Your code would be something like this:&#xD;&#xA;&#xD;&#xA;        public class MainWindow extends JFrame implements ActionListener, WindowListener&#xD;&#xA;        {&#xD;&#xA;         // Some code, like generating JFrame, JButtons and other stuff not affencting the task.&#xD;&#xA;        &#xD;&#xA;            final Thread th1 = new Thread(new Runnable() {&#xD;&#xA;            &#xD;&#xA;            			@Override&#xD;&#xA;            			public void run() {&#xD;&#xA;            				mapp();					&#xD;&#xA;            				&#xD;&#xA;            			}&#xD;&#xA;            		});	&#xD;&#xA;            public void actionPerformed(ActionEvent e)&#xD;&#xA;            {       &#xD;&#xA;            boolean isStarted = false;&#xD;&#xA;    &#xD;&#xA;        // Start Button&#xD;&#xA;        if (e.getSource() == this.buttonStart)&#xD;&#xA;        {&#xD;&#xA;            if(!isStarted)&#xD;&#xA;            {&#xD;&#xA;            System.out.println(""start"");&#xD;&#xA;            labelSuccess.setText(""Mapping started!"");&#xD;&#xA;            this.setEnabled(true);&#xD;&#xA;            th1.start();&#xD;&#xA;            isStarted = false;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        // Stop Button&#xD;&#xA;        if (e.getSource() == this.buttonStop)&#xD;&#xA;            {&#xD;&#xA;            labelSuccess.setText(""Mapping stopped!"");&#xD;&#xA;            th1.stop();&#xD;&#xA;            }&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;This solutions uses the method `stop()`, which is deprecated, but it works. I've tried using `interrupt()`, but I don't know why the thread ran till finish the execution of `mapp()`. Obviously, using `stop()` is not the best method but it works stopping the `mapp()` execution before it finishes.&#xD;&#xA;&#xD;&#xA;**I recommend you to learn more about `SwingWorker`, `Thread` and `Task` to find the best solution to your problem.**&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/6/docs/api/javax/swing/SwingWorker.html&#xD;&#xA;  [2]: https://stackoverflow.com/questions/8083768/stop-cancel-swingworker-thread?rq=1&#xD;&#xA;  [3]: https://stackoverflow.com/questions/6113944/how-cancel-the-execution-of-a-swingworker&#xD;&#xA;  [4]: http://docs.oracle.com/javase/7/docs/api/javax/swing/SwingWorker.html#cancel%28boolean%29";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
