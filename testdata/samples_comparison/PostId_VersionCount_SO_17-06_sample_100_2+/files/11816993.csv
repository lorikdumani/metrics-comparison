Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
27613056;11816993;892932;2;f5b54708-d164-4526-a1bc-3792fbd67d74;2012-08-05 13:54:02.0;"The idea behind fixed-point arithmetic is that you store the values multiplied by a certain amount, use the multiplied values for all calculus, and divide the result by the same amount when you want the result.&#xD;&#xA;&#xD;&#xA;The usual and most efficient way of doing this in C is by using the shifting operators (<< and >>). They have the property of multiplying and dividing integer values. A drawback is that the multiplier must be a power of 2 (which is usually not a problem by itself).&#xD;&#xA;&#xD;&#xA;Now let's say we want to use 32 bits integers for storing our values. We must choose a power of 2 multiplier, say 65536. This is 2¹⁶, and the 16 here means that we're using the 16 most significant bits (MSB) for the integer part and the 16 least significant bits (LSB) for the fractional part.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #define SHIFT_AMOUNT 16 // 2^16 = 65536&#xD;&#xA;    #define SHIFT_MASK ((1 << SHIFT_AMOUNT) - 1)&#xD;&#xA;    &#xD;&#xA;    int price = 500 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;This is the value you must put in store (structure, database, whatever).&#xD;&#xA;&#xD;&#xA;When you want to do calculus on this value, you can use the 4 basic operators: +, -, * and /.&#xD;&#xA;&#xD;&#xA;You have to keep in mind that when adding and substrating a value (+ and -), that value must also be shifted. Let's say we want to add 10 to our 500 price:&#xD;&#xA;&#xD;&#xA;    price += 10 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;But for multiplication and division (* and /), the multiplier/divisor must NOT be shifted. Let's say we want to multiply by 10:&#xD;&#xA;&#xD;&#xA;    price *= 10;&#xD;&#xA; &#xD;&#xA;That's all about the rules. When you want to retrieve the real price at any point, you must right-shift:&#xD;&#xA;&#xD;&#xA;    printf(""price is %d"", price >> SHIFT_AMOUNT);&#xD;&#xA;&#xD;&#xA;If you need the fractional part, you must mask it out:&#xD;&#xA;&#xD;&#xA;    printf (""price fraction is %d"", price & SHIFT_MASK);&#xD;&#xA;&#xD;&#xA;Of course, the fractional part is a fraction of 65536 (0 => 0, 32768 => 0.5, 65535 => 0.9999....). So if we want it as a decimal fraction, we must do something like this:&#xD;&#xA;&#xD;&#xA;    printf(""price fraction in decimal is %f\\n"", ((double)(price & SHIFT_MASK) / (1 << SHIFT_AMOUNT)));&#xD;&#xA;&#xD;&#xA;These are the basic ideas behind fixed-point arithmetics.&#xD;&#xA;&#xD;&#xA;Be careful with negative values. It will work in calculus, but when it's time to show them up, it may be tricky so you shall experiment.&#xD;&#xA;&#xD;&#xA;Also take note that if a 32 bits integer can not represent values bigger than 2³² - 1, using this technique limits them to 2¹⁶ - 1! (and divide all of this by 2 for negative values). The goal is then to choose a SHIFT_AMOUNT suitable to the situation. This is a tradeoff between integer part and fractional part precisions.&#xD;&#xA;&#xD;&#xA;Now for the real warnings: this technique is definitely not suitable in areas where precision is a top priority (financial, science, military...). Usual floating point (float/double) are also often not precise enough, even though they have better properties than fixed-point overall. Fixed-point has the same precision whatever the value (this can be an advantage in some cases), where floats precision is inversely proportional to the value magnitude (ie. the lower the magnitude, the more precision you get). Also floats can represent a lot more higher values than the equivalent (in number of bits) integers (fixed-point or not), to the cost of a loss of precision with high values as already stated.&#xD;&#xA;&#xD;&#xA;If you work in those sensible areas, you're better off using libraries dedicated to the purpose of arbitrary precision (go take a look at [gmplib][1]. It's open-source). In computing science, essentially, gaining precision is about the number of bits you use to store you values. You want high precision? Use bits. That's all.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://gmplib.org/";;
64739524;11816993;892932;5;bd84fe74-908f-44be-b5b4-a669f408533b;2014-05-09 09:28:45.0;"The idea behind fixed-point arithmetic is that you store the values multiplied by a certain amount, use the multiplied values for all calculus, and divide it by the same amount when you want the result. The purpose of this technique is to use integer arithmetic (int, long...) while still being able to represent fractions.&#xD;&#xA;&#xD;&#xA;The usual and most efficient way of doing this in C is by using the bits shifting operators (<< and >>). Shifting bits have the property of multiplying and dividing integer values. A drawback is that the multiplier must be a power of 2 (which is usually not a problem by itself as we don't really care about this value).&#xD;&#xA;&#xD;&#xA;Now let's say we want to use 32 bits integers for storing our values. We must choose a power of 2 multiplier. Let's divide the cake in two, so say 65536 (this is the most common case, but you can really use any power of 2 depending on your needs in precision). This is 2<sup>16</sup> and the 16 here means that we will use the 16 least significant bits (LSB) for the fractional part. The rest (32 - 16 = 16) is for the most significant bits (MSB), the integer part.&#xD;&#xA;&#xD;&#xA;         integer (MSB)    fraction (LSB)&#xD;&#xA;               v                 v&#xD;&#xA;        0000000000000000.0000000000000000&#xD;&#xA;&#xD;&#xA;Let's put this in code:&#xD;&#xA;&#xD;&#xA;    #define SHIFT_AMOUNT 16 // 2^16 = 65536&#xD;&#xA;    #define SHIFT_MASK ((1 << SHIFT_AMOUNT) - 1) // 65535 (all LSB set, all MSB clear)&#xD;&#xA;    &#xD;&#xA;    int price = 500 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;This is the value you must put in store (structure, database, whatever).&#xD;&#xA;&#xD;&#xA;When you want to do calculus on this value, you can use the 4 basic operators: +, -, * and /. You have to keep in mind that when adding and subtracting a value (+ and -), that value must also be shifted. Let's say we want to add 10 to our 500 price:&#xD;&#xA;&#xD;&#xA;    price += 10 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;But for multiplication and division (* and /), the multiplier/divisor must NOT be shifted. Let's say we want to multiply by 10:&#xD;&#xA;&#xD;&#xA;    price *= 10;&#xD;&#xA; &#xD;&#xA;That's all about the rules. When you want to retrieve the real price at any point, you must right-shift:&#xD;&#xA;&#xD;&#xA;    printf(""price is %d"", price >> SHIFT_AMOUNT);&#xD;&#xA;&#xD;&#xA;If you need the fractional part, you must mask it out:&#xD;&#xA;&#xD;&#xA;    printf (""price fraction is %d"", price & SHIFT_MASK);&#xD;&#xA;&#xD;&#xA;Of course, this value is not what we can call a decimal fraction, in fact it is an integer in the range [0 - 65535]. But it maps exactly with the decimal fraction range [0 - 0.9999...]. In other words, mapping looks like: 0 => 0, 32768 => 0.5, 65535 => 0.9999.... An easy way to show it as a decimal fraction is to resort to C built-in float arithmetic at this point:&#xD;&#xA;&#xD;&#xA;    printf(""price fraction in decimal is %f\\n"", ((double)(price & SHIFT_MASK) / (1 << SHIFT_AMOUNT)));&#xD;&#xA;&#xD;&#xA;These are the basic ideas behind fixed-point arithmetics.&#xD;&#xA;&#xD;&#xA;Be careful with negative values. It can becomes tricky sometimes, especially when it's time to show the final value. Besides, C is implementation-defined about signed integers (even though platforms where this is a problem are very uncommon nowadays). You should always make minimal tests in your environment to make sure everything goes as expected. If not, you can hack around it if you know what you do (I won't develop on this, but this has something to do with arithmetic shift vs logical shift and 2's complement representation). With unsigned integers however, you're mostly safe whatever you do as behaviors are well defined anyway.&#xD;&#xA;&#xD;&#xA;Also take note that if a 32 bits integer can not represent values bigger than 2<sup>32</sup> - 1, using fixed-point arithmetic with 2<sup>16</sup> limits your range to 2<sup>16</sup> - 1! (and divide all of this by 2 with negative values, which in our example would leave us with an available range of 2<sup>15</sup> - 1). The goal is then to choose a SHIFT_AMOUNT suitable to the situation. This is a tradeoff between integer part and fractional part precisions.&#xD;&#xA;&#xD;&#xA;Now for the real warnings: this technique is definitely not suitable in areas where precision is a top priority (financial, science, military...). Usual floating point (float/double) are also often not precise enough, even though they have better properties than fixed-point overall. Fixed-point has the same precision whatever the value (this can be an advantage in some cases), where floats precision is inversely proportional to the value magnitude (ie. the lower the magnitude, the more precision you get... well, this is more complex than that but you get the point). Also floats have a much higher dynamic range than the equivalent (in number of bits) integers (fixed-point or not), to the cost of a loss of precision with high values as already stated.&#xD;&#xA;&#xD;&#xA;If you work in those sensible areas, you're better off using libraries dedicated to the purpose of arbitrary precision (go take a look at [gmplib][1], it's open-source). In computing science, essentially, gaining precision is about the number of bits you use to store your values. You want high precision? Use bits. That's all.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://gmplib.org/";;typo
64740947;11816993;892932;5;2f90d6eb-7e27-423d-8e2c-ef2df7ed9624;2014-05-09 09:46:25.0;"The idea behind fixed-point arithmetic is that you store the values multiplied by a certain amount, use the multiplied values for all calculus, and divide it by the same amount when you want the result. The purpose of this technique is to use integer arithmetic (int, long...) while still being able to represent fractions.&#xD;&#xA;&#xD;&#xA;The usual and most efficient way of doing this in C is by using the bits shifting operators (<< and >>). Shifting bits have the property of multiplying and dividing integer values. A drawback is that the multiplier must be a power of 2 (which is usually not a problem by itself as we don't really care about this value).&#xD;&#xA;&#xD;&#xA;Now let's say we want to use 32 bits integers for storing our values. We must choose a power of 2 multiplier. Let's divide the cake in two, so say 65536 (this is the most common case, but you can really use any power of 2 depending on your needs in precision). This is 2<sup>16</sup> and the 16 here means that we will use the 16 least significant bits (LSB) for the fractional part. The rest (32 - 16 = 16) is for the most significant bits (MSB), the integer part.&#xD;&#xA;&#xD;&#xA;         integer (MSB)    fraction (LSB)&#xD;&#xA;               v                 v&#xD;&#xA;        0000000000000000.0000000000000000&#xD;&#xA;&#xD;&#xA;Let's put this in code:&#xD;&#xA;&#xD;&#xA;    #define SHIFT_AMOUNT 16 // 2^16 = 65536&#xD;&#xA;    #define SHIFT_MASK ((1 << SHIFT_AMOUNT) - 1) // 65535 (all LSB set, all MSB clear)&#xD;&#xA;    &#xD;&#xA;    int price = 500 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;This is the value you must put in store (structure, database, whatever).&#xD;&#xA;&#xD;&#xA;When you want to do calculus on this value, you can use the 4 basic operators: +, -, * and /. You have to keep in mind that when adding and subtracting a value (+ and -), that value must also be shifted. Let's say we want to add 10 to our 500 price:&#xD;&#xA;&#xD;&#xA;    price += 10 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;But for multiplication and division (* and /), the multiplier/divisor must NOT be shifted. Let's say we want to multiply by 10:&#xD;&#xA;&#xD;&#xA;    price *= 10;&#xD;&#xA; &#xD;&#xA;That's all about the rules. When you want to retrieve the real price at any point, you must right-shift:&#xD;&#xA;&#xD;&#xA;    printf(""price is %d"", price >> SHIFT_AMOUNT);&#xD;&#xA;&#xD;&#xA;If you need the fractional part, you must mask it out:&#xD;&#xA;&#xD;&#xA;    printf (""price fraction is %d"", price & SHIFT_MASK);&#xD;&#xA;&#xD;&#xA;Of course, this value is not what we can call a decimal fraction, in fact it is an integer in the range [0 - 65535]. But it maps exactly with the decimal fraction range [0 - 0.9999...]. In other words, mapping looks like: 0 => 0, 32768 => 0.5, 65535 => 0.9999.... An easy way to show it as a decimal fraction is to resort to C built-in float arithmetic at this point:&#xD;&#xA;&#xD;&#xA;    printf(""price fraction in decimal is %f\\n"", ((double)(price & SHIFT_MASK) / (1 << SHIFT_AMOUNT)));&#xD;&#xA;&#xD;&#xA;These are the basic ideas behind fixed-point arithmetics.&#xD;&#xA;&#xD;&#xA;Be careful with negative values. It can becomes tricky sometimes, especially when it's time to show the final value. Besides, C is implementation-defined about signed integers (even though platforms where this is a problem are very uncommon nowadays). You should always make minimal tests in your environment to make sure everything goes as expected. If not, you can hack around it if you know what you do (I won't develop on this, but this has something to do with arithmetic shift vs logical shift and 2's complement representation). With unsigned integers however, you're mostly safe whatever you do as behaviors are well defined anyway.&#xD;&#xA;&#xD;&#xA;Also take note that if a 32 bits integer can not represent values bigger than 2<sup>32</sup> - 1, using fixed-point arithmetic with 2<sup>16</sup> limits your range to 2<sup>16</sup> - 1! (and divide all of this by 2 with negative values, which in our example would leave us with an available range of 2<sup>15</sup> - 1). The goal is then to choose a SHIFT_AMOUNT suitable to the situation. This is a tradeoff between integer part and fractional part precisions.&#xD;&#xA;&#xD;&#xA;Now for the real warnings: this technique is definitely not suitable in areas where precision is a top priority (financial, science, military...). Usual floating point (float/double) are also often not precise enough, even though they have better properties than fixed-point overall. Fixed-point has the same precision whatever the value (this can be an advantage in some cases), where floats precision is inversely proportional to the value magnitude (ie. the lower the magnitude, the more precision you get... well, this is more complex than that but you get the point). Also floats have a much higher dynamic range than the equivalent (in number of bits) integers (fixed-point or not), to the cost of a loss of precision with high values as already stated.&#xD;&#xA;&#xD;&#xA;If you work in those sensible areas, you're better off using libraries dedicated to the purpose of arbitrary precision (go take a look at [gmplib][1], it's open-source). In computing science, essentially, gaining precision is about the number of bits you use to store your values. You want high precision? Use bits. That's all.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://gmplib.org/";;[Edit removed during grace period]
64741686;11816993;892932;5;74b6d8d0-d3dc-4724-9f77-439c5f8b775e;2014-05-09 09:55:41.0;"The idea behind fixed-point arithmetic is that you store the values multiplied by a certain amount, use the multiplied values for all calculus, and divide it by the same amount when you want the result. The purpose of this technique is to use integer arithmetic (int, long...) while still being able to represent fractions.&#xD;&#xA;&#xD;&#xA;The usual and most efficient way of doing this in C is by using the bits shifting operators (<< and >>). Shifting bits have the property of multiplying and dividing integer values. A drawback is that the multiplier must be a power of 2 (which is usually not a problem by itself as we don't really care about this value).&#xD;&#xA;&#xD;&#xA;Now let's say we want to use 32 bits integers for storing our values. We must choose a power of 2 multiplier. Let's divide the cake in two, so say 65536 (this is the most common case, but you can really use any power of 2 depending on your needs in precision). This is 2<sup>16</sup> and the 16 here means that we will use the 16 least significant bits (LSB) for the fractional part. The rest (32 - 16 = 16) is for the most significant bits (MSB), the integer part.&#xD;&#xA;&#xD;&#xA;         integer (MSB)    fraction (LSB)&#xD;&#xA;               v                 v&#xD;&#xA;        0000000000000000.0000000000000000&#xD;&#xA;&#xD;&#xA;Let's put this in code:&#xD;&#xA;&#xD;&#xA;    #define SHIFT_AMOUNT 16 // 2^16 = 65536&#xD;&#xA;    #define SHIFT_MASK ((1 << SHIFT_AMOUNT) - 1) // 65535 (all LSB set, all MSB clear)&#xD;&#xA;    &#xD;&#xA;    int price = 500 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;This is the value you must put in store (structure, database, whatever). Note that int is not necessarily 32 bits in C even though it is mostly the case nowadays. Also without further declaration, it is signed by default. You can add unsigned to the declaration to be sure. Better than that, you can use uint32_t or uint_least32_t (defined in stdint.h) if your code highly depends on the integer bit size (you may introduce some hacks about it). In doubt, use a typedef for your fixed-point type and you're safer.&#xD;&#xA;&#xD;&#xA;When you want to do calculus on this value, you can use the 4 basic operators: +, -, * and /. You have to keep in mind that when adding and subtracting a value (+ and -), that value must also be shifted. Let's say we want to add 10 to our 500 price:&#xD;&#xA;&#xD;&#xA;    price += 10 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;But for multiplication and division (* and /), the multiplier/divisor must NOT be shifted. Let's say we want to multiply by 10:&#xD;&#xA;&#xD;&#xA;    price *= 10;&#xD;&#xA; &#xD;&#xA;That's all about the rules. When you want to retrieve the real price at any point, you must right-shift:&#xD;&#xA;&#xD;&#xA;    printf(""price is %d"", price >> SHIFT_AMOUNT);&#xD;&#xA;&#xD;&#xA;If you need the fractional part, you must mask it out:&#xD;&#xA;&#xD;&#xA;    printf (""price fraction is %d"", price & SHIFT_MASK);&#xD;&#xA;&#xD;&#xA;Of course, this value is not what we can call a decimal fraction, in fact it is an integer in the range [0 - 65535]. But it maps exactly with the decimal fraction range [0 - 0.9999...]. In other words, mapping looks like: 0 => 0, 32768 => 0.5, 65535 => 0.9999.... An easy way to show it as a decimal fraction is to resort to C built-in float arithmetic at this point:&#xD;&#xA;&#xD;&#xA;    printf(""price fraction in decimal is %f\\n"", ((double)(price & SHIFT_MASK) / (1 << SHIFT_AMOUNT)));&#xD;&#xA;&#xD;&#xA;These are the basic ideas behind fixed-point arithmetics.&#xD;&#xA;&#xD;&#xA;Be careful with negative values. It can becomes tricky sometimes, especially when it's time to show the final value. Besides, C is implementation-defined about signed integers (even though platforms where this is a problem are very uncommon nowadays). You should always make minimal tests in your environment to make sure everything goes as expected. If not, you can hack around it if you know what you do (I won't develop on this, but this has something to do with arithmetic shift vs logical shift and 2's complement representation). With unsigned integers however, you're mostly safe whatever you do as behaviors are well defined anyway.&#xD;&#xA;&#xD;&#xA;Also take note that if a 32 bits integer can not represent values bigger than 2<sup>32</sup> - 1, using fixed-point arithmetic with 2<sup>16</sup> limits your range to 2<sup>16</sup> - 1! (and divide all of this by 2 with negative values, which in our example would leave us with an available range of 2<sup>15</sup> - 1). The goal is then to choose a SHIFT_AMOUNT suitable to the situation. This is a tradeoff between integer part and fractional part precisions.&#xD;&#xA;&#xD;&#xA;Now for the real warnings: this technique is definitely not suitable in areas where precision is a top priority (financial, science, military...). Usual floating point (float/double) are also often not precise enough, even though they have better properties than fixed-point overall. Fixed-point has the same precision whatever the value (this can be an advantage in some cases), where floats precision is inversely proportional to the value magnitude (ie. the lower the magnitude, the more precision you get... well, this is more complex than that but you get the point). Also floats have a much higher dynamic range than the equivalent (in number of bits) integers (fixed-point or not), to the cost of a loss of precision with high values as already stated.&#xD;&#xA;&#xD;&#xA;If you work in those sensible areas, you're better off using libraries dedicated to the purpose of arbitrary precision (go take a look at [gmplib][1], it's open-source). In computing science, essentially, gaining precision is about the number of bits you use to store your values. You want high precision? Use bits. That's all.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://gmplib.org/";;warn about C integer size
64742204;11816993;892932;5;f88494e8-f496-4186-8661-7e6192566568;2014-05-09 10:02:58.0;"The idea behind fixed-point arithmetic is that you store the values multiplied by a certain amount, use the multiplied values for all calculus, and divide it by the same amount when you want the result. The purpose of this technique is to use integer arithmetic (int, long...) while still being able to represent fractions.&#xD;&#xA;&#xD;&#xA;The usual and most efficient way of doing this in C is by using the bits shifting operators (<< and >>). Shifting bits have the property of multiplying and dividing integer values. A drawback is that the multiplier must be a power of 2 (which is usually not a problem by itself as we don't really care about this value).&#xD;&#xA;&#xD;&#xA;Now let's say we want to use 32 bits integers for storing our values. We must choose a power of 2 multiplier. Let's divide the cake in two, so say 65536 (this is the most common case, but you can really use any power of 2 depending on your needs in precision). This is 2<sup>16</sup> and the 16 here means that we will use the 16 least significant bits (LSB) for the fractional part. The rest (32 - 16 = 16) is for the most significant bits (MSB), the integer part.&#xD;&#xA;&#xD;&#xA;         integer (MSB)    fraction (LSB)&#xD;&#xA;               v                 v&#xD;&#xA;        0000000000000000.0000000000000000&#xD;&#xA;&#xD;&#xA;Let's put this in code:&#xD;&#xA;&#xD;&#xA;    #define SHIFT_AMOUNT 16 // 2^16 = 65536&#xD;&#xA;    #define SHIFT_MASK ((1 << SHIFT_AMOUNT) - 1) // 65535 (all LSB set, all MSB clear)&#xD;&#xA;    &#xD;&#xA;    int price = 500 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;This is the value you must put in store (structure, database, whatever). Note that int is not necessarily 32 bits in C even though it is mostly the case nowadays. Also without further declaration, it is signed by default. You can add unsigned to the declaration to be sure. Better than that, you can use uint32_t or uint_least32_t (defined in stdint.h) if your code highly depends on the integer bit size (you may introduce some hacks about it). In doubt, use a typedef for your fixed-point type and you're safer.&#xD;&#xA;&#xD;&#xA;When you want to do calculus on this value, you can use the 4 basic operators: +, -, * and /. You have to keep in mind that when adding and subtracting a value (+ and -), that value must also be shifted. Let's say we want to add 10 to our 500 price:&#xD;&#xA;&#xD;&#xA;    price += 10 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;But for multiplication and division (* and /), the multiplier/divisor must NOT be shifted. Let's say we want to multiply by 10:&#xD;&#xA;&#xD;&#xA;    price *= 10;&#xD;&#xA; &#xD;&#xA;That's all about the rules. When you want to retrieve the real price at any point, you must right-shift:&#xD;&#xA;&#xD;&#xA;    printf(""price is %d"", price >> SHIFT_AMOUNT);&#xD;&#xA;&#xD;&#xA;If you need the fractional part, you must mask it out:&#xD;&#xA;&#xD;&#xA;    printf (""price fraction is %d"", price & SHIFT_MASK);&#xD;&#xA;&#xD;&#xA;Of course, this value is not what we can call a decimal fraction, in fact it is an integer in the range [0 - 65535]. But it maps exactly with the decimal fraction range [0 - 0.9999...]. In other words, mapping looks like: 0 => 0, 32768 => 0.5, 65535 => 0.9999.... An easy way to show it as a decimal fraction is to resort to C built-in float arithmetic at this point:&#xD;&#xA;&#xD;&#xA;    printf(""price fraction in decimal is %f\\n"", ((double)(price & SHIFT_MASK) / (1 << SHIFT_AMOUNT)));&#xD;&#xA;&#xD;&#xA;These are the basic ideas behind fixed-point arithmetics.&#xD;&#xA;&#xD;&#xA;Be careful with negative values. It can becomes tricky sometimes, especially when it's time to show the final value. Besides, C is implementation-defined about signed integers (even though platforms where this is a problem are very uncommon nowadays). You should always make minimal tests in your environment to make sure everything goes as expected. If not, you can hack around it if you know what you do (I won't develop on this, but this has something to do with arithmetic shift vs logical shift and 2's complement representation). With unsigned integers however, you're mostly safe whatever you do as behaviors are well defined anyway.&#xD;&#xA;&#xD;&#xA;Also take note that if a 32 bits integer can not represent values bigger than 2<sup>32</sup> - 1, using fixed-point arithmetic with 2<sup>16</sup> limits your range to 2<sup>16</sup> - 1! (and divide all of this by 2 with signed integers, which in our example would leave us with an available range of 2<sup>15</sup> - 1). The goal is then to choose a SHIFT_AMOUNT suitable to the situation. This is a tradeoff between integer part and fractional part precisions.&#xD;&#xA;&#xD;&#xA;Now for the real warnings: this technique is definitely not suitable in areas where precision is a top priority (financial, science, military...). Usual floating point (float/double) are also often not precise enough, even though they have better properties than fixed-point overall. Fixed-point has the same precision whatever the value (this can be an advantage in some cases), where floats precision is inversely proportional to the value magnitude (ie. the lower the magnitude, the more precision you get... well, this is more complex than that but you get the point). Also floats have a much higher dynamic range than the equivalent (in number of bits) integers (fixed-point or not), to the cost of a loss of precision with high values as already stated.&#xD;&#xA;&#xD;&#xA;If you work in those sensible areas, you're better off using libraries dedicated to the purpose of arbitrary precision (go take a look at [gmplib][1], it's open-source). In computing science, essentially, gaining precision is about the number of bits you use to store your values. You want high precision? Use bits. That's all.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://gmplib.org/";;edited body
92798103;11816993;892932;5;eccbafb4-fc49-46b2-a2e7-d351e8119a1e;2015-06-14 13:50:14.0;"The idea behind fixed-point arithmetic is that you store the values multiplied by a certain amount, use the multiplied values for all calculus, and divide it by the same amount when you want the result. The purpose of this technique is to use integer arithmetic (int, long...) while being able to represent fractions.&#xD;&#xA;&#xD;&#xA;The usual and most efficient way of doing this in C is by using the bits shifting operators (<< and >>). Shifting bits is a pretty damn simple and fast operation for the ALU and doing this have the property to multiply (<<) and divide (>>) the integer value by 2 on each shift. Of course, the drawback is that the multiplier must be a power of 2 (which is usually not a problem by itself as we don't really care about that exact multiplier value).&#xD;&#xA;&#xD;&#xA;Now let's say we want to use 32 bits integers for storing our values. We must choose a power of 2 multiplier. Let's divide the cake in two, so say 65536 (this is the most common case, but you can really use any power of 2 depending on your needs in precision). This is 2<sup>16</sup> and the 16 here means that we will use the 16 least significant bits (LSB) for the fractional part. The rest (32 - 16 = 16) is for the most significant bits (MSB), the integer part.&#xD;&#xA;&#xD;&#xA;         integer (MSB)    fraction (LSB)&#xD;&#xA;               v                 v&#xD;&#xA;        0000000000000000.0000000000000000&#xD;&#xA;&#xD;&#xA;Let's put this in code:&#xD;&#xA;&#xD;&#xA;    #define SHIFT_AMOUNT 16 // 2^16 = 65536&#xD;&#xA;    #define SHIFT_MASK ((1 << SHIFT_AMOUNT) - 1) // 65535 (all LSB set, all MSB clear)&#xD;&#xA;    &#xD;&#xA;    int price = 500 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;This is the value you must put in store (structure, database, whatever). Note that int is not necessarily 32 bits in C even though it is mostly the case nowadays. Also without further declaration, it is signed by default. You can add unsigned to the declaration to be sure. Better than that, you can use uint32_t or uint_least32_t (defined in stdint.h) if your code highly depends on the integer bit size (you may introduce some hacks about it). In doubt, use a typedef for your fixed-point type and you're safer.&#xD;&#xA;&#xD;&#xA;When you want to do calculus on this value, you can use the 4 basic operators: +, -, * and /. You have to keep in mind that when adding and subtracting a value (+ and -), that value must also be shifted. Let's say we want to add 10 to our 500 price:&#xD;&#xA;&#xD;&#xA;    price += 10 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;But for multiplication and division (* and /), the multiplier/divisor must NOT be shifted. Let's say we want to multiply by 10:&#xD;&#xA;&#xD;&#xA;    price *= 10;&#xD;&#xA; &#xD;&#xA;That's all about the rules. When you want to retrieve the real price at any point, you must right-shift:&#xD;&#xA;&#xD;&#xA;    printf(""price is %d"", price >> SHIFT_AMOUNT);&#xD;&#xA;&#xD;&#xA;If you need the fractional part, you must mask it out:&#xD;&#xA;&#xD;&#xA;    printf (""price fraction is %d"", price & SHIFT_MASK);&#xD;&#xA;&#xD;&#xA;Of course, this value is not what we can call a decimal fraction, in fact it is an integer in the range [0 - 65535]. But it maps exactly with the decimal fraction range [0 - 0.9999...]. In other words, mapping looks like: 0 => 0, 32768 => 0.5, 65535 => 0.9999.... An easy way to show it as a decimal fraction is to resort to C built-in float arithmetic at this point:&#xD;&#xA;&#xD;&#xA;    printf(""price fraction in decimal is %f\\n"", ((double)(price & SHIFT_MASK) / (1 << SHIFT_AMOUNT)));&#xD;&#xA;&#xD;&#xA;These are the basic ideas behind fixed-point arithmetics.&#xD;&#xA;&#xD;&#xA;Be careful with negative values. It can becomes tricky sometimes, especially when it's time to show the final value. Besides, C is implementation-defined about signed integers (even though platforms where this is a problem are very uncommon nowadays). You should always make minimal tests in your environment to make sure everything goes as expected. If not, you can hack around it if you know what you do (I won't develop on this, but this has something to do with arithmetic shift vs logical shift and 2's complement representation). With unsigned integers however, you're mostly safe whatever you do as behaviors are well defined anyway.&#xD;&#xA;&#xD;&#xA;Also take note that if a 32 bits integer can not represent values bigger than 2<sup>32</sup> - 1, using fixed-point arithmetic with 2<sup>16</sup> limits your range to 2<sup>16</sup> - 1! (and divide all of this by 2 with signed integers, which in our example would leave us with an available range of 2<sup>15</sup> - 1). The goal is then to choose a SHIFT_AMOUNT suitable to the situation. This is a tradeoff between integer part magnitude and fractional part precision.&#xD;&#xA;&#xD;&#xA;Now for the real warnings: this technique is definitely not suitable in areas where precision is a top priority (financial, science, military...). Usual floating point (float/double) are also often not precise enough, even though they have better properties than fixed-point overall. Fixed-point has the same precision whatever the value (this can be an advantage in some cases), where floats precision is inversely proportional to the value magnitude (ie. the lower the magnitude, the more precision you get... well, this is more complex than that but you get the point). Also floats have a much higher dynamic range than the equivalent (in number of bits) integers (fixed-point or not), to the cost of a loss of precision with high values as already stated.&#xD;&#xA;&#xD;&#xA;If you work in those sensible areas, you're better off using libraries dedicated to the purpose of arbitrary precision (go take a look at [gmplib][1], it's open-source). In computing science, essentially, gaining precision is about the number of bits you use to store your values. You want high precision? Use bits. That's all.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://gmplib.org/";;improved some formulations
92798839;11816993;892932;5;92d86d4c-9692-4bf2-a004-09df5db1c817;2015-06-14 14:08:14.0;"The idea behind fixed-point arithmetic is that you store the values multiplied by a certain amount, use the multiplied values for all calculus, and divide it by the same amount when you want the result. The purpose of this technique is to use integer arithmetic (int, long...) while being able to represent fractions.&#xD;&#xA;&#xD;&#xA;The usual and most efficient way of doing this in C is by using the bits shifting operators (<< and >>). Shifting bits is a pretty damn simple and fast operation for the ALU and doing this have the property to multiply (<<) and divide (>>) the integer value by 2 on each shift. Of course, the drawback is that the multiplier must be a power of 2 (which is usually not a problem by itself as we don't really care about that exact multiplier value).&#xD;&#xA;&#xD;&#xA;Now let's say we want to use 32 bits integers for storing our values. We must choose a power of 2 multiplier. Let's divide the cake in two, so say 65536 (this is the most common case, but you can really use any power of 2 depending on your needs in precision). This is 2<sup>16</sup> and the 16 here means that we will use the 16 least significant bits (LSB) for the fractional part. The rest (32 - 16 = 16) is for the most significant bits (MSB), the integer part.&#xD;&#xA;&#xD;&#xA;         integer (MSB)    fraction (LSB)&#xD;&#xA;               v                 v&#xD;&#xA;        0000000000000000.0000000000000000&#xD;&#xA;&#xD;&#xA;Let's put this in code:&#xD;&#xA;&#xD;&#xA;    #define SHIFT_AMOUNT 16 // 2^16 = 65536&#xD;&#xA;    #define SHIFT_MASK ((1 << SHIFT_AMOUNT) - 1) // 65535 (all LSB set, all MSB clear)&#xD;&#xA;    &#xD;&#xA;    int price = 500 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;This is the value you must put in store (structure, database, whatever). Note that int is not necessarily 32 bits in C even though it is mostly the case nowadays. Also without further declaration, it is signed by default. You can add unsigned to the declaration to be sure. Better than that, you can use uint32_t or uint_least32_t (defined in stdint.h) if your code highly depends on the integer bit size (you may introduce some hacks about it). In doubt, use a typedef for your fixed-point type and you're safer.&#xD;&#xA;&#xD;&#xA;When you want to do calculus on this value, you can use the 4 basic operators: +, -, * and /. You have to keep in mind that when adding and subtracting a value (+ and -), that value must also be shifted. Let's say we want to add 10 to our 500 price:&#xD;&#xA;&#xD;&#xA;    price += 10 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;But for multiplication and division (* and /), the multiplier/divisor must NOT be shifted. Let's say we want to multiply by 10:&#xD;&#xA;&#xD;&#xA;    price *= 10;&#xD;&#xA; &#xD;&#xA;That's all about the rules. When you want to retrieve the real price at any point, you must right-shift:&#xD;&#xA;&#xD;&#xA;    printf(""price is %d"", price >> SHIFT_AMOUNT);&#xD;&#xA;&#xD;&#xA;If you need the fractional part, you must mask it out:&#xD;&#xA;&#xD;&#xA;    printf (""price fraction is %d"", price & SHIFT_MASK);&#xD;&#xA;&#xD;&#xA;Of course, this value is not what we can call a decimal fraction, in fact it is an integer in the range [0 - 65535]. But it maps exactly with the decimal fraction range [0 - 0.9999...]. In other words, mapping looks like: 0 => 0, 32768 => 0.5, 65535 => 0.9999.... An easy way to show it as a decimal fraction is to resort to C built-in float arithmetic at this point:&#xD;&#xA;&#xD;&#xA;    printf(""price fraction in decimal is %f\\n"", ((double)(price & SHIFT_MASK) / (1 << SHIFT_AMOUNT)));&#xD;&#xA;&#xD;&#xA;These are the basic ideas behind fixed-point arithmetics.&#xD;&#xA;&#xD;&#xA;Be careful with negative values. It can becomes tricky sometimes, especially when it's time to show the final value. Besides, C is implementation-defined about signed integers (even though platforms where this is a problem are very uncommon nowadays). You should always make minimal tests in your environment to make sure everything goes as expected. If not, you can hack around it if you know what you do (I won't develop on this, but this has something to do with arithmetic shift vs logical shift and 2's complement representation). With unsigned integers however, you're mostly safe whatever you do as behaviors are well defined anyway.&#xD;&#xA;&#xD;&#xA;Also take note that if a 32 bits integer can not represent values bigger than 2<sup>32</sup> - 1, using fixed-point arithmetic with 2<sup>16</sup> limits your range to 2<sup>16</sup> - 1! (and divide all of this by 2 with signed integers, which in our example would leave us with an available range of 2<sup>15</sup> - 1). The goal is then to choose a SHIFT_AMOUNT suitable to the situation. This is a tradeoff between integer part magnitude and fractional part precision.&#xD;&#xA;&#xD;&#xA;Now for the real warnings: this technique is definitely not suitable in areas where precision is a top priority (financial, science, military...). Usual floating point (float/double) are also often not precise enough, even though they have better properties than fixed-point overall. Fixed-point has the same precision whatever the value (this can be an advantage in some cases), where floats precision is inversely proportional to the value magnitude (ie. the lower the magnitude, the more precision you get... well, this is more complex than that but you get the point). Also floats have a much greater magnitude than the equivalent (in number of bits) integers (fixed-point or not), to the cost of a loss of precision with high values (you can even reach a point of magnitude where adding 1 or even greater values will have no effect at all, something that cannot happen with integers).&#xD;&#xA;&#xD;&#xA;If you work in those sensible areas, you're better off using libraries dedicated to the purpose of arbitrary precision (go take a look at [gmplib][1], it's open-source). In computing science, essentially, gaining precision is about the number of bits you use to store your values. You want high precision? Use bits. That's all.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://gmplib.org/";;added 130 characters in body
115839433;11816993;892932;5;ed0b9e00-b4cf-4c5c-9991-f4adfba45edf;2016-04-16 03:51:26.0;"The idea behind fixed-point arithmetic is that you store the values multiplied by a certain amount, use the multiplied values for all calculus, and divide it by the same amount when you want the result. The purpose of this technique is to use integer arithmetic (int, long...) while being able to represent fractions.&#xD;&#xA;&#xD;&#xA;The usual and most efficient way of doing this in C is by using the bits shifting operators (<< and >>). Shifting bits is a pretty damn simple and fast operation for the ALU and doing this have the property to multiply (<<) and divide (>>) the integer value by 2 on each shift. Of course, the drawback is that the multiplier must be a power of 2 (which is usually not a problem by itself as we don't really care about that exact multiplier value).&#xD;&#xA;&#xD;&#xA;Now let's say we want to use 32 bits integers for storing our values. We must choose a power of 2 multiplier. Let's divide the cake in two, so say 65536 (this is the most common case, but you can really use any power of 2 depending on your needs in precision). This is 2<sup>16</sup> and the 16 here means that we will use the 16 least significant bits (LSB) for the fractional part. The rest (32 - 16 = 16) is for the most significant bits (MSB), the integer part.&#xD;&#xA;&#xD;&#xA;         integer (MSB)    fraction (LSB)&#xD;&#xA;               v                 v&#xD;&#xA;        0000000000000000.0000000000000000&#xD;&#xA;&#xD;&#xA;Let's put this in code:&#xD;&#xA;&#xD;&#xA;    #define SHIFT_AMOUNT 16 // 2^16 = 65536&#xD;&#xA;    #define SHIFT_MASK ((1 << SHIFT_AMOUNT) - 1) // 65535 (all LSB set, all MSB clear)&#xD;&#xA;    &#xD;&#xA;    int price = 500 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;This is the value you must put in store (structure, database, whatever). Note that int is not necessarily 32 bits in C even though it is mostly the case nowadays. Also without further declaration, it is signed by default. You can add unsigned to the declaration to be sure. Better than that, you can use uint32_t or uint_least32_t (defined in stdint.h) if your code highly depends on the integer bit size (you may introduce some hacks about it). In doubt, use a typedef for your fixed-point type and you're safer.&#xD;&#xA;&#xD;&#xA;When you want to do calculus on this value, you can use the 4 basic operators: +, -, * and /. You have to keep in mind that when adding and subtracting a value (+ and -), that value must also be shifted. Let's say we want to add 10 to our 500 price:&#xD;&#xA;&#xD;&#xA;    price += 10 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;But for multiplication and division (* and /), the multiplier/divisor must NOT be shifted. Let's say we want to multiply by 3:&#xD;&#xA;&#xD;&#xA;    price *= 3;&#xD;&#xA;&#xD;&#xA;Now let's make things more interesting by dividing the price by 4 so we make up for a non-zero fractional part:&#xD;&#xA;&#xD;&#xA;    price /= 4; // now our price is ((500 + 10) * 3) / 4 = 382.5&#xD;&#xA; &#xD;&#xA;That's all about the rules. When you want to retrieve the real price at any point, you must right-shift:&#xD;&#xA;&#xD;&#xA;    printf(""price is %d"", price >> SHIFT_AMOUNT);&#xD;&#xA;&#xD;&#xA;If you need the fractional part, you must mask it out:&#xD;&#xA;&#xD;&#xA;    printf (""price fraction is %d"", price & SHIFT_MASK);&#xD;&#xA;&#xD;&#xA;Of course, this value is not what we can call a decimal fraction, in fact it is an integer in the range [0 - 65535]. But it maps exactly with the decimal fraction range [0 - 0.9999...]. In other words, mapping looks like: 0 => 0, 32768 => 0.5, 65535 => 0.9999.... An easy way to show it as a decimal fraction is to resort to C built-in float arithmetic at this point:&#xD;&#xA;&#xD;&#xA;    printf(""price fraction in decimal is %f\\n"", ((double)(price & SHIFT_MASK) / (1 << SHIFT_AMOUNT)));&#xD;&#xA;&#xD;&#xA;These are the basic ideas behind fixed-point arithmetics.&#xD;&#xA;&#xD;&#xA;Be careful with negative values. It can becomes tricky sometimes, especially when it's time to show the final value. Besides, C is implementation-defined about signed integers (even though platforms where this is a problem are very uncommon nowadays). You should always make minimal tests in your environment to make sure everything goes as expected. If not, you can hack around it if you know what you do (I won't develop on this, but this has something to do with arithmetic shift vs logical shift and 2's complement representation). With unsigned integers however, you're mostly safe whatever you do as behaviors are well defined anyway.&#xD;&#xA;&#xD;&#xA;Also take note that if a 32 bits integer can not represent values bigger than 2<sup>32</sup> - 1, using fixed-point arithmetic with 2<sup>16</sup> limits your range to 2<sup>16</sup> - 1! (and divide all of this by 2 with signed integers, which in our example would leave us with an available range of 2<sup>15</sup> - 1). The goal is then to choose a SHIFT_AMOUNT suitable to the situation. This is a tradeoff between integer part magnitude and fractional part precision.&#xD;&#xA;&#xD;&#xA;Now for the real warnings: this technique is definitely not suitable in areas where precision is a top priority (financial, science, military...). Usual floating point (float/double) are also often not precise enough, even though they have better properties than fixed-point overall. Fixed-point has the same precision whatever the value (this can be an advantage in some cases), where floats precision is inversely proportional to the value magnitude (ie. the lower the magnitude, the more precision you get... well, this is more complex than that but you get the point). Also floats have a much greater magnitude than the equivalent (in number of bits) integers (fixed-point or not), to the cost of a loss of precision with high values (you can even reach a point of magnitude where adding 1 or even greater values will have no effect at all, something that cannot happen with integers).&#xD;&#xA;&#xD;&#xA;If you work in those sensible areas, you're better off using libraries dedicated to the purpose of arbitrary precision (go take a look at [gmplib][1], it's free). In computing science, essentially, gaining precision is about the number of bits you use to store your values. You want high precision? Use bits. That's all.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://gmplib.org/";;more concrete example and gmblib license more exactly described
115894226;11816993;892932;5;e8328678-e722-4f11-bed3-992b80e128a1;2016-04-17 01:40:50.0;"The idea behind fixed-point arithmetic is that you store the values multiplied by a certain amount, use the multiplied values for all calculus, and divide it by the same amount when you want the result. The purpose of this technique is to use integer arithmetic (int, long...) while being able to represent fractions.&#xD;&#xA;&#xD;&#xA;The usual and most efficient way of doing this in C is by using the bits shifting operators (<< and >>). Shifting bits is a pretty damn simple and fast operation for the ALU and doing this have the property to multiply (<<) and divide (>>) the integer value by 2 on each shift. Of course, the drawback is that the multiplier must be a power of 2 (which is usually not a problem by itself as we don't really care about that exact multiplier value).&#xD;&#xA;&#xD;&#xA;Now let's say we want to use 32 bits integers for storing our values. We must choose a power of 2 multiplier. Let's divide the cake in two, so say 65536 (this is the most common case, but you can really use any power of 2 depending on your needs in precision). This is 2<sup>16</sup> and the 16 here means that we will use the 16 least significant bits (LSB) for the fractional part. The rest (32 - 16 = 16) is for the most significant bits (MSB), the integer part.&#xD;&#xA;&#xD;&#xA;         integer (MSB)    fraction (LSB)&#xD;&#xA;               v                 v&#xD;&#xA;        0000000000000000.0000000000000000&#xD;&#xA;&#xD;&#xA;Let's put this in code:&#xD;&#xA;&#xD;&#xA;    #define SHIFT_AMOUNT 16 // 2^16 = 65536&#xD;&#xA;    #define SHIFT_MASK ((1 << SHIFT_AMOUNT) - 1) // 65535 (all LSB set, all MSB clear)&#xD;&#xA;    &#xD;&#xA;    int price = 500 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;This is the value you must put in store (structure, database, whatever). Note that int is not necessarily 32 bits in C even though it is mostly the case nowadays. Also without further declaration, it is signed by default. You can add unsigned to the declaration to be sure. Better than that, you can use uint32_t or uint_least32_t (defined in stdint.h) if your code highly depends on the integer bit size (you may introduce some hacks about it). In doubt, use a typedef for your fixed-point type and you're safer.&#xD;&#xA;&#xD;&#xA;When you want to do calculus on this value, you can use the 4 basic operators: +, -, * and /. You have to keep in mind that when adding and subtracting a value (+ and -), that value must also be shifted. Let's say we want to add 10 to our 500 price:&#xD;&#xA;&#xD;&#xA;    price += 10 << SHIFT_AMOUNT;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;But for multiplication and division (* and /), the multiplier/divisor must NOT be shifted. Let's say we want to multiply by 3:&#xD;&#xA;&#xD;&#xA;    price *= 3;&#xD;&#xA;&#xD;&#xA;Now let's make things more interesting by dividing the price by 4 so we make up for a non-zero fractional part:&#xD;&#xA;&#xD;&#xA;    price /= 4; // now our price is ((500 + 10) * 3) / 4 = 382.5&#xD;&#xA; &#xD;&#xA;That's all about the rules. When you want to retrieve the real price at any point, you must right-shift:&#xD;&#xA;&#xD;&#xA;    printf(""price is %d\\n"", price >> SHIFT_AMOUNT);&#xD;&#xA;&#xD;&#xA;If you need the fractional part, you must mask it out:&#xD;&#xA;&#xD;&#xA;    printf (""price fraction is %d\\n"", price & SHIFT_MASK);&#xD;&#xA;&#xD;&#xA;Of course, this value is not what we can call a decimal fraction, in fact it is an integer in the range [0 - 65535]. But it maps exactly with the decimal fraction range [0 - 0.9999...]. In other words, mapping looks like: 0 => 0, 32768 => 0.5, 65535 => 0.9999.... An easy way to show it as a decimal fraction is to resort to C built-in float arithmetic at this point:&#xD;&#xA;&#xD;&#xA;    printf(""price fraction in decimal is %f\\n"", ((double)(price & SHIFT_MASK) / (1 << SHIFT_AMOUNT)));&#xD;&#xA;&#xD;&#xA;These are the basic ideas behind fixed-point arithmetics.&#xD;&#xA;&#xD;&#xA;Be careful with negative values. It can becomes tricky sometimes, especially when it's time to show the final value. Besides, C is implementation-defined about signed integers (even though platforms where this is a problem are very uncommon nowadays). You should always make minimal tests in your environment to make sure everything goes as expected. If not, you can hack around it if you know what you do (I won't develop on this, but this has something to do with arithmetic shift vs logical shift and 2's complement representation). With unsigned integers however, you're mostly safe whatever you do as behaviors are well defined anyway.&#xD;&#xA;&#xD;&#xA;Also take note that if a 32 bits integer can not represent values bigger than 2<sup>32</sup> - 1, using fixed-point arithmetic with 2<sup>16</sup> limits your range to 2<sup>16</sup> - 1! (and divide all of this by 2 with signed integers, which in our example would leave us with an available range of 2<sup>15</sup> - 1). The goal is then to choose a SHIFT_AMOUNT suitable to the situation. This is a tradeoff between integer part magnitude and fractional part precision.&#xD;&#xA;&#xD;&#xA;Now for the real warnings: this technique is definitely not suitable in areas where precision is a top priority (financial, science, military...). Usual floating point (float/double) are also often not precise enough, even though they have better properties than fixed-point overall. Fixed-point has the same precision whatever the value (this can be an advantage in some cases), where floats precision is inversely proportional to the value magnitude (ie. the lower the magnitude, the more precision you get... well, this is more complex than that but you get the point). Also floats have a much greater magnitude than the equivalent (in number of bits) integers (fixed-point or not), to the cost of a loss of precision with high values (you can even reach a point of magnitude where adding 1 or even greater values will have no effect at all, something that cannot happen with integers).&#xD;&#xA;&#xD;&#xA;If you work in those sensible areas, you're better off using libraries dedicated to the purpose of arbitrary precision (go take a look at [gmplib][1], it's free). In computing science, essentially, gaining precision is about the number of bits you use to store your values. You want high precision? Use bits. That's all.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://gmplib.org/";;code consistency
