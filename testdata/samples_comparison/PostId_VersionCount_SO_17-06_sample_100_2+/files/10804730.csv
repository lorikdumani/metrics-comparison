Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
24955127;10804730;767881;2;0705adae-6f34-49a6-af7f-fd8a58735b77;2012-05-29 18:33:50.0;"*I was wondering if it is possible to execute something like this using JDBC.*&#xD;&#xA;&#xD;&#xA;    ""SELECT FROM * TABLE;INSERT INTO TABLE;""&#xD;&#xA;&#xD;&#xA;Yes it is possible. There are two ways, as far as I know. They are&#xD;&#xA;&#xD;&#xA;     1. By setting database connection property to allow multiple queries,&#xD;&#xA;        separated by a semi-colon by default.&#xD;&#xA;     2. By calling a stored procedure that returns cursors implicit.&#xD;&#xA;&#xD;&#xA;Following examples demonstrate the above two possibilities.  &#xD;&#xA;&#xD;&#xA;**Example 1**: ( To allow multiple queries ):  &#xD;&#xA;&#xD;&#xA;While sending a connection request, you need to append a connection property `allowMutilQuery=true` to the database url. This is additional connection property to those if already exists some, like `autoReConnect=true`, etc.. Acceptable values for `allowMultiQuery` property are `true`, `false`, `yes`, and `no`. Any other value is rejected at runtime with an `SQLException`.  &#xD;&#xA;&#xD;&#xA;    String dbUrl = ""jdbc:mysql:///test?allowMultiQuery=true"";  &#xD;&#xA;&#xD;&#xA;Unless such instruction is passed, an `SQLException` is thrown.&#xD;&#xA;&#xD;&#xA;You have to use [`execute( String sql )`][1] or its other variants to fetch results of the query execution.  &#xD;&#xA;&#xD;&#xA;    boolean hasMoreResultSets = stmt.execute( multiQuerySqlString );&#xD;&#xA;&#xD;&#xA;To iterate through and process results you require following steps:  &#xD;&#xA;&#xD;&#xA;    READING_QUERY_RESULTS: // label  &#xD;&#xA;      while ( hasMoreResultSets || stmt.getUpdateCount() != -1 ) {  &#xD;&#xA;        if ( hasMoreResultSets ) {  &#xD;&#xA;          Resultset rs = stmt.getResultSet();&#xD;&#xA;          // handle your rs here&#xD;&#xA;        } // if has rs&#xD;&#xA;        else { // if ddl/dml/...&#xD;&#xA;          int queryResult = stmt.getUpdateCount();  &#xD;&#xA;          if ( queryResult == -1 ) { // no more queries processed  &#xD;&#xA;            break READING_QUERY_RESULTS;  &#xD;&#xA;          } // no more queries processed  &#xD;&#xA;          // handle success, failure, generated keys, etc here&#xD;&#xA;        } // if ddl/dml/...&#xD;&#xA;    &#xD;&#xA;        // check to continue in the loop  &#xD;&#xA;        hasMoreResultSets = stmt.getMoreResults();  &#xD;&#xA;      } // while results&#xD;&#xA;&#xD;&#xA;**Example 2**: Steps to follow:  &#xD;&#xA;&#xD;&#xA; 1. Create a procedure with one or more `select`, and `DML` queries.&#xD;&#xA; 2. Call it from java using `CallableStatement`.&#xD;&#xA; 3. You can capture multiple `ResultSet`s executed in procedure.  &#xD;&#xA;    DML results can't be captured but can issue another `select`  &#xD;&#xA;    to find how the rows are affected in the table.   &#xD;&#xA;&#xD;&#xA;*Sample table and procedure*:  &#xD;&#xA;&#xD;&#xA;    mysql> create table mq( i int not null auto_increment, name varchar(10), primary key (i) );&#xD;&#xA;    Query OK, 0 rows affected (0.16 sec)&#xD;&#xA;    &#xD;&#xA;    mysql> delimiter //&#xD;&#xA;    mysql> create procedure mq()&#xD;&#xA;        -> begin&#xD;&#xA;        ->  select count(*) as name_count from mq;&#xD;&#xA;        ->  insert into tbl_mq( names ) values ( 'ravi' );&#xD;&#xA;        ->  select last_insert_id();&#xD;&#xA;        -> end;&#xD;&#xA;        -> //&#xD;&#xA;    Query OK, 0 rows affected (0.02 sec)&#xD;&#xA;    mysql> delimiter ;&#xD;&#xA;    mysql> call mq();&#xD;&#xA;    +------------+&#xD;&#xA;    | name_count |&#xD;&#xA;    +------------+&#xD;&#xA;    |          0 |&#xD;&#xA;    +------------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;    &#xD;&#xA;    mysql> call mq();&#xD;&#xA;    +------------+&#xD;&#xA;    | name_count |&#xD;&#xA;    +------------+&#xD;&#xA;    |          0 |&#xD;&#xA;    +------------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;    &#xD;&#xA;    mysql> select * from mq;&#xD;&#xA;    +---+------+&#xD;&#xA;    | i | name |&#xD;&#xA;    +---+------+&#xD;&#xA;    | 1 | ravi |&#xD;&#xA;    +---+------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;&#xD;&#xA;*Call Procedure from Java*:  &#xD;&#xA;&#xD;&#xA;    CallableStatement cstmt = con.prepareCall( ""call mq()"" );  &#xD;&#xA;    boolean hasMoreResultSets = cstmt.execute();  &#xD;&#xA;    READING_QUERY_RESULTS:  &#xD;&#xA;      while ( hasMoreResultSets ) {  &#xD;&#xA;        Resultset rs = stmt.getResultSet();&#xD;&#xA;        // handle your rs here&#xD;&#xA;      } // while has more rs&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/6/docs/api/java/sql/Statement.html#execute%28java.lang.String%29&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;
24979060;10804730;767881;5;a2a24410-23aa-40a5-9c96-d849eece9751;2012-05-30 09:59:19.0;"*I was wondering if it is possible to execute something like this using JDBC.*&#xD;&#xA;&#xD;&#xA;    ""SELECT FROM * TABLE;INSERT INTO TABLE;""&#xD;&#xA;&#xD;&#xA;Yes it is possible. There are two ways, as far as I know. They are&#xD;&#xA;&#xD;&#xA;     1. By setting database connection property to allow multiple queries,&#xD;&#xA;        separated by a semi-colon by default.&#xD;&#xA;     2. By calling a stored procedure that returns cursors implicit.&#xD;&#xA;&#xD;&#xA;Following examples demonstrate the above two possibilities.  &#xD;&#xA;&#xD;&#xA;**Example 1**: ( To allow multiple queries ):  &#xD;&#xA;&#xD;&#xA;While sending a connection request, you need to append a connection property `allowMutilQuery=true` to the database url. This is additional connection property to those if already exists some, like `autoReConnect=true`, etc.. Acceptable values for `allowMultiQuery` property are `true`, `false`, `yes`, and `no`. Any other value is rejected at runtime with an `SQLException`.  &#xD;&#xA;&#xD;&#xA;    String dbUrl = ""jdbc:mysql:///test?allowMultiQuery=true"";  &#xD;&#xA;&#xD;&#xA;Unless such instruction is passed, an `SQLException` is thrown.&#xD;&#xA;&#xD;&#xA;You have to use [`execute( String sql )`][1] or its other variants to fetch results of the query execution.  &#xD;&#xA;&#xD;&#xA;    boolean hasMoreResultSets = stmt.execute( multiQuerySqlString );&#xD;&#xA;&#xD;&#xA;To iterate through and process results you require following steps:  &#xD;&#xA;&#xD;&#xA;    READING_QUERY_RESULTS: // label  &#xD;&#xA;        while ( hasMoreResultSets || stmt.getUpdateCount() != -1 ) {  &#xD;&#xA;            if ( hasMoreResultSets ) {  &#xD;&#xA;                Resultset rs = stmt.getResultSet();&#xD;&#xA;                // handle your rs here&#xD;&#xA;            } // if has rs&#xD;&#xA;            else { // if ddl/dml/...&#xD;&#xA;                int queryResult = stmt.getUpdateCount();  &#xD;&#xA;                if ( queryResult == -1 ) { // no more queries processed  &#xD;&#xA;                    break READING_QUERY_RESULTS;  &#xD;&#xA;                } // no more queries processed  &#xD;&#xA;                // handle success, failure, generated keys, etc here&#xD;&#xA;            } // if ddl/dml/...&#xD;&#xA;    &#xD;&#xA;            // check to continue in the loop  &#xD;&#xA;            hasMoreResultSets = stmt.getMoreResults();  &#xD;&#xA;        } // while results&#xD;&#xA;&#xD;&#xA;**Example 2**: Steps to follow:  &#xD;&#xA;&#xD;&#xA; 1. Create a procedure with one or more `select`, and `DML` queries.&#xD;&#xA; 2. Call it from java using `CallableStatement`.&#xD;&#xA; 3. You can capture multiple `ResultSet`s executed in procedure.  &#xD;&#xA;    DML results can't be captured but can issue another `select`  &#xD;&#xA;    to find how the rows are affected in the table.   &#xD;&#xA;&#xD;&#xA;*Sample table and procedure*:  &#xD;&#xA;&#xD;&#xA;    mysql> create table tbl_mq( i int not null auto_increment, name varchar(10), primary key (i) );&#xD;&#xA;    Query OK, 0 rows affected (0.16 sec)&#xD;&#xA;    &#xD;&#xA;    mysql> delimiter //&#xD;&#xA;    mysql> create procedure multi_query()&#xD;&#xA;        -> begin&#xD;&#xA;        ->  select count(*) as name_count from tbl_mq;&#xD;&#xA;        ->  insert into tbl_mq( names ) values ( 'ravi' );&#xD;&#xA;        ->  select last_insert_id();&#xD;&#xA;        -> end;&#xD;&#xA;        -> //&#xD;&#xA;    Query OK, 0 rows affected (0.02 sec)&#xD;&#xA;    mysql> delimiter ;&#xD;&#xA;    mysql> call multi_query();&#xD;&#xA;    +------------+&#xD;&#xA;    | name_count |&#xD;&#xA;    +------------+&#xD;&#xA;    |          0 |&#xD;&#xA;    +------------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;    &#xD;&#xA;    mysql> call multi_query();&#xD;&#xA;    +------------+&#xD;&#xA;    | name_count |&#xD;&#xA;    +------------+&#xD;&#xA;    |          1 |&#xD;&#xA;    +------------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;    &#xD;&#xA;    mysql> select * from tbl_mq;&#xD;&#xA;    +---+------+&#xD;&#xA;    | i | name |&#xD;&#xA;    +---+------+&#xD;&#xA;    | 1 | ravi |&#xD;&#xA;    +---+------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;&#xD;&#xA;*Call Procedure from Java*:  &#xD;&#xA;&#xD;&#xA;    CallableStatement cstmt = con.prepareCall( ""call multi_query()"" );  &#xD;&#xA;    boolean hasMoreResultSets = cstmt.execute();  &#xD;&#xA;    READING_QUERY_RESULTS:  &#xD;&#xA;        while ( hasMoreResultSets ) {  &#xD;&#xA;            Resultset rs = stmt.getResultSet();&#xD;&#xA;            // handle your rs here&#xD;&#xA;        } // while has more rs&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/6/docs/api/java/sql/Statement.html#execute%28java.lang.String%29&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;some typo errors
24979319;10804730;767881;5;f1e4bb5c-fc26-4a71-942f-126190e3b8af;2012-05-30 10:04:50.0;"*I was wondering if it is possible to execute something like this using JDBC.*&#xD;&#xA;&#xD;&#xA;    ""SELECT FROM * TABLE;INSERT INTO TABLE;""&#xD;&#xA;&#xD;&#xA;Yes it is possible. There are two ways, as far as I know. They are&#xD;&#xA;&#xD;&#xA;     1. By setting database connection property to allow multiple queries,&#xD;&#xA;        separated by a semi-colon by default.&#xD;&#xA;     2. By calling a stored procedure that returns cursors implicit.&#xD;&#xA;&#xD;&#xA;Following examples demonstrate the above two possibilities.  &#xD;&#xA;&#xD;&#xA;**Example 1**: ( To allow multiple queries ):  &#xD;&#xA;&#xD;&#xA;While sending a connection request, you need to append a connection property `allowMutilQuery=true` to the database url. This is additional connection property to those if already exists some, like `autoReConnect=true`, etc.. Acceptable values for `allowMultiQuery` property are `true`, `false`, `yes`, and `no`. Any other value is rejected at runtime with an `SQLException`.  &#xD;&#xA;&#xD;&#xA;    String dbUrl = ""jdbc:mysql:///test?allowMultiQuery=true"";  &#xD;&#xA;&#xD;&#xA;Unless such instruction is passed, an `SQLException` is thrown.&#xD;&#xA;&#xD;&#xA;You have to use [`execute( String sql )`][1] or its other variants to fetch results of the query execution.  &#xD;&#xA;&#xD;&#xA;    boolean hasMoreResultSets = stmt.execute( multiQuerySqlString );&#xD;&#xA;&#xD;&#xA;To iterate through and process results you require following steps:  &#xD;&#xA;&#xD;&#xA;    READING_QUERY_RESULTS: // label  &#xD;&#xA;        while ( hasMoreResultSets || stmt.getUpdateCount() != -1 ) {  &#xD;&#xA;            if ( hasMoreResultSets ) {  &#xD;&#xA;                Resultset rs = stmt.getResultSet();&#xD;&#xA;                // handle your rs here&#xD;&#xA;            } // if has rs&#xD;&#xA;            else { // if ddl/dml/...&#xD;&#xA;                int queryResult = stmt.getUpdateCount();  &#xD;&#xA;                if ( queryResult == -1 ) { // no more queries processed  &#xD;&#xA;                    break READING_QUERY_RESULTS;  &#xD;&#xA;                } // no more queries processed  &#xD;&#xA;                // handle success, failure, generated keys, etc here&#xD;&#xA;            } // if ddl/dml/...&#xD;&#xA;    &#xD;&#xA;            // check to continue in the loop  &#xD;&#xA;            hasMoreResultSets = stmt.getMoreResults();  &#xD;&#xA;        } // while results&#xD;&#xA;&#xD;&#xA;**Example 2**: Steps to follow:  &#xD;&#xA;&#xD;&#xA; 1. Create a procedure with one or more `select`, and `DML` queries.&#xD;&#xA; 2. Call it from java using `CallableStatement`.&#xD;&#xA; 3. You can capture multiple `ResultSet`s executed in procedure.  &#xD;&#xA;    DML results can't be captured but can issue another `select`  &#xD;&#xA;    to find how the rows are affected in the table.   &#xD;&#xA;&#xD;&#xA;*Sample table and procedure*:  &#xD;&#xA;&#xD;&#xA;    mysql> create table tbl_mq( i int not null auto_increment, name varchar(10), primary key (i) );&#xD;&#xA;    Query OK, 0 rows affected (0.16 sec)&#xD;&#xA;    &#xD;&#xA;    mysql> delimiter //&#xD;&#xA;    mysql> create procedure multi_query()&#xD;&#xA;        -> begin&#xD;&#xA;        ->  select count(*) as name_count from tbl_mq;&#xD;&#xA;        ->  insert into tbl_mq( names ) values ( 'ravi' );&#xD;&#xA;        ->  select last_insert_id();&#xD;&#xA;        ->  select * from tbl_mq;&#xD;&#xA;        -> end;&#xD;&#xA;        -> //&#xD;&#xA;    Query OK, 0 rows affected (0.02 sec)&#xD;&#xA;    mysql> delimiter ;&#xD;&#xA;    mysql> call multi_query();&#xD;&#xA;    +------------+&#xD;&#xA;    | name_count |&#xD;&#xA;    +------------+&#xD;&#xA;    |          0 |&#xD;&#xA;    +------------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;    &#xD;&#xA;    +------------------+&#xD;&#xA;    | last_insert_id() |&#xD;&#xA;    +------------------+&#xD;&#xA;    |                3 |&#xD;&#xA;    +------------------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;    &#xD;&#xA;    +---+------+&#xD;&#xA;    | i | name |&#xD;&#xA;    +---+------+&#xD;&#xA;    | 1 | ravi |&#xD;&#xA;    +---+------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;&#xD;&#xA;    Query OK, 0 rows affected (0.00 sec)&#xD;&#xA;&#xD;&#xA;*Call Procedure from Java*:  &#xD;&#xA;&#xD;&#xA;    CallableStatement cstmt = con.prepareCall( ""call multi_query()"" );  &#xD;&#xA;    boolean hasMoreResultSets = cstmt.execute();  &#xD;&#xA;    READING_QUERY_RESULTS:  &#xD;&#xA;        while ( hasMoreResultSets ) {  &#xD;&#xA;            Resultset rs = stmt.getResultSet();&#xD;&#xA;            // handle your rs here&#xD;&#xA;        } // while has more rs&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/6/docs/api/java/sql/Statement.html#execute%28java.lang.String%29&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;some typo errors
52298251;10804730;767881;5;4dea909b-ebf2-4011-a578-cbb93af04b08;2013-11-26 07:10:46.0;"*I was wondering if it is possible to execute something like this using JDBC.*&#xD;&#xA;&#xD;&#xA;    ""SELECT FROM * TABLE;INSERT INTO TABLE;""&#xD;&#xA;&#xD;&#xA;Yes it is possible. There are two ways, as far as I know. They are&#xD;&#xA;&#xD;&#xA;     1. By setting database connection property to allow multiple queries,&#xD;&#xA;        separated by a semi-colon by default.&#xD;&#xA;     2. By calling a stored procedure that returns cursors implicit.&#xD;&#xA;&#xD;&#xA;Following examples demonstrate the above two possibilities.  &#xD;&#xA;&#xD;&#xA;**Example 1**: ( To allow multiple queries ):  &#xD;&#xA;&#xD;&#xA;While sending a connection request, you need to append a connection property `allowMutilQuery=true` to the database url. This is additional connection property to those if already exists some, like `autoReConnect=true`, etc.. Acceptable values for `allowMultiQuery` property are `true`, `false`, `yes`, and `no`. Any other value is rejected at runtime with an `SQLException`.  &#xD;&#xA;&#xD;&#xA;    String dbUrl = ""jdbc:mysql:///test?allowMultiQueries=true"";  &#xD;&#xA;&#xD;&#xA;Unless such instruction is passed, an `SQLException` is thrown.&#xD;&#xA;&#xD;&#xA;You have to use [`execute( String sql )`][1] or its other variants to fetch results of the query execution.  &#xD;&#xA;&#xD;&#xA;    boolean hasMoreResultSets = stmt.execute( multiQuerySqlString );&#xD;&#xA;&#xD;&#xA;To iterate through and process results you require following steps:  &#xD;&#xA;&#xD;&#xA;    READING_QUERY_RESULTS: // label  &#xD;&#xA;        while ( hasMoreResultSets || stmt.getUpdateCount() != -1 ) {  &#xD;&#xA;            if ( hasMoreResultSets ) {  &#xD;&#xA;                Resultset rs = stmt.getResultSet();&#xD;&#xA;                // handle your rs here&#xD;&#xA;            } // if has rs&#xD;&#xA;            else { // if ddl/dml/...&#xD;&#xA;                int queryResult = stmt.getUpdateCount();  &#xD;&#xA;                if ( queryResult == -1 ) { // no more queries processed  &#xD;&#xA;                    break READING_QUERY_RESULTS;  &#xD;&#xA;                } // no more queries processed  &#xD;&#xA;                // handle success, failure, generated keys, etc here&#xD;&#xA;            } // if ddl/dml/...&#xD;&#xA;    &#xD;&#xA;            // check to continue in the loop  &#xD;&#xA;            hasMoreResultSets = stmt.getMoreResults();  &#xD;&#xA;        } // while results&#xD;&#xA;&#xD;&#xA;**Example 2**: Steps to follow:  &#xD;&#xA;&#xD;&#xA; 1. Create a procedure with one or more `select`, and `DML` queries.&#xD;&#xA; 2. Call it from java using `CallableStatement`.&#xD;&#xA; 3. You can capture multiple `ResultSet`s executed in procedure.  &#xD;&#xA;    DML results can't be captured but can issue another `select`  &#xD;&#xA;    to find how the rows are affected in the table.   &#xD;&#xA;&#xD;&#xA;*Sample table and procedure*:  &#xD;&#xA;&#xD;&#xA;    mysql> create table tbl_mq( i int not null auto_increment, name varchar(10), primary key (i) );&#xD;&#xA;    Query OK, 0 rows affected (0.16 sec)&#xD;&#xA;    &#xD;&#xA;    mysql> delimiter //&#xD;&#xA;    mysql> create procedure multi_query()&#xD;&#xA;        -> begin&#xD;&#xA;        ->  select count(*) as name_count from tbl_mq;&#xD;&#xA;        ->  insert into tbl_mq( names ) values ( 'ravi' );&#xD;&#xA;        ->  select last_insert_id();&#xD;&#xA;        ->  select * from tbl_mq;&#xD;&#xA;        -> end;&#xD;&#xA;        -> //&#xD;&#xA;    Query OK, 0 rows affected (0.02 sec)&#xD;&#xA;    mysql> delimiter ;&#xD;&#xA;    mysql> call multi_query();&#xD;&#xA;    +------------+&#xD;&#xA;    | name_count |&#xD;&#xA;    +------------+&#xD;&#xA;    |          0 |&#xD;&#xA;    +------------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;    &#xD;&#xA;    +------------------+&#xD;&#xA;    | last_insert_id() |&#xD;&#xA;    +------------------+&#xD;&#xA;    |                3 |&#xD;&#xA;    +------------------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;    &#xD;&#xA;    +---+------+&#xD;&#xA;    | i | name |&#xD;&#xA;    +---+------+&#xD;&#xA;    | 1 | ravi |&#xD;&#xA;    +---+------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;&#xD;&#xA;    Query OK, 0 rows affected (0.00 sec)&#xD;&#xA;&#xD;&#xA;*Call Procedure from Java*:  &#xD;&#xA;&#xD;&#xA;    CallableStatement cstmt = con.prepareCall( ""call multi_query()"" );  &#xD;&#xA;    boolean hasMoreResultSets = cstmt.execute();  &#xD;&#xA;    READING_QUERY_RESULTS:  &#xD;&#xA;        while ( hasMoreResultSets ) {  &#xD;&#xA;            Resultset rs = stmt.getResultSet();&#xD;&#xA;            // handle your rs here&#xD;&#xA;        } // while has more rs&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/6/docs/api/java/sql/Statement.html#execute%28java.lang.String%29&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added 2 characters in body
61090474;10804730;767881;5;337bb77d-23d3-49e2-b867-2d43bb8e638e;2014-03-23 16:39:03.0;"*I was wondering if it is possible to execute something like this using JDBC.*&#xD;&#xA;&#xD;&#xA;    ""SELECT FROM * TABLE;INSERT INTO TABLE;""&#xD;&#xA;&#xD;&#xA;Yes it is possible. There are two ways, as far as I know. They are&#xD;&#xA;&#xD;&#xA;     1. By setting database connection property to allow multiple queries,&#xD;&#xA;        separated by a semi-colon by default.&#xD;&#xA;     2. By calling a stored procedure that returns cursors implicit.&#xD;&#xA;&#xD;&#xA;Following examples demonstrate the above two possibilities.  &#xD;&#xA;&#xD;&#xA;**Example 1**: ( To allow multiple queries ):  &#xD;&#xA;&#xD;&#xA;While sending a connection request, you need to append a connection property `allowMultiQueries=true` to the database url. This is additional connection property to those if already exists some, like `autoReConnect=true`, etc.. Acceptable values for `allowMultiQueries` property are `true`, `false`, `yes`, and `no`. Any other value is rejected at runtime with an `SQLException`.  &#xD;&#xA;&#xD;&#xA;    String dbUrl = ""jdbc:mysql:///test?allowMultiQueries=true"";  &#xD;&#xA;&#xD;&#xA;Unless such instruction is passed, an `SQLException` is thrown.&#xD;&#xA;&#xD;&#xA;You have to use [`execute( String sql )`][1] or its other variants to fetch results of the query execution.  &#xD;&#xA;&#xD;&#xA;    boolean hasMoreResultSets = stmt.execute( multiQuerySqlString );&#xD;&#xA;&#xD;&#xA;To iterate through and process results you require following steps:  &#xD;&#xA;&#xD;&#xA;    READING_QUERY_RESULTS: // label  &#xD;&#xA;        while ( hasMoreResultSets || stmt.getUpdateCount() != -1 ) {  &#xD;&#xA;            if ( hasMoreResultSets ) {  &#xD;&#xA;                Resultset rs = stmt.getResultSet();&#xD;&#xA;                // handle your rs here&#xD;&#xA;            } // if has rs&#xD;&#xA;            else { // if ddl/dml/...&#xD;&#xA;                int queryResult = stmt.getUpdateCount();  &#xD;&#xA;                if ( queryResult == -1 ) { // no more queries processed  &#xD;&#xA;                    break READING_QUERY_RESULTS;  &#xD;&#xA;                } // no more queries processed  &#xD;&#xA;                // handle success, failure, generated keys, etc here&#xD;&#xA;            } // if ddl/dml/...&#xD;&#xA;    &#xD;&#xA;            // check to continue in the loop  &#xD;&#xA;            hasMoreResultSets = stmt.getMoreResults();  &#xD;&#xA;        } // while results&#xD;&#xA;&#xD;&#xA;**Example 2**: Steps to follow:  &#xD;&#xA;&#xD;&#xA; 1. Create a procedure with one or more `select`, and `DML` queries.&#xD;&#xA; 2. Call it from java using `CallableStatement`.&#xD;&#xA; 3. You can capture multiple `ResultSet`s executed in procedure.  &#xD;&#xA;    DML results can't be captured but can issue another `select`  &#xD;&#xA;    to find how the rows are affected in the table.   &#xD;&#xA;&#xD;&#xA;*Sample table and procedure*:  &#xD;&#xA;&#xD;&#xA;    mysql> create table tbl_mq( i int not null auto_increment, name varchar(10), primary key (i) );&#xD;&#xA;    Query OK, 0 rows affected (0.16 sec)&#xD;&#xA;    &#xD;&#xA;    mysql> delimiter //&#xD;&#xA;    mysql> create procedure multi_query()&#xD;&#xA;        -> begin&#xD;&#xA;        ->  select count(*) as name_count from tbl_mq;&#xD;&#xA;        ->  insert into tbl_mq( names ) values ( 'ravi' );&#xD;&#xA;        ->  select last_insert_id();&#xD;&#xA;        ->  select * from tbl_mq;&#xD;&#xA;        -> end;&#xD;&#xA;        -> //&#xD;&#xA;    Query OK, 0 rows affected (0.02 sec)&#xD;&#xA;    mysql> delimiter ;&#xD;&#xA;    mysql> call multi_query();&#xD;&#xA;    +------------+&#xD;&#xA;    | name_count |&#xD;&#xA;    +------------+&#xD;&#xA;    |          0 |&#xD;&#xA;    +------------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;    &#xD;&#xA;    +------------------+&#xD;&#xA;    | last_insert_id() |&#xD;&#xA;    +------------------+&#xD;&#xA;    |                3 |&#xD;&#xA;    +------------------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;    &#xD;&#xA;    +---+------+&#xD;&#xA;    | i | name |&#xD;&#xA;    +---+------+&#xD;&#xA;    | 1 | ravi |&#xD;&#xA;    +---+------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;&#xD;&#xA;    Query OK, 0 rows affected (0.00 sec)&#xD;&#xA;&#xD;&#xA;*Call Procedure from Java*:  &#xD;&#xA;&#xD;&#xA;    CallableStatement cstmt = con.prepareCall( ""call multi_query()"" );  &#xD;&#xA;    boolean hasMoreResultSets = cstmt.execute();  &#xD;&#xA;    READING_QUERY_RESULTS:  &#xD;&#xA;        while ( hasMoreResultSets ) {  &#xD;&#xA;            Resultset rs = stmt.getResultSet();&#xD;&#xA;            // handle your rs here&#xD;&#xA;        } // while has more rs&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/6/docs/api/java/sql/Statement.html#execute%28java.lang.String%29&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;typo error. correction missed on last edit.
109255913;10804730;521799;5;69584330-fe00-43f5-8587-13318bc3c081;2016-01-25 15:18:49.0;"*I was wondering if it is possible to execute something like this using JDBC.*&#xD;&#xA;&#xD;&#xA;    ""SELECT FROM * TABLE;INSERT INTO TABLE;""&#xD;&#xA;&#xD;&#xA;Yes it is possible. There are two ways, as far as I know. They are&#xD;&#xA;&#xD;&#xA;<!-- language: lang-none -->&#xD;&#xA;&#xD;&#xA;     1. By setting database connection property to allow multiple queries,&#xD;&#xA;        separated by a semi-colon by default.&#xD;&#xA;     2. By calling a stored procedure that returns cursors implicit.&#xD;&#xA;&#xD;&#xA;Following examples demonstrate the above two possibilities.  &#xD;&#xA;&#xD;&#xA;**Example 1**: ( To allow multiple queries ):  &#xD;&#xA;&#xD;&#xA;While sending a connection request, you need to append a connection property `allowMultiQueries=true` to the database url. This is additional connection property to those if already exists some, like `autoReConnect=true`, etc.. Acceptable values for `allowMultiQueries` property are `true`, `false`, `yes`, and `no`. Any other value is rejected at runtime with an `SQLException`.  &#xD;&#xA;&#xD;&#xA;    String dbUrl = ""jdbc:mysql:///test?allowMultiQueries=true"";  &#xD;&#xA;&#xD;&#xA;Unless such instruction is passed, an `SQLException` is thrown.&#xD;&#xA;&#xD;&#xA;You have to use [`execute( String sql )`][1] or its other variants to fetch results of the query execution.  &#xD;&#xA;&#xD;&#xA;    boolean hasMoreResultSets = stmt.execute( multiQuerySqlString );&#xD;&#xA;&#xD;&#xA;To iterate through and process results you require following steps:  &#xD;&#xA;&#xD;&#xA;    READING_QUERY_RESULTS: // label  &#xD;&#xA;        while ( hasMoreResultSets || stmt.getUpdateCount() != -1 ) {  &#xD;&#xA;            if ( hasMoreResultSets ) {  &#xD;&#xA;                Resultset rs = stmt.getResultSet();&#xD;&#xA;                // handle your rs here&#xD;&#xA;            } // if has rs&#xD;&#xA;            else { // if ddl/dml/...&#xD;&#xA;                int queryResult = stmt.getUpdateCount();  &#xD;&#xA;                if ( queryResult == -1 ) { // no more queries processed  &#xD;&#xA;                    break READING_QUERY_RESULTS;  &#xD;&#xA;                } // no more queries processed  &#xD;&#xA;                // handle success, failure, generated keys, etc here&#xD;&#xA;            } // if ddl/dml/...&#xD;&#xA;    &#xD;&#xA;            // check to continue in the loop  &#xD;&#xA;            hasMoreResultSets = stmt.getMoreResults();  &#xD;&#xA;        } // while results&#xD;&#xA;&#xD;&#xA;**Example 2**: Steps to follow:  &#xD;&#xA;&#xD;&#xA; 1. Create a procedure with one or more `select`, and `DML` queries.&#xD;&#xA; 2. Call it from java using `CallableStatement`.&#xD;&#xA; 3. You can capture multiple `ResultSet`s executed in procedure.  &#xD;&#xA;    DML results can't be captured but can issue another `select`  &#xD;&#xA;    to find how the rows are affected in the table.   &#xD;&#xA;&#xD;&#xA;*Sample table and procedure*:  &#xD;&#xA;&#xD;&#xA;<!-- language: lang-none -->&#xD;&#xA;&#xD;&#xA;    mysql> create table tbl_mq( i int not null auto_increment, name varchar(10), primary key (i) );&#xD;&#xA;    Query OK, 0 rows affected (0.16 sec)&#xD;&#xA;    &#xD;&#xA;    mysql> delimiter //&#xD;&#xA;    mysql> create procedure multi_query()&#xD;&#xA;        -> begin&#xD;&#xA;        ->  select count(*) as name_count from tbl_mq;&#xD;&#xA;        ->  insert into tbl_mq( names ) values ( 'ravi' );&#xD;&#xA;        ->  select last_insert_id();&#xD;&#xA;        ->  select * from tbl_mq;&#xD;&#xA;        -> end;&#xD;&#xA;        -> //&#xD;&#xA;    Query OK, 0 rows affected (0.02 sec)&#xD;&#xA;    mysql> delimiter ;&#xD;&#xA;    mysql> call multi_query();&#xD;&#xA;    +------------+&#xD;&#xA;    | name_count |&#xD;&#xA;    +------------+&#xD;&#xA;    |          0 |&#xD;&#xA;    +------------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;    &#xD;&#xA;    +------------------+&#xD;&#xA;    | last_insert_id() |&#xD;&#xA;    +------------------+&#xD;&#xA;    |                3 |&#xD;&#xA;    +------------------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;    &#xD;&#xA;    +---+------+&#xD;&#xA;    | i | name |&#xD;&#xA;    +---+------+&#xD;&#xA;    | 1 | ravi |&#xD;&#xA;    +---+------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;&#xD;&#xA;    Query OK, 0 rows affected (0.00 sec)&#xD;&#xA;&#xD;&#xA;*Call Procedure from Java*:  &#xD;&#xA;&#xD;&#xA;    CallableStatement cstmt = con.prepareCall( ""call multi_query()"" );  &#xD;&#xA;    boolean hasMoreResultSets = cstmt.execute();  &#xD;&#xA;    READING_QUERY_RESULTS:  &#xD;&#xA;        while ( hasMoreResultSets ) {  &#xD;&#xA;            Resultset rs = stmt.getResultSet();&#xD;&#xA;            // handle your rs here&#xD;&#xA;        } // while has more rs&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/6/docs/api/java/sql/Statement.html#execute%28java.lang.String%29&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;Suffering from OCD, I just *had* to remove syntax highlighting on these parts...
134157481;10804730;466862;5;9a3b3a23-dd45-4018-bc23-7d5d6fd24378;2016-12-19 11:08:11.0;"*I was wondering if it is possible to execute something like this using JDBC.*&#xD;&#xA;&#xD;&#xA;    ""SELECT FROM * TABLE;INSERT INTO TABLE;""&#xD;&#xA;&#xD;&#xA;Yes it is possible. There are two ways, as far as I know. They are&#xD;&#xA;&#xD;&#xA; 1. By setting database connection property to allow multiple queries,&#xD;&#xA;    separated by a semi-colon by default.&#xD;&#xA; 2. By calling a stored procedure that returns cursors implicit.&#xD;&#xA;&#xD;&#xA;Following examples demonstrate the above two possibilities.  &#xD;&#xA;&#xD;&#xA;**Example 1**: ( To allow multiple queries ):  &#xD;&#xA;&#xD;&#xA;While sending a connection request, you need to append a connection property `allowMultiQueries=true` to the database url. This is additional connection property to those if already exists some, like `autoReConnect=true`, etc.. Acceptable values for `allowMultiQueries` property are `true`, `false`, `yes`, and `no`. Any other value is rejected at runtime with an `SQLException`.  &#xD;&#xA;&#xD;&#xA;    String dbUrl = ""jdbc:mysql:///test?allowMultiQueries=true"";  &#xD;&#xA;&#xD;&#xA;Unless such instruction is passed, an `SQLException` is thrown.&#xD;&#xA;&#xD;&#xA;You have to use [`execute( String sql )`][1] or its other variants to fetch results of the query execution.  &#xD;&#xA;&#xD;&#xA;    boolean hasMoreResultSets = stmt.execute( multiQuerySqlString );&#xD;&#xA;&#xD;&#xA;To iterate through and process results you require following steps:  &#xD;&#xA;&#xD;&#xA;    READING_QUERY_RESULTS: // label  &#xD;&#xA;        while ( hasMoreResultSets || stmt.getUpdateCount() != -1 ) {  &#xD;&#xA;            if ( hasMoreResultSets ) {  &#xD;&#xA;                Resultset rs = stmt.getResultSet();&#xD;&#xA;                // handle your rs here&#xD;&#xA;            } // if has rs&#xD;&#xA;            else { // if ddl/dml/...&#xD;&#xA;                int queryResult = stmt.getUpdateCount();  &#xD;&#xA;                if ( queryResult == -1 ) { // no more queries processed  &#xD;&#xA;                    break READING_QUERY_RESULTS;  &#xD;&#xA;                } // no more queries processed  &#xD;&#xA;                // handle success, failure, generated keys, etc here&#xD;&#xA;            } // if ddl/dml/...&#xD;&#xA;    &#xD;&#xA;            // check to continue in the loop  &#xD;&#xA;            hasMoreResultSets = stmt.getMoreResults();  &#xD;&#xA;        } // while results&#xD;&#xA;&#xD;&#xA;**Example 2**: Steps to follow:  &#xD;&#xA;&#xD;&#xA; 1. Create a procedure with one or more `select`, and `DML` queries.&#xD;&#xA; 2. Call it from java using `CallableStatement`.&#xD;&#xA; 3. You can capture multiple `ResultSet`s executed in procedure.  &#xD;&#xA;    DML results can't be captured but can issue another `select`  &#xD;&#xA;    to find how the rows are affected in the table.   &#xD;&#xA;&#xD;&#xA;*Sample table and procedure*:  &#xD;&#xA;&#xD;&#xA;<!-- language: lang-none -->&#xD;&#xA;&#xD;&#xA;    mysql> create table tbl_mq( i int not null auto_increment, name varchar(10), primary key (i) );&#xD;&#xA;    Query OK, 0 rows affected (0.16 sec)&#xD;&#xA;    &#xD;&#xA;    mysql> delimiter //&#xD;&#xA;    mysql> create procedure multi_query()&#xD;&#xA;        -> begin&#xD;&#xA;        ->  select count(*) as name_count from tbl_mq;&#xD;&#xA;        ->  insert into tbl_mq( names ) values ( 'ravi' );&#xD;&#xA;        ->  select last_insert_id();&#xD;&#xA;        ->  select * from tbl_mq;&#xD;&#xA;        -> end;&#xD;&#xA;        -> //&#xD;&#xA;    Query OK, 0 rows affected (0.02 sec)&#xD;&#xA;    mysql> delimiter ;&#xD;&#xA;    mysql> call multi_query();&#xD;&#xA;    +------------+&#xD;&#xA;    | name_count |&#xD;&#xA;    +------------+&#xD;&#xA;    |          0 |&#xD;&#xA;    +------------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;    &#xD;&#xA;    +------------------+&#xD;&#xA;    | last_insert_id() |&#xD;&#xA;    +------------------+&#xD;&#xA;    |                3 |&#xD;&#xA;    +------------------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;    &#xD;&#xA;    +---+------+&#xD;&#xA;    | i | name |&#xD;&#xA;    +---+------+&#xD;&#xA;    | 1 | ravi |&#xD;&#xA;    +---+------+&#xD;&#xA;    1 row in set (0.00 sec)&#xD;&#xA;&#xD;&#xA;    Query OK, 0 rows affected (0.00 sec)&#xD;&#xA;&#xD;&#xA;*Call Procedure from Java*:  &#xD;&#xA;&#xD;&#xA;    CallableStatement cstmt = con.prepareCall( ""call multi_query()"" );  &#xD;&#xA;    boolean hasMoreResultSets = cstmt.execute();  &#xD;&#xA;    READING_QUERY_RESULTS:  &#xD;&#xA;        while ( hasMoreResultSets ) {  &#xD;&#xA;            Resultset rs = stmt.getResultSet();&#xD;&#xA;            // handle your rs here&#xD;&#xA;        } // while has more rs&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/6/docs/api/java/sql/Statement.html#execute%28java.lang.String%29&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;List as list, not as code block
