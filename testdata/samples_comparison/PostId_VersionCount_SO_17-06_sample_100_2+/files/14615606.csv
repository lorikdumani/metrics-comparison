Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
35257950;14615606;1052261;2;a40a79f0-9ce6-4e95-a9f5-4cab54b966fd;2013-01-30 23:10:28.0;"You can try this one it is short :)&#xD;&#xA;&#xD;&#xA;SystemClock.sleep(7000);";;
44641961;14615606;1206052;5;63a458e6-0bbc-46fd-9e45-92f41b50f78d;2013-08-01 05:01:21.0;"You can try this one it is **short**  &#xD;&#xA;**:)**&#xD;&#xA;&#xD;&#xA;    SystemClock.sleep(7000);";;formatting
44641963;14615606;1155650;5;85aec7d3-dc9b-48d7-828f-4d50d4110997;2013-08-01 05:01:21.0;"You can try this one it is short &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    SystemClock.sleep(7000);";;formatting
65319815;14615606;1052261;5;b134cdf2-48e9-452d-a59e-e6b5cf998a3b;2014-05-17 09:10:15.0;"You can try this one it is **short** &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    SystemClock.sleep(7000);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; [Documentation][1]&#xD;&#xA;&#xD;&#xA;    public static void sleep (long ms)&#xD;&#xA;    &#xD;&#xA;    Added in API level 1&#xD;&#xA;    Waits a given number of milliseconds (of uptimeMillis) before returning. Similar to sleep(long), but does not throw InterruptedException; interrupt() events are deferred until the next interruptible operation. Does not return until at least the specified number of milliseconds has elapsed.&#xD;&#xA;    &#xD;&#xA;    Parameters&#xD;&#xA;    ms	to sleep before returning, in milliseconds of uptime.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://developer.android.com/reference/android/os/SystemClock.html#sleep%28long%29";;added 583 characters in body
65320018;14615606;1052261;5;695e5777-ffe5-4d14-ba65-941464f345df;2014-05-17 09:16:07.0;"You can try this one it is **short** &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    SystemClock.sleep(7000);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; [Documentation][1]&#xD;&#xA;&#xD;&#xA;>public static void sleep (long ms)&#xD;&#xA;>&#xD;&#xA;>  &#xD;&#xA;> Added in API level 1&#xD;&#xA;>&#xD;&#xA;> Waits a given number of milliseconds (of uptimeMillis) before returning. Similar to sleep(long), **but does not throw InterruptedException**; interrupt() events are deferred until the&#xD;&#xA;> next interruptible operation. &#xD;&#xA;> Does **not return** until at least the specified number of milliseconds has elapsed.&#xD;&#xA;>&#xD;&#xA;> Parameters&#xD;&#xA;>&#xD;&#xA;>    **ms** to sleep before returning, in milliseconds of uptime.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  &#xD;&#xA;&#xD;&#xA;[1]: http://developer.android.com/reference/android/os/SystemClock.html#sleep%28long%29";;added 583 characters in body
95275297;14615606;1052261;5;5fa87004-b28e-4889-8254-383dd5fc1018;2015-07-16 20:55:49.0;"You can try this one it is **short** &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    SystemClock.sleep(7000);&#xD;&#xA;&#xD;&#xA;**WARNING**: Never, ever, do this on a UI thread.&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; [Documentation][1]&#xD;&#xA;&#xD;&#xA;>public static void sleep (long ms)&#xD;&#xA;>&#xD;&#xA;>  &#xD;&#xA;> Added in API level 1&#xD;&#xA;>&#xD;&#xA;> Waits a given number of milliseconds (of uptimeMillis) before returning. Similar to sleep(long), **but does not throw InterruptedException**; interrupt() events are deferred until the&#xD;&#xA;> next interruptible operation. &#xD;&#xA;> Does **not return** until at least the specified number of milliseconds has elapsed.&#xD;&#xA;>&#xD;&#xA;> Parameters&#xD;&#xA;>&#xD;&#xA;>    **ms** to sleep before returning, in milliseconds of uptime.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  &#xD;&#xA;&#xD;&#xA;[1]: http://developer.android.com/reference/android/os/SystemClock.html#sleep%28long%29";;added 49 characters in body
118888004;14615606;1052261;5;21f1c003-1f78-4203-ac16-b5c66cd9dbb3;2016-05-25 08:54:08.0;"You can try this one it is **short** &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    SystemClock.sleep(7000);&#xD;&#xA;&#xD;&#xA;**WARNING**: Never, ever, do this on a UI thread.&#xD;&#xA;&#xD;&#xA;Use this to sleep eg. background thread.&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;Full solution for your problem will be:&#xD;&#xA;This is available API 1&#xD;&#xA;&#xD;&#xA;    findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {&#xD;&#xA;    			@Override&#xD;&#xA;    			public void onClick(final View button) {&#xD;&#xA;    				button.setBackgroundResource(R.drawable.avatar_dead);&#xD;&#xA;    				final long changeTime = 1000L;&#xD;&#xA;    				button.postDelayed(new Runnable() {&#xD;&#xA;    					@Override&#xD;&#xA;    					public void run() {&#xD;&#xA;    						button.setBackgroundResource(R.drawable.avatar_small);&#xD;&#xA;    					}&#xD;&#xA;    				}, changeTime);&#xD;&#xA;    			}&#xD;&#xA;    		});&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;Without creating tmp Handler. Also this solution is better than @tronman because we do not retain view by Handler.&#xD;&#xA;Also we don't have problem with Handler created at bad thread ;) &#xD;&#xA;&#xD;&#xA;&#xD;&#xA; [Documentation][1]&#xD;&#xA;&#xD;&#xA;>public static void sleep (long ms)&#xD;&#xA;>&#xD;&#xA;>  &#xD;&#xA;> Added in API level 1&#xD;&#xA;>&#xD;&#xA;> Waits a given number of milliseconds (of uptimeMillis) before returning. Similar to sleep(long), **but does not throw InterruptedException**; interrupt() events are deferred until the&#xD;&#xA;> next interruptible operation. &#xD;&#xA;> Does **not return** until at least the specified number of milliseconds has elapsed.&#xD;&#xA;>&#xD;&#xA;> Parameters&#xD;&#xA;>&#xD;&#xA;>    **ms** to sleep before returning, in milliseconds of uptime.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Code for [postDelayed][2] from View class:&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * <p>Causes the Runnable to be added to the message queue, to be run&#xD;&#xA;     * after the specified amount of time elapses.&#xD;&#xA;     * The runnable will be run on the user interface thread.</p>&#xD;&#xA;     *&#xD;&#xA;     * @param action The Runnable that will be executed.&#xD;&#xA;     * @param delayMillis The delay (in milliseconds) until the Runnable&#xD;&#xA;     *        will be executed.&#xD;&#xA;     *&#xD;&#xA;     * @return true if the Runnable was successfully placed in to the&#xD;&#xA;     *         message queue.  Returns false on failure, usually because the&#xD;&#xA;     *         looper processing the message queue is exiting.  Note that a&#xD;&#xA;     *         result of true does not mean the Runnable will be processed --&#xD;&#xA;     *         if the looper is quit before the delivery time of the message&#xD;&#xA;     *         occurs then the message will be dropped.&#xD;&#xA;     *&#xD;&#xA;     * @see #post&#xD;&#xA;     * @see #removeCallbacks&#xD;&#xA;     */&#xD;&#xA;    public boolean postDelayed(Runnable action, long delayMillis) {&#xD;&#xA;        final AttachInfo attachInfo = mAttachInfo;&#xD;&#xA;        if (attachInfo != null) {&#xD;&#xA;            return attachInfo.mHandler.postDelayed(action, delayMillis);&#xD;&#xA;        }&#xD;&#xA;        // Assume that post will succeed later&#xD;&#xA;        ViewRootImpl.getRunQueue().postDelayed(action, delayMillis);&#xD;&#xA;        return true;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://developer.android.com/reference/android/os/SystemClock.html#sleep%28long%29&#xD;&#xA;  [2]: https://developer.android.com/reference/android/view/View.html#postDelayed(java.lang.Runnable,%20long)";;add code sample for detailed question... (more)
