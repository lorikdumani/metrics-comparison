Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
111720023;35622441;4191711;2;f4709b14-1dc9-4977-ab5f-78bb005cce01;2016-02-25 08:53:28.0;"The following snippet is intentionally accessing the next sizeof(int) bytes following t[4], so it is not necessarily a mistake. Bear with me. &#xD;&#xA;&#xD;&#xA;    int t[5], i;&#xD;&#xA;    &#xD;&#xA;    for (i = 0; i <= 5; i++) {&#xD;&#xA;       t[i] = 0;&#xD;&#xA;    }&#xD;&#xA;When  executing this little program on a friend's Windows PC (I think he was using Code::Blocks with a ported version of the GNU C Compiler), it will always gets stuck in an infinite loop. I am pretty sure that this happens because t and i are allocated on the stack one after the other and t[5] points to to the same address as the i variable. Therefore, when executing t[5] = 0 the program actually sets the value of i to 0.&#xD;&#xA;&#xD;&#xA;However, when running this on Linux/Mac I never get the infinite loop. The address of t[5] is not the same as the address of i (I've printed out the addresses).&#xD;&#xA;&#xD;&#xA;My question is, why this different behavior? After all, I think that the the stack allocations should happen in the same way.";;
111722162;35622441;4191711;5;7c847cae-57cb-4043-86e3-e1657985103a;2016-02-25 09:19:53.0;"The following snippet is intentionally accessing the next sizeof(int) bytes following t[4], so it is not necessarily a mistake. Bear with me. &#xD;&#xA;&#xD;&#xA;    int t[5], i;&#xD;&#xA;    &#xD;&#xA;    for (i = 0; i <= 5; i++) {&#xD;&#xA;       t[i] = 0;&#xD;&#xA;    }&#xD;&#xA;When  executing this little program on a friend's Windows PC (I think he was using Code::Blocks with a ported version of the GNU C Compiler), it will always gets stuck in an infinite loop. I am pretty sure that this happens because t and i are allocated on the stack one after the other and t[5] points to to the same address as the i variable. Therefore, when executing t[5] = 0 the program actually sets the value of i to 0.&#xD;&#xA;&#xD;&#xA;However, when running this on Linux/Mac I never get the infinite loop. The address of t[5] is not the same as the address of i (I've printed out the addresses).&#xD;&#xA;&#xD;&#xA;My question is, why this different behavior? After all, I think that the the stack allocations should happen in the same way.&#xD;&#xA;&#xD;&#xA;	&#xD;&#xA;This question is receiving a really negative response. What I was really curious about was indeed how the compiler does those stack allocations. Is there any padding? Is the order always the same as in the source code? Obviously there are differences between implementations and it has nothing to do with the standard, but that doesn't really answer my question.";;added 369 characters in body
111722942;35622441;4191711;5;7c148500-460e-411c-b751-0831c8d091af;2016-02-25 09:28:16.0;"The following snippet is intentionally accessing the next sizeof(int) bytes following t[4], so it is not necessarily a mistake. I am doing this just to see how the stack allocations are being made. &#xD;&#xA;&#xD;&#xA;    int t[5], i;&#xD;&#xA;    &#xD;&#xA;    for (i = 0; i <= 5; i++) {&#xD;&#xA;       t[i] = 0;&#xD;&#xA;    }&#xD;&#xA;When executing this code on a particular Windows PC (using Code::Blocks with a ported version of the GNU C Compiler), it will always gets stuck in an infinite loop. I am pretty sure that this happens because t and i are allocated on the stack one after the other and t[5] points to to the same address as the i variable. Therefore, when executing t[5] = 0 the program actually sets the value of i to 0.&#xD;&#xA;&#xD;&#xA;However, when running this on Linux/Mac I never get the infinite loop. The address of t[5] is not the same as the address of i (I've printed out the addresses).&#xD;&#xA;&#xD;&#xA;My question is, why this different behavior? After all, I think that the the stack allocations should happen in the same way.&#xD;&#xA;&#xD;&#xA;What I am really curious about is how does the compiler do those stack allocations. Is there any padding? Is the order always the same as in the source code? Obviously there are differences between implementations and it has nothing to do with the standard, but I am curious what are the possible outcomes in this particular case.";;deleted 35 characters in body
111723476;35622441;4191711;5;0276fce8-5b33-41d7-a87e-510812056de2;2016-02-25 09:33:35.0;"The following snippet is intentionally accessing the next sizeof(int) bytes following t[4], so it is not necessarily a mistake. I am doing this just to see how the stack allocations are being made. &#xD;&#xA;&#xD;&#xA;    int t[5], i;&#xD;&#xA;    &#xD;&#xA;    for (i = 0; i <= 5; i++) {&#xD;&#xA;       t[i] = 0;&#xD;&#xA;    }&#xD;&#xA;When executing this code on a particular Windows PC (using Code::Blocks with a ported version of the GNU C Compiler), it will always gets stuck in an infinite loop. I am pretty sure that this happens because t and i are allocated on the stack one after the other and t[5] points to to the same address as the i variable. Therefore, when executing t[5] = 0 the program actually sets the value of i to 0.&#xD;&#xA;&#xD;&#xA;However, when compiling this with a different version of the GNU C Compiler, I never get the infinite loop. The address of t[5] is not the same as the address of i (I've printed out the addresses).&#xD;&#xA;&#xD;&#xA;My question is, why this different behavior? Is it not the case that stack allocations should happen in the same way?&#xD;&#xA;&#xD;&#xA;What I am really curious about is how does the compiler do those stack allocations. Is there any padding? Is the order always the same as in the source code? Obviously there are differences between implementations and it has nothing to do with the standard, but I am curious what are the possible outcomes in this particular case.";;deleted 35 characters in body
111724373;35622441;4191711;5;a08ea5ea-4fce-4de8-9c1b-c46b59123f6a;2016-02-25 09:40:34.0;"The following snippet is intentionally accessing the next sizeof(int) bytes following t[4], so it is not necessarily a mistake. I am doing this just to see how the stack allocations are being made. &#xD;&#xA;&#xD;&#xA;    int t[5], i;&#xD;&#xA;    &#xD;&#xA;    for (i = 0; i <= 5; i++) {&#xD;&#xA;       t[i] = 0;&#xD;&#xA;    }&#xD;&#xA;When executing this code on a particular Windows PC (using Code::Blocks with a ported version of the GNU C Compiler), it will always gets stuck in an infinite loop. I am pretty sure that this happens because t and i are allocated on the stack one after the other and t[5] points to to the same address as the i variable. Therefore, when executing t[5] = 0 the program actually sets the value of i to 0.&#xD;&#xA;&#xD;&#xA;However, when compiling this with a different version of the GNU C Compiler, I never get the infinite loop. The address of t[5] is not the same as the address of i (I've printed out the addresses).&#xD;&#xA;&#xD;&#xA;My question is, why this different behavior? I know you should not assume anything about the outcome, but is it not the case that stack allocations should happen in the same way?&#xD;&#xA;&#xD;&#xA;What I am really curious about is how does the compiler do those stack allocations. Is there any padding? Is the order always the same as in the source code? Obviously there are differences between implementations and it has nothing to do with the standard, but I am curious what are the possible outcomes in this particular case.";;edited title
111724565;35622441;4191711;5;80ce059d-fd32-4ea9-bf0b-694aa4d41224;2016-02-25 09:46:07.0;"The following snippet is intentionally accessing the next sizeof(int) bytes following t[4], so it is not necessarily a mistake. I am doing this just to see how the stack allocations are being made. &#xD;&#xA;&#xD;&#xA;    int t[5], i;&#xD;&#xA;    &#xD;&#xA;    for (i = 0; i <= 5; i++) {&#xD;&#xA;       t[i] = 0;&#xD;&#xA;    }&#xD;&#xA;When executing this code on on a Windows PC, using a ported version of the GNU C Compiler, it always gets stuck in an infinite loop. I am sure that this could only happen because t and i are allocated sequentially on the stack one after the other and t[5] points to to the same address as the i variable. Therefore, when executing t[5] = 0 the program actually sets the value of i to 0.&#xD;&#xA;&#xD;&#xA;However, when compiling this with a different version of the GNU C Compiler, I never get the infinite loop. The address of t[5] is not the same as the address of i. I've printed out the addresses.&#xD;&#xA;&#xD;&#xA;My question is, why this different behavior? I know you should not assume anything about the outcome, but is it not the case that stack allocations should happen in the same way?&#xD;&#xA;&#xD;&#xA;What I am really curious about is how does the compiler do those stack allocations. Is there any padding? Is the order always the same as in the source code? Obviously this has nothing to do with the C standard and there are differences between implementations, or even different versions of the same compiler. I am curious what are the possible outcomes and considerations in this particular case.";;edited title
111727035;35622441;4191711;5;63104e6c-4426-4894-bcaa-681cf4c66554;2016-02-25 10:12:32.0;"The following snippet is intentionally accessing the next sizeof(int) bytes following t[4], so it is not necessarily a mistake. I am doing this just to see how the stack allocations are being made. &#xD;&#xA;&#xD;&#xA;    int t[5], i;&#xD;&#xA;    &#xD;&#xA;    for (i = 0; i <= 5; i++) {&#xD;&#xA;       t[i] = 0;&#xD;&#xA;    }&#xD;&#xA;When executing this code on on a Windows PC, using a ported version of the GNU C Compiler, it always gets stuck in an infinite loop. I am sure that this could only happen because t and i are allocated sequentially on the stack one after the other and t[5] points to to the same address as the i variable. Therefore, when executing t[5] = 0 the program actually sets the value of i to 0.&#xD;&#xA;&#xD;&#xA;However, when compiling this with a different version of the GNU C Compiler, I never get the infinite loop. The address of t[5] is not the same as the address of i. I've printed out the addresses.&#xD;&#xA;&#xD;&#xA;My question is, why this different behavior? I know you should not assume anything about the outcome, but is it not the case that stack allocations should happen in the same way?&#xD;&#xA;&#xD;&#xA;What I am really curious about is how does the compiler manage those stack allocations. Is there any padding? Is the order always the same as in the source code? Obviously this has nothing to do with the C standard and there are differences between implementations, or even different versions of the same compiler. I am curious what are the possible outcomes and considerations in this particular case.";;added 4 characters in body
111727751;35622441;4191711;5;b0ee5de7-d14a-4418-a473-4869f97a342f;2016-02-25 10:20:05.0;"The following snippet is intentionally accessing the next sizeof(int) bytes following t[4], so it is not necessarily a mistake. I am doing this just to see how the stack allocations are being made. &#xD;&#xA;&#xD;&#xA;    int t[5], i;&#xD;&#xA;    &#xD;&#xA;    for (i = 0; i <= 5; i++) {&#xD;&#xA;       t[i] = 0;&#xD;&#xA;    }&#xD;&#xA;When executing this code on Windows, using a ported version of the GNU C Compiler, it always gets stuck in an infinite loop. I am sure that this could only happen because t and i are allocated sequentially on the stack one after the other and t[5] points to to the same address as the i variable. Therefore, when executing t[5] = 0 the program actually sets the value of i to 0.&#xD;&#xA;&#xD;&#xA;However, when compiling this with a different version of the GNU C Compiler, I never get the infinite loop. The address of t[5] is not the same as the address of i.&#xD;&#xA;&#xD;&#xA;My question is, why this different behavior? I know you should not assume anything about the outcome, but is it not the case that stack allocations should happen in the same way?&#xD;&#xA;&#xD;&#xA;What I am really curious about is how does the compiler manage those stack allocations. Is there any padding? Is the order always the same as in the source code? Obviously this has nothing to do with the C standard and there are differences between implementations, or even different versions of the same compiler. I am curious what are the possible outcomes and considerations in this particular case.";;deleted 8 characters in body
111731741;35622441;4191711;5;06e0adb9-133d-42f7-997a-380f0c0aaa74;2016-02-25 11:05:41.0;"The following snippet is intentionally accessing the next sizeof(int) bytes following t[4], so I am aware of the mistake being made. I am just doing this as an experiment to see how the stack allocations are being managed. &#xD;&#xA;&#xD;&#xA;    int t[5], i;&#xD;&#xA;    &#xD;&#xA;    for (i = 0; i <= 5; i++) {&#xD;&#xA;       t[i] = 0;&#xD;&#xA;    }&#xD;&#xA;When executing this code on Windows, using a ported version of the GNU C Compiler, it always gets stuck in an infinite loop. I am sure that this could only happen because t and i are allocated sequentially on the stack one after the other and t[5] points to to the same address as the i variable. Therefore, when executing t[5] = 0 the program actually sets the value of i to 0.&#xD;&#xA;&#xD;&#xA;However, when compiling this with a different version of the GNU C Compiler, I never get the infinite loop. The address of t[5] is not the same as the address of i.&#xD;&#xA;&#xD;&#xA;My question is, why this different behavior? I know you should not assume anything about the outcome, but is it not the case that stack allocations should happen in the same way?&#xD;&#xA;&#xD;&#xA;What I am really curious about is how does the compiler manage those stack allocations. Is there any padding? Is the order always the same as in the source code? Obviously this has nothing to do with the C standard and there are differences between implementations, or even different versions of the same compiler. I am curious though what are the possible outcomes and considerations in this particular case.";;added 14 characters in body
111732130;35622441;4191711;5;625d7931-38e5-4a2e-8813-003be0551a74;2016-02-25 11:11:01.0;"The following snippet is intentionally accessing the next sizeof(int) bytes following `t[4]`, so I am aware of the **mistake** that is being made here. I am just doing this as an experiment to see how the compiler handles the stack allocations. &#xD;&#xA;&#xD;&#xA;    int t[5], i;&#xD;&#xA;    &#xD;&#xA;    for (i = 0; i <= 5; i++) {&#xD;&#xA;       t[i] = 0;&#xD;&#xA;    }&#xD;&#xA;When executing this code on Windows, using a ported version of the GNU C Compiler, the program always gets stuck in an infinite loop. I am sure that this could only happen because `t` and `i` are allocated sequentially on the stack one after the other and t[5] points to to the same address as the i variable. Therefore, when executing `t[5] = 0` the program actually sets the value of `i` to zero.&#xD;&#xA;&#xD;&#xA;However, when compiling this with a different version of the GNU C Compiler, I never get the infinite loop. The address of `t[5]` is not the same as the address of `i`.&#xD;&#xA;&#xD;&#xA;My question is, why this different behavior? I know you should not assume anything about the outcome, but is it not the case that stack allocations should happen in the same way?&#xD;&#xA;&#xD;&#xA;What I am really curious about is how does the compiler manage those stack allocations. Is there any padding? Is the order always the same as in the source code? Obviously this has nothing to do with the C standard and there are differences between implementations, or even different versions of the same compiler. I am curious though what are the possible outcomes and considerations in this particular case.";;added 14 characters in body
111734861;35622441;4191711;5;eca3fa95-fe06-4f38-901f-3b569a494fe4;2016-02-25 11:41:20.0;"The following snippet is intentionally accessing the next sizeof(int) bytes following `t[4]`, so I am aware of the **mistake** that is being made here. I am just doing this as an experiment to see how the compiler handles the stack allocations. &#xD;&#xA;&#xD;&#xA;    int t[5], i;&#xD;&#xA;    &#xD;&#xA;    for (i = 0; i <= 5; i++) {&#xD;&#xA;       t[i] = 0;&#xD;&#xA;    }&#xD;&#xA;When executing this code on Windows, using a ported version of the GNU C Compiler, the program always gets stuck in an infinite loop. I am sure that this could only happen because `t` and `i` are allocated sequentially on the stack one after the other and `t[5]` points to to the same address as the i variable. Therefore, when executing `t[5] = 0` the program actually sets the value of `i` to zero.&#xD;&#xA;&#xD;&#xA;However, when compiling this with a different version of the GNU C Compiler, I never get the infinite loop. The address of `t[5]` is not the same as the address of `i`.&#xD;&#xA;&#xD;&#xA;My question is, why this different behavior? I know you should not assume anything about the outcome, but is it not the case that stack allocations should happen in the same way?&#xD;&#xA;&#xD;&#xA;What I am really curious about is how does the compiler manage those stack allocations. Is there any padding? Is the order always the same as in the source code? Obviously this has nothing to do with the C standard and there are differences between implementations, or even different versions of the same compiler. I am curious though what are the possible outcomes and considerations in this particular case.";;added 2 characters in body
111735749;35622441;4191711;5;2a39e202-2a21-48b4-a7bf-1fbd616cb32e;2016-02-25 11:51:46.0;"The following snippet is intentionally accessing the next sizeof(int) bytes following `t[4]`, so I am aware of the **mistake** that is being made here. I am just doing this as an experiment to see how the compiler handles the stack allocations. &#xD;&#xA;&#xD;&#xA;    int t[5], i;&#xD;&#xA;    &#xD;&#xA;    for (i = 0; i <= 5; i++) {&#xD;&#xA;       t[i] = 0;&#xD;&#xA;    }&#xD;&#xA;When executing this code on Windows, using a ported version of the GNU C Compiler, the program always gets stuck in an infinite loop. I am sure that this could only happen because `t` and `i` are allocated sequentially on the stack one after the other and `t[5]` points to to the same address as the `i` variable. Therefore, when executing `t[5] = 0` the program actually sets the value of `i` to zero.&#xD;&#xA;&#xD;&#xA;However, when compiling this with a different version of the GNU C Compiler, I never get the infinite loop. The address of `t[5]` is not the same as the address of `i`.&#xD;&#xA;&#xD;&#xA;My question is, why this different behavior? I know you should not assume anything about the outcome of this, but is it not the case that stack allocations should happen in the same way?&#xD;&#xA;&#xD;&#xA;What I am really curious about is how does the compiler manage those stack allocations. Is there any padding? Is the order always the same as in the source code? Obviously this has nothing to do with the C standard and there are differences between implementations, or even different versions of the same compiler. I am curious though what are the possible outcomes and considerations in this particular case.";;added 2 characters in body
