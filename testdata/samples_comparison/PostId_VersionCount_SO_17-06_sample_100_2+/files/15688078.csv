Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
38227694;15688078;649810;2;bc642ad2-f03c-4f0d-823c-50162b516fce;2013-03-28 17:14:36.0;"I wanted to receive data from different clients(Number of clients is fixed,say 10) ,And each of the clients send data on 5 different predefined ports which wont change.(example, client 1 ports 5000,5001,5002,etc).All the clients can send data simultaneously. &#xD;&#xA;(All the above are fixed)&#xD;&#xA;In TCP, i can create multiple threads for each of the connection we accept ,like the below. UDP is connectionless,So how can we create one thread per UDP client(UDP port) to handle the concurrent data?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;        //Accept and incoming connection&#xD;&#xA;    	puts(""Waiting for incoming connections..."");&#xD;&#xA;    	c = sizeof(struct sockaddr_in);&#xD;&#xA;    	while( (client_sock = accept(socket_desc, (struct sockaddr *)&client, (socklen_t*)&c)) )&#xD;&#xA;    	{&#xD;&#xA;    		puts(""Connection accepted"");&#xD;&#xA;    		&#xD;&#xA;    		pthread_t sniffer_thread;&#xD;&#xA;    		new_sock = malloc(1);&#xD;&#xA;    		*new_sock = client_sock;&#xD;&#xA;    		&#xD;&#xA;    		if( pthread_create( &sniffer_thread , NULL ,  connection_handler , (void*) new_sock) < 0)&#xD;&#xA;    		{&#xD;&#xA;    			perror(""could not create thread"");&#xD;&#xA;    			return 1;&#xD;&#xA;    		}&#xD;&#xA;    		&#xD;&#xA;    		//Now join the thread , so that we dont terminate before the thread&#xD;&#xA;    		//pthread_join( sniffer_thread , NULL);&#xD;&#xA;    		puts(""Handler assigned"");&#xD;&#xA;    	}&#xD;&#xA;    //end of TCP&#xD;&#xA;//UDP Server&#xD;&#xA;&#xD;&#xA;    #include <arpa/inet.h>&#xD;&#xA;    #include <netinet/in.h>&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    #include <string.h>&#xD;&#xA;    #include <sys/types.h>&#xD;&#xA;    #include <sys/socket.h>&#xD;&#xA;    #include <unistd.h>&#xD;&#xA;    &#xD;&#xA;    #define BUFLEN 512&#xD;&#xA;    &#xD;&#xA;    #define CLIENT1_PORT1 5000&#xD;&#xA;    #define CLIENT1_PORT2 5001&#xD;&#xA;    #define CLIENT1_PORT3 5002&#xD;&#xA;    &#xD;&#xA;    #define CLIENT2_PORT1 5050&#xD;&#xA;    #define CLIENT2_PORT2 5051&#xD;&#xA;    #define CLIENT2_PORT3 5052	&#xD;&#xA;    &#xD;&#xA;    #define CLIENT3_PORT1 6000&#xD;&#xA;    #define CLIENT3_PORT2 6001&#xD;&#xA;    #define CLIENT3_PORT3 6002&#xD;&#xA;    &#xD;&#xA;    void diep(char *s) {&#xD;&#xA;      perror(s);&#xD;&#xA;      exit(1);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;      struct sockaddr_in client1_sockaddr_1, client1_sockaddr_2,client2_sockaddr_1,client2_sockaddr_2, si_other;&#xD;&#xA;      int c1_sockfd_1,c1_sockfd_2, c2_sockfd_1,c2_sockfd_2, i, slen = sizeof(si_other);&#xD;&#xA;    &#xD;&#xA;      char buf[BUFLEN];&#xD;&#xA;      //for client 1 port1&#xD;&#xA;      if((c1_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;    &#xD;&#xA;      memset((char *) &client1_sockaddr_1, 0, sizeof(client1_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client1_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client1_sockaddr_1.sin_port = htons(CLIENT1_PORT1);&#xD;&#xA;      client1_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_1, (struct sockaddr *) &client1_sockaddr_1, sizeof(client1_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;      if((c2_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;      //for client 2 port1&#xD;&#xA;      memset((char *) &client2_sockaddr_1, 0, sizeof(client2_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client2_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client2_sockaddr_1.sin_port = htons(CLIENT2_PORT1);&#xD;&#xA;      client2_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_2, (struct sockaddr *) &client2_sockaddr_1, sizeof(client2_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;    //Receive from clients&#xD;&#xA;    while(1) {&#xD;&#xA;      if(recvfrom(c1_sockfd_1, buf, BUFLEN, 0, (struct sockaddr *) &si_other, &slen) == -1)&#xD;&#xA;          diep(""recvfrom()"");&#xD;&#xA;    &#xD;&#xA;        printf(""Recieved packet from %s: %d\\nData: %s\\n\\n"", inet_ntoa(si_other.sin_addr), ntohs(si_other.sin_port), buf);&#xD;&#xA;      }&#xD;&#xA;      close(c1_sockfd_1);&#xD;&#xA;      return 0;&#xD;&#xA;    }&#xD;&#xA;";;
38228010;15688078;649810;5;e10dfe47-d8af-47f9-8aae-5f2ed424828d;2013-03-28 17:20:02.0;"I wanted to receive data from different clients(Number of clients is fixed,say 10) ,And each of the clients send data on 5 different predefined ports which wont change.(example, client 1 ports 5000,5001,5002,etc).All the clients can send data simultaneously. &#xD;&#xA;(All the above are fixed)&#xD;&#xA;&#xD;&#xA;In TCP, i can create multiple threads,one for each of the connection we accept ,like the below. UDP is connectionless,So how can we create one thread per UDP client(UDP port) to handle the concurrent data?Like each thread having a receivefrom() function to get data.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;        //Accept and incoming connection&#xD;&#xA;    	puts(""Waiting for incoming connections..."");&#xD;&#xA;    	c = sizeof(struct sockaddr_in);&#xD;&#xA;    	while( (client_sock = accept(socket_desc, (struct sockaddr *)&client, (socklen_t*)&c)) )&#xD;&#xA;    	{&#xD;&#xA;    		puts(""Connection accepted"");&#xD;&#xA;    		&#xD;&#xA;    		pthread_t sniffer_thread;&#xD;&#xA;    		new_sock = malloc(1);&#xD;&#xA;    		*new_sock = client_sock;&#xD;&#xA;    		&#xD;&#xA;    		if( pthread_create( &sniffer_thread , NULL ,  connection_handler , (void*) new_sock) < 0)&#xD;&#xA;    		{&#xD;&#xA;    			perror(""could not create thread"");&#xD;&#xA;    			return 1;&#xD;&#xA;    		}&#xD;&#xA;    		&#xD;&#xA;    		//Now join the thread , so that we dont terminate before the thread&#xD;&#xA;    		//pthread_join( sniffer_thread , NULL);&#xD;&#xA;    		puts(""Handler assigned"");&#xD;&#xA;    	}&#xD;&#xA;    //end of TCP&#xD;&#xA;//UDP Server&#xD;&#xA;&#xD;&#xA;    #include <arpa/inet.h>&#xD;&#xA;    #include <netinet/in.h>&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    #include <string.h>&#xD;&#xA;    #include <sys/types.h>&#xD;&#xA;    #include <sys/socket.h>&#xD;&#xA;    #include <unistd.h>&#xD;&#xA;    &#xD;&#xA;    #define BUFLEN 512&#xD;&#xA;    &#xD;&#xA;    #define CLIENT1_PORT1 5000&#xD;&#xA;    #define CLIENT1_PORT2 5001&#xD;&#xA;    #define CLIENT1_PORT3 5002&#xD;&#xA;    &#xD;&#xA;    #define CLIENT2_PORT1 5050&#xD;&#xA;    #define CLIENT2_PORT2 5051&#xD;&#xA;    #define CLIENT2_PORT3 5052	&#xD;&#xA;    &#xD;&#xA;    #define CLIENT3_PORT1 6000&#xD;&#xA;    #define CLIENT3_PORT2 6001&#xD;&#xA;    #define CLIENT3_PORT3 6002&#xD;&#xA;    &#xD;&#xA;    void diep(char *s) {&#xD;&#xA;      perror(s);&#xD;&#xA;      exit(1);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;      struct sockaddr_in client1_sockaddr_1, client1_sockaddr_2,client2_sockaddr_1,client2_sockaddr_2, si_other;&#xD;&#xA;      int c1_sockfd_1,c1_sockfd_2, c2_sockfd_1,c2_sockfd_2, i, slen = sizeof(si_other);&#xD;&#xA;    &#xD;&#xA;      char buf[BUFLEN];&#xD;&#xA;      //for client 1 port1&#xD;&#xA;      if((c1_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;    &#xD;&#xA;      memset((char *) &client1_sockaddr_1, 0, sizeof(client1_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client1_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client1_sockaddr_1.sin_port = htons(CLIENT1_PORT1);&#xD;&#xA;      client1_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_1, (struct sockaddr *) &client1_sockaddr_1, sizeof(client1_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;      if((c2_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;      //for client 2 port1&#xD;&#xA;      memset((char *) &client2_sockaddr_1, 0, sizeof(client2_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client2_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client2_sockaddr_1.sin_port = htons(CLIENT2_PORT1);&#xD;&#xA;      client2_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_2, (struct sockaddr *) &client2_sockaddr_1, sizeof(client2_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;    //Receive from clients&#xD;&#xA;    while(1) {&#xD;&#xA;      if(recvfrom(c1_sockfd_1, buf, BUFLEN, 0, (struct sockaddr *) &si_other, &slen) == -1)&#xD;&#xA;          diep(""recvfrom()"");&#xD;&#xA;    &#xD;&#xA;        printf(""Recieved packet from %s: %d\\nData: %s\\n\\n"", inet_ntoa(si_other.sin_addr), ntohs(si_other.sin_port), buf);&#xD;&#xA;      }&#xD;&#xA;      close(c1_sockfd_1);&#xD;&#xA;      return 0;&#xD;&#xA;    }&#xD;&#xA;";;added 69 characters in body
38228583;15688078;649810;5;05d9f6b8-c9f6-4f4c-83c5-6bdcea0457b4;2013-03-28 17:29:19.0;"I wanted to receive data from different clients(Number of clients is fixed,say 10) ,And each of the clients send data on 5 different predefined ports which wont change.(example, client 1 ports 5000,5001,5002,etc).All the clients can send data simultaneously. &#xD;&#xA;(All the above are fixed)&#xD;&#xA;&#xD;&#xA;In TCP, i can create multiple threads,one for each of the connection we accept ,like the below. UDP is connectionless,So how can we create one thread per UDP client(UDP port) to handle the concurrent data?Like each thread having a receivefrom() function to get data.&#xD;&#xA;&#xD;&#xA;         //TCP sample code start&#xD;&#xA;        //Accept and incoming connection&#xD;&#xA;    	puts(""Waiting for incoming connections..."");&#xD;&#xA;    	c = sizeof(struct sockaddr_in);&#xD;&#xA;    	while( (client_sock = accept(socket_desc, (struct sockaddr *)&client, (socklen_t*)&c)) )&#xD;&#xA;    	{&#xD;&#xA;    		puts(""Connection accepted"");&#xD;&#xA;    		&#xD;&#xA;    		pthread_t sniffer_thread;&#xD;&#xA;    		new_sock = malloc(1);&#xD;&#xA;    		*new_sock = client_sock;&#xD;&#xA;    		&#xD;&#xA;    		if( pthread_create( &sniffer_thread , NULL ,  connection_handler , (void*) new_sock) < 0)&#xD;&#xA;    		{&#xD;&#xA;    			perror(""could not create thread"");&#xD;&#xA;    			return 1;&#xD;&#xA;    		}&#xD;&#xA;    		&#xD;&#xA;    		//Now join the thread , so that we dont terminate before the thread&#xD;&#xA;    		//pthread_join( sniffer_thread , NULL);&#xD;&#xA;    		puts(""Handler assigned"");&#xD;&#xA;    	}&#xD;&#xA;    //end of TCP&#xD;&#xA;&#xD;&#xA;//UDP Server&#xD;&#xA;&#xD;&#xA;    #include <arpa/inet.h>&#xD;&#xA;    #include <netinet/in.h>&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    #include <string.h>&#xD;&#xA;    #include <sys/types.h>&#xD;&#xA;    #include <sys/socket.h>&#xD;&#xA;    #include <unistd.h>&#xD;&#xA;    &#xD;&#xA;    #define BUFLEN 512&#xD;&#xA;    &#xD;&#xA;    #define CLIENT1_PORT1 5000&#xD;&#xA;    #define CLIENT1_PORT2 5001&#xD;&#xA;    #define CLIENT1_PORT3 5002&#xD;&#xA;    &#xD;&#xA;    #define CLIENT2_PORT1 5050&#xD;&#xA;    #define CLIENT2_PORT2 5051&#xD;&#xA;    #define CLIENT2_PORT3 5052	&#xD;&#xA;    &#xD;&#xA;    #define CLIENT3_PORT1 6000&#xD;&#xA;    #define CLIENT3_PORT2 6001&#xD;&#xA;    #define CLIENT3_PORT3 6002&#xD;&#xA;    &#xD;&#xA;    void diep(char *s) {&#xD;&#xA;      perror(s);&#xD;&#xA;      exit(1);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;      struct sockaddr_in client1_sockaddr_1, client1_sockaddr_2,client2_sockaddr_1,client2_sockaddr_2, si_other;&#xD;&#xA;      int c1_sockfd_1,c1_sockfd_2, c2_sockfd_1,c2_sockfd_2, i, slen = sizeof(si_other);&#xD;&#xA;    &#xD;&#xA;      char buf[BUFLEN];&#xD;&#xA;      //for client 1 port1&#xD;&#xA;      if((c1_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;    &#xD;&#xA;      memset((char *) &client1_sockaddr_1, 0, sizeof(client1_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client1_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client1_sockaddr_1.sin_port = htons(CLIENT1_PORT1);&#xD;&#xA;      client1_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_1, (struct sockaddr *) &client1_sockaddr_1, sizeof(client1_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;      if((c2_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;      //for client 2 port1&#xD;&#xA;      memset((char *) &client2_sockaddr_1, 0, sizeof(client2_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client2_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client2_sockaddr_1.sin_port = htons(CLIENT2_PORT1);&#xD;&#xA;      client2_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_2, (struct sockaddr *) &client2_sockaddr_1, sizeof(client2_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;    //Receive from clients&#xD;&#xA;    while(1) {&#xD;&#xA;      if(recvfrom(c1_sockfd_1, buf, BUFLEN, 0, (struct sockaddr *) &si_other, &slen) == -1)&#xD;&#xA;          diep(""recvfrom()"");&#xD;&#xA;    &#xD;&#xA;        printf(""Recieved packet from %s: %d\\nData: %s\\n\\n"", inet_ntoa(si_other.sin_addr), ntohs(si_other.sin_port), buf);&#xD;&#xA;      }&#xD;&#xA;      close(c1_sockfd_1);&#xD;&#xA;      return 0;&#xD;&#xA;    }&#xD;&#xA;";;minor changes
38230606;15688078;649810;5;204ce089-ad35-4c23-a5b3-7609424eeb47;2013-03-28 18:07:02.0;"I wanted to receive data from different clients(Number of clients is fixed,say 10) ,And each of the clients send data on 5 different predefined ports which wont change.(example, client 1 ports 5000,5001,5002,etc).All the clients can send data simultaneously. &#xD;&#xA;(All the above are fixed)&#xD;&#xA;&#xD;&#xA;In TCP, i can create multiple threads,one for each of the connection we accept ,like the below. UDP is connectionless,So how can we create one thread per UDP client(UDP port) to handle the concurrent data?Like each thread having a receivefrom() function to get data.&#xD;&#xA;&#xD;&#xA;         //TCP sample code start&#xD;&#xA;        //Accept and incoming connection&#xD;&#xA;    	puts(""Waiting for incoming connections..."");&#xD;&#xA;    	c = sizeof(struct sockaddr_in);&#xD;&#xA;    	while( (client_sock = accept(socket_desc, (struct sockaddr *)&client, (socklen_t*)&c)) )&#xD;&#xA;    	{&#xD;&#xA;    		puts(""Connection accepted"");&#xD;&#xA;    		&#xD;&#xA;    		pthread_t sniffer_thread;&#xD;&#xA;    		new_sock = malloc(1);&#xD;&#xA;    		*new_sock = client_sock;&#xD;&#xA;    		&#xD;&#xA;    		if( pthread_create( &sniffer_thread , NULL ,  connection_handler , (void*) new_sock) < 0)&#xD;&#xA;    		{&#xD;&#xA;    			perror(""could not create thread"");&#xD;&#xA;    			return 1;&#xD;&#xA;    		}&#xD;&#xA;    		&#xD;&#xA;    		//Now join the thread , so that we dont terminate before the thread&#xD;&#xA;    		//pthread_join( sniffer_thread , NULL);&#xD;&#xA;    		puts(""Handler assigned"");&#xD;&#xA;    	}&#xD;&#xA;    //end of TCP&#xD;&#xA;&#xD;&#xA;//UDP Server&#xD;&#xA;&#xD;&#xA;    #include <arpa/inet.h>&#xD;&#xA;    #include <netinet/in.h>&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    #include <string.h>&#xD;&#xA;    #include <sys/types.h>&#xD;&#xA;    #include <sys/socket.h>&#xD;&#xA;    #include <unistd.h>&#xD;&#xA;    &#xD;&#xA;    #define BUFLEN 512&#xD;&#xA;    &#xD;&#xA;    #define CLIENT1_PORT1 5000&#xD;&#xA;    #define CLIENT1_PORT2 5001&#xD;&#xA;    #define CLIENT1_PORT3 5002&#xD;&#xA;    &#xD;&#xA;    #define CLIENT2_PORT1 5050&#xD;&#xA;    #define CLIENT2_PORT2 5051&#xD;&#xA;    #define CLIENT2_PORT3 5052	&#xD;&#xA;    &#xD;&#xA;    #define CLIENT3_PORT1 6000&#xD;&#xA;    #define CLIENT3_PORT2 6001&#xD;&#xA;    #define CLIENT3_PORT3 6002&#xD;&#xA;    &#xD;&#xA;    void diep(char *s) {&#xD;&#xA;      perror(s);&#xD;&#xA;      exit(1);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;      struct sockaddr_in client1_sockaddr_1, client1_sockaddr_2,client2_sockaddr_1,client2_sockaddr_2, si_other;&#xD;&#xA;      int c1_sockfd_1,c1_sockfd_2, c2_sockfd_1,c2_sockfd_2, i, slen = sizeof(si_other);&#xD;&#xA;    &#xD;&#xA;      char buf[BUFLEN];&#xD;&#xA;      //for client 1 port1&#xD;&#xA;      if((c1_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;    &#xD;&#xA;      memset((char *) &client1_sockaddr_1, 0, sizeof(client1_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client1_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client1_sockaddr_1.sin_port = htons(CLIENT1_PORT1);&#xD;&#xA;      client1_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_1, (struct sockaddr *) &client1_sockaddr_1, sizeof(client1_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;      if((c2_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;      //for client 2 port1&#xD;&#xA;      memset((char *) &client2_sockaddr_1, 0, sizeof(client2_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client2_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client2_sockaddr_1.sin_port = htons(CLIENT2_PORT1);&#xD;&#xA;      client2_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_2, (struct sockaddr *) &client2_sockaddr_1, sizeof(client2_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;    //Receive from clients&#xD;&#xA;    while(1) {&#xD;&#xA;&#xD;&#xA;      //How to create threads at this point and have a separate recvfrom for each client port ??&#xD;&#xA;      if(recvfrom(c1_sockfd_1, buf, BUFLEN, 0, (struct sockaddr *) &si_other, &slen) == -1)&#xD;&#xA;          diep(""recvfrom()"");&#xD;&#xA;    &#xD;&#xA;        printf(""Recieved packet from %s: %d\\nData: %s\\n\\n"", inet_ntoa(si_other.sin_addr), ntohs(si_other.sin_port), buf);&#xD;&#xA;      }&#xD;&#xA;      close(c1_sockfd_1);&#xD;&#xA;      return 0;&#xD;&#xA;    }&#xD;&#xA;";;added 100 characters in body
38248781;15688078;649810;5;a1a28b14-569d-49b8-99ed-8942722adfb1;2013-03-29 02:26:25.0;"I wanted to receive data from different clients(Number of clients is fixed,say 10) ,And each of the clients send data on 5 different predefined ports which wont change.(example, client 1 ports 5000,5001,5002,etc).All the clients can send data simultaneously. &#xD;&#xA;(All the above are fixed)&#xD;&#xA;&#xD;&#xA;Say in TCP, i can create multiple threads,one for each of the connection we accept ,like the below. **UDP is connectionless,So how can we create one thread per UDP client(UDP port) to handle the concurrent data?Like each thread having a receivefrom() function to get data.**&#xD;&#xA;&#xD;&#xA;//UDP Server&#xD;&#xA;&#xD;&#xA;    #include <arpa/inet.h>&#xD;&#xA;    #include <netinet/in.h>&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    #include <string.h>&#xD;&#xA;    #include <sys/types.h>&#xD;&#xA;    #include <sys/socket.h>&#xD;&#xA;    #include <unistd.h>&#xD;&#xA;    &#xD;&#xA;    #define BUFLEN 512&#xD;&#xA;    &#xD;&#xA;    #define CLIENT1_PORT1 5000&#xD;&#xA;    #define CLIENT1_PORT2 5001&#xD;&#xA;    #define CLIENT1_PORT3 5002&#xD;&#xA;    &#xD;&#xA;    #define CLIENT2_PORT1 5050&#xD;&#xA;    #define CLIENT2_PORT2 5051&#xD;&#xA;    #define CLIENT2_PORT3 5052	&#xD;&#xA;    &#xD;&#xA;    #define CLIENT3_PORT1 6000&#xD;&#xA;    #define CLIENT3_PORT2 6001&#xD;&#xA;    #define CLIENT3_PORT3 6002&#xD;&#xA;    &#xD;&#xA;    void diep(char *s) {&#xD;&#xA;      perror(s);&#xD;&#xA;      exit(1);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;      struct sockaddr_in client1_sockaddr_1, client1_sockaddr_2,client2_sockaddr_1,client2_sockaddr_2, si_other;&#xD;&#xA;      int c1_sockfd_1,c1_sockfd_2, c2_sockfd_1,c2_sockfd_2, i, slen = sizeof(si_other);&#xD;&#xA;    &#xD;&#xA;      char buf[BUFLEN];&#xD;&#xA;&#xD;&#xA;      /******for client 1 port1 **********/&#xD;&#xA;      if((c1_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;    &#xD;&#xA;      memset((char *) &client1_sockaddr_1, 0, sizeof(client1_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client1_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client1_sockaddr_1.sin_port = htons(CLIENT1_PORT1);&#xD;&#xA;      client1_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_1, (struct sockaddr *) &client1_sockaddr_1, sizeof(client1_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;      if((c2_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;&#xD;&#xA;      /*******for client 2 port1 *******/&#xD;&#xA;      memset((char *) &client2_sockaddr_1, 0, sizeof(client2_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client2_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client2_sockaddr_1.sin_port = htons(CLIENT2_PORT1);&#xD;&#xA;      client2_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_2, (struct sockaddr *) &client2_sockaddr_1, sizeof(client2_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;    //Receive from clients&#xD;&#xA;    while(1) {&#xD;&#xA;&#xD;&#xA;      /*How to create threads at this point and have a separate recvfrom for each client port ??*/&#xD;&#xA;      if(recvfrom(c1_sockfd_1, buf, BUFLEN, 0, (struct sockaddr *) &si_other, &slen) == -1)&#xD;&#xA;          diep(""recvfrom()"");&#xD;&#xA;    &#xD;&#xA;        printf(""Recieved packet from %s: %d\\nData: %s\\n\\n"", inet_ntoa(si_other.sin_addr), ntohs(si_other.sin_port), buf);&#xD;&#xA;      }&#xD;&#xA;      close(c1_sockfd_1);&#xD;&#xA;      return 0;&#xD;&#xA;    }&#xD;&#xA;";;deleted 735 characters in body
38301417;15688078;649810;5;4ca3f5d8-ec29-4f70-8bee-d22659a4a32f;2013-03-30 06:32:05.0;"I wanted to receive data from different clients(Number of clients is fixed,say 10) ,And each of the clients send data on 5 different predefined ports which wont change.(example, client 1 ports 5000,5001,5002,etc).All the clients can send data simultaneously. &#xD;&#xA;(All the above are fixed)&#xD;&#xA;&#xD;&#xA;Say in TCP, i can create multiple threads,one for each of the connection we accept ,like the below. **UDP is connectionless,So how can we create one thread per UDP client(UDP port) to handle the concurrent data?Like each thread having a receivefrom() function to get data.**&#xD;&#xA;&#xD;&#xA;//UDP Server&#xD;&#xA; &#xD;&#xA;    &#xD;&#xA;    #define BUFLEN 512&#xD;&#xA;    &#xD;&#xA;    #define CLIENT1_PORT1 5000&#xD;&#xA;    #define CLIENT1_PORT2 5001&#xD;&#xA;    #define CLIENT1_PORT3 5002&#xD;&#xA;    &#xD;&#xA;    #define CLIENT2_PORT1 5050&#xD;&#xA;    #define CLIENT2_PORT2 5051&#xD;&#xA;    #define CLIENT2_PORT3 5052	&#xD;&#xA;    &#xD;&#xA;    #define CLIENT3_PORT1 6000&#xD;&#xA;    #define CLIENT3_PORT2 6001&#xD;&#xA;    #define CLIENT3_PORT3 6002&#xD;&#xA;    &#xD;&#xA;    void diep(char *s) {&#xD;&#xA;      perror(s);&#xD;&#xA;      exit(1);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;      struct sockaddr_in client1_sockaddr_1, client1_sockaddr_2,client2_sockaddr_1,client2_sockaddr_2, si_other;&#xD;&#xA;      int c1_sockfd_1,c1_sockfd_2, c2_sockfd_1,c2_sockfd_2, i, slen = sizeof(si_other);&#xD;&#xA;    &#xD;&#xA;      char buf[BUFLEN];&#xD;&#xA;&#xD;&#xA;      /******for client 1 port1 **********/&#xD;&#xA;      if((c1_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;    &#xD;&#xA;      memset((char *) &client1_sockaddr_1, 0, sizeof(client1_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client1_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client1_sockaddr_1.sin_port = htons(CLIENT1_PORT1);&#xD;&#xA;      client1_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_1, (struct sockaddr *) &client1_sockaddr_1, sizeof(client1_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;      if((c2_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;&#xD;&#xA;      /*******for client 2 port1 *******/&#xD;&#xA;      memset((char *) &client2_sockaddr_1, 0, sizeof(client2_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client2_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client2_sockaddr_1.sin_port = htons(CLIENT2_PORT1);&#xD;&#xA;      client2_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_2, (struct sockaddr *) &client2_sockaddr_1, sizeof(client2_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;    //Receive from clients&#xD;&#xA;    while(1) {&#xD;&#xA;&#xD;&#xA;      /*How to create threads at this point and have a separate recvfrom for each client port ??*/&#xD;&#xA;      if(recvfrom(c1_sockfd_1, buf, BUFLEN, 0, (struct sockaddr *) &si_other, &slen) == -1)&#xD;&#xA;          diep(""recvfrom()"");&#xD;&#xA;    &#xD;&#xA;        printf(""Recieved packet from %s: %d\\nData: %s\\n\\n"", inet_ntoa(si_other.sin_addr), ntohs(si_other.sin_port), buf);&#xD;&#xA;      }&#xD;&#xA;      close(c1_sockfd_1);&#xD;&#xA;      return 0;&#xD;&#xA;    }&#xD;&#xA;";;deleted 212 characters in body
38339998;15688078;649810;5;c02fca84-b77b-4177-80f6-55db961f57bd;2013-03-31 07:46:54.0;"I wanted to receive data from different clients(Number of clients is fixed,say 10) ,And each of the clients send data on 5 different predefined ports which wont change.(example, client 1 ports 5000,5001,5002,etc).All the clients can send data simultaneously. &#xD;&#xA;(All the above are fixed)&#xD;&#xA;&#xD;&#xA;Say in TCP, i can create multiple threads,one for each of the connection we accept ,like the below. **UDP is connectionless,So how can we create one thread per UDP client(UDP port) to handle the concurrent data?Like each thread having a receivefrom() function to get data.**&#xD;&#xA;&#xD;&#xA;//UDP Server&#xD;&#xA; &#xD;&#xA;    &#xD;&#xA;    #define BUFLEN 512&#xD;&#xA;    &#xD;&#xA;    #define CLIENT1_PORT1 5000&#xD;&#xA;    #define CLIENT1_PORT2 5001&#xD;&#xA;    #define CLIENT1_PORT3 5002&#xD;&#xA;    &#xD;&#xA;    #define CLIENT2_PORT1 5050&#xD;&#xA;    #define CLIENT2_PORT2 5051&#xD;&#xA;    #define CLIENT2_PORT3 5052	&#xD;&#xA;    &#xD;&#xA;    #define CLIENT3_PORT1 6000&#xD;&#xA;    #define CLIENT3_PORT2 6001&#xD;&#xA;    #define CLIENT3_PORT3 6002&#xD;&#xA;    &#xD;&#xA;    void diep(char *s) {&#xD;&#xA;      perror(s);&#xD;&#xA;      exit(1);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;      struct sockaddr_in client1_sockaddr_1, client1_sockaddr_2,client2_sockaddr_1,client2_sockaddr_2, si_other;&#xD;&#xA;      int c1_sockfd_1,c1_sockfd_2, c2_sockfd_1,c2_sockfd_2, i, slen = sizeof(si_other);&#xD;&#xA;    &#xD;&#xA;      char buf[BUFLEN];&#xD;&#xA;&#xD;&#xA;      /******for client 1 port1 **********/&#xD;&#xA;      if((c1_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;    &#xD;&#xA;      memset((char *) &client1_sockaddr_1, 0, sizeof(client1_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client1_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client1_sockaddr_1.sin_port = htons(CLIENT1_PORT1);&#xD;&#xA;      client1_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_1, (struct sockaddr *) &client1_sockaddr_1, sizeof(client1_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;      if((c2_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;&#xD;&#xA;      /*******for client 2 port1 *******/&#xD;&#xA;      memset((char *) &client2_sockaddr_1, 0, sizeof(client2_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client2_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client2_sockaddr_1.sin_port = htons(CLIENT2_PORT1);&#xD;&#xA;      client2_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_2, (struct sockaddr *) &client2_sockaddr_1, sizeof(client2_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;    //Receive from clients&#xD;&#xA;    while(1) {&#xD;&#xA;&#xD;&#xA;      /*How to create threads at this point and have a separate recvfrom for each client port ??*/&#xD;&#xA;      if(recvfrom(c1_sockfd_1, buf, BUFLEN, 0, (struct sockaddr *) &si_other, &slen) == -1)&#xD;&#xA;          diep(""recvfrom()"");&#xD;&#xA;    &#xD;&#xA;        printf(""Recieved packet from %s: %d\\nData: %s\\n\\n"", inet_ntoa(si_other.sin_addr), ntohs(si_other.sin_port), buf);&#xD;&#xA;      }&#xD;&#xA;      close(c1_sockfd_1);&#xD;&#xA;      return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Update:&#xD;&#xA;I have like 5 ports per client, totally 5 * 10 sockets and data will be sent in time gaps of few milliseconds simultaneously.Here packets received on each port are of different sizes. The packets are sent with Header and CRC. Is it a good idea to have packet numbers inorder to track and rerequest the lost packets ?&#xD;&#xA;";;added 329 characters in body
38560774;15688078;649810;5;6961c90f-7c7c-484e-a5f5-5d36f24fcaa5;2013-04-04 10:28:52.0;"I wanted to receive data from different clients(Number of clients is fixed,say 10) ,And each of the clients send data on 5 different predefined ports which wont change.(example, client 1 ports 5000,5001,5002,etc).All the clients can send data simultaneously. &#xD;&#xA;(All the above are fixed)&#xD;&#xA;&#xD;&#xA;Say in TCP, i can create multiple threads,one for each of the connection we accept ,like the below. **UDP is connectionless,So how can we create one thread per UDP client(UDP port) to handle the concurrent data?Like each thread having a receivefrom() function to get data.**&#xD;&#xA;&#xD;&#xA;//UDP Server&#xD;&#xA; &#xD;&#xA;    &#xD;&#xA;    #define BUFLEN 512&#xD;&#xA;    &#xD;&#xA;    #define CLIENT1_PORT1 5000&#xD;&#xA;    #define CLIENT1_PORT2 5001&#xD;&#xA;    #define CLIENT1_PORT3 5002&#xD;&#xA;    &#xD;&#xA;    #define CLIENT2_PORT1 5050&#xD;&#xA;    #define CLIENT2_PORT2 5051&#xD;&#xA;    #define CLIENT2_PORT3 5052	&#xD;&#xA;    &#xD;&#xA;    #define CLIENT3_PORT1 6000&#xD;&#xA;    #define CLIENT3_PORT2 6001&#xD;&#xA;    #define CLIENT3_PORT3 6002&#xD;&#xA;    &#xD;&#xA;    void diep(char *s) {&#xD;&#xA;      perror(s);&#xD;&#xA;      exit(1);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;      struct sockaddr_in client1_sockaddr_1, client1_sockaddr_2,client2_sockaddr_1,client2_sockaddr_2, si_other;&#xD;&#xA;      int c1_sockfd_1,c1_sockfd_2, c2_sockfd_1,c2_sockfd_2, i, slen = sizeof(si_other);&#xD;&#xA;    &#xD;&#xA;      char buf[BUFLEN];&#xD;&#xA;&#xD;&#xA;      /******for client 1 port1 **********/&#xD;&#xA;      if((c1_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;    &#xD;&#xA;      memset((char *) &client1_sockaddr_1, 0, sizeof(client1_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client1_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client1_sockaddr_1.sin_port = htons(CLIENT1_PORT1);&#xD;&#xA;      client1_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_1, (struct sockaddr *) &client1_sockaddr_1, sizeof(client1_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;      if((c2_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;&#xD;&#xA;      /*******for client 2 port1 *******/&#xD;&#xA;      memset((char *) &client2_sockaddr_1, 0, sizeof(client2_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client2_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client2_sockaddr_1.sin_port = htons(CLIENT2_PORT1);&#xD;&#xA;      client2_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_2, (struct sockaddr *) &client2_sockaddr_1, sizeof(client2_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;    //Receive from clients&#xD;&#xA;    while(1) {&#xD;&#xA;&#xD;&#xA;      /*How to create threads at this point and have a separate recvfrom for each client port ??*/&#xD;&#xA;      if(recvfrom(c1_sockfd_1, buf, BUFLEN, 0, (struct sockaddr *) &si_other, &slen) == -1)&#xD;&#xA;          diep(""recvfrom()"");&#xD;&#xA;    &#xD;&#xA;        printf(""Recieved packet from %s: %d\\nData: %s\\n\\n"", inet_ntoa(si_other.sin_addr), ntohs(si_other.sin_port), buf);&#xD;&#xA;      }&#xD;&#xA;      close(c1_sockfd_1);&#xD;&#xA;      return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**Update**&#xD;&#xA;I have like 5 ports per client, totally 5 * 10 sockets( 10 clients , i.e. 10 * 5ports * 10soc) and data will be sent in time gaps of few milliseconds simultaneously.Here packets received on each port are of different sizes. The packets are sent with Header and CRC. Is it a good idea to have packet numbers in order to track and rerequest the lost packets ?&#xD;&#xA;&#xD;&#xA;(or) What are the different ways to track the lost packets and request for them using UDP?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added 102 characters in body
38606830;15688078;649810;5;eca620ae-f036-4374-ad9d-2c6db806c8de;2013-04-05 04:05:05.0;"I wanted to receive data from different clients(Number of clients is fixed,say 10) ,And each of the clients send data on 5 different predefined ports which wont change.(example, client 1 ports 5000,5001,5002,etc).All the clients can send data simultaneously. &#xD;&#xA;(All the above are fixed)&#xD;&#xA;&#xD;&#xA;Say in TCP, i can create multiple threads,one for each of the connection we accept ,like the below. **UDP is connectionless,So how can we create one thread per UDP client(UDP port) to handle the concurrent data?Like each thread having a receivefrom() function to get data.**&#xD;&#xA;&#xD;&#xA;//UDP Server&#xD;&#xA; &#xD;&#xA;    &#xD;&#xA;    #define BUFLEN 512&#xD;&#xA;    &#xD;&#xA;    #define CLIENT1_PORT1 5000&#xD;&#xA;    #define CLIENT1_PORT2 5001&#xD;&#xA;    #define CLIENT1_PORT3 5002&#xD;&#xA;    &#xD;&#xA;    #define CLIENT2_PORT1 5050&#xD;&#xA;    #define CLIENT2_PORT2 5051&#xD;&#xA;    #define CLIENT2_PORT3 5052	&#xD;&#xA;    &#xD;&#xA;    #define CLIENT3_PORT1 6000&#xD;&#xA;    #define CLIENT3_PORT2 6001&#xD;&#xA;    #define CLIENT3_PORT3 6002&#xD;&#xA;    &#xD;&#xA;    void diep(char *s) {&#xD;&#xA;      perror(s);&#xD;&#xA;      exit(1);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;      struct sockaddr_in client1_sockaddr_1, client1_sockaddr_2,client2_sockaddr_1,client2_sockaddr_2, si_other;&#xD;&#xA;      int c1_sockfd_1,c1_sockfd_2, c2_sockfd_1,c2_sockfd_2, i, slen = sizeof(si_other);&#xD;&#xA;    &#xD;&#xA;      char buf[BUFLEN];&#xD;&#xA;&#xD;&#xA;      /******for client 1 port1 **********/&#xD;&#xA;      if((c1_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;    &#xD;&#xA;      memset((char *) &client1_sockaddr_1, 0, sizeof(client1_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client1_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client1_sockaddr_1.sin_port = htons(CLIENT1_PORT1);&#xD;&#xA;      client1_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_1, (struct sockaddr *) &client1_sockaddr_1, sizeof(client1_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;      if((c2_sockfd_1 = socket(AF_INET, SOCK_DGRAM, 0)) == -1)&#xD;&#xA;        diep(""socket"");&#xD;&#xA;&#xD;&#xA;      /*******for client 2 port1 *******/&#xD;&#xA;      memset((char *) &client2_sockaddr_1, 0, sizeof(client2_sockaddr_1));&#xD;&#xA;      &#xD;&#xA;      client2_sockaddr_1.sin_family = AF_INET;&#xD;&#xA;      client2_sockaddr_1.sin_port = htons(CLIENT2_PORT1);&#xD;&#xA;      client2_sockaddr_1.sin_addr.s_addr = htonl(INADDR_ANY);&#xD;&#xA;      &#xD;&#xA;      if(bind(c1_sockfd_2, (struct sockaddr *) &client2_sockaddr_1, sizeof(client2_sockaddr_1)) == -1)&#xD;&#xA;        diep(""bind"");&#xD;&#xA;    &#xD;&#xA;    //Receive from clients&#xD;&#xA;    while(1) {&#xD;&#xA;&#xD;&#xA;      /*How to create threads at this point and have a separate recvfrom for each client port ??*/&#xD;&#xA;      if(recvfrom(c1_sockfd_1, buf, BUFLEN, 0, (struct sockaddr *) &si_other, &slen) == -1)&#xD;&#xA;          diep(""recvfrom()"");&#xD;&#xA;    &#xD;&#xA;        printf(""Recieved packet from %s: %d\\nData: %s\\n\\n"", inet_ntoa(si_other.sin_addr), ntohs(si_other.sin_port), buf);&#xD;&#xA;      }&#xD;&#xA;      close(c1_sockfd_1);&#xD;&#xA;      return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**Update**&#xD;&#xA;I have like 5 ports per client, totally 5 * 10 sockets and data will be sent in time gaps of few milliseconds simultaneously.Here packets received on each port are of different sizes. The packets are sent with Header and CRC. Is it a good idea to have packet numbers in order to track and rerequest the lost packets ?&#xD;&#xA;&#xD;&#xA;(or) What are the different ways to track the lost packets and request for them using UDP?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;deleted 40 characters in body
