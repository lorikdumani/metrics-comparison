Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
4989776;2449029;220594;2;8179c10e-d7ab-4e4e-8a04-6535c72769f1;2010-03-15 17:14:51.0;"i know this is kinda retarded but I just can't figure it out. I'm debugging this:&#xD;&#xA;&#xD;&#xA;    xor eax,eax&#xD;&#xA;    &#xD;&#xA;    mov ah,[var1]&#xD;&#xA;    mov al,[var2]&#xD;&#xA;    &#xD;&#xA;    call addition&#xD;&#xA;    &#xD;&#xA;    stop: jmp stop&#xD;&#xA;    &#xD;&#xA;    var1: db 5&#xD;&#xA;    var2: db 6&#xD;&#xA;    &#xD;&#xA;    addition:&#xD;&#xA;    add ah,al&#xD;&#xA;    ret&#xD;&#xA;&#xD;&#xA;the numbers that I find on addresses var1 and var2 are 0x0E and 0x07. I know it's not segmented, but that ain't reason for it to do such escapades, because the addition call works just fine. Could you please explain to me where is my mistake?";;
4990900;2449029;220594;5;36c0d609-3afd-4a2e-92c2-293d6f65e1d5;2010-03-15 18:37:49.0;"i know this is kinda retarded but I just can't figure it out. I'm debugging this:&#xD;&#xA;&#xD;&#xA;    xor eax,eax&#xD;&#xA;    &#xD;&#xA;    mov ah,[var1]&#xD;&#xA;    mov al,[var2]&#xD;&#xA;    &#xD;&#xA;    call addition&#xD;&#xA;    &#xD;&#xA;    stop: jmp stop&#xD;&#xA;    &#xD;&#xA;    var1: db 5&#xD;&#xA;    var2: db 6&#xD;&#xA;    &#xD;&#xA;    addition:&#xD;&#xA;    add ah,al&#xD;&#xA;    ret&#xD;&#xA;&#xD;&#xA;the numbers that I find on addresses var1 and var2 are 0x0E and 0x07. I know it's not segmented, but that ain't reason for it to do such escapades, because the addition call works just fine. Could you please explain to me where is my mistake?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;I see the problem, dunno how to fix it yet though. The thing is, for some reason the stack pointer starts at 0100 and all the segment registers at 1628. To address the instruction the used combination is i guess [cs:ip] (one of the segment registers and the instruction pointer for sure). The offset to var1 is 10 which I don't get at all, i tried to examine the memory and what i got was:&#xD;&#xA;&#xD;&#xA;    1628:100 8 bytes&#xD;&#xA;    1628:108 8 bytes&#xD;&#xA;    1628:110 <- wtf? (assume another 8 bytes)&#xD;&#xA;    1628:118 ...&#xD;&#xA;&#xD;&#xA;whatever tricks are there in the memory [cs:var1] points somewhere else than in my code, which is probably where the label .data would usually address ds.... probably.. i don't know what is supposed to be at 1628:10";;"added 721 characters in body; added 18 characters in body"
4991235;2449029;220594;5;9ad70b73-8d81-482b-88a5-1df8cff758b2;2010-03-15 19:01:43.0;"i know this is kinda retarded but I just can't figure it out. I'm debugging this:&#xD;&#xA;&#xD;&#xA;    xor eax,eax&#xD;&#xA;    &#xD;&#xA;    mov ah,[var1]&#xD;&#xA;    mov al,[var2]&#xD;&#xA;    &#xD;&#xA;    call addition&#xD;&#xA;    &#xD;&#xA;    stop: jmp stop&#xD;&#xA;    &#xD;&#xA;    var1: db 5&#xD;&#xA;    var2: db 6&#xD;&#xA;    &#xD;&#xA;    addition:&#xD;&#xA;    add ah,al&#xD;&#xA;    ret&#xD;&#xA;&#xD;&#xA;the numbers that I find on addresses var1 and var2 are 0x0E and 0x07. I know it's not segmented, but that ain't reason for it to do such escapades, because the addition call works just fine. Could you please explain to me where is my mistake?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;I see the problem, dunno how to fix it yet though. The thing is, for some reason the stack pointer starts at 0100 and all the segment registers at 1628. To address the instruction the used combination is i guess [cs:ip] (one of the segment registers and the instruction pointer for sure). The offset to var1 is 0x10 (probably because from the begining of the code it's the 0x10th byte in order), i tried to examine the memory and what i got was:&#xD;&#xA;&#xD;&#xA;    1628:100 8 bytes&#xD;&#xA;    1628:108 8 bytes&#xD;&#xA;    1628:110 <- wtf? (assume another 8 bytes)&#xD;&#xA;    1628:118 ...&#xD;&#xA;&#xD;&#xA;whatever tricks are there in the memory [cs:var1] points somewhere else than in my code, which is probably where the label .data would usually address ds.... probably.. i don't know what is supposed to be at 1628:10";;added 56 characters in body
4991316;2449029;220594;5;d6132cd2-944c-4dde-80c3-146ff47445aa;2010-03-15 19:06:47.0;"i know this is kinda retarded but I just can't figure it out. I'm debugging this:&#xD;&#xA;&#xD;&#xA;    xor eax,eax&#xD;&#xA;    &#xD;&#xA;    mov ah,[var1]&#xD;&#xA;    mov al,[var2]&#xD;&#xA;    &#xD;&#xA;    call addition&#xD;&#xA;    &#xD;&#xA;    stop: jmp stop&#xD;&#xA;    &#xD;&#xA;    var1: db 5&#xD;&#xA;    var2: db 6&#xD;&#xA;    &#xD;&#xA;    addition:&#xD;&#xA;    add ah,al&#xD;&#xA;    ret&#xD;&#xA;&#xD;&#xA;the numbers that I find on addresses var1 and var2 are 0x0E and 0x07. I know it's not segmented, but that ain't reason for it to do such escapades, because the addition call works just fine. Could you please explain to me where is my mistake?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;I see the problem, dunno how to fix it yet though. The thing is, for some reason the instruction pointer starts at 0100 and all the segment registers at 1628. To address the instruction the used combination is i guess [cs:ip] (one of the segment registers and the instruction pointer for sure). The offset to var1 is 0x10 (probably because from the begining of the code it's the 0x10th byte in order), i tried to examine the memory and what i got was:&#xD;&#xA;&#xD;&#xA;    1628:100 8 bytes&#xD;&#xA;    1628:108 8 bytes&#xD;&#xA;    1628:110 <- wtf? (assume another 8 bytes)&#xD;&#xA;    1628:118 ...&#xD;&#xA;&#xD;&#xA;whatever tricks are there in the memory [cs:var1] points somewhere else than in my code, which is probably where the label .data would usually address ds.... probably.. i don't know what is supposed to be at 1628:10";;added 6 characters in body
4991888;2449029;220594;5;705e9a80-ad23-4af1-9daa-fc4b9c857d1d;2010-03-15 19:49:26.0;"i know this is kinda retarded but I just can't figure it out. I'm debugging this:&#xD;&#xA;&#xD;&#xA;    xor eax,eax&#xD;&#xA;    &#xD;&#xA;    mov ah,[var1]&#xD;&#xA;    mov al,[var2]&#xD;&#xA;    &#xD;&#xA;    call addition&#xD;&#xA;    &#xD;&#xA;    stop: jmp stop&#xD;&#xA;    &#xD;&#xA;    var1: db 5&#xD;&#xA;    var2: db 6&#xD;&#xA;    &#xD;&#xA;    addition:&#xD;&#xA;    add ah,al&#xD;&#xA;    ret&#xD;&#xA;&#xD;&#xA;the numbers that I find on addresses var1 and var2 are 0x0E and 0x07. I know it's not segmented, but that ain't reason for it to do such escapades, because the addition call works just fine. Could you please explain to me where is my mistake?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;I see the problem, dunno how to fix it yet though. The thing is, for some reason the instruction pointer starts at 0x100 and all the segment registers at 0x1628. To address the instruction the used combination is i guess [cs:ip] (one of the segment registers and the instruction pointer for sure). The offset to var1 is 0x10 (probably because from the begining of the code it's the 0x10th byte in order), i tried to examine the memory and what i got was:&#xD;&#xA;&#xD;&#xA;    1628:100 8 bytes&#xD;&#xA;    1628:108 8 bytes&#xD;&#xA;    1628:110 <- wtf? (assume another 8 bytes)&#xD;&#xA;    1628:118 ...&#xD;&#xA;&#xD;&#xA;whatever tricks are there in the memory [cs:var1] points somewhere else than in my code, which is probably where the label .data would usually address ds.... probably.. i don't know what is supposed to be at 1628:10";;added 3 characters in body
4993445;2449029;220594;5;f606ac34-5b85-4328-a79a-8c6e120f3838;2010-03-15 21:42:42.0;"i know this is kinda retarded but I just can't figure it out. I'm debugging this:&#xD;&#xA;&#xD;&#xA;    xor eax,eax&#xD;&#xA;    &#xD;&#xA;    mov ah,[var1]&#xD;&#xA;    mov al,[var2]&#xD;&#xA;    &#xD;&#xA;    call addition&#xD;&#xA;    &#xD;&#xA;    stop: jmp stop&#xD;&#xA;    &#xD;&#xA;    var1: db 5&#xD;&#xA;    var2: db 6&#xD;&#xA;    &#xD;&#xA;    addition:&#xD;&#xA;    add ah,al&#xD;&#xA;    ret&#xD;&#xA;&#xD;&#xA;the numbers that I find on addresses var1 and var2 are 0x0E and 0x07. I know it's not segmented, but that ain't reason for it to do such escapades, because the addition call works just fine. Could you please explain to me where is my mistake?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;I see the problem, dunno how to fix it yet though. The thing is, for some reason the instruction pointer starts at 0x100 and all the segment registers at 0x1628. To address the instruction the used combination is i guess [cs:ip] (one of the segment registers and the instruction pointer for sure). The offset to var1 is 0x10 (probably because from the begining of the code it's the 0x10th byte in order), i tried to examine the memory and what i got was:&#xD;&#xA;&#xD;&#xA;    1628:100 8 bytes&#xD;&#xA;    1628:108 8 bytes&#xD;&#xA;    1628:110 <- wtf? (assume another 8 bytes)&#xD;&#xA;    1628:118 ...&#xD;&#xA;&#xD;&#xA;whatever tricks are there in the memory [cs:var1] points somewhere else than in my code, which is probably where the label .data would usually address ds.... probably.. i don't know what is supposed to be at 1628:10&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;ok, i found out what caused the assness and wasted me whole fuckin day. the behaviour described above is just correct, the code is fully functional. what i didn't know is that grdb debugger for some reason sets the begining address to 0x100... the sollution is to insert the directive ORG 0x100 on the first line and that's the whole thing. the code was working because instruction pointer has the right address to first instruction and goes one by one, but your assembler doesn't know what effective address will be your program stored at so it pretty much remains relative to first line of the code which means all the variables (if not using label for data section) will remain pointing as if it started at 0x0. which of course wouldn't work with DOS. and grdb apparently emulates some DOS features... sry for the language, thx everyone for effort, hope this will spare someone's time if having the same problem...";;"added 937 characters in body; edited title"
4993552;2449029;220594;5;78c655be-8716-4cc2-839e-a8a5a91ed44a;2010-03-15 21:50:30.0;"i know this is kinda retarded but I just can't figure it out. I'm debugging this:&#xD;&#xA;&#xD;&#xA;    xor eax,eax&#xD;&#xA;    &#xD;&#xA;    mov ah,[var1]&#xD;&#xA;    mov al,[var2]&#xD;&#xA;    &#xD;&#xA;    call addition&#xD;&#xA;    &#xD;&#xA;    stop: jmp stop&#xD;&#xA;    &#xD;&#xA;    var1: db 5&#xD;&#xA;    var2: db 6&#xD;&#xA;    &#xD;&#xA;    addition:&#xD;&#xA;    add ah,al&#xD;&#xA;    ret&#xD;&#xA;&#xD;&#xA;the numbers that I find on addresses var1 and var2 are 0x0E and 0x07. I know it's not segmented, but that ain't reason for it to do such escapades, because the addition call works just fine. Could you please explain to me where is my mistake?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;I see the problem, dunno how to fix it yet though. The thing is, for some reason the instruction pointer starts at 0x100 and all the segment registers at 0x1628. To address the instruction the used combination is i guess [cs:ip] (one of the segment registers and the instruction pointer for sure). The offset to var1 is 0x10 (probably because from the begining of the code it's the 0x10th byte in order), i tried to examine the memory and what i got was:&#xD;&#xA;&#xD;&#xA;    1628:100 8 bytes&#xD;&#xA;    1628:108 8 bytes&#xD;&#xA;    1628:110 <- wtf? (assume another 8 bytes)&#xD;&#xA;    1628:118 ...&#xD;&#xA;&#xD;&#xA;whatever tricks are there in the memory [cs:var1] points somewhere else than in my code, which is probably where the label .data would usually address ds.... probably.. i don't know what is supposed to be at 1628:10&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;ok, i found out what caused the assness and wasted me whole fuckin day. the behaviour described above is just correct, the code is fully functional. what i didn't know is that grdb debugger for some reason sets the begining address to 0x100... the sollution is to insert the directive ORG 0x100 on the first line and that's the whole thing. the code was working because instruction pointer has the right address to first instruction and goes one by one, but your assembler doesn't know what effective address will be your program stored at so it pretty much remains relative to first line of the code which means all the variables (if not using label for data section) will remain pointing as if it started at 0x0. which of course wouldn't work with DOS. and grdb apparently emulates some DOS features... sry for the language, thx everyone for effort, hope this will spare someone's time if having the same problem...&#xD;&#xA;&#xD;&#xA;heheh.. at least now i know the reason why to use .data section :))))";;added 73 characters in body
