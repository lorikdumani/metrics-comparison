Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
12178265;5665600;180239;2;698beb4e-913e-41e5-96c0-49df20615d84;2011-04-14 15:26:26.0;I just had the same issue while importing rows, as it seems, calling `DataTable.BeginLoadData` before the insert fixed it for me.;;
12198784;5665600;180239;5;37c7a04a-47b8-42ee-83e5-7862959ce4f2;2011-04-15 08:40:06.0;"I just had the same issue while importing rows, as it seems, calling `DataTable.BeginLoadData` before the insert fixed it for me.&#xD;&#xA;&#xD;&#xA;**Edit:** As it turns out, this only fixed it on one side, now adding rows throws this exception.";;added 101 characters in body
12199580;5665600;180239;5;bebdfc1a-9a02-46d7-b1ae-c32eb2b47dfd;2011-04-15 09:11:29.0;"I just had the same issue while importing rows, as it seems, calling `DataTable.BeginLoadData` before the insert fixed it for me.&#xD;&#xA;&#xD;&#xA;**Edit:** As it turns out, this only fixed it on one side, now adding rows throws this exception.&#xD;&#xA;&#xD;&#xA;**Edit2:** Suspending binding as suggested by [Robert Rossney](http://stackoverflow.com/questions/450675/datatable-internal-index-is-corrupted/663399#663399) fixed the adding problem for me, too. I simply removed the `DataSource` from the `DataGridView` and readded it after I was done with the `DataTable`.";;added 311 characters in body
12261506;5665600;180239;5;de21039f-7914-41a7-a6e8-df96711d13d1;2011-04-18 08:54:00.0;"I just had the same issue while importing rows, as it seems, calling `DataTable.BeginLoadData` before the insert fixed it for me.&#xD;&#xA;&#xD;&#xA;**Edit:** As it turns out, this only fixed it on one side, now adding rows throws this exception.&#xD;&#xA;&#xD;&#xA;**Edit2:** Suspending binding as suggested by [Robert Rossney](http://stackoverflow.com/questions/450675/datatable-internal-index-is-corrupted/663399#663399) fixed the adding problem for me, too. I simply removed the `DataSource` from the `DataGridView` and readded it after I was done with the `DataTable`.&#xD;&#xA;&#xD;&#xA;**Edit3:** Still not fixed...the exception keeps creeping up in all different places in my code since Thursday...this is by far the strangest and most f\\*\\*\\*\\*ing bug I've encountered in the Framework so far (and I've seen many odd things in the 3 years I've been working with .NET 2.0, enough to warrant that not a single of my future projects will be build on it). But enough of ranting, back on topic.&#xD;&#xA;&#xD;&#xA;I've read through the whole discussion [at the Microsoft support forums](http://social.msdn.microsoft.com/Forums/en/adodotnetdataproviders/thread/18544cd3-1083-45fe-b9e7-bb34482b68dd) and I'll give you a brief summary of it. The original [bug report originates in '05](http://connect.microsoft.com/VisualStudio/feedback/details/98279/funny-one-datatable-internal-index-is-corrupted#details).&#xD;&#xA;&#xD;&#xA; * ***March '06:*** Bug is reported the first time, investigation starts. Throughout the course of the next year it is reported in different forms and different manifestations.&#xD;&#xA; * ***March '07:*** Finally [a hotfix with number KB 932491](http://support.microsoft.com/kb/932491/en-us) is released (don't get your hopes up), it links against [a download of an completely irrelevant looking hotfix](http://archive.msdn.microsoft.com/KB932491), or at least so it seems. Throughout the next months many report that the **hotfix does not work**, some are reporting success.&#xD;&#xA; * ***July '07:*** Last sign of live from Microsoft (with a complete useless answer), beyond this point is no further response from Microsoft. No further confirmations, no attempts on support, no requests for more information...nothing. Beyond this point there's only community related information.&#xD;&#xA;&#xD;&#xA;No seriously, this sums it up in my opinion. I was able to extract the following information from the whole discussion:&#xD;&#xA;&#xD;&#xA; * The `DataTable` is **not** Thread-Safe. You'll have to `Lock`/`Synchronize` it on your own if you have Multi-Threading anywhere on it.&#xD;&#xA; * The corruption of the index happens somewhere **before** the actual exception is thrown.&#xD;&#xA; * One possible corruption source is either an applied `Expression` or an applied `Sort`.&#xD;&#xA; * Another possible source is the `DataTable.ListChanged()` event, do never modify data in this event or any event which spawns from it. This includes different `Changed` events from bound controls.&#xD;&#xA; * There are possible issues when binding the `DefaultView` against a control. Always use `DataTable.BeginLoadData()` and `DataTable.EndLoadData()`.&#xD;&#xA; * Creation and manipulation of the `DefaultView` is a **writing operation** on the `DataTable` (and its `Index`), the Flying Spaghetti Monster knows why.&#xD;&#xA;&#xD;&#xA;The possible source of this is most likely a race condition, either in our source code or in the code of the framework. As it seems, Microsoft is unable to fix this bug or has no intention to. Either way, check your code for race conditions, it has something to do with the `DefaultView` in my opinion. At some point an `Insert` or a manipulation of the data is corrupting the internal Index because the changed are not properly propagated through the whole `DataTable`.&#xD;&#xA;&#xD;&#xA;I'll of course report back when I find further informations or additional fixes. And sorry if I get a little bit emotional here, but I've spent three days trying to pinpoint this issue, and it slowly starts to look like a good reason to get a new job.";;"Added additional information.; added 167 characters in body"
15730925;5665600;180239;5;c4cccc3a-0ad5-4851-b3f7-d06a0b1c36a0;2011-08-23 08:02:48.0;"I just had the same issue while importing rows, as it seems, calling `DataTable.BeginLoadData` before the insert fixed it for me.&#xD;&#xA;&#xD;&#xA;**Edit:** As it turns out, this only fixed it on one side, now adding rows throws this exception.&#xD;&#xA;&#xD;&#xA;**Edit2:** Suspending binding as suggested by [Robert Rossney](http://stackoverflow.com/questions/450675/datatable-internal-index-is-corrupted/663399#663399) fixed the adding problem for me, too. I simply removed the `DataSource` from the `DataGridView` and readded it after I was done with the `DataTable`.&#xD;&#xA;&#xD;&#xA;**Edit3:** Still not fixed...the exception keeps creeping up in all different places in my code since Thursday...this is by far the strangest and most f\\*\\*\\*\\*ing bug I've encountered in the Framework so far (and I've seen many odd things in the 3 years I've been working with .NET 2.0, enough to warrant that not a single of my future projects will be build on it). But enough of ranting, back on topic.&#xD;&#xA;&#xD;&#xA;I've read through the whole discussion [at the Microsoft support forums](http://social.msdn.microsoft.com/Forums/en/adodotnetdataproviders/thread/18544cd3-1083-45fe-b9e7-bb34482b68dd) and I'll give you a brief summary of it. The original [bug report originates in '05](http://connect.microsoft.com/VisualStudio/feedback/details/98279/funny-one-datatable-internal-index-is-corrupted#details).&#xD;&#xA;&#xD;&#xA; * ***March '06:*** Bug is reported the first time, investigation starts. Throughout the course of the next year it is reported in different forms and different manifestations.&#xD;&#xA; * ***March '07:*** Finally [a hotfix with number KB 932491](http://support.microsoft.com/kb/932491/en-us) is released (don't get your hopes up), it links against [a download of an completely irrelevant looking hotfix](http://archive.msdn.microsoft.com/KB932491), or at least so it seems. Throughout the next months many report that the **hotfix does not work**, some are reporting success.&#xD;&#xA; * ***July '07:*** Last sign of live from Microsoft (with a complete useless answer), beyond this point is no further response from Microsoft. No further confirmations, no attempts on support, no requests for more information...nothing. Beyond this point there's only community related information.&#xD;&#xA;&#xD;&#xA;No seriously, this sums it up in my opinion. I was able to extract the following information from the whole discussion:&#xD;&#xA;&#xD;&#xA; * The `DataTable` is **not** Thread-Safe. You'll have to `Lock`/`Synchronize` it on your own if you have Multi-Threading anywhere on it.&#xD;&#xA; * The corruption of the index happens somewhere **before** the actual exception is thrown.&#xD;&#xA; * One possible corruption source is either an applied `Expression` or an applied `Sort`.&#xD;&#xA; * Another possible source is the `DataTable.ListChanged()` event, do never modify data in this event or any event which spawns from it. This includes different `Changed` events from bound controls.&#xD;&#xA; * There are possible issues when binding the `DefaultView` against a control. Always use `DataTable.BeginLoadData()` and `DataTable.EndLoadData()`.&#xD;&#xA; * Creation and manipulation of the `DefaultView` is a **writing operation** on the `DataTable` (and its `Index`), the Flying Spaghetti Monster knows why.&#xD;&#xA;&#xD;&#xA;The possible source of this is most likely a race condition, either in our source code or in the code of the framework. As it seems, Microsoft is unable to fix this bug or has no intention to. Either way, check your code for race conditions, it has something to do with the `DefaultView` in my opinion. At some point an `Insert` or a manipulation of the data is corrupting the internal Index because the changes are not properly propagated through the whole `DataTable`.&#xD;&#xA;&#xD;&#xA;I'll of course report back when I find further informations or additional fixes. And sorry if I get a little bit emotional here, but I've spent three days trying to pinpoint this issue, and it slowly starts to look like a good reason to get a new job.&#xD;&#xA;&#xD;&#xA;**Edit4:** I was able to avoid this bug by completely removing the binding (`control.DataSource = null;`) and re-adding it after the loading of the data is completed. Which fuels my thought that it has something to do with the `DefaultView` and the events which spawn from the bound controls.";;Extended
20517980;5665600;180239;5;3f5797c0-35e1-41f4-93ba-67aeeb8fdc27;2012-01-30 10:05:01.0;"I just had the same issue while importing rows, as it seems, calling `DataTable.BeginLoadData` before the insert fixed it for me.&#xD;&#xA;&#xD;&#xA;**Edit:** As it turns out, this only fixed it on one side, now adding rows throws this exception.&#xD;&#xA;&#xD;&#xA;**Edit2:** Suspending binding as suggested by [Robert Rossney](http://stackoverflow.com/questions/450675/datatable-internal-index-is-corrupted/663399#663399) fixed the adding problem for me, too. I simply removed the `DataSource` from the `DataGridView` and readded it after I was done with the `DataTable`.&#xD;&#xA;&#xD;&#xA;**Edit3:** Still not fixed...the exception keeps creeping up in all different places in my code since Thursday...this is by far the strangest and most f\\*\\*\\*\\*ing bug I've encountered in the Framework so far (and I've seen many odd things in the 3 years I've been working with .NET 2.0, enough to warrant that not a single of my future projects will be build on it). But enough of ranting, back on topic.&#xD;&#xA;&#xD;&#xA;I've read through the whole discussion [at the Microsoft support forums](http://social.msdn.microsoft.com/Forums/en/adodotnetdataproviders/thread/18544cd3-1083-45fe-b9e7-bb34482b68dd) and I'll give you a brief summary of it. The original [bug report originates in '05](http://connect.microsoft.com/VisualStudio/feedback/details/98279/funny-one-datatable-internal-index-is-corrupted#details).&#xD;&#xA;&#xD;&#xA; * ***March '06:*** Bug is reported the first time, investigation starts. Throughout the course of the next year it is reported in different forms and different manifestations.&#xD;&#xA; * ***March '07:*** Finally [a hotfix with number KB 932491](http://support.microsoft.com/kb/932491/en-us) is released (don't get your hopes up), it links against [a download of an completely irrelevant looking hotfix](http://archive.msdn.microsoft.com/KB932491), or at least so it seems. Throughout the next months many report that the **hotfix does not work**, some are reporting success.&#xD;&#xA; * ***July '07:*** Last sign of live from Microsoft (with a complete useless answer), beyond this point is no further response from Microsoft. No further confirmations, no attempts on support, no requests for more information...nothing. Beyond this point there's only community related information.&#xD;&#xA;&#xD;&#xA;No seriously, this sums it up in my opinion. I was able to extract the following information from the whole discussion:&#xD;&#xA;&#xD;&#xA; * The `DataTable` is **not** Thread-Safe. You'll have to `Lock`/`Synchronize` it on your own if you have Multi-Threading anywhere on it.&#xD;&#xA; * The corruption of the index happens somewhere **before** the actual exception is thrown.&#xD;&#xA; * One possible corruption source is either an applied `Expression` or an applied `Sort`.&#xD;&#xA; * Another possible source is the `DataTable.ListChanged()` event, do never modify data in this event or any event which spawns from it. This includes different `Changed` events from bound controls.&#xD;&#xA; * There are possible issues when binding the `DefaultView` against a control. Always use `DataTable.BeginLoadData()` and `DataTable.EndLoadData()`.&#xD;&#xA; * Creation and manipulation of the `DefaultView` is a **writing operation** on the `DataTable` (and its `Index`), the Flying Spaghetti Monster knows why.&#xD;&#xA;&#xD;&#xA;The possible source of this is most likely a race condition, either in our source code or in the code of the framework. As it seems, Microsoft is unable to fix this bug or has no intention to. Either way, check your code for race conditions, it has something to do with the `DefaultView` in my opinion. At some point an `Insert` or a manipulation of the data is corrupting the internal Index because the changes are not properly propagated through the whole `DataTable`.&#xD;&#xA;&#xD;&#xA;I'll of course report back when I find further informations or additional fixes. And sorry if I get a little bit emotional here, but I've spent three days trying to pinpoint this issue, and it slowly starts to look like a good reason to get a new job.&#xD;&#xA;&#xD;&#xA;**Edit4:** I was able to avoid this bug by completely removing the binding (`control.DataSource = null;`) and re-adding it after the loading of the data is completed. Which fuels my thought that it has something to do with the `DefaultView` and the events which spawn from the bound controls.&#xD;&#xA;&#xD;&#xA;**Edit5:** A similar error, which also is associated with this has been creeping up in my application since last Thursday:&#xD;&#xA;&#xD;&#xA;    (NullReferenceException) Object reference not set to an instance of an object.&#xD;&#xA;       at System.Data.DataView.FinishAddNew(Int32 currentIndex, Boolean success)&#xD;&#xA;       at System.Data.DataRowView.EndEdit()&#xD;&#xA;       at System.Windows.Forms.CurrencyManager.EndCurrentEdit()&#xD;&#xA;       at System.Windows.Forms.CurrencyManager.ChangeRecordState(Int32 newPosition, Boolean validating, Boolean endCurrentEdit, Boolean firePositionChange, Boolean pullData)&#xD;&#xA;       at System.Windows.Forms.CurrencyManager.List_ListChanged(Object sender, ListChangedEventArgs e)&#xD;&#xA;       at System.Data.DataView.OnListChanged(ListChangedEventArgs e)&#xD;&#xA;       at System.Data.DataView.IndexListChanged(Object sender, ListChangedEventArgs e)&#xD;&#xA;       at System.Data.DataViewListener.IndexListChanged(Object sender, ListChangedEventArgs e)&#xD;&#xA;       at System.Data.Index.OnListChanged(ListChangedType changedType, Int32 index)&#xD;&#xA;       at System.Data.Index.InsertRecord(Int32 record, Boolean fireEvent)&#xD;&#xA;       at System.Data.Index.ApplyChangeAction(Int32 record, Int32 action)&#xD;&#xA;       at System.Data.Index.RecordStateChanged(Int32 oldRecord, DataViewRowState oldOldState, DataViewRowState oldNewState, Int32 newRecord, DataViewRowState newOldState, DataViewRowState newNewState)&#xD;&#xA;       at System.Data.DataTable.RecordStateChanged(Int32 record1, DataViewRowState oldState1, DataViewRowState newState1, Int32 record2, DataViewRowState oldState2, DataViewRowState newState2)&#xD;&#xA;       at System.Data.DataTable.SetNewRecordWorker(DataRow row, Int32 proposedRecord, DataRowAction action, Boolean isInMerge, Int32 position, Boolean fireEvent, Exception& deferredException)&#xD;&#xA;       at System.Data.DataTable.SetNewRecord(DataRow row, Int32 proposedRecord, DataRowAction action, Boolean isInMerge, Boolean fireEvent)&#xD;&#xA;       at System.Data.DataRow.EndEdit()&#xD;&#xA;       at System.Data.DataRow.set_Item(DataColumn column, Object value)&#xD;&#xA;       at System.Data.DataRow.set_Item(String columnName, Object value)&#xD;&#xA;&#xD;&#xA;and&#xD;&#xA;&#xD;&#xA;    (NullReferenceException) Object reference not set to an instance of an object.&#xD;&#xA;       at System.Data.DataView.IsOriginalVersion(Int32 index)&#xD;&#xA;       at System.Data.DataRowView.GetColumnValue(DataColumn column)&#xD;&#xA;       at System.Data.DataColumnPropertyDescriptor.GetValue(Object component)&#xD;&#xA;       at System.Windows.Forms.DataGridView.DataGridViewDataConnection.GetValue(Int32 boundColumnIndex, Int32 columnIndex, Int32 rowIndex)&#xD;&#xA;       at System.Windows.Forms.DataGridViewCell.GetValue(Int32 rowIndex)&#xD;&#xA;       at System.Windows.Forms.DataGridView.OnCellValidating(DataGridViewCell& dataGridViewCell, Int32 columnIndex, Int32 rowIndex, DataGridViewDataErrorContexts context)&#xD;&#xA;       at System.Windows.Forms.DataGridView.CommitEdit(DataGridViewCell& dataGridViewCurrentCell, DataGridViewDataErrorContexts context, DataGridViewValidateCellInternal validateCell, Boolean fireCellLeave, Boolean fireCellEnter, Boolean fireRowLeave, Boolean fireRowEnter, Boolean fireLeave)&#xD;&#xA;       at System.Windows.Forms.DataGridView.EndEdit(DataGridViewDataErrorContexts context, DataGridViewValidateCellInternal validateCell, Boolean fireCellLeave, Boolean fireCellEnter, Boolean fireRowLeave, Boolean fireRowEnter, Boolean fireLeave, Boolean keepFocus, Boolean resetCurrentCell, Boolean resetAnchorCell)&#xD;&#xA;       at System.Windows.Forms.DataGridView.CommitEditForOperation(Int32 columnIndex, Int32 rowIndex, Boolean forCurrentCellChange)&#xD;&#xA;       at System.Windows.Forms.DataGridView.ScrollIntoView(Int32 columnIndex, Int32 rowIndex, Boolean forCurrentCellChange)&#xD;&#xA;&#xD;&#xA;Those are creeping up on random intervals on a handful of machines. The good news is that those machines use Vanilla .NET 2.0, which means that *there have been fixes issued* with later versions which fix at least some issues. So another possible fix is to install all Service Packages and upgrade to later versions (installing those without recompiling might suffice, not sure).";;added 4032 characters in body
46057358;5665600;180239;5;13612373-ce83-4411-81b5-b78fa39aaf46;2013-08-27 09:03:44.0;"I just had the same issue while importing rows, as it seems, calling `DataTable.BeginLoadData` before the insert fixed it for me.&#xD;&#xA;&#xD;&#xA;**Edit:** As it turns out, this only fixed it on one side, now adding rows throws this exception.&#xD;&#xA;&#xD;&#xA;**Edit2:** Suspending binding as suggested by [Robert Rossney](http://stackoverflow.com/questions/450675/datatable-internal-index-is-corrupted/663399#663399) fixed the adding problem for me, too. I simply removed the `DataSource` from the `DataGridView` and readded it after I was done with the `DataTable`.&#xD;&#xA;&#xD;&#xA;**Edit3:** Still not fixed...the exception keeps creeping up in all different places in my code since Thursday...this is by far the strangest and most f\\*\\*\\*\\*ing bug I've encountered in the Framework so far (and I've seen many odd things in the 3 years I've been working with .NET 2.0, enough to warrant that not a single of my future projects will be build on it). But enough of ranting, back on topic.&#xD;&#xA;&#xD;&#xA;I've read through the whole discussion [at the Microsoft support forums](http://social.msdn.microsoft.com/Forums/en/adodotnetdataproviders/thread/18544cd3-1083-45fe-b9e7-bb34482b68dd) and I'll give you a brief summary of it. The original [bug report originates in '05](http://connect.microsoft.com/VisualStudio/feedback/details/98279/funny-one-datatable-internal-index-is-corrupted#details).&#xD;&#xA;&#xD;&#xA; * ***March '06:*** Bug is reported the first time, investigation starts. Throughout the course of the next year it is reported in different forms and different manifestations.&#xD;&#xA; * ***March '07:*** Finally [a hotfix with number KB 932491](http://support.microsoft.com/kb/932491/en-us) is released (don't get your hopes up), it links against [a download of an completely irrelevant looking hotfix](http://archive.msdn.microsoft.com/KB932491), or at least so it seems. Throughout the next months many report that the **hotfix does not work**, some are reporting success.&#xD;&#xA; * ***July '07:*** Last sign of live from Microsoft (with a complete useless answer), beyond this point is no further response from Microsoft. No further confirmations, no attempts on support, no requests for more information...nothing. Beyond this point there's only community related information.&#xD;&#xA;&#xD;&#xA;No seriously, this sums it up in my opinion. I was able to extract the following information from the whole discussion:&#xD;&#xA;&#xD;&#xA; * The `DataTable` is **not** Thread-Safe. You'll have to `Lock`/`Synchronize` it on your own if you have Multi-Threading anywhere on it.&#xD;&#xA; * The corruption of the index happens somewhere **before** the actual exception is thrown.&#xD;&#xA; * One possible corruption source is either an applied `Expression` or an applied `Sort`.&#xD;&#xA; * Another possible source is the `DataTable.ListChanged()` event, do never modify data in this event or any event which spawns from it. This includes different `Changed` events from bound controls.&#xD;&#xA; * There are possible issues when binding the `DefaultView` against a control. Always use `DataTable.BeginLoadData()` and `DataTable.EndLoadData()`.&#xD;&#xA; * Creation and manipulation of the `DefaultView` is a **writing operation** on the `DataTable` (and its `Index`), the Flying Spaghetti Monster knows why.&#xD;&#xA;&#xD;&#xA;The possible source of this is most likely a race condition, either in our source code or in the code of the framework. As it seems, Microsoft is unable to fix this bug or has no intention to. Either way, check your code for race conditions, it has something to do with the `DefaultView` in my opinion. At some point an `Insert` or a manipulation of the data is corrupting the internal Index because the changes are not properly propagated through the whole `DataTable`.&#xD;&#xA;&#xD;&#xA;I'll of course report back when I find further informations or additional fixes. And sorry if I get a little bit emotional here, but I've spent three days trying to pinpoint this issue, and it slowly starts to look like a good reason to get a new job.&#xD;&#xA;&#xD;&#xA;**Edit4:** I was able to avoid this bug by completely removing the binding (`control.DataSource = null;`) and re-adding it after the loading of the data is completed. Which fuels my thought that it has something to do with the `DefaultView` and the events which spawn from the bound controls.";;Removed this bit of information as it was most likely a bug in my handling of cells/rows rather then the DataTable.
146430520;5665600;-1;5;e60973b2-c63e-491e-a265-30d427d120f5;2017-05-23 11:47:01.0;"I just had the same issue while importing rows, as it seems, calling `DataTable.BeginLoadData` before the insert fixed it for me.&#xD;&#xA;&#xD;&#xA;**Edit:** As it turns out, this only fixed it on one side, now adding rows throws this exception.&#xD;&#xA;&#xD;&#xA;**Edit2:** Suspending binding as suggested by [Robert Rossney](https://stackoverflow.com/questions/450675/datatable-internal-index-is-corrupted/663399#663399) fixed the adding problem for me, too. I simply removed the `DataSource` from the `DataGridView` and readded it after I was done with the `DataTable`.&#xD;&#xA;&#xD;&#xA;**Edit3:** Still not fixed...the exception keeps creeping up in all different places in my code since Thursday...this is by far the strangest and most f\\*\\*\\*\\*ing bug I've encountered in the Framework so far (and I've seen many odd things in the 3 years I've been working with .NET 2.0, enough to warrant that not a single of my future projects will be build on it). But enough of ranting, back on topic.&#xD;&#xA;&#xD;&#xA;I've read through the whole discussion [at the Microsoft support forums](http://social.msdn.microsoft.com/Forums/en/adodotnetdataproviders/thread/18544cd3-1083-45fe-b9e7-bb34482b68dd) and I'll give you a brief summary of it. The original [bug report originates in '05](http://connect.microsoft.com/VisualStudio/feedback/details/98279/funny-one-datatable-internal-index-is-corrupted#details).&#xD;&#xA;&#xD;&#xA; * ***March '06:*** Bug is reported the first time, investigation starts. Throughout the course of the next year it is reported in different forms and different manifestations.&#xD;&#xA; * ***March '07:*** Finally [a hotfix with number KB 932491](http://support.microsoft.com/kb/932491/en-us) is released (don't get your hopes up), it links against [a download of an completely irrelevant looking hotfix](http://archive.msdn.microsoft.com/KB932491), or at least so it seems. Throughout the next months many report that the **hotfix does not work**, some are reporting success.&#xD;&#xA; * ***July '07:*** Last sign of live from Microsoft (with a complete useless answer), beyond this point is no further response from Microsoft. No further confirmations, no attempts on support, no requests for more information...nothing. Beyond this point there's only community related information.&#xD;&#xA;&#xD;&#xA;No seriously, this sums it up in my opinion. I was able to extract the following information from the whole discussion:&#xD;&#xA;&#xD;&#xA; * The `DataTable` is **not** Thread-Safe. You'll have to `Lock`/`Synchronize` it on your own if you have Multi-Threading anywhere on it.&#xD;&#xA; * The corruption of the index happens somewhere **before** the actual exception is thrown.&#xD;&#xA; * One possible corruption source is either an applied `Expression` or an applied `Sort`.&#xD;&#xA; * Another possible source is the `DataTable.ListChanged()` event, do never modify data in this event or any event which spawns from it. This includes different `Changed` events from bound controls.&#xD;&#xA; * There are possible issues when binding the `DefaultView` against a control. Always use `DataTable.BeginLoadData()` and `DataTable.EndLoadData()`.&#xD;&#xA; * Creation and manipulation of the `DefaultView` is a **writing operation** on the `DataTable` (and its `Index`), the Flying Spaghetti Monster knows why.&#xD;&#xA;&#xD;&#xA;The possible source of this is most likely a race condition, either in our source code or in the code of the framework. As it seems, Microsoft is unable to fix this bug or has no intention to. Either way, check your code for race conditions, it has something to do with the `DefaultView` in my opinion. At some point an `Insert` or a manipulation of the data is corrupting the internal Index because the changes are not properly propagated through the whole `DataTable`.&#xD;&#xA;&#xD;&#xA;I'll of course report back when I find further informations or additional fixes. And sorry if I get a little bit emotional here, but I've spent three days trying to pinpoint this issue, and it slowly starts to look like a good reason to get a new job.&#xD;&#xA;&#xD;&#xA;**Edit4:** I was able to avoid this bug by completely removing the binding (`control.DataSource = null;`) and re-adding it after the loading of the data is completed. Which fuels my thought that it has something to do with the `DefaultView` and the events which spawn from the bound controls.";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
