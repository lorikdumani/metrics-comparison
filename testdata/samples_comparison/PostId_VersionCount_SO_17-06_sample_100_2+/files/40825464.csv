Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
132500398;40825464;695364;2;6dd7914c-72be-4a63-adfe-946a72daaee8;2016-11-27 03:20:38.0;"What I saw was that you were missing two closing curly braces that were causing errors. I added my own `isPrime()` function. See comments for locations:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false console: true babel: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    window.onload=go;&#xD;&#xA;&#xD;&#xA;    var NUMBERS = 100;&#xD;&#xA;&#xD;&#xA;    function go(){&#xD;&#xA;&#xD;&#xA;        &#xD;&#xA;      var out = document.getElementById(""output"");&#xD;&#xA;      &#xD;&#xA;      for (var i = 1; i < NUMBERS+1; i++) {&#xD;&#xA;        &#xD;&#xA;        var span_one = document.createElement(""span"");&#xD;&#xA;        span_one.id = ""span"" + i;&#xD;&#xA;        span_one.textContent = i; // use textContent when the value isn't HTML&#xD;&#xA;        out.appendChild(span_one);&#xD;&#xA;&#xD;&#xA;        if (isPrime(i)) { // where i is a prime number (3, 5, 7..etc)&#xD;&#xA;          span_one.style.backgroundColor = ""red"";&#xD;&#xA;          &#xD;&#xA;          span_one.onmouseover = function() {&#xD;&#xA;            hover(""span"" + i, ""yellow"", ""150%"")&#xD;&#xA;          };&#xD;&#xA;          &#xD;&#xA;          span_one.onmouseout = function() { &#xD;&#xA;            // whatever color in this line always overrides previous set color...&#xD;&#xA;            hover(""span"" + i, ""red"", ""100%"") &#xD;&#xA;          };&#xD;&#xA;          &#xD;&#xA;        }  // <-- Missing&#xD;&#xA;      }    // <-- Missing&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;      &#xD;&#xA;    function isPrime(value) {&#xD;&#xA;        for(var i = 2; i < value; i++) {&#xD;&#xA;            if(value % i === 0) {&#xD;&#xA;                return false;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return value > 1;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    function hover(id, color, size) {&#xD;&#xA;        var span = document.getElementById(id);&#xD;&#xA;        span.style.backgroundColor = color;&#xD;&#xA;        span.style.fontSize = size;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;<!-- language: lang-html -->&#xD;&#xA;&#xD;&#xA;    <div id=""output""></div>&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;";;
132500766;40825464;695364;5;3ada8d10-51c9-4aa5-9c5b-9daa651d7903;2016-11-27 03:36:24.0;"Your issue is that you have closures around your `i` variable. Changing `var i` to `let i` on your loop solves that.&#xD;&#xA;&#xD;&#xA;Also, I saw that you were missing two closing curly braces that were causing errors. I added my own `isPrime()` function. See comments for locations:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false console: true babel: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    window.onload=go;&#xD;&#xA;&#xD;&#xA;    const NUMBERS = 100;&#xD;&#xA;&#xD;&#xA;    function go(){&#xD;&#xA;&#xD;&#xA;        &#xD;&#xA;      var out = document.getElementById(""output"");&#xD;&#xA;      &#xD;&#xA;      // Using let instead of var avoids a closure by making sure&#xD;&#xA;      // that each looping number exists in the block scope of the&#xD;&#xA;      // loop and upon each iteration a new variable is created.&#xD;&#xA;      for (let i = 1; i < NUMBERS+1; i++) {&#xD;&#xA;        &#xD;&#xA;        var span = document.createElement(""span"");&#xD;&#xA;        span.id = ""span"" + i;&#xD;&#xA;        console.log(i, span.id);&#xD;&#xA;        span.textContent = i; // use textContent when the value isn't HTML&#xD;&#xA;        out.appendChild(span);&#xD;&#xA;&#xD;&#xA;        if (isPrime(i)) { // where i is a prime number (2, 3, 5, 7..etc)&#xD;&#xA;          span.style.backgroundColor = ""red"";&#xD;&#xA;          &#xD;&#xA;          // If you use the i variable in nested functions, you will create a&#xD;&#xA;          // closure around it and both the mouseover and mouseout functions will&#xD;&#xA;          // share the last known value of i. Each function must get its own copy&#xD;&#xA;          // of i.&#xD;&#xA;          span.onmouseover = function() {&#xD;&#xA;              hover(""span"" + i, ""yellow"", ""150%"")&#xD;&#xA;          };&#xD;&#xA;          &#xD;&#xA;          span.onmouseout = function() { &#xD;&#xA;            // whatever color in this line always overrides previous set color...&#xD;&#xA;            hover(""span"" + i, ""red"", ""100%"") &#xD;&#xA;          };&#xD;&#xA;          &#xD;&#xA;        }  // <-- Missing&#xD;&#xA;      }    // <-- Missing&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;      &#xD;&#xA;    function isPrime(value) {&#xD;&#xA;        for(var i = 2; i < value; i++) {&#xD;&#xA;            if(value % i === 0) {&#xD;&#xA;                return false;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return value > 1;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    function hover(id, color, size) {&#xD;&#xA;        var span = document.getElementById(id);&#xD;&#xA;        console.log(id, span);&#xD;&#xA;        span.style.backgroundColor = color;&#xD;&#xA;        span.style.fontSize = size;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;<!-- language: lang-html -->&#xD;&#xA;&#xD;&#xA;    <div id=""output""></div>&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;";;added 479 characters in body
132500967;40825464;695364;5;ba4a253d-d0e0-4155-9392-b3268de84692;2016-11-27 03:49:13.0;"> **Your issue is that you have closures around your `i` variable.**&#xD;&#xA;&#xD;&#xA;Closures occur whenever you nest a function within another function. **Where the code runs unpredictably is when the nested function uses a variable from an ancestor function and the nested function has a longer lifetime than the ancestor in question.** &#xD;&#xA;&#xD;&#xA;Here, your `mouseover` and `mouseout` functions rely on `i` from the parent function `go`. Since the `mouseover` and `mouseout` functions are being attached to DOM elements and those DOM elements are going to remain in memory until the page is unloaded, those functions will have a longer lifetime than `go`. This means that the `i` variable that `go` declared can't go out of scope when `go` completes and that both of the mouse functions will SHARE the same value of `i`.  Since the last prime generated is 51, that is the value that `i` has by the time a human comes along and moves the mouse.&#xD;&#xA;&#xD;&#xA;Closures can be challenging at first, but you can read a bit more about them [here][1].&#xD;&#xA;&#xD;&#xA;Changing `var i` to `let i` on your loop solves that because `let` introduces block scope for each iteration of the loop.&#xD;&#xA;&#xD;&#xA;Also, I saw that you were missing two closing curly braces that were causing errors. I added my own `isPrime()` function. See comments for locations:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false console: true babel: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    window.onload=go;&#xD;&#xA;&#xD;&#xA;    const NUMBERS = 100;&#xD;&#xA;&#xD;&#xA;    function go(){&#xD;&#xA;&#xD;&#xA;        &#xD;&#xA;      var out = document.getElementById(""output"");&#xD;&#xA;      &#xD;&#xA;      // Using let instead of var avoids a closure by making sure&#xD;&#xA;      // that each looping number exists in the block scope of the&#xD;&#xA;      // loop and upon each iteration a new variable is created.&#xD;&#xA;      for (let i = 1; i < NUMBERS+1; i++) {&#xD;&#xA;        &#xD;&#xA;        var span = document.createElement(""span"");&#xD;&#xA;        span.id = ""span"" + i;&#xD;&#xA;        console.log(i, span.id);&#xD;&#xA;        span.textContent = i; // use textContent when the value isn't HTML&#xD;&#xA;        out.appendChild(span);&#xD;&#xA;&#xD;&#xA;        if (isPrime(i)) { // where i is a prime number (2, 3, 5, 7..etc)&#xD;&#xA;          span.style.backgroundColor = ""red"";&#xD;&#xA;          &#xD;&#xA;          // If you use the i variable in nested functions, you will create a&#xD;&#xA;          // closure around it and both the mouseover and mouseout functions will&#xD;&#xA;          // share the last known value of i. Each function must get its own copy&#xD;&#xA;          // of i.&#xD;&#xA;          span.onmouseover = function() {&#xD;&#xA;              hover(""span"" + i, ""yellow"", ""150%"")&#xD;&#xA;          };&#xD;&#xA;          &#xD;&#xA;          span.onmouseout = function() { &#xD;&#xA;            // whatever color in this line always overrides previous set color...&#xD;&#xA;            hover(""span"" + i, ""red"", ""100%"") &#xD;&#xA;          };&#xD;&#xA;          &#xD;&#xA;        }  // <-- Missing&#xD;&#xA;      }    // <-- Missing&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;      &#xD;&#xA;    function isPrime(value) {&#xD;&#xA;        for(var i = 2; i < value; i++) {&#xD;&#xA;            if(value % i === 0) {&#xD;&#xA;                return false;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return value > 1;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    function hover(id, color, size) {&#xD;&#xA;        var span = document.getElementById(id);&#xD;&#xA;        console.log(id, span);&#xD;&#xA;        span.style.backgroundColor = color;&#xD;&#xA;        span.style.fontSize = size;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;<!-- language: lang-html -->&#xD;&#xA;&#xD;&#xA;    <div id=""output""></div>&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/40821499/what-is-missing-from-this-description-for-nested-functions-and-closures-at-mozil/40821712#40821712";;added 1092 characters in body
132501325;40825464;695364;5;da2bfc5e-10f8-4a6f-8823-1bb9b6266192;2016-11-27 04:10:00.0;"> **Your issue is that you have closures around your `i` variable.**&#xD;&#xA;&#xD;&#xA;Closures occur whenever you nest a function within another function. **Where the code runs unpredictably is when the nested function uses a variable from an ancestor function and the nested function has a longer lifetime than the ancestor in question.** &#xD;&#xA;&#xD;&#xA;Here, your `mouseover` and `mouseout` functions rely on `i` from the parent function `go`. Since the `mouseover` and `mouseout` functions are being attached to DOM elements and those DOM elements are going to remain in memory until the page is unloaded, those functions will have a longer lifetime than `go`. This means that the `i` variable that `go` declared can't go out of scope when `go` completes and that both of the mouse functions will SHARE the same value of `i`.  The value that `i` has by the time a human comes along and moves the mouse is the LAST value it had when the loop ended.&#xD;&#xA;&#xD;&#xA;Closures can be challenging at first, but you can read a bit more about them [here][1].&#xD;&#xA;&#xD;&#xA;Changing `var i` to `let i` on your loop solves that because `let` introduces block scope for each iteration of the loop.&#xD;&#xA;&#xD;&#xA;Also, I saw that you were missing two closing curly braces that were causing errors. I added my own `isPrime()` function. See comments for locations:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false console: true babel: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    window.onload=go;&#xD;&#xA;&#xD;&#xA;    const NUMBERS = 100;&#xD;&#xA;&#xD;&#xA;    function go(){&#xD;&#xA;&#xD;&#xA;        &#xD;&#xA;      var out = document.getElementById(""output"");&#xD;&#xA;      &#xD;&#xA;      // Using let instead of var avoids a closure by making sure&#xD;&#xA;      // that each looping number exists in the block scope of the&#xD;&#xA;      // loop and upon each iteration a new variable is created.&#xD;&#xA;      for (let i = 1; i < NUMBERS+1; i++) {&#xD;&#xA;        &#xD;&#xA;        var span = document.createElement(""span"");&#xD;&#xA;        span.id = ""span"" + i;&#xD;&#xA;        console.log(i, span.id);&#xD;&#xA;        span.textContent = i; // use textContent when the value isn't HTML&#xD;&#xA;        out.appendChild(span);&#xD;&#xA;&#xD;&#xA;        if (isPrime(i)) { // where i is a prime number (2, 3, 5, 7..etc)&#xD;&#xA;          span.style.backgroundColor = ""red"";&#xD;&#xA;          &#xD;&#xA;          // If you use the i variable in nested functions, you will create a&#xD;&#xA;          // closure around it and both the mouseover and mouseout functions will&#xD;&#xA;          // share the last known value of i. Each function must get its own copy&#xD;&#xA;          // of i.&#xD;&#xA;          span.onmouseover = function() {&#xD;&#xA;              hover(""span"" + i, ""yellow"", ""150%"")&#xD;&#xA;          };&#xD;&#xA;          &#xD;&#xA;          span.onmouseout = function() { &#xD;&#xA;            // whatever color in this line always overrides previous set color...&#xD;&#xA;            hover(""span"" + i, ""red"", ""100%"") &#xD;&#xA;          };&#xD;&#xA;          &#xD;&#xA;        }  // <-- Missing&#xD;&#xA;      }    // <-- Missing&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;      &#xD;&#xA;    function isPrime(value) {&#xD;&#xA;        for(var i = 2; i < value; i++) {&#xD;&#xA;            if(value % i === 0) {&#xD;&#xA;                return false;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return value > 1;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    function hover(id, color, size) {&#xD;&#xA;        var span = document.getElementById(id);&#xD;&#xA;        console.log(id, span);&#xD;&#xA;        span.style.backgroundColor = color;&#xD;&#xA;        span.style.fontSize = size;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;<!-- language: lang-html -->&#xD;&#xA;&#xD;&#xA;    <div id=""output""></div>&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/40821499/what-is-missing-from-this-description-for-nested-functions-and-closures-at-mozil/40821712#40821712";;deleted 1 character in body
132501812;40825464;695364;5;5ad66307-62e3-4388-a1ba-7ec06bdc16f0;2016-11-27 04:36:00.0;"> **Your issue is that you have closures around your `i` variable.**&#xD;&#xA;&#xD;&#xA;Closures occur whenever you nest a function within another function. **Where the code runs unpredictably is when the nested function uses a variable from an ancestor function and the nested function has a longer lifetime than the ancestor in question.** &#xD;&#xA;&#xD;&#xA;Here, your `mouseover` and `mouseout` functions rely on `i` from the parent function `go`. Since the `mouseover` and `mouseout` functions are being attached to DOM elements and those DOM elements are going to remain in memory until the page is unloaded, those functions will have a longer lifetime than `go`. This means that the `i` variable that `go` declared can't go out of scope when `go` completes and that both of the mouse functions will SHARE the same value of `i`.  The value that `i` has by the time a human comes along and moves the mouse is the LAST value it had when the loop ended.&#xD;&#xA;&#xD;&#xA;Closures can be challenging at first, but you can read a bit more about them [here][1].&#xD;&#xA;&#xD;&#xA;Changing `var i` to `let i` on your loop solves that because `let` introduces block scope for each iteration of the loop.&#xD;&#xA;&#xD;&#xA;Also, I saw that you were missing two closing curly braces that were causing errors. I added my own `isPrime()` function. See comments for locations:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false console: true babel: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    window.onload=go;&#xD;&#xA;&#xD;&#xA;    const NUMBERS = 100;&#xD;&#xA;&#xD;&#xA;    function go(){&#xD;&#xA;&#xD;&#xA;        &#xD;&#xA;      var out = document.getElementById(""output"");&#xD;&#xA;      &#xD;&#xA;      // Using let instead of var avoids a closure by making sure&#xD;&#xA;      // that each looping number exists in the block scope of the&#xD;&#xA;      // loop and upon each iteration a new variable is created.&#xD;&#xA;      for (let i = 1; i < NUMBERS+1; i++) {&#xD;&#xA;        &#xD;&#xA;        var span = document.createElement(""span"");&#xD;&#xA;        span.id = ""span"" + i;&#xD;&#xA;&#xD;&#xA;        span.textContent = i; // use textContent when the value isn't HTML&#xD;&#xA;        out.appendChild(span);&#xD;&#xA;&#xD;&#xA;        if (isPrime(i)) { // where i is a prime number (2, 3, 5, 7..etc)&#xD;&#xA;          span.style.backgroundColor = ""red"";&#xD;&#xA;          &#xD;&#xA;          // If you use the i variable in nested functions, you will create a&#xD;&#xA;          // closure around it and both the mouseover and mouseout functions will&#xD;&#xA;          // share the last known value of i. Each function must get its own copy&#xD;&#xA;          // of i.&#xD;&#xA;          span.onmouseover = function() {&#xD;&#xA;              hover(""span"" + i, ""yellow"", ""150%"")&#xD;&#xA;          };&#xD;&#xA;          &#xD;&#xA;          span.onmouseout = function() { &#xD;&#xA;            // whatever color in this line always overrides previous set color...&#xD;&#xA;            hover(""span"" + i, ""red"", ""100%"") &#xD;&#xA;          };&#xD;&#xA;          &#xD;&#xA;        }  // <-- Missing&#xD;&#xA;      }    // <-- Missing&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;      &#xD;&#xA;    function isPrime(value) {&#xD;&#xA;        for(var i = 2; i < value; i++) {&#xD;&#xA;            if(value % i === 0) {&#xD;&#xA;                return false;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return value > 1;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    function hover(id, color, size) {&#xD;&#xA;        var span = document.getElementById(id);&#xD;&#xA;        span.style.backgroundColor = color;&#xD;&#xA;        span.style.fontSize = size;&#xD;&#xA;        console.log(id, span);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;<!-- language: lang-html -->&#xD;&#xA;&#xD;&#xA;    <div id=""output""></div>&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/40821499/what-is-missing-from-this-description-for-nested-functions-and-closures-at-mozil/40821712#40821712";;deleted 32 characters in body
132502139;40825464;695364;5;8d39c811-46a6-4421-802d-276fbf3525f8;2016-11-27 04:55:10.0;"> **Your issue is that you have closures around your `i` variable.**&#xD;&#xA;&#xD;&#xA;Closures occur whenever you nest a function within another function. **Where the code runs unpredictably is when the nested function uses a variable from an ancestor function and the nested function has a longer lifetime than the ancestor in question.** &#xD;&#xA;&#xD;&#xA;Here, your `mouseover` and `mouseout` functions rely on `i` from the parent function `go`. Since the `mouseover` and `mouseout` functions are being attached to DOM elements and those DOM elements are going to remain in memory until the page is unloaded, those functions will have a longer lifetime than `go`. This means that the `i` variable that `go` declared can't go out of scope when `go` completes and that both of the mouse functions will SHARE the same value of `i`.  The value that `i` has by the time a human comes along and moves the mouse is the LAST value it had when the loop ended.&#xD;&#xA;&#xD;&#xA;Closures can be challenging at first, but you can read a bit more about them [here][1].&#xD;&#xA;&#xD;&#xA;Changing `var i` to `let i` on your loop solves that because `let` introduces block scope for each iteration of the loop.&#xD;&#xA;&#xD;&#xA;Also, I saw that you were missing two closing curly braces that were causing errors. I added my own `isPrime()` function. See comments for locations:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false console: true babel: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    window.onload=go;&#xD;&#xA;&#xD;&#xA;    const NUMBERS = 100;&#xD;&#xA;&#xD;&#xA;    function go(){&#xD;&#xA;&#xD;&#xA;        &#xD;&#xA;      var out = document.getElementById(""output"");&#xD;&#xA;      &#xD;&#xA;      // Using let instead of var avoids a closure by making sure&#xD;&#xA;      // that each looping number exists in the block scope of the&#xD;&#xA;      // loop and upon each iteration a new variable is created.&#xD;&#xA;      for (let i = 1; i < NUMBERS+1; i++) {&#xD;&#xA;        &#xD;&#xA;        var span = document.createElement(""span"");&#xD;&#xA;        span.id = ""span"" + i;&#xD;&#xA;&#xD;&#xA;        span.innerHTML = i + ""<br>""; &#xD;&#xA;        out.appendChild(span);&#xD;&#xA;&#xD;&#xA;        if (isPrime(i)) { // where i is a prime number (2, 3, 5, 7..etc)&#xD;&#xA;          span.style.backgroundColor = ""red"";&#xD;&#xA;          &#xD;&#xA;          // If you use the i variable in nested functions, you will create a&#xD;&#xA;          // closure around it and both the mouseover and mouseout functions will&#xD;&#xA;          // share the last known value of i. Each function must get its own copy&#xD;&#xA;          // of i.&#xD;&#xA;          span.onmouseover = function() {&#xD;&#xA;              hover(""span"" + i, ""yellow"", ""150%"")&#xD;&#xA;          };&#xD;&#xA;          &#xD;&#xA;          span.onmouseout = function() { &#xD;&#xA;            // whatever color in this line always overrides previous set color...&#xD;&#xA;            hover(""span"" + i, ""red"", ""100%"") &#xD;&#xA;          };&#xD;&#xA;          &#xD;&#xA;        }  // <-- Missing&#xD;&#xA;      }    // <-- Missing&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;      &#xD;&#xA;    function isPrime(value) {&#xD;&#xA;        for(var i = 2; i < value; i++) {&#xD;&#xA;            if(value % i === 0) {&#xD;&#xA;                return false;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return value > 1;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    function hover(id, color, size) {&#xD;&#xA;        var span = document.getElementById(id);&#xD;&#xA;        span.style.backgroundColor = color;&#xD;&#xA;        span.style.fontSize = size;&#xD;&#xA;        console.log(id, span);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;<!-- language: lang-html -->&#xD;&#xA;&#xD;&#xA;    <div id=""output""></div>&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/40821499/what-is-missing-from-this-description-for-nested-functions-and-closures-at-mozil/40821712#40821712";;deleted 37 characters in body
147448048;40825464;-1;5;12d2df0e-da76-4b9b-835e-485acb59962f;2017-05-23 12:24:31.0;"> **Your issue is that you have closures around your `i` variable.**&#xD;&#xA;&#xD;&#xA;Closures occur whenever you nest a function within another function. **Where the code runs unpredictably is when the nested function uses a variable from an ancestor function and the nested function has a longer lifetime than the ancestor in question.** &#xD;&#xA;&#xD;&#xA;Here, your `mouseover` and `mouseout` functions rely on `i` from the parent function `go`. Since the `mouseover` and `mouseout` functions are being attached to DOM elements and those DOM elements are going to remain in memory until the page is unloaded, those functions will have a longer lifetime than `go`. This means that the `i` variable that `go` declared can't go out of scope when `go` completes and that both of the mouse functions will SHARE the same value of `i`.  The value that `i` has by the time a human comes along and moves the mouse is the LAST value it had when the loop ended.&#xD;&#xA;&#xD;&#xA;Closures can be challenging at first, but you can read a bit more about them [here][1].&#xD;&#xA;&#xD;&#xA;Changing `var i` to `let i` on your loop solves that because `let` introduces block scope for each iteration of the loop.&#xD;&#xA;&#xD;&#xA;Also, I saw that you were missing two closing curly braces that were causing errors. I added my own `isPrime()` function. See comments for locations:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false console: true babel: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    window.onload=go;&#xD;&#xA;&#xD;&#xA;    const NUMBERS = 100;&#xD;&#xA;&#xD;&#xA;    function go(){&#xD;&#xA;&#xD;&#xA;        &#xD;&#xA;      var out = document.getElementById(""output"");&#xD;&#xA;      &#xD;&#xA;      // Using let instead of var avoids a closure by making sure&#xD;&#xA;      // that each looping number exists in the block scope of the&#xD;&#xA;      // loop and upon each iteration a new variable is created.&#xD;&#xA;      for (let i = 1; i < NUMBERS+1; i++) {&#xD;&#xA;        &#xD;&#xA;        var span = document.createElement(""span"");&#xD;&#xA;        span.id = ""span"" + i;&#xD;&#xA;&#xD;&#xA;        span.innerHTML = i + ""<br>""; &#xD;&#xA;        out.appendChild(span);&#xD;&#xA;&#xD;&#xA;        if (isPrime(i)) { // where i is a prime number (2, 3, 5, 7..etc)&#xD;&#xA;          span.style.backgroundColor = ""red"";&#xD;&#xA;          &#xD;&#xA;          // If you use the i variable in nested functions, you will create a&#xD;&#xA;          // closure around it and both the mouseover and mouseout functions will&#xD;&#xA;          // share the last known value of i. Each function must get its own copy&#xD;&#xA;          // of i.&#xD;&#xA;          span.onmouseover = function() {&#xD;&#xA;              hover(""span"" + i, ""yellow"", ""150%"")&#xD;&#xA;          };&#xD;&#xA;          &#xD;&#xA;          span.onmouseout = function() { &#xD;&#xA;            // whatever color in this line always overrides previous set color...&#xD;&#xA;            hover(""span"" + i, ""red"", ""100%"") &#xD;&#xA;          };&#xD;&#xA;          &#xD;&#xA;        }  // <-- Missing&#xD;&#xA;      }    // <-- Missing&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;      &#xD;&#xA;    function isPrime(value) {&#xD;&#xA;        for(var i = 2; i < value; i++) {&#xD;&#xA;            if(value % i === 0) {&#xD;&#xA;                return false;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return value > 1;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    function hover(id, color, size) {&#xD;&#xA;        var span = document.getElementById(id);&#xD;&#xA;        span.style.backgroundColor = color;&#xD;&#xA;        span.style.fontSize = size;&#xD;&#xA;        console.log(id, span);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;<!-- language: lang-html -->&#xD;&#xA;&#xD;&#xA;    <div id=""output""></div>&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://stackoverflow.com/questions/40821499/what-is-missing-from-this-description-for-nested-functions-and-closures-at-mozil/40821712#40821712";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
