Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
51373220;19951540;849891;2;592122c0-a88e-4bc9-8ddc-6f25fbba04c2;2013-11-13 10:39:56.0;"Imagine you are to go from a city **A** on the left, to a city **B**, on the right, and you want to know the distance between the two. How can you achieve this? &#xD;&#xA;&#xD;&#xA;A mathematician employs magic, known as [*structural recursion*][5]. He says to himself, what if I'll make one step towards the city **B**? I'll be closer to it! Then, having made that one step, I'll mumble a spell, spawn a copy of myself, and ask *it*, what is *its* distance from the city **B**! My second self will do the same, and will ask *his* copy to do the same, etc... But that's all right since the distance is finite, and all  the copies of me always take one step by themselves, before making the spell to spawn their copy. &#xD;&#xA;&#xD;&#xA;So there will come such time that a certain copy of me will actually find itself right at the city **B**'s gates - and won't have to take another step! &#xD;&#xA;&#xD;&#xA;So it'll report its finding as 0; and *its* caller will add 1 to that, and *its* caller will add 1 to *that*, etc. &#xD;&#xA;&#xD;&#xA;And when my 2nd self will report his findings to me, I will add 1 to that - since I'd made one step in the beginning before making the spell. And that will be the result, the distance I wanted to know.&#xD;&#xA;&#xD;&#xA;So I could then safely *start* a journey towards the city **B**, if I feel like it. :)&#xD;&#xA;&#xD;&#xA;That's how the [magician mathematician][3] thinks. But his [*dual*][4] the practical mathematician just goes on a journey. And counts his steps along the way. Now the journey may be finite, or it may be infinite - he has no way of knowing upfront. But when he will arrive at the city B's gates, he will know his distance traveled so far. And then he could decide to go on, or to stop. But he certainly won't have to go back all the way to the beginning of the road to tell himself the distance. &#xD;&#xA;&#xD;&#xA;And that's the difference between the structural recursion of the first, and guarded recursion &frasl; [tail recursion modulo cons][1] &frasl; [corecursion][2] employed by the 2nd.&#xD;&#xA;&#xD;&#xA; see also: &#xD;&#xA;&#xD;&#xA;* http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR19&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Tail_call#Tail_recursion_modulo_cons&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Corecursion&#xD;&#xA;  [3]: https://en.wikipedia.org/wiki/Catamorphism&#xD;&#xA;  [4]: https://en.wikipedia.org/wiki/Anamorphism&#xD;&#xA;  [5]: https://en.wikipedia.org/wiki/Fold_(higher-order_function)#Folds_as_structural_transformations";;
51373894;19951540;849891;5;1822ac83-f71d-46d4-acfb-04f5a84a639a;2013-11-13 10:48:33.0;"Imagine you are to go from a city **A** on the left, to a city **B**, on the right, and you want to know the distance between the two. How can you achieve this? &#xD;&#xA;&#xD;&#xA;A mathematician employs magic, known as [*structural recursion*][5]. He says to himself, what if I'll make one step towards the city **B**? I'll be closer to it! Then, having made that one step, I'll mumble a spell, spawn a copy of myself, and ask *it*, what is *its* distance from the city **B**! My second self will do the same, and will ask *his* copy to do the same, etc... But that's all right since the distance is finite, and all  the copies of me always take one step by themselves, before making the spell to spawn their copy. &#xD;&#xA;&#xD;&#xA;So there will come such time that a certain copy of me will actually find itself right at the city **B**'s gates - and won't have to take another step! &#xD;&#xA;&#xD;&#xA;So it'll report its finding as 0; and *its* caller will add 1 to that, and *its* caller will add 1 to *that*, etc. &#xD;&#xA;&#xD;&#xA;And when my 2nd self will report his findings to me, I will add 1 to that - since I'd made one step in the beginning before making the spell. And that will be the result, the distance I wanted to know.&#xD;&#xA;&#xD;&#xA;So I could then safely *start* a journey towards the city **B**, if I feel like it. :)&#xD;&#xA;&#xD;&#xA;That's how the [magician mathematician][3] thinks. But his [*dual*][4] the practical mathematician just goes on a journey. And counts his steps along the way. Now the journey may be finite, or it may be infinite - he has no way of knowing upfront. But when he will arrive at the city **B**'s gates, he will know his distance traveled so far. And then he could decide whether to go on, or to stop. But he certainly won't have to go back all the way to the beginning of the road to tell himself the distance. &#xD;&#xA;&#xD;&#xA;And that's the difference between the structural recursion of the first, and *guarded recursion &frasl; [tail recursion modulo cons][1] &frasl; [corecursion][2]* employed by the 2nd.&#xD;&#xA;&#xD;&#xA; see also: &#xD;&#xA;&#xD;&#xA;* http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR19&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Tail_call#Tail_recursion_modulo_cons&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Corecursion&#xD;&#xA;  [3]: https://en.wikipedia.org/wiki/Catamorphism&#xD;&#xA;  [4]: https://en.wikipedia.org/wiki/Anamorphism&#xD;&#xA;  [5]: https://en.wikipedia.org/wiki/Fold_(higher-order_function)#Folds_as_structural_transformations";;added 14 characters in body
51374720;19951540;849891;5;f8c45b80-7d10-4a20-bf05-980e3b531901;2013-11-13 11:00:57.0;"Imagine you are to go from a city **A** on the left, to a city **B**, on the right, and you want to know the distance between the two. How can you achieve this? &#xD;&#xA;&#xD;&#xA;A mathematician employs magic, known as [*structural recursion*][5]. He says to himself, what if I'll make one step towards the city **B**? I'll be closer to it! Then, having made that one step, I'll mumble a spell, spawn a copy of myself, and ask *it*, what is *its* distance from the city **B**! My second self will do the same, and will ask *his* copy to do the same, etc... But that's all right since the distance is finite, and all  the copies of me always take one step by themselves, before making the spell to spawn their copy. &#xD;&#xA;&#xD;&#xA;So there will come such time that a certain copy of me will actually find itself right at the city **B**'s gates - and won't have to take another step! &#xD;&#xA;&#xD;&#xA;So it'll report its finding as 0; and *its* caller will add 1 to that, and *its* caller will add 1 to *that*, etc. &#xD;&#xA;&#xD;&#xA;And when my 2nd self will report his findings to me, I will add 1 to that - since I'd made one step in the beginning before making the spell. And that will be the result, the distance I wanted to know.&#xD;&#xA;&#xD;&#xA;So I could then safely *start* a journey towards the city **B**, if I feel like it. :)&#xD;&#xA;&#xD;&#xA;That's how the [magician mathematician][3] thinks. But his [*dual*][4] the practical mathematician just goes on a journey. And counts his steps along the way. Now the journey may be finite, or it may be infinite - he has no way of knowing upfront. But when he will arrive at the city **B**'s gates, he will know his distance traveled so far. And then he could decide whether to go on, or to stop. But he certainly won't have to go back all the way to the beginning of the road to tell himself the distance. &#xD;&#xA;&#xD;&#xA;And that's the difference between the structural recursion of the first, and *guarded recursion &frasl; [tail recursion modulo cons][1] &frasl; [corecursion][2]* employed by the 2nd.&#xD;&#xA;&#xD;&#xA;see also: &#xD;&#xA;&#xD;&#xA;* [Technical Report TR19: Unwinding Structured Recursions into Iterations. <br /> Daniel P. Friedman and David S. Wise (Dec 1974)][6].&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Tail_call#Tail_recursion_modulo_cons&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Corecursion&#xD;&#xA;  [3]: https://en.wikipedia.org/wiki/Catamorphism&#xD;&#xA;  [4]: https://en.wikipedia.org/wiki/Anamorphism&#xD;&#xA;  [5]: https://en.wikipedia.org/wiki/Fold_(higher-order_function)#Folds_as_structural_transformations&#xD;&#xA;  [6]: http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR19";;added 140 characters in body
51404228;19951540;849891;5;0fcff345-59bc-4a04-8a0e-6cda79e75aac;2013-11-13 17:30:29.0;"Imagine you are to go from a city **A** on the left, to a city **B**, on the right, and you want to know the distance between the two. How can you achieve this? &#xD;&#xA;&#xD;&#xA;A *mathematician* in such a position employs magic known as [*structural recursion*][5]. He says to himself, what if I'll make one step towards the city **B**? I'll be closer to it! Then, having made that one step, I'll mumble a spell, spawn a copy of myself, and ask *it*, what is *its* distance from the city **B**! My second self will do the same, and will ask *his* copy to do the same, etc... But that's all right since the distance is finite, and all  the copies of me always take one step by themselves, before making the spell to spawn their copy. &#xD;&#xA;&#xD;&#xA;So there will come such time that a certain copy of me will actually find itself right at the city **B**'s gates - and won't have to take another step! So it'll report its finding as 0; and *its* caller will *then* add 1 to that, and *its* caller will *then* add 1 to *that*, etc. &#xD;&#xA;&#xD;&#xA;And ***after*** my 2nd self will have reported his findings to me (after having sent *his* copy forth and receiving the result back from it), I will add 1 to that - since I'd made one step in the beginning before making my first spell. And that will be the result, the distance I wanted to know. *(Each copy does exactly the same thing, of course, except the last one)*.&#xD;&#xA;&#xD;&#xA;That's how the [magician mathematician][3] thinks. But his [*dual*][4] the practical mathematician just goes on a journey, and counts his steps along the way, adding 1 to the current steps counter after each step ***before*** the rest of his journey. Now, the journey may be finite, or it may be infinite - he has no way of knowing upfront. But when he will arrive at the city **B**'s gates, he will know his distance traveled so far. And then he could decide whether to go on any further, or stop. But he certainly won't have to go back all the way to the beginning of the road to tell himself the distance.&#xD;&#xA;&#xD;&#xA;And that's the difference between the structural recursion of the first, and *guarded recursion &frasl; [tail recursion modulo cons][1] &frasl; [corecursion][2]* employed by the second. The first one builds up his knowledge on the way *back* from his goal; the second one on his way *towards* the goal.&#xD;&#xA;&#xD;&#xA;see also: &#xD;&#xA;&#xD;&#xA;* [Technical Report TR19: Unwinding Structured Recursions into Iterations. <br /> Daniel P. Friedman and David S. Wise (Dec 1974)][6].&#xD;&#xA; &#xD;&#xA;____&#xD;&#xA;What are the practical implications of all that, you ask? Why, imagine our friend the *magician* mathematician needs to boil some eggs. He has a pot; a faucet; a hot plate; and some eggs. What is he to do? &#xD;&#xA;&#xD;&#xA;Well, it's easy - he'll just put eggs into the pot, add some water from the faucet and will put it on the hot plate.&#xD;&#xA;&#xD;&#xA;And what if he's already given a pot with eggs and water in it? Why, it's even easier to him - he'll just take the eggs out, pour out the water, and will end up with the problem he already knows how to solve! Pure *magic*, isn't it!&#xD;&#xA;&#xD;&#xA;But before we laugh at the poor chap, [we mustn't forget][7] [the tale of the centipede][8]. Sometimes ignorance *is* bliss.&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Tail_call#Tail_recursion_modulo_cons&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Corecursion&#xD;&#xA;  [3]: https://en.wikipedia.org/wiki/Catamorphism&#xD;&#xA;  [4]: https://en.wikipedia.org/wiki/Anamorphism&#xD;&#xA;  [5]: https://en.wikipedia.org/wiki/Fold_(higher-order_function)#Folds_as_structural_transformations&#xD;&#xA;  [6]: http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR19&#xD;&#xA;  [7]: https://en.wikipedia.org/wiki/Analysis_paralysis&#xD;&#xA;  [8]: https://en.wikipedia.org/wiki/The_Centipede's_Dilemma&#xD;&#xA;";;added 1242 characters in body
51424100;19951540;849891;5;14ece0db-0ddd-4a08-9596-66c7209b1799;2013-11-13 22:48:23.0;"Imagine you are to go from a city **A** on the left, to a city **B**, on the right, and you want to know the distance between the two. How can you achieve this? &#xD;&#xA;&#xD;&#xA;A *mathematician* in such a position employs magic known as [*structural recursion*][5]. He says to himself, what if I'll make one step towards the city **B**? I'll be closer to it! Then, having made that one step, I'll mumble a spell, spawn a copy of myself, and ask *it*, what is *its* distance from the city **B**! My second self will do the same, and will ask *his* copy to do the same, etc... But that's all right since the distance is finite, and all  the copies of me always take one step by themselves, before making the spell to spawn their copy. &#xD;&#xA;&#xD;&#xA;So there will come such time that a certain copy of me will actually find itself right at the city **B**'s gates - and won't have to take another step! So it'll report its finding as 0; and *its* caller will *then* add 1 to that, and *its* caller will *then* add 1 to *that*, etc. &#xD;&#xA;&#xD;&#xA;And ***after*** my 2nd self will have reported his findings to me (after having sent *his* copy forth and receiving the result back from it), I will add 1 to that - since I'd made one step in the beginning before making my first spell. And that will be the result, the distance I wanted to know. *(Each copy does exactly the same thing, of course, except the last one)*.&#xD;&#xA;&#xD;&#xA;That's how the [magician mathematician][3] thinks. But his [*dual*][4] the practical mathematician just goes on a journey, and counts his steps along the way, adding 1 to *the current steps counter* on each step, ***before*** the rest of his journey. Now, the journey may be finite, or it may be infinite - he has no way of knowing upfront. But at each point along his route, and hence when he arrives at the city **B**'s gates too, he will know his distance traveled so far. And he certainly won't have to go back all the way to the beginning of the road to tell himself the result.&#xD;&#xA;&#xD;&#xA;And that's the difference between the structural recursion of the first, and *guarded recursion &frasl; [tail recursion modulo cons][1] &frasl; [corecursion][2]* employed by the second. The first one builds up his knowledge on the way ***back*** *from* his goal; the second one on his way ***forth*** from the starting point, *towards* the goal.&#xD;&#xA;&#xD;&#xA;see also: &#xD;&#xA;&#xD;&#xA;* [Technical Report TR19: Unwinding Structured Recursions into Iterations. <br /> Daniel P. Friedman and David S. Wise (Dec 1974)][6].&#xD;&#xA; &#xD;&#xA;____&#xD;&#xA;What are the practical implications of all that, you ask? Why, imagine our friend the *magician* mathematician needs to boil some eggs. He has a pot; a faucet; a hot plate; and some eggs. What is he to do? &#xD;&#xA;&#xD;&#xA;Well, it's easy - he'll just put eggs into the pot, add some water from the faucet and will put it on the hot plate.&#xD;&#xA;&#xD;&#xA;And what if he's already given a pot with eggs and water in it? Why, it's even easier to him - he'll just take the eggs out, pour out the water, and will end up with the problem he already knows how to solve! Pure *magic*, isn't it!&#xD;&#xA;&#xD;&#xA;But before we laugh at the poor chap, [we mustn't forget][7] [the tale of the centipede][8]. Sometimes ignorance *is* bliss.&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Tail_call#Tail_recursion_modulo_cons&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Corecursion&#xD;&#xA;  [3]: https://en.wikipedia.org/wiki/Catamorphism&#xD;&#xA;  [4]: https://en.wikipedia.org/wiki/Anamorphism&#xD;&#xA;  [5]: https://en.wikipedia.org/wiki/Fold_(higher-order_function)#Folds_as_structural_transformations&#xD;&#xA;  [6]: http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR19&#xD;&#xA;  [7]: https://en.wikipedia.org/wiki/Analysis_paralysis&#xD;&#xA;  [8]: https://en.wikipedia.org/wiki/The_Centipede's_Dilemma&#xD;&#xA;";;added 18 characters in body
53573740;19951540;849891;5;8970b597-96c5-431c-971c-644f6ac8a60b;2013-12-13 13:06:37.0;"***TL;DR***: yes, they are.&#xD;&#xA;&#xD;&#xA;Imagine you are to go from a city **A** on the left to a city **B** on the right, and you want to know the distance between the two in advance. How are you to achieve this? &#xD;&#xA;&#xD;&#xA;A [*mathematician*][9] in such a position employs magic known as [*structural recursion*][5]. He says to himself, what if I'll send my own copy one step closer *towards* the city **B**, and ask *it* of *its* distance to the city? I will then add 1 to its result, ***after*** receiving it from my copy, since I have sent it *one* step *closer* towards the city, and will know my answer without having moved an inch! Of course if I am already at the city gates, I won't send any copies of me anywhere since I'll know that the distance is 0 - without having moved an inch! &#xD;&#xA;&#xD;&#xA;And how do I know that my *copy-of-me* will succeed? Simply because he will follow the same exact rules, while starting from a point *closer* to our destination. Whatever value my answer will be, *his* will be one less, and only a finite number of copies of us will be called into action - because the distance between the cities is finite. So the total operation is certain to complete in a finite amount of time and I *will* get my answer. Because getting your answer after an infinite time has passed, is not getting it at all - ever.&#xD;&#xA;&#xD;&#xA;And now, having found out his answer in advance, our cautious magician mathematician is ready to embark on his safe (now!) journey.&#xD;&#xA;&#xD;&#xA;But that of course wasn't magic at all - it's all being a dirty trick! He didn't find out the answer in advance out of thin air - he has sent out the whole *stack* of others to find it for him. The grueling work needed to be done after all, he just pretended not to be aware of it. The distance *was* traveled. Moreover, the distance *back* had to be traveled too, for each copy to tell their result to their master, the result being actually created on the way ***back*** from the destination. All this before our fake magician had ever started walking himself. How's *that* for a team effort. For *him* it could seem like a sweet deal. But overall...&#xD;&#xA;____&#xD;&#xA;So that's how the [magician mathematician][3] thinks. But his [*dual*][10] the brave traveler just [goes on a journey][4], and counts his steps along the way, adding 1 to *the current steps counter* on each step, ***before*** the rest of his actual journey. There's no pretense anymore. The journey may be finite, or it may be infinite - he has no way of knowing upfront. But at each point along his route, and hence when &frasl; if he arrives at the city **B** gates too, he will know his distance traveled so far. And he certainly won't have to go back all the way to the beginning of the road to tell himself the result. &#xD;&#xA;&#xD;&#xA;And that's the difference between the structural recursion of the first, and *[tail recursion with accumulator][11] &frasl; [tail recursion modulo cons][1] &frasl; [corecursion][2]* employed by the second. The knowledge of the first is built on the way back *from* the goal; of the second - on the way ***forth*** from the starting point, *towards* the goal.&#xD;&#xA;&#xD;&#xA;see also: &#xD;&#xA;&#xD;&#xA;* [Technical Report TR19: Unwinding Structured Recursions into Iterations. <br /> Daniel P. Friedman and David S. Wise (Dec 1974)][6].&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;<!--&#xD;&#xA;____&#xD;&#xA;What are the practical implications of all that, you ask? Why, imagine our friend the *magician* mathematician needs to boil some eggs. He has a pot; a faucet; a hot plate; and some eggs. What is he to do? &#xD;&#xA;&#xD;&#xA;Well, it's easy - he'll just put eggs into the pot, add some water from the faucet into it  and will put it on the hot plate.&#xD;&#xA;&#xD;&#xA;And what if he's already given a pot with eggs and water in it? Why, it's even easier to him - he'll just take the eggs out, pour out the water, and will end up with the problem he already knows how to solve! Pure *magic*, isn't it!&#xD;&#xA;&#xD;&#xA;Before we laugh at the poor chap, [we mustn't forget][7] [the tale of the centipede][8]. Sometimes ignorance *is* bliss. But when the required knowledge is simple and ""one-dimensional"" like the *distance* here, it'd be a crime to pretend to have no memory at all.&#xD;&#xA;-->&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Tail_call#Tail_recursion_modulo_cons&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Corecursion&#xD;&#xA;  [3]: http://en.wikipedia.org/wiki/Catamorphism&#xD;&#xA;  [4]: http://en.wikipedia.org/wiki/Anamorphism&#xD;&#xA;  [5]: http://en.wikipedia.org/wiki/Fold_(higher-order_function)#Folds_as_structural_transformations&#xD;&#xA;  [6]: http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR19&#xD;&#xA;  [7]: http://en.wikipedia.org/wiki/Analysis_paralysis&#xD;&#xA;  [8]: http://en.wikipedia.org/wiki/The_Centipede's_Dilemma&#xD;&#xA;  [9]: http://en.wikipedia.org/wiki/Structural_induction&#xD;&#xA;  [10]: http://en.wikipedia.org/wiki/Coinduction&#xD;&#xA;  [11]: http://en.wikipedia.org/wiki/Tail_call";;added 1097 characters in body
56566698;19951540;849891;5;68d31c4e-b039-40b3-8e93-00c83756b597;2014-01-27 09:09:05.0;"***TL;DR***: yes, they are.&#xD;&#xA;&#xD;&#xA;Imagine you are to go from a city **A** on the left to a city **B** on the right, and you want to know the distance between the two in advance. How are you to achieve this? &#xD;&#xA;&#xD;&#xA;A [*mathematician*][9] in such a position employs magic known as [*structural recursion*][5]. He says to himself, what if I'll send my own copy one step closer *towards* the city **B**, and ask *it* of *its* distance to the city? I will then add 1 to its result, ***after*** receiving it from my copy, since I have sent it *one* step *closer* towards the city, and will know my answer without having moved an inch! Of course if I am already at the city gates, I won't send any copies of me anywhere since I'll know that the distance is 0 - without having moved an inch! &#xD;&#xA;&#xD;&#xA;And how do I know that my *copy-of-me* will succeed? Simply because he will follow the same exact rules, while starting from a point *closer* to our destination. Whatever value my answer will be, *his* will be one less, and only a finite number of copies of us will be called into action - because the distance between the cities is finite. So the total operation is certain to complete in a finite amount of time and I *will* get my answer. Because getting your answer after an infinite time has passed, is not getting it at all - ever.&#xD;&#xA;&#xD;&#xA;And now, having found out his answer in advance, our cautious magician mathematician is ready to embark on his safe (now!) journey.&#xD;&#xA;&#xD;&#xA;But that of course wasn't magic at all - it's all being a dirty trick! He didn't find out the answer in advance out of thin air - he has sent out the whole *stack* of others to find it for him. The grueling work had to be done after all, he just pretended not to be aware of it. The distance *was* traveled. Moreover, the distance *back* had to be traveled too, for each copy to tell their result to their master, the result being actually created on the way ***back*** from the destination. All this before our fake magician had ever started walking himself. How's *that* for a team effort. For *him* it could seem like a sweet deal. But overall...&#xD;&#xA;____&#xD;&#xA;So that's how the [magician mathematician][3] thinks. But his [*dual*][10] the brave traveler just [goes on a journey][4], and counts his steps along the way, adding 1 to *the current steps counter* on each step, ***before*** the rest of his actual journey. There's no pretense anymore. The journey may be finite, or it may be infinite - he has no way of knowing upfront. But at each point along his route, and hence when &frasl; if he arrives at the city **B** gates too, he will know his distance traveled so far. And he certainly won't have to go back all the way to the beginning of the road to tell himself the result. &#xD;&#xA;&#xD;&#xA;And that's the difference between the structural recursion of the first, and *[tail recursion with accumulator][11] &frasl; [tail recursion modulo cons][1] &frasl; [corecursion][2]* employed by the second. The knowledge of the first is built on the way back *from* the goal; of the second - on the way ***forth*** from the starting point, *towards* the goal.&#xD;&#xA;&#xD;&#xA;see also: &#xD;&#xA;&#xD;&#xA;* [Technical Report TR19: Unwinding Structured Recursions into Iterations. <br /> Daniel P. Friedman and David S. Wise (Dec 1974)][6].&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;<!--&#xD;&#xA;____&#xD;&#xA;What are the practical implications of all that, you ask? Why, imagine our friend the *magician* mathematician needs to boil some eggs. He has a pot; a faucet; a hot plate; and some eggs. What is he to do? &#xD;&#xA;&#xD;&#xA;Well, it's easy - he'll just put eggs into the pot, add some water from the faucet into it  and will put it on the hot plate.&#xD;&#xA;&#xD;&#xA;And what if he's already given a pot with eggs and water in it? Why, it's even easier to him - he'll just take the eggs out, pour out the water, and will end up with the problem he already knows how to solve! Pure *magic*, isn't it!&#xD;&#xA;&#xD;&#xA;Before we laugh at the poor chap, [we mustn't forget][7] [the tale of the centipede][8]. Sometimes ignorance *is* bliss. But when the required knowledge is simple and ""one-dimensional"" like the *distance* here, it'd be a crime to pretend to have no memory at all.&#xD;&#xA;-->&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Tail_call#Tail_recursion_modulo_cons&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Corecursion&#xD;&#xA;  [3]: http://en.wikipedia.org/wiki/Catamorphism&#xD;&#xA;  [4]: http://en.wikipedia.org/wiki/Anamorphism&#xD;&#xA;  [5]: http://en.wikipedia.org/wiki/Fold_(higher-order_function)#Folds_as_structural_transformations&#xD;&#xA;  [6]: http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR19&#xD;&#xA;  [7]: http://en.wikipedia.org/wiki/Analysis_paralysis&#xD;&#xA;  [8]: http://en.wikipedia.org/wiki/The_Centipede's_Dilemma&#xD;&#xA;  [9]: http://en.wikipedia.org/wiki/Structural_induction&#xD;&#xA;  [10]: http://en.wikipedia.org/wiki/Coinduction&#xD;&#xA;  [11]: http://en.wikipedia.org/wiki/Tail_call";;c/e
69140828;19951540;849891;5;7d00720f-fb24-4b9c-acd3-c1f7bb45c196;2014-07-11 14:09:06.0;"***TL;DR***: yes, they are.&#xD;&#xA;&#xD;&#xA;Imagine you are to go from a city **A** on the left to a city **B** on the right, and you want to know the distance between the two in advance. How are you to achieve this? &#xD;&#xA;&#xD;&#xA;A [*mathematician*][9] in such a position employs magic known as [*structural recursion*][5]. He says to himself, what if I'll send my own copy one step closer *towards* the city **B**, and ask *it* of *its* distance to the city? I will then add 1 to its result, ***after*** receiving it from my copy, since I have sent it *one* step *closer* towards the city, and will know my answer without having moved an inch! Of course if I am already at the city gates, I won't send any copies of me anywhere since I'll know that the distance is 0 - without having moved an inch! &#xD;&#xA;&#xD;&#xA;And how do I know that my *copy-of-me* will succeed? Simply because he will follow the same exact rules, while starting from a point *closer* to our destination. Whatever value my answer will be, *his* will be one less, and only a finite number of copies of us will be called into action - because the distance between the cities is finite. So the total operation is certain to complete in a finite amount of time and I *will* get my answer. Because getting your answer after an infinite time has passed, is not getting it at all - ever.&#xD;&#xA;&#xD;&#xA;And now, having found out his answer in advance, our cautious magician mathematician is ready to embark on his safe (now!) journey.&#xD;&#xA;&#xD;&#xA;But that of course wasn't magic at all - it's all being a dirty trick! He didn't find out the answer in advance out of thin air - he has sent out the whole *stack* of others to find it for him. The grueling work had to be done after all, he just pretended not to be aware of it. The distance *was* traveled. Moreover, the distance *back* had to be traveled too, for each copy to tell their result to their master, the result being actually created on the way ***back*** from the destination. All this before our fake magician had ever started walking himself. How's *that* for a team effort. For *him* it could seem like a sweet deal. But overall...&#xD;&#xA;____&#xD;&#xA;So that's how the [magician mathematician][3] thinks. But his [*dual*][10] the brave traveler just [goes on a journey][4], and counts his steps along the way, adding 1 to *the current steps counter* on each step, ***before*** the rest of his actual journey. There's no pretense anymore. The journey may be finite, or it may be infinite - he has no way of knowing upfront. But at each point along his route, and hence when &frasl; if he arrives at the city **B** gates too, he will know his distance traveled so far. And he certainly won't have to go back all the way to the beginning of the road to tell himself the result. &#xD;&#xA;&#xD;&#xA;And that's the difference between the structural recursion of the first, and *[tail recursion with accumulator][11] &frasl; [tail recursion modulo cons][1] &frasl; [corecursion][2]* employed by the second. The knowledge of the first is built on the way back *from* the goal; of the second - on the way ***forth*** from the starting point, *towards* the goal.&#xD;&#xA;&#xD;&#xA;see also: &#xD;&#xA;&#xD;&#xA;* [Technical Report TR19: Unwinding Structured Recursions into Iterations. <br /> Daniel P. Friedman and David S. Wise (Dec 1974)][6].&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;____&#xD;&#xA;What are the practical implications of all that, you ask? Why, imagine our friend the *magician* mathematician needs to boil some eggs. He has a pot; a faucet; a hot plate; and some eggs. What is he to do? &#xD;&#xA;&#xD;&#xA;Well, it's easy - he'll just put eggs into the pot, add some water from the faucet into it  and will put it on the hot plate.&#xD;&#xA;&#xD;&#xA;And what if he's already given a pot with eggs and water in it? Why, it's even easier to him - he'll just take the eggs out, pour out the water, and will end up with the problem he already knows how to solve! Pure *magic*, isn't it!&#xD;&#xA;&#xD;&#xA;Before we laugh at the poor chap, [we mustn't forget][7] [the tale of the centipede][8]. Sometimes ignorance *is* bliss. But when the required knowledge is simple and ""one-dimensional"" like *the distance* here, it'd be a crime to pretend to have no memory at all.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Tail_call#Tail_recursion_modulo_cons&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Corecursion&#xD;&#xA;  [3]: http://en.wikipedia.org/wiki/Catamorphism&#xD;&#xA;  [4]: http://en.wikipedia.org/wiki/Anamorphism&#xD;&#xA;  [5]: http://en.wikipedia.org/wiki/Fold_(higher-order_function)#Folds_as_structural_transformations&#xD;&#xA;  [6]: http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR19&#xD;&#xA;  [7]: http://en.wikipedia.org/wiki/Analysis_paralysis&#xD;&#xA;  [8]: http://en.wikipedia.org/wiki/The_Centipede's_Dilemma&#xD;&#xA;  [9]: http://en.wikipedia.org/wiki/Structural_induction&#xD;&#xA;  [10]: http://en.wikipedia.org/wiki/Coinduction&#xD;&#xA;  [11]: http://en.wikipedia.org/wiki/Tail_call";;deleted 7 characters in body
97647509;19951540;849891;5;51e60058-2823-4868-9023-50e6a279c9ed;2015-08-18 09:48:44.0;"***TL;DR***: yes, they are.&#xD;&#xA;&#xD;&#xA;Imagine you are to go from a city **A** on the left to a city **B** on the right, and you want to know the distance between the two in advance. How are you to achieve this? &#xD;&#xA;&#xD;&#xA;A [*mathematician*][9] in such a position employs magic known as [*structural recursion*][5]. He says to himself, what if I'll send my own copy one step closer *towards* the city **B**, and ask *it* of *its* distance to the city? I will then add 1 to its result, ***after*** receiving it from my copy, since I have sent it *one* step *closer* towards the city, and will know my answer without having moved an inch! Of course if I am already at the city gates, I won't send any copies of me anywhere since I'll know that the distance is 0 - without having moved an inch! &#xD;&#xA;&#xD;&#xA;And how do I know that my *copy-of-me* will succeed? Simply because he will follow the same exact rules, while starting from a point *closer* to our destination. Whatever value my answer will be, *his* will be one less, and only a finite number of copies of us will be called into action - because the distance between the cities is finite. So the total operation is certain to complete in a finite amount of time and I *will* get my answer. Because getting your answer after an infinite time has passed, is not getting it at all - ever.&#xD;&#xA;&#xD;&#xA;And now, having found out his answer in advance, our cautious magician mathematician is ready to embark on his safe (now!) journey.&#xD;&#xA;&#xD;&#xA;But that of course wasn't magic at all - it's all being a dirty trick! He didn't find out the answer in advance out of thin air - he has sent out the whole *stack* of others to find it for him. The grueling work had to be done after all, he just pretended not to be aware of it. The distance *was* traveled. Moreover, the distance *back* had to be traveled too, for each copy to tell their result to their master, the result being actually created on the way ***back*** from the destination. All this before our fake magician had ever started walking himself. How's *that* for a team effort. For *him* it could seem like a sweet deal. But overall...&#xD;&#xA;____&#xD;&#xA;So that's how the [magician mathematician][3] thinks. But his [*dual*][10] the brave traveler just [goes on a journey][4], and counts his steps along the way, adding 1 to *the current steps counter* on each step, ***before*** the rest of his actual journey. There's no pretense anymore. The journey may be finite, or it may be infinite - he has no way of knowing upfront. But at each point along his route, and hence when &frasl; if he arrives at the city **B** gates too, he will know his distance traveled so far. And he certainly won't have to go back all the way to the beginning of the road to tell himself the result. &#xD;&#xA;&#xD;&#xA;And that's the difference between the structural recursion of the first, and *[tail recursion with accumulator][11] &frasl; [tail recursion modulo cons][1] &frasl; [corecursion][2]* employed by the second. The knowledge of the first is built on the way back *from* the goal; of the second - on the way ***forth*** from the starting point, *towards* the goal.&#xD;&#xA;&#xD;&#xA;see also: &#xD;&#xA;&#xD;&#xA;* [Technical Report TR19: Unwinding Structured Recursions into Iterations. <br /> Daniel P. Friedman and David S. Wise (Dec 1974)][6].&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;____&#xD;&#xA;What are the practical implications of all this, you ask? Why, imagine our friend the *magician* mathematician needs to boil some eggs. He has a pot; a faucet; a hot plate; and some eggs. What is he to do? &#xD;&#xA;&#xD;&#xA;Well, it's easy - he'll just put eggs into the pot, add some water from the faucet into it  and will put it on the hot plate.&#xD;&#xA;&#xD;&#xA;And what if he's already given a pot with eggs and water in it? Why, it's even easier to him - he'll just take the eggs out, pour out the water, and will end up with the problem he already knows how to solve! Pure *magic*, isn't it!&#xD;&#xA;&#xD;&#xA;Before we laugh at the poor chap, [we mustn't forget][7] [the tale of the centipede][8]. Sometimes ignorance *is* bliss. But when the required knowledge is simple and ""one-dimensional"" like *the distance* here, it'd be a crime to pretend to have no memory at all.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Tail_call#Tail_recursion_modulo_cons&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Corecursion&#xD;&#xA;  [3]: http://en.wikipedia.org/wiki/Catamorphism&#xD;&#xA;  [4]: http://en.wikipedia.org/wiki/Anamorphism&#xD;&#xA;  [5]: http://en.wikipedia.org/wiki/Fold_(higher-order_function)#Folds_as_structural_transformations&#xD;&#xA;  [6]: http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR19&#xD;&#xA;  [7]: http://en.wikipedia.org/wiki/Analysis_paralysis&#xD;&#xA;  [8]: http://en.wikipedia.org/wiki/The_Centipede's_Dilemma&#xD;&#xA;  [9]: http://en.wikipedia.org/wiki/Structural_induction&#xD;&#xA;  [10]: http://en.wikipedia.org/wiki/Coinduction&#xD;&#xA;  [11]: http://en.wikipedia.org/wiki/Tail_call";;typo
