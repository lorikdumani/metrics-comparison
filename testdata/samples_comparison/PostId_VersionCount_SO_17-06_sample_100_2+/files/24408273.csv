Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
68023489;24408273;564092;2;ccc3c47f-7cf8-4d36-92be-f63da58cac60;2014-06-25 12:08:19.0;"You don't need the IDE to generate and process templates at runtime. &#xD;&#xA;&#xD;&#xA;    Engine engine = new Engine();&#xD;&#xA;    &#xD;&#xA;    //read the text template&#xD;&#xA;    string input = File.ReadAllText(templateFileName);&#xD;&#xA;    &#xD;&#xA;    //transform the text template&#xD;&#xA;    string output = engine.ProcessTemplate(input, host);&#xD;&#xA;&#xD;&#xA;In your template, you can mix template language with C# code (sample HTML generation):&#xD;&#xA;&#xD;&#xA;    <table>&#xD;&#xA;      <# for (int i = 1; i <= 10; i++)&#xD;&#xA;         { #>&#xD;&#xA;            <tr><td>Test name <#= i #> </td>&#xD;&#xA;              <td>Test value <#= i * i #> </td> &#xD;&#xA;            </tr>&#xD;&#xA;      <# } #>&#xD;&#xA;    </table>&#xD;&#xA;&#xD;&#xA;You can even generate source code for [**C# class at runtime, compile and load**][1] and execute from your program.&#xD;&#xA;&#xD;&#xA;If you combine all those techniques, perhaps even with composable parts, like [**MEF**][2], I'm sure you will be able to achieve what you need. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.codeproject.com/Tips/715891/Compiling-Csharp-Code-at-Runtime&#xD;&#xA;  [2]: http://msdn.microsoft.com/en-us/library/dd460648(v=vs.110).aspx";;
68024231;24408273;564092;5;a5f46b22-6067-43b9-9f36-5e25f704abd7;2014-06-25 12:18:09.0;"You don't need the IDE to generate and process templates at runtime. &#xD;&#xA;&#xD;&#xA;    Engine engine = new Engine();&#xD;&#xA;    &#xD;&#xA;    //read the text template&#xD;&#xA;    string input = File.ReadAllText(templateFileName);&#xD;&#xA;    &#xD;&#xA;    //transform the text template&#xD;&#xA;    string output = engine.ProcessTemplate(input, host);&#xD;&#xA;&#xD;&#xA;In your template, you can mix template language with C# code (sample HTML generation):&#xD;&#xA;&#xD;&#xA;    <table>&#xD;&#xA;      <# for (int i = 1; i <= 10; i++)&#xD;&#xA;         { #>&#xD;&#xA;            <tr><td>Test name <#= i #> </td>&#xD;&#xA;              <td>Test value <#= i * i #> </td> &#xD;&#xA;            </tr>&#xD;&#xA;      <# } #>&#xD;&#xA;    </table>&#xD;&#xA;&#xD;&#xA;Here is how I use T4 to [**generate all kinds of state machines**][1] from text files.&#xD;&#xA;&#xD;&#xA;You can even generate source code for [**C# class at runtime, compile and load**][2] and execute from your program.&#xD;&#xA;&#xD;&#xA;If you combine all those techniques, perhaps even with composable parts, like [**MEF**][3], I'm sure you will be able to achieve what you need. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.codeproject.com/Articles/658841/Using-T-templates-for-Finite-State-Machine-genera&#xD;&#xA;  [2]: http://www.codeproject.com/Tips/715891/Compiling-Csharp-Code-at-Runtime&#xD;&#xA;  [3]: http://msdn.microsoft.com/en-us/library/dd460648(v=vs.110).aspx";;Added link to state machine generation
68032165;24408273;564092;5;e33b9948-bffd-473c-a622-e3fad14379ae;2014-06-25 13:50:18.0;"You don't need the IDE to generate and process templates at runtime. &#xD;&#xA;&#xD;&#xA;    Engine engine = new Engine();&#xD;&#xA;    &#xD;&#xA;    //read the text template&#xD;&#xA;    string input = File.ReadAllText(templateFileName);&#xD;&#xA;    &#xD;&#xA;    //transform the text template&#xD;&#xA;    string output = engine.ProcessTemplate(input, host);&#xD;&#xA;&#xD;&#xA;In your template, you can mix template language with C# code (sample HTML generation):&#xD;&#xA;&#xD;&#xA;    <table>&#xD;&#xA;      <# for (int i = 1; i <= 10; i++)&#xD;&#xA;         { #>&#xD;&#xA;            <tr><td>Test name <#= i #> </td>&#xD;&#xA;              <td>Test value <#= i * i #> </td> &#xD;&#xA;            </tr>&#xD;&#xA;      <# } #>&#xD;&#xA;    </table>&#xD;&#xA;&#xD;&#xA;Here is how I use T4 to [**generate all kinds of state machines**][1] from text files.&#xD;&#xA;&#xD;&#xA;You can even generate source code for [**C# class at runtime, compile and load**][2] and execute from your program.&#xD;&#xA;&#xD;&#xA;If you combine all those techniques, perhaps even with composable parts, like [**MEF**][3], I'm sure you will be able to achieve what you need. &#xD;&#xA;&#xD;&#xA;**UPDATE** *without MEF and IDE*&#xD;&#xA;&#xD;&#xA;Since I don't have your DLL, I can't give you an exact answer, but perhaps this will help.&#xD;&#xA;&#xD;&#xA;Given this template (ExtDll.tt):&#xD;&#xA;&#xD;&#xA;    <#@ template language=""C#"" #>&#xD;&#xA;    <#@ assembly name=""System.Core"" #>&#xD;&#xA;    <#@ assembly name=""mscorlib"" #>&#xD;&#xA;    <#@ import namespace=""System"" #>&#xD;&#xA;    <#@ import namespace=""System.Linq"" #>&#xD;&#xA;    <#@ import namespace=""System.Text"" #>&#xD;&#xA;    <#@ import namespace=""System.Collections.Generic"" #>&#xD;&#xA;    <# &#xD;&#xA;                var extraCodeArray = new[]&#xD;&#xA;                                 { string.Empty,&#xD;&#xA;                                     ""var localVar = 1;"",&#xD;&#xA;                                     ""var localVar = 2;"",&#xD;&#xA;                                     ""var localVar = 3;"",&#xD;&#xA;                                     ""var localVar = 4;"",&#xD;&#xA;                                     ""var localVar = 5;"",&#xD;&#xA;                                     ""var localVar = 6;"",&#xD;&#xA;                                     ""var localVar = 7;"",&#xD;&#xA;                                     ""var localVar = 8;"",&#xD;&#xA;                                     ""var localVar = 9;"",&#xD;&#xA;                                     ""var localVar = 10;"",&#xD;&#xA;                                 };&#xD;&#xA;    &#xD;&#xA;    #>&#xD;&#xA;    using System;&#xD;&#xA;    static class C{&#xD;&#xA;    <# for (int i = 1; i <= 10; i++)&#xD;&#xA;           { #>&#xD;&#xA;           public static double MyWrapper<#= i #>(Func<int,double> a) {&#xD;&#xA;             <#= extraCodeArray[i] #>&#xD;&#xA;           return a.Invoke(localVar);&#xD;&#xA;           }&#xD;&#xA;        <# } #>&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;and this Program:&#xD;&#xA;&#xD;&#xA;    using System;&#xD;&#xA;    using System.Linq;&#xD;&#xA;    &#xD;&#xA;    namespace ConsoleApplication4&#xD;&#xA;    {&#xD;&#xA;        using System.CodeDom.Compiler;&#xD;&#xA;        using System.Reflection;&#xD;&#xA;    &#xD;&#xA;        using Microsoft.CSharp;&#xD;&#xA;    &#xD;&#xA;        class Program&#xD;&#xA;        {&#xD;&#xA;            static void Main(string[] args)&#xD;&#xA;            {&#xD;&#xA;                ExtDll code = new ExtDll();&#xD;&#xA;                string source = code.TransformText();&#xD;&#xA;                CSharpCodeProvider provider = new CSharpCodeProvider();&#xD;&#xA;                CompilerParameters parameters = new CompilerParameters()&#xD;&#xA;                                                {&#xD;&#xA;                                                    GenerateInMemory = true,&#xD;&#xA;                                                    GenerateExecutable = false&#xD;&#xA;                                                };&#xD;&#xA;                parameters.ReferencedAssemblies.AddRange(&#xD;&#xA;                    new[]&#xD;&#xA;                    {&#xD;&#xA;                        ""System.Core.dll"",&#xD;&#xA;                        ""mscorlib.dll""&#xD;&#xA;                    });&#xD;&#xA;                CompilerResults results = provider.CompileAssemblyFromSource(parameters, source);&#xD;&#xA;                if (results.Errors.HasErrors)&#xD;&#xA;                {&#xD;&#xA;                    var errorString = String.Join(""\\n"", results.Errors.Cast<CompilerError>().Select(error => String.Format(""Error ({0}): {1}"", error.ErrorNumber, error.ErrorText)));&#xD;&#xA;    &#xD;&#xA;                    throw new InvalidOperationException(errorString);&#xD;&#xA;                }&#xD;&#xA;                Assembly assembly = results.CompiledAssembly;&#xD;&#xA;                Func<int,double> squareRoot = (i) => { return Math.Sqrt(i); };&#xD;&#xA;                Type type = assembly.GetType(""C"");&#xD;&#xA;                //object instance = Activator.CreateInstance(type);&#xD;&#xA;                MethodInfo method = type.GetMethod(""MyWrapper4"");&#xD;&#xA;                Console.WriteLine(method.Invoke(null, new object[]{squareRoot})); &#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;it will print 2, since it is a square root of 4.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.codeproject.com/Articles/658841/Using-T-templates-for-Finite-State-Machine-genera&#xD;&#xA;  [2]: http://www.codeproject.com/Tips/715891/Compiling-Csharp-Code-at-Runtime&#xD;&#xA;  [3]: http://msdn.microsoft.com/en-us/library/dd460648(v=vs.110).aspx";;Added sample template and code
68034113;24408273;564092;5;5fdda893-fbbc-450a-9166-ace70f252651;2014-06-25 14:14:51.0;"You don't need the IDE to generate and process templates at runtime, but you have to [**create your own host**][1]. &#xD;&#xA;&#xD;&#xA;    Engine engine = new Engine();&#xD;&#xA;    &#xD;&#xA;    //read the text template&#xD;&#xA;    string input = File.ReadAllText(templateFileName);&#xD;&#xA;    &#xD;&#xA;    //transform the text template&#xD;&#xA;    string output = engine.ProcessTemplate(input, host);&#xD;&#xA;&#xD;&#xA;In your template, you can mix template language with C# code (sample HTML generation):&#xD;&#xA;&#xD;&#xA;    <table>&#xD;&#xA;      <# for (int i = 1; i <= 10; i++)&#xD;&#xA;         { #>&#xD;&#xA;            <tr><td>Test name <#= i #> </td>&#xD;&#xA;              <td>Test value <#= i * i #> </td> &#xD;&#xA;            </tr>&#xD;&#xA;      <# } #>&#xD;&#xA;    </table>&#xD;&#xA;&#xD;&#xA;Here is how I use T4 to [**generate all kinds of state machines**][2] from text files.&#xD;&#xA;&#xD;&#xA;You can even generate source code for [**C# class at runtime, compile and load**][3] and execute from your program.&#xD;&#xA;&#xD;&#xA;If you combine all those techniques, perhaps even with composable parts, like [**MEF**][4], I'm sure you will be able to achieve what you need. &#xD;&#xA;&#xD;&#xA;**UPDATE** *without MEF, but you still need IDE to pre-process the template.*&#xD;&#xA;&#xD;&#xA;Since I don't have your DLL, I can't give you an exact answer, but perhaps this will help.&#xD;&#xA;&#xD;&#xA;Given this template (ExtDll.tt):&#xD;&#xA;&#xD;&#xA;    <#@ template language=""C#"" #>&#xD;&#xA;    <#@ assembly name=""System.Core"" #>&#xD;&#xA;    <#@ assembly name=""mscorlib"" #>&#xD;&#xA;    <#@ import namespace=""System"" #>&#xD;&#xA;    <#@ import namespace=""System.Linq"" #>&#xD;&#xA;    <#@ import namespace=""System.Text"" #>&#xD;&#xA;    <#@ import namespace=""System.Collections.Generic"" #>&#xD;&#xA;    <# &#xD;&#xA;                var extraCodeArray = new[]&#xD;&#xA;                                 { string.Empty,&#xD;&#xA;                                     ""var localVar = 1;"",&#xD;&#xA;                                     ""var localVar = 2;"",&#xD;&#xA;                                     ""var localVar = 3;"",&#xD;&#xA;                                     ""var localVar = 4;"",&#xD;&#xA;                                     ""var localVar = 5;"",&#xD;&#xA;                                     ""var localVar = 6;"",&#xD;&#xA;                                     ""var localVar = 7;"",&#xD;&#xA;                                     ""var localVar = 8;"",&#xD;&#xA;                                     ""var localVar = 9;"",&#xD;&#xA;                                     ""var localVar = 10;"",&#xD;&#xA;                                 };&#xD;&#xA;    &#xD;&#xA;    #>&#xD;&#xA;    using System;&#xD;&#xA;    static class C{&#xD;&#xA;    <# for (int i = 1; i <= 10; i++)&#xD;&#xA;           { #>&#xD;&#xA;           public static double MyWrapper<#= i #>(Func<int,double> a) {&#xD;&#xA;             <#= extraCodeArray[i] #>&#xD;&#xA;           return a.Invoke(localVar);&#xD;&#xA;           }&#xD;&#xA;        <# } #>&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;and this Program:&#xD;&#xA;&#xD;&#xA;    using System;&#xD;&#xA;    using System.Linq;&#xD;&#xA;    &#xD;&#xA;    namespace ConsoleApplication4&#xD;&#xA;    {&#xD;&#xA;        using System.CodeDom.Compiler;&#xD;&#xA;        using System.Reflection;&#xD;&#xA;    &#xD;&#xA;        using Microsoft.CSharp;&#xD;&#xA;    &#xD;&#xA;        class Program&#xD;&#xA;        {&#xD;&#xA;            static void Main(string[] args)&#xD;&#xA;            {&#xD;&#xA;                ExtDll code = new ExtDll();&#xD;&#xA;                string source = code.TransformText();&#xD;&#xA;                CSharpCodeProvider provider = new CSharpCodeProvider();&#xD;&#xA;                CompilerParameters parameters = new CompilerParameters()&#xD;&#xA;                                                {&#xD;&#xA;                                                    GenerateInMemory = true,&#xD;&#xA;                                                    GenerateExecutable = false&#xD;&#xA;                                                };&#xD;&#xA;                parameters.ReferencedAssemblies.AddRange(&#xD;&#xA;                    new[]&#xD;&#xA;                    {&#xD;&#xA;                        ""System.Core.dll"",&#xD;&#xA;                        ""mscorlib.dll""&#xD;&#xA;                    });&#xD;&#xA;                CompilerResults results = provider.CompileAssemblyFromSource(parameters, source);&#xD;&#xA;                if (results.Errors.HasErrors)&#xD;&#xA;                {&#xD;&#xA;                    var errorString = String.Join(""\\n"", results.Errors.Cast<CompilerError>().Select(error => String.Format(""Error ({0}): {1}"", error.ErrorNumber, error.ErrorText)));&#xD;&#xA;    &#xD;&#xA;                    throw new InvalidOperationException(errorString);&#xD;&#xA;                }&#xD;&#xA;                Assembly assembly = results.CompiledAssembly;&#xD;&#xA;                Func<int,double> squareRoot = (i) => { return Math.Sqrt(i); };&#xD;&#xA;                Type type = assembly.GetType(""C"");&#xD;&#xA;                //object instance = Activator.CreateInstance(type);&#xD;&#xA;                MethodInfo method = type.GetMethod(""MyWrapper4"");&#xD;&#xA;                Console.WriteLine(method.Invoke(null, new object[]{squareRoot})); &#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;it will print 2, since it is a square root of 4.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://msdn.microsoft.com/EN-US/library/bb126542(v=VS.120,d=hv.2).aspx&#xD;&#xA;  [2]: http://www.codeproject.com/Articles/658841/Using-T-templates-for-Finite-State-Machine-genera&#xD;&#xA;  [3]: http://www.codeproject.com/Tips/715891/Compiling-Csharp-Code-at-Runtime&#xD;&#xA;  [4]: http://msdn.microsoft.com/en-us/library/dd460648(v=vs.110).aspx";;added 128 characters in body
68034916;24408273;564092;5;2df2d312-e90b-489c-af92-ec0736f171de;2014-06-25 14:24:23.0;"You don't need the IDE to generate and process templates at runtime, but you have to [**create your own directive processor**][1] and/or [**host**][2]. &#xD;&#xA;&#xD;&#xA;    Engine engine = new Engine();&#xD;&#xA;    &#xD;&#xA;    //read the text template&#xD;&#xA;    string input = File.ReadAllText(templateFileName);&#xD;&#xA;    &#xD;&#xA;    //transform the text template&#xD;&#xA;    string output = engine.ProcessTemplate(input, host);&#xD;&#xA;&#xD;&#xA;In your template, you can mix template language with C# code (sample HTML generation):&#xD;&#xA;&#xD;&#xA;    <table>&#xD;&#xA;      <# for (int i = 1; i <= 10; i++)&#xD;&#xA;         { #>&#xD;&#xA;            <tr><td>Test name <#= i #> </td>&#xD;&#xA;              <td>Test value <#= i * i #> </td> &#xD;&#xA;            </tr>&#xD;&#xA;      <# } #>&#xD;&#xA;    </table>&#xD;&#xA;&#xD;&#xA;Here is how I use T4 to [**generate all kinds of state machines**][3] from text files.&#xD;&#xA;&#xD;&#xA;You can even generate source code for [**C# class at runtime, compile and load**][4] and execute from your program.&#xD;&#xA;&#xD;&#xA;If you combine all those techniques, perhaps even with composable parts, like [**MEF**][5], I'm sure you will be able to achieve what you need. &#xD;&#xA;&#xD;&#xA;**UPDATE** *without MEF, but you still need IDE to pre-process the template.*&#xD;&#xA;&#xD;&#xA;Since I don't have your DLL, I can't give you an exact answer, but perhaps this will help.&#xD;&#xA;&#xD;&#xA;Given this template (ExtDll.tt):&#xD;&#xA;&#xD;&#xA;    <#@ template language=""C#"" #>&#xD;&#xA;    <#@ assembly name=""System.Core"" #>&#xD;&#xA;    <#@ assembly name=""mscorlib"" #>&#xD;&#xA;    <#@ import namespace=""System"" #>&#xD;&#xA;    <#@ import namespace=""System.Linq"" #>&#xD;&#xA;    <#@ import namespace=""System.Text"" #>&#xD;&#xA;    <#@ import namespace=""System.Collections.Generic"" #>&#xD;&#xA;    <# &#xD;&#xA;                var extraCodeArray = new[]&#xD;&#xA;                                 { string.Empty,&#xD;&#xA;                                     ""var localVar = 1;"",&#xD;&#xA;                                     ""var localVar = 2;"",&#xD;&#xA;                                     ""var localVar = 3;"",&#xD;&#xA;                                     ""var localVar = 4;"",&#xD;&#xA;                                     ""var localVar = 5;"",&#xD;&#xA;                                     ""var localVar = 6;"",&#xD;&#xA;                                     ""var localVar = 7;"",&#xD;&#xA;                                     ""var localVar = 8;"",&#xD;&#xA;                                     ""var localVar = 9;"",&#xD;&#xA;                                     ""var localVar = 10;"",&#xD;&#xA;                                 };&#xD;&#xA;    &#xD;&#xA;    #>&#xD;&#xA;    using System;&#xD;&#xA;    static class C{&#xD;&#xA;    <# for (int i = 1; i <= 10; i++)&#xD;&#xA;           { #>&#xD;&#xA;           public static double MyWrapper<#= i #>(Func<int,double> a) {&#xD;&#xA;             <#= extraCodeArray[i] #>&#xD;&#xA;           return a.Invoke(localVar);&#xD;&#xA;           }&#xD;&#xA;        <# } #>&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;and this Program:&#xD;&#xA;&#xD;&#xA;    using System;&#xD;&#xA;    using System.Linq;&#xD;&#xA;    &#xD;&#xA;    namespace ConsoleApplication4&#xD;&#xA;    {&#xD;&#xA;        using System.CodeDom.Compiler;&#xD;&#xA;        using System.Reflection;&#xD;&#xA;    &#xD;&#xA;        using Microsoft.CSharp;&#xD;&#xA;    &#xD;&#xA;        class Program&#xD;&#xA;        {&#xD;&#xA;            static void Main(string[] args)&#xD;&#xA;            {&#xD;&#xA;                ExtDll code = new ExtDll();&#xD;&#xA;                string source = code.TransformText();&#xD;&#xA;                CSharpCodeProvider provider = new CSharpCodeProvider();&#xD;&#xA;                CompilerParameters parameters = new CompilerParameters()&#xD;&#xA;                                                {&#xD;&#xA;                                                    GenerateInMemory = true,&#xD;&#xA;                                                    GenerateExecutable = false&#xD;&#xA;                                                };&#xD;&#xA;                parameters.ReferencedAssemblies.AddRange(&#xD;&#xA;                    new[]&#xD;&#xA;                    {&#xD;&#xA;                        ""System.Core.dll"",&#xD;&#xA;                        ""mscorlib.dll""&#xD;&#xA;                    });&#xD;&#xA;                CompilerResults results = provider.CompileAssemblyFromSource(parameters, source);&#xD;&#xA;                if (results.Errors.HasErrors)&#xD;&#xA;                {&#xD;&#xA;                    var errorString = String.Join(""\\n"", results.Errors.Cast<CompilerError>().Select(error => String.Format(""Error ({0}): {1}"", error.ErrorNumber, error.ErrorText)));&#xD;&#xA;    &#xD;&#xA;                    throw new InvalidOperationException(errorString);&#xD;&#xA;                }&#xD;&#xA;                Assembly assembly = results.CompiledAssembly;&#xD;&#xA;                Func<int,double> squareRoot = (i) => { return Math.Sqrt(i); };&#xD;&#xA;                Type type = assembly.GetType(""C"");&#xD;&#xA;                //object instance = Activator.CreateInstance(type);&#xD;&#xA;                MethodInfo method = type.GetMethod(""MyWrapper4"");&#xD;&#xA;                Console.WriteLine(method.Invoke(null, new object[]{squareRoot})); &#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;it will print 2, since it is a square root of 4.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://msdn.microsoft.com/EN-US/library/bb126542(v=VS.120,d=hv.2).aspx&#xD;&#xA;  [2]: http://msdn.microsoft.com/en-us/library/bb126579.aspx&#xD;&#xA;  [3]: http://www.codeproject.com/Articles/658841/Using-T-templates-for-Finite-State-Machine-genera&#xD;&#xA;  [4]: http://www.codeproject.com/Tips/715891/Compiling-Csharp-Code-at-Runtime&#xD;&#xA;  [5]: http://msdn.microsoft.com/en-us/library/dd460648(v=vs.110).aspx";;added 98 characters in body
68036590;24408273;564092;5;93eebef3-62f4-456e-8abc-4e9562a22d12;2014-06-25 14:43:00.0;"You don't need the IDE to generate and process templates at runtime, but you have to [**create your own directive processor**][1] and/or [**host**][2]. &#xD;&#xA;&#xD;&#xA;    Engine engine = new Engine();&#xD;&#xA;    &#xD;&#xA;    //read the text template&#xD;&#xA;    string input = File.ReadAllText(templateFileName);&#xD;&#xA;    &#xD;&#xA;    //transform the text template&#xD;&#xA;    string output = engine.ProcessTemplate(input, host);&#xD;&#xA;&#xD;&#xA;In your template, you can mix template language with C# code (sample HTML generation):&#xD;&#xA;&#xD;&#xA;    <table>&#xD;&#xA;      <# for (int i = 1; i <= 10; i++)&#xD;&#xA;         { #>&#xD;&#xA;            <tr><td>Test name <#= i #> </td>&#xD;&#xA;              <td>Test value <#= i * i #> </td> &#xD;&#xA;            </tr>&#xD;&#xA;      <# } #>&#xD;&#xA;    </table>&#xD;&#xA;&#xD;&#xA;Here is how I use T4 to [**generate all kinds of state machines**][3] from text files.&#xD;&#xA;&#xD;&#xA;You can even generate source code for [**C# class at runtime, compile and load**][4] and execute from your program.&#xD;&#xA;&#xD;&#xA;If you combine all those techniques, perhaps even with composable parts, like [**MEF**][5], I'm sure you will be able to achieve what you need. &#xD;&#xA;&#xD;&#xA;**UPDATE** *without MEF, but you still need IDE to pre-process the template.*&#xD;&#xA;&#xD;&#xA;Since I don't have your DLL, I can't give you an exact answer, but perhaps this will help.&#xD;&#xA;&#xD;&#xA;Given this template (ExtDll.tt):&#xD;&#xA;&#xD;&#xA;    <#@ template language=""C#"" #>&#xD;&#xA;    <#@ assembly name=""System.Core"" #>&#xD;&#xA;    <#@ assembly name=""mscorlib"" #>&#xD;&#xA;    <#@ import namespace=""System"" #>&#xD;&#xA;    <#@ import namespace=""System.Linq"" #>&#xD;&#xA;    <#@ import namespace=""System.Text"" #>&#xD;&#xA;    <#@ import namespace=""System.Collections.Generic"" #>&#xD;&#xA;    <# &#xD;&#xA;                var extraCodeArray = new[]&#xD;&#xA;                                 { string.Empty,&#xD;&#xA;                                     ""var localVar = 1;"",&#xD;&#xA;                                     ""var localVar = 2;"",&#xD;&#xA;                                     ""var localVar = 3;"",&#xD;&#xA;                                     ""var localVar = 4;"",&#xD;&#xA;                                     ""var localVar = 5;"",&#xD;&#xA;                                     ""var localVar = 6;"",&#xD;&#xA;                                     ""var localVar = 7;"",&#xD;&#xA;                                     ""var localVar = 8;"",&#xD;&#xA;                                     ""var localVar = 9;"",&#xD;&#xA;                                     ""var localVar = 10;"",&#xD;&#xA;                                 };&#xD;&#xA;    &#xD;&#xA;    #>&#xD;&#xA;    using System;&#xD;&#xA;    static class C{&#xD;&#xA;    <# for (int i = 1; i <= 10; i++)&#xD;&#xA;           { #>&#xD;&#xA;           public static double MyWrapper<#= i #>(Func<int,double> a) {&#xD;&#xA;             <#= extraCodeArray[i] #>&#xD;&#xA;           return a.Invoke(localVar);&#xD;&#xA;           }&#xD;&#xA;        <# } #>&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;and this Program:&#xD;&#xA;&#xD;&#xA;    using System;&#xD;&#xA;    using System.Linq;&#xD;&#xA;    &#xD;&#xA;    namespace ConsoleApplication4&#xD;&#xA;    {&#xD;&#xA;        using System.CodeDom.Compiler;&#xD;&#xA;        using System.Reflection;&#xD;&#xA;    &#xD;&#xA;        using Microsoft.CSharp;&#xD;&#xA;    &#xD;&#xA;        class Program&#xD;&#xA;        {&#xD;&#xA;            static void Main(string[] args)&#xD;&#xA;            {&#xD;&#xA;                ExtDll code = new ExtDll();&#xD;&#xA;                string source = code.TransformText();&#xD;&#xA;                CSharpCodeProvider provider = new CSharpCodeProvider();&#xD;&#xA;                CompilerParameters parameters = new CompilerParameters()&#xD;&#xA;                                                {&#xD;&#xA;                                                    GenerateInMemory = true,&#xD;&#xA;                                                    GenerateExecutable = false&#xD;&#xA;                                                };&#xD;&#xA;                parameters.ReferencedAssemblies.AddRange(&#xD;&#xA;                    new[]&#xD;&#xA;                    {&#xD;&#xA;                        ""System.Core.dll"",&#xD;&#xA;                        ""mscorlib.dll""&#xD;&#xA;                    });&#xD;&#xA;                CompilerResults results = provider.CompileAssemblyFromSource(parameters, source);&#xD;&#xA;                if (results.Errors.HasErrors)&#xD;&#xA;                {&#xD;&#xA;                    var errorString = String.Join(""\\n"", results.Errors.Cast<CompilerError>().Select(error => String.Format(""Error ({0}): {1}"", error.ErrorNumber, error.ErrorText)));&#xD;&#xA;    &#xD;&#xA;                    throw new InvalidOperationException(errorString);&#xD;&#xA;                }&#xD;&#xA;                Assembly assembly = results.CompiledAssembly;&#xD;&#xA;                Func<int,double> squareRoot = (i) => { return Math.Sqrt(i); };&#xD;&#xA;                Type type = assembly.GetType(""C"");&#xD;&#xA;                //object instance = Activator.CreateInstance(type);&#xD;&#xA;                MethodInfo method = type.GetMethod(""MyWrapper4"");&#xD;&#xA;                Console.WriteLine(method.Invoke(null, new object[]{squareRoot})); &#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;it will print 2, since it is a square root of 4.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**UPDATE 2**&#xD;&#xA;&#xD;&#xA;After slightly modifying the CustomCmdLineHost from the second link above:&#xD;&#xA;&#xD;&#xA;        public IList<string> StandardAssemblyReferences&#xD;&#xA;        {&#xD;&#xA;            get&#xD;&#xA;            {&#xD;&#xA;                return new string[]&#xD;&#xA;                {&#xD;&#xA;                    //If this host searches standard paths and the GAC,&#xD;&#xA;                    //we can specify the assembly name like this.&#xD;&#xA;                    //---------------------------------------------------------&#xD;&#xA;                    //""System""&#xD;&#xA;&#xD;&#xA;                    //Because this host only resolves assemblies from the &#xD;&#xA;                    //fully qualified path and name of the assembly,&#xD;&#xA;                    //this is a quick way to get the code to give us the&#xD;&#xA;                    //fully qualified path and name of the System assembly.&#xD;&#xA;                    //---------------------------------------------------------&#xD;&#xA;                    typeof(System.Uri).Assembly.Location,&#xD;&#xA;                    typeof(System.Linq.Enumerable).Assembly.Location&#xD;&#xA;                };&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;the sample program no longer requires the IDE:&#xD;&#xA;&#xD;&#xA;            var host = new CustomCmdLineHost();&#xD;&#xA;            host.TemplateFileValue = ""ExtDll.tt"";&#xD;&#xA;            Engine engine = new Engine();&#xD;&#xA;            string input = File.ReadAllText(""ExtDll.tt"");&#xD;&#xA;            string source = engine.ProcessTemplate(input, host);&#xD;&#xA;            if (host.Errors.HasErrors)&#xD;&#xA;            {&#xD;&#xA;                var errorString = String.Join(""\\n"", host.Errors.Cast<CompilerError>().Select(error => String.Format(""Error ({0}): {1}"", error.ErrorNumber, error.ErrorText)));&#xD;&#xA;&#xD;&#xA;                throw new InvalidOperationException(errorString);            &#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            CSharpCodeProvider provider = new CSharpCodeProvider();&#xD;&#xA;    ... rest of the code as before&#xD;&#xA;&#xD;&#xA;I hope this satisfies your needs.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://msdn.microsoft.com/EN-US/library/bb126542(v=VS.120,d=hv.2).aspx&#xD;&#xA;  [2]: http://msdn.microsoft.com/en-us/library/bb126579.aspx&#xD;&#xA;  [3]: http://www.codeproject.com/Articles/658841/Using-T-templates-for-Finite-State-Machine-genera&#xD;&#xA;  [4]: http://www.codeproject.com/Tips/715891/Compiling-Csharp-Code-at-Runtime&#xD;&#xA;  [5]: http://msdn.microsoft.com/en-us/library/dd460648(v=vs.110).aspx";;Added sample without IDE
68039702;24408273;564092;5;8392c2e7-0568-4309-8566-779f3cf059da;2014-06-25 15:19:45.0;"You don't need the IDE to generate and process templates at runtime, but you have to [**create your own directive processor**][1] and/or [**host**][2]. &#xD;&#xA;&#xD;&#xA;    Engine engine = new Engine();&#xD;&#xA;    &#xD;&#xA;    //read the text template&#xD;&#xA;    string input = File.ReadAllText(templateFileName);&#xD;&#xA;    &#xD;&#xA;    //transform the text template&#xD;&#xA;    string output = engine.ProcessTemplate(input, host);&#xD;&#xA;&#xD;&#xA;In your template, you can mix template language with C# code (sample HTML generation):&#xD;&#xA;&#xD;&#xA;    <table>&#xD;&#xA;      <# for (int i = 1; i <= 10; i++)&#xD;&#xA;         { #>&#xD;&#xA;            <tr><td>Test name <#= i #> </td>&#xD;&#xA;              <td>Test value <#= i * i #> </td> &#xD;&#xA;            </tr>&#xD;&#xA;      <# } #>&#xD;&#xA;    </table>&#xD;&#xA;&#xD;&#xA;Here is how I use T4 to [**generate all kinds of state machines**][3] from text files.&#xD;&#xA;&#xD;&#xA;You can even generate source code for [**C# class at runtime, compile and load**][4] and execute from your program.&#xD;&#xA;&#xD;&#xA;If you combine all those techniques, perhaps even with composable parts, like [**MEF**][5], I'm sure you will be able to achieve what you need. &#xD;&#xA;&#xD;&#xA;**UPDATE** *without MEF, but you still need IDE to pre-process the template.*&#xD;&#xA;&#xD;&#xA;Since I don't have your DLL, I can't give you an exact answer, but perhaps this will help.&#xD;&#xA;&#xD;&#xA;Given this template (ExtDll.tt):&#xD;&#xA;&#xD;&#xA;    <#@ template language=""C#"" #>&#xD;&#xA;    <#@ assembly name=""System.Core"" #>&#xD;&#xA;    <#@ assembly name=""mscorlib"" #>&#xD;&#xA;    <#@ import namespace=""System"" #>&#xD;&#xA;    <#@ import namespace=""System.Linq"" #>&#xD;&#xA;    <#@ import namespace=""System.Text"" #>&#xD;&#xA;    <#@ import namespace=""System.Collections.Generic"" #>&#xD;&#xA;    <# &#xD;&#xA;                var extraCodeArray = new[]&#xD;&#xA;                                 { string.Empty,&#xD;&#xA;                                     ""var localVar = 1;"",&#xD;&#xA;                                     ""var localVar = 2;"",&#xD;&#xA;                                     ""var localVar = 3;"",&#xD;&#xA;                                     ""var localVar = 4;"",&#xD;&#xA;                                     ""var localVar = 5;"",&#xD;&#xA;                                     ""var localVar = 6;"",&#xD;&#xA;                                     ""var localVar = 7;"",&#xD;&#xA;                                     ""var localVar = 8;"",&#xD;&#xA;                                     ""var localVar = 9;"",&#xD;&#xA;                                     ""var localVar = 10;"",&#xD;&#xA;                                 };&#xD;&#xA;    &#xD;&#xA;    #>&#xD;&#xA;    using System;&#xD;&#xA;    static class C{&#xD;&#xA;    <# for (int i = 1; i <= 10; i++)&#xD;&#xA;           { #>&#xD;&#xA;           public static double MyWrapper<#= i #>(Func<int,double> a) {&#xD;&#xA;             <#= extraCodeArray[i] #>&#xD;&#xA;           return a.Invoke(localVar);&#xD;&#xA;           }&#xD;&#xA;        <# } #>&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;and this Program:&#xD;&#xA;&#xD;&#xA;    using System;&#xD;&#xA;    using System.Linq;&#xD;&#xA;    &#xD;&#xA;    namespace ConsoleApplication4&#xD;&#xA;    {&#xD;&#xA;        using System.CodeDom.Compiler;&#xD;&#xA;        using System.Reflection;&#xD;&#xA;    &#xD;&#xA;        using Microsoft.CSharp;&#xD;&#xA;    &#xD;&#xA;        class Program&#xD;&#xA;        {&#xD;&#xA;            static void Main(string[] args)&#xD;&#xA;            {&#xD;&#xA;                ExtDll code = new ExtDll();&#xD;&#xA;                string source = code.TransformText();&#xD;&#xA;                CSharpCodeProvider provider = new CSharpCodeProvider();&#xD;&#xA;                CompilerParameters parameters = new CompilerParameters()&#xD;&#xA;                                                {&#xD;&#xA;                                                    GenerateInMemory = true,&#xD;&#xA;                                                    GenerateExecutable = false&#xD;&#xA;                                                };&#xD;&#xA;                parameters.ReferencedAssemblies.AddRange(&#xD;&#xA;                    new[]&#xD;&#xA;                    {&#xD;&#xA;                        ""System.Core.dll"",&#xD;&#xA;                        ""mscorlib.dll""&#xD;&#xA;                    });&#xD;&#xA;                CompilerResults results = provider.CompileAssemblyFromSource(parameters, source);&#xD;&#xA;                if (results.Errors.HasErrors)&#xD;&#xA;                {&#xD;&#xA;                    var errorString = String.Join(""\\n"", results.Errors.Cast<CompilerError>().Select(error => String.Format(""Error ({0}): {1}"", error.ErrorNumber, error.ErrorText)));&#xD;&#xA;    &#xD;&#xA;                    throw new InvalidOperationException(errorString);&#xD;&#xA;                }&#xD;&#xA;                Assembly assembly = results.CompiledAssembly;&#xD;&#xA;                Func<int,double> squareRoot = (i) => { return Math.Sqrt(i); };&#xD;&#xA;                Type type = assembly.GetType(""C"");&#xD;&#xA;                //object instance = Activator.CreateInstance(type);&#xD;&#xA;                MethodInfo method = type.GetMethod(""MyWrapper4"");&#xD;&#xA;                Console.WriteLine(method.Invoke(null, new object[]{squareRoot})); &#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;it will print 2, since it is a square root of 4.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**UPDATE 2**&#xD;&#xA;&#xD;&#xA;After slightly modifying the CustomCmdLineHost from the second link above:&#xD;&#xA;&#xD;&#xA;        public IList<string> StandardAssemblyReferences&#xD;&#xA;        {&#xD;&#xA;            get&#xD;&#xA;            {&#xD;&#xA;                return new string[]&#xD;&#xA;                {&#xD;&#xA;                    //If this host searches standard paths and the GAC,&#xD;&#xA;                    //we can specify the assembly name like this.&#xD;&#xA;                    //---------------------------------------------------------&#xD;&#xA;                    //""System""&#xD;&#xA;&#xD;&#xA;                    //Because this host only resolves assemblies from the &#xD;&#xA;                    //fully qualified path and name of the assembly,&#xD;&#xA;                    //this is a quick way to get the code to give us the&#xD;&#xA;                    //fully qualified path and name of the System assembly.&#xD;&#xA;                    //---------------------------------------------------------&#xD;&#xA;                    typeof(System.Uri).Assembly.Location,&#xD;&#xA;                    typeof(System.Linq.Enumerable).Assembly.Location&#xD;&#xA;                };&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;the sample program no longer requires the IDE:&#xD;&#xA;&#xD;&#xA;            var host = new CustomCmdLineHost();&#xD;&#xA;            host.TemplateFileValue = ""ExtDll.tt"";&#xD;&#xA;            Engine engine = new Engine();&#xD;&#xA;            string input = File.ReadAllText(""ExtDll.tt"");&#xD;&#xA;            string source = engine.ProcessTemplate(input, host);&#xD;&#xA;            if (host.Errors.HasErrors)&#xD;&#xA;            {&#xD;&#xA;                var errorString = String.Join(""\\n"", host.Errors.Cast<CompilerError>().Select(error => String.Format(""Error ({0}): {1}"", error.ErrorNumber, error.ErrorText)));&#xD;&#xA;&#xD;&#xA;                throw new InvalidOperationException(errorString);            &#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            CSharpCodeProvider provider = new CSharpCodeProvider();&#xD;&#xA;    ... rest of the code as before&#xD;&#xA;&#xD;&#xA;I hope this satisfies your needs.&#xD;&#xA;&#xD;&#xA;**UPDATE 3**&#xD;&#xA;&#xD;&#xA;If you further modify the sample host like this:&#xD;&#xA;&#xD;&#xA;    internal string TemplateFileValue = Path.Combine(&#xD;&#xA;        AppDomain.CurrentDomain.BaseDirectory,""CustomCmdLineHost.tt"");&#xD;&#xA;&#xD;&#xA;Then you can avoid having to specify the template file name and just use in-memory processing:&#xD;&#xA;&#xD;&#xA;    var host = new CustomCmdLineHost();&#xD;&#xA;    Engine engine = new Engine();&#xD;&#xA;    string input = File.ReadAllText(""ExtDll.tt"");&#xD;&#xA;    string source = engine.ProcessTemplate(input, host);&#xD;&#xA;&#xD;&#xA;Enjoy and kindly mark your preferred answer.&#xD;&#xA;&#xD;&#xA;  [1]: http://msdn.microsoft.com/EN-US/library/bb126542(v=VS.120,d=hv.2).aspx&#xD;&#xA;  [2]: http://msdn.microsoft.com/en-us/library/bb126579.aspx&#xD;&#xA;  [3]: http://www.codeproject.com/Articles/658841/Using-T-templates-for-Finite-State-Machine-genera&#xD;&#xA;  [4]: http://www.codeproject.com/Tips/715891/Compiling-Csharp-Code-at-Runtime&#xD;&#xA;  [5]: http://msdn.microsoft.com/en-us/library/dd460648(v=vs.110).aspx";;added 528 characters in body
