Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
35108883;14560509;812912;2;d1a55d9f-45f8-41b8-a61e-efcdb21a6273;2013-01-28 10:57:05.0;"A unique representation of the graph can be given by the neighbourhood list. For each vertex create a list with all it's neighbours. Write all the lists one after the other appending the number of neighbours for each list to the front. Also keep the neighbours sorted in ascending order to make the representation unique for each graph. So for example assume you have the graph:&#xD;&#xA;&#xD;&#xA;    1->2, 1->5&#xD;&#xA;    2->1, 2->4&#xD;&#xA;    3->4&#xD;&#xA;    5->3&#xD;&#xA;&#xD;&#xA;What I propose is that you transform this to `({2,2,5}, {2,1,4}, {1,4}, {0}, {1,3})`, here the curly brackets being only to visualize the representation, not part of the python's syntax. So the list is in fact: `(2,2,5, 2,1,4, 1,4, 0, 1,3)`.&#xD;&#xA;&#xD;&#xA;Now to compute the unique hash, you need to order these representations somehow and assign a unique number to them. I suggest you do something like a lexicographical sort to do that. Lets assume you have two sequences `(a1, b1_1, b_1_2,...b_1_a1,a2, b_2_1, b_2_2,...b_2_a2,...an, b_n_1, b_n_2,...b_n_an)` and  `(c1, d1_1, d_1_2,...d_1_c1,c2, d_2_1, d_2_2,...d_2_c2,...cn, d_n_1, d_n_2,...d_n_cn)`, Here c and a are the number of neighbours for each vertex and b_i_j and d_k_l are the corresponding neighbours. For the ordering first compare the sequnces `(a1,a2,...an)` and `(c1,c2, ...,cn)` and if they are different use this to compare the sequences. If these sequences are different, compare the lists from left to right first comparing lexicographically `(b_1_1, b_1_2...b_1_a1)` to `(d_1_1, d_1_2...d_1_c1)` and so on until the first missmatch.&#xD;&#xA;&#xD;&#xA;I believe you can find the number of a given sequence in the above order relatively easily using a DP for instance. Remember that the number of a sequence of neighbours is simply the number of the given combinations of vertices in the lexicographical order of n elements. Also the sequences of neighbours for the vertices are independent. &#xD;&#xA;&#xD;&#xA;This algorithm will work. Still, keep in mind as you want the hash to be unique, the generated number will be **huge** and grows really fast with the growth of the number of vertices `N`.&#xD;&#xA;&#xD;&#xA;Hope this helps.";;
35111756;14560509;812912;5;e77c1b32-b29e-450f-9480-13a1c3fceac8;2013-01-28 12:00:26.0;"A unique representation of the graph can be given by the neighbourhood list. For each vertex create a list with all it's neighbours. Write all the lists one after the other appending the number of neighbours for each list to the front. Also keep the neighbours sorted in ascending order to make the representation unique for each graph. So for example assume you have the graph:&#xD;&#xA;&#xD;&#xA;    1->2, 1->5&#xD;&#xA;    2->1, 2->4&#xD;&#xA;    3->4&#xD;&#xA;    5->3&#xD;&#xA;&#xD;&#xA;What I propose is that you transform this to `({2,2,5}, {2,1,4}, {1,4}, {0}, {1,3})`, here the curly brackets being only to visualize the representation, not part of the python's syntax. So the list is in fact: `(2,2,5, 2,1,4, 1,4, 0, 1,3)`.&#xD;&#xA;&#xD;&#xA;Now to compute the unique hash, you need to order these representations somehow and assign a unique number to them. I suggest you do something like a lexicographical sort to do that. Lets assume you have two sequences `(a1, b1_1, b_1_2,...b_1_a1,a2, b_2_1, b_2_2,...b_2_a2,...an, b_n_1, b_n_2,...b_n_an)` and  `(c1, d1_1, d_1_2,...d_1_c1,c2, d_2_1, d_2_2,...d_2_c2,...cn, d_n_1, d_n_2,...d_n_cn)`, Here c and a are the number of neighbours for each vertex and b_i_j and d_k_l are the corresponding neighbours. For the ordering first compare the sequnces `(a1,a2,...an)` and `(c1,c2, ...,cn)` and if they are different use this to compare the sequences. If these sequences are different, compare the lists from left to right first comparing lexicographically `(b_1_1, b_1_2...b_1_a1)` to `(d_1_1, d_1_2...d_1_c1)` and so on until the first missmatch.&#xD;&#xA;&#xD;&#xA;I believe you can find the number of a given sequence in the above order relatively easily using a DP for instance. Remember that the number of a sequence of neighbours is simply the number of the given combinations of vertices in the lexicographical order of n elements. Also the sequences of neighbours for the vertices are independent. &#xD;&#xA;&#xD;&#xA;This algorithm will work. Still, keep in mind as you want the hash to be unique, the generated number will be **huge** and grows really fast with the growth of the number of vertices `N`.&#xD;&#xA;&#xD;&#xA;EDIT: adding more details to make the answer easier to understand:&#xD;&#xA;&#xD;&#xA;In fact what I propose to use as hash value a word of size `N` over the alphabet that is formed by all possible selection of subsets of elements of `{1,2,3,...N}`. The neighbourhood list for a given vertex is a letter over this alphabet e.g. `{2,2,5}` is the subset consisting of two elements of the set, namely `2` and `5`. &#xD;&#xA;&#xD;&#xA;Now the number of subsets of the set `{1,2,3,....N}` is `2^N` and thus the number of letters of this alphabet is `2^N`. Now we code each directed graph of N nodes with a _word_ with exactly `N` letters from this alphabet and thus the number of possible hash codes is precisely: `(2^N)^N`. This also proves the statement I gave above that the hash code grows **really** fast. Also this is the number of possible different directed graphs with N nodes so what I suggest is optimal hashing in the sense it is bijection and no smaller hash can be unique. &#xD;&#xA;&#xD;&#xA;";;added 932 characters in body
35112093;14560509;812912;5;ed76c8bd-99de-44fa-a0e8-1f113fc8cc63;2013-01-28 12:08:15.0;"A unique representation of the graph can be given by the neighbourhood list. For each vertex create a list with all it's neighbours. Write all the lists one after the other appending the number of neighbours for each list to the front. Also keep the neighbours sorted in ascending order to make the representation unique for each graph. So for example assume you have the graph:&#xD;&#xA;&#xD;&#xA;    1->2, 1->5&#xD;&#xA;    2->1, 2->4&#xD;&#xA;    3->4&#xD;&#xA;    5->3&#xD;&#xA;&#xD;&#xA;What I propose is that you transform this to `({2,2,5}, {2,1,4}, {1,4}, {0}, {1,3})`, here the curly brackets being only to visualize the representation, not part of the python's syntax. So the list is in fact: `(2,2,5, 2,1,4, 1,4, 0, 1,3)`.&#xD;&#xA;&#xD;&#xA;Now to compute the unique hash, you need to order these representations somehow and assign a unique number to them. I suggest you do something like a lexicographical sort to do that. Lets assume you have two sequences `(a1, b1_1, b_1_2,...b_1_a1,a2, b_2_1, b_2_2,...b_2_a2,...an, b_n_1, b_n_2,...b_n_an)` and  `(c1, d1_1, d_1_2,...d_1_c1,c2, d_2_1, d_2_2,...d_2_c2,...cn, d_n_1, d_n_2,...d_n_cn)`, Here c and a are the number of neighbours for each vertex and b_i_j and d_k_l are the corresponding neighbours. For the ordering first compare the sequnces `(a1,a2,...an)` and `(c1,c2, ...,cn)` and if they are different use this to compare the sequences. If these sequences are different, compare the lists from left to right first comparing lexicographically `(b_1_1, b_1_2...b_1_a1)` to `(d_1_1, d_1_2...d_1_c1)` and so on until the first missmatch.&#xD;&#xA;&#xD;&#xA;I believe you can find the number of a given sequence in the above order relatively easily using a DP for instance. Remember that the number of a sequence of neighbours is simply the number of the given combinations of vertices in the lexicographical order of n elements. Also the sequences of neighbours for the vertices are independent. &#xD;&#xA;&#xD;&#xA;This algorithm will work. Still, keep in mind as you want the hash to be unique, the generated number will be **huge** and grows really fast with the growth of the number of vertices `N`.&#xD;&#xA;&#xD;&#xA;EDIT: adding more details to make the answer easier to understand:&#xD;&#xA;&#xD;&#xA;In fact what I propose to use as hash value a word of size `N` over the alphabet that is formed by all possible selection of subsets of elements of `{1,2,3,...N}`. The neighbourhood list for a given vertex is a letter over this alphabet e.g. `{2,2,5}` is the subset consisting of two elements of the set, namely `2` and `5`. &#xD;&#xA;&#xD;&#xA;Now the number of subsets of the set `{1,2,3,....N}` is `2^N` and thus the number of letters of this alphabet is `2^N`. Now we code each directed graph of N nodes with a _word_ with exactly `N` _letters_ from this alphabet and thus the number of possible hash codes is precisely: `(2^N)^N`. This also proves the statement I gave above that the hash code grows **really** fast. Also this is the number of possible different directed graphs with N nodes so what I suggest is optimal hashing in the sense it is bijection and no smaller hash can be unique. &#xD;&#xA;&#xD;&#xA;There is a linear algorithm to get a given subset number in the the lexicographical ordering of all subsets of a given set, in this case `{1,2,....N}`. Here is the code I have written for coding/decoding a subset in number and vice versa. It is written in `C++` but quite easy to understand I hope. For the hashing you will need only the code function but as the hash I propose is reversable I add the decode function - you will be able to reconstruct the graph from the hash which is quite cool I think:&#xD;&#xA;&#xD;&#xA;    typedef long long ll;&#xD;&#xA;    &#xD;&#xA;    // Returns the number in the lexicographical order of all combinations of n numbers&#xD;&#xA;    // of the provided combination. &#xD;&#xA;    ll code(vector<int> a,int n)&#xD;&#xA;    {&#xD;&#xA;        sort(a.begin(),a.end());  // not needed if the set you pass is already sorted.&#xD;&#xA;        int cur = 0;&#xD;&#xA;        int m = a.size();&#xD;&#xA;    &#xD;&#xA;        ll res =0;&#xD;&#xA;        for(int i=0;i<a.size();i++)&#xD;&#xA;        {&#xD;&#xA;            if(a[i] == cur+1)&#xD;&#xA;            {&#xD;&#xA;                res++;&#xD;&#xA;                cur = a[i];&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                res++;&#xD;&#xA;                int number_of_greater_nums = n - a[i];&#xD;&#xA;                for(int j = a[i]-1,increment=1;j>cur;j--,increment++)&#xD;&#xA;                    res += 1LL << (number_of_greater_nums+increment);&#xD;&#xA;                cur = a[i];&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;    // Takes the lexicographical code of a combination of n numbers and returns the &#xD;&#xA;    // combination&#xD;&#xA;    vector<int> decode(ll kod, int n)&#xD;&#xA;    {&#xD;&#xA;        vector<int> res;&#xD;&#xA;        int cur = 0;&#xD;&#xA;    &#xD;&#xA;        int left = n; // Out of how many numbers are we left to choose.&#xD;&#xA;        while(kod)&#xD;&#xA;        {&#xD;&#xA;            ll all = 1LL << left;// how many are the total combinations&#xD;&#xA;            for(int i=n;i>=0;i--)&#xD;&#xA;            {&#xD;&#xA;                if(all - (1LL << (n-i+1)) +1 <= kod)&#xD;&#xA;                {&#xD;&#xA;                    res.push_back(i);&#xD;&#xA;                    left = n-i;&#xD;&#xA;                    kod -= all - (1LL << (n-i+1)) +1;&#xD;&#xA;                    break;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Also this code stores the result in long long which is only enough for graphs with less than 64 elements. A graph with 64 nodes is `(2^64)^64` or has about 1280 **digits** so maybe a big number. Still the algorithm I describe will work really fast and I believe you should be able to hash and 'unhash' graphs with a lot of vertices.&#xD;&#xA;&#xD;&#xA;Also have a look at [this question][1].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/14160942/perfect-minimal-hash-for-mathematical-combinations/14160991#14160991";;added 932 characters in body
35112389;14560509;812912;5;e5a0b6a8-a8e0-4a20-ae3a-91b013bce795;2013-01-28 12:14:20.0;"A unique representation of the graph can be given by the neighbourhood list. For each vertex create a list with all it's neighbours. Write all the lists one after the other appending the number of neighbours for each list to the front. Also keep the neighbours sorted in ascending order to make the representation unique for each graph. So for example assume you have the graph:&#xD;&#xA;&#xD;&#xA;    1->2, 1->5&#xD;&#xA;    2->1, 2->4&#xD;&#xA;    3->4&#xD;&#xA;    5->3&#xD;&#xA;&#xD;&#xA;What I propose is that you transform this to `({2,2,5}, {2,1,4}, {1,4}, {0}, {1,3})`, here the curly brackets being only to visualize the representation, not part of the python's syntax. So the list is in fact: `(2,2,5, 2,1,4, 1,4, 0, 1,3)`.&#xD;&#xA;&#xD;&#xA;Now to compute the unique hash, you need to order these representations somehow and assign a unique number to them. I suggest you do something like a lexicographical sort to do that. Lets assume you have two sequences `(a1, b1_1, b_1_2,...b_1_a1,a2, b_2_1, b_2_2,...b_2_a2,...an, b_n_1, b_n_2,...b_n_an)` and  `(c1, d1_1, d_1_2,...d_1_c1,c2, d_2_1, d_2_2,...d_2_c2,...cn, d_n_1, d_n_2,...d_n_cn)`, Here c and a are the number of neighbours for each vertex and b_i_j and d_k_l are the corresponding neighbours. For the ordering first compare the sequnces `(a1,a2,...an)` and `(c1,c2, ...,cn)` and if they are different use this to compare the sequences. If these sequences are different, compare the lists from left to right first comparing lexicographically `(b_1_1, b_1_2...b_1_a1)` to `(d_1_1, d_1_2...d_1_c1)` and so on until the first missmatch.&#xD;&#xA;&#xD;&#xA;I believe you can find the number of a given sequence in the above order relatively easily using a DP for instance. Remember that the number of a sequence of neighbours is simply the number of the given combinations of vertices in the lexicographical order of n elements. Also the sequences of neighbours for the vertices are independent. &#xD;&#xA;&#xD;&#xA;This algorithm will work. Still, keep in mind as you want the hash to be unique, the generated number will be **huge** and grows really fast with the growth of the number of vertices `N`.&#xD;&#xA;&#xD;&#xA;EDIT: adding more details to make the answer easier to understand:&#xD;&#xA;&#xD;&#xA;In fact what I propose to use as hash the lexicographical number of a word of size `N` over the alphabet that is formed by all possible selection of subsets of elements of `{1,2,3,...N}`. The neighbourhood list for a given vertex is a letter over this alphabet e.g. `{2,2,5}` is the subset consisting of two elements of the set, namely `2` and `5`. &#xD;&#xA;&#xD;&#xA;Now the number of subsets of the set `{1,2,3,....N}` is `2^N` and thus the number of letters of this alphabet is `2^N`. Now we code each directed graph of N nodes with a _word_ with exactly `N` _letters_ from this alphabet and thus the number of possible hash codes is precisely: `(2^N)^N`. This also proves the statement I gave above that the hash code grows **really** fast. Also this is the number of possible different directed graphs with N nodes so what I suggest is optimal hashing in the sense it is bijection and no smaller hash can be unique. &#xD;&#xA;&#xD;&#xA;There is a linear algorithm to get a given subset number in the the lexicographical ordering of all subsets of a given set, in this case `{1,2,....N}`. Here is the code I have written for coding/decoding a subset in number and vice versa. It is written in `C++` but quite easy to understand I hope. For the hashing you will need only the code function but as the hash I propose is reversable I add the decode function - you will be able to reconstruct the graph from the hash which is quite cool I think:&#xD;&#xA;&#xD;&#xA;    typedef long long ll;&#xD;&#xA;    &#xD;&#xA;    // Returns the number in the lexicographical order of all combinations of n numbers&#xD;&#xA;    // of the provided combination. &#xD;&#xA;    ll code(vector<int> a,int n)&#xD;&#xA;    {&#xD;&#xA;        sort(a.begin(),a.end());  // not needed if the set you pass is already sorted.&#xD;&#xA;        int cur = 0;&#xD;&#xA;        int m = a.size();&#xD;&#xA;    &#xD;&#xA;        ll res =0;&#xD;&#xA;        for(int i=0;i<a.size();i++)&#xD;&#xA;        {&#xD;&#xA;            if(a[i] == cur+1)&#xD;&#xA;            {&#xD;&#xA;                res++;&#xD;&#xA;                cur = a[i];&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                res++;&#xD;&#xA;                int number_of_greater_nums = n - a[i];&#xD;&#xA;                for(int j = a[i]-1,increment=1;j>cur;j--,increment++)&#xD;&#xA;                    res += 1LL << (number_of_greater_nums+increment);&#xD;&#xA;                cur = a[i];&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;    // Takes the lexicographical code of a combination of n numbers and returns the &#xD;&#xA;    // combination&#xD;&#xA;    vector<int> decode(ll kod, int n)&#xD;&#xA;    {&#xD;&#xA;        vector<int> res;&#xD;&#xA;        int cur = 0;&#xD;&#xA;    &#xD;&#xA;        int left = n; // Out of how many numbers are we left to choose.&#xD;&#xA;        while(kod)&#xD;&#xA;        {&#xD;&#xA;            ll all = 1LL << left;// how many are the total combinations&#xD;&#xA;            for(int i=n;i>=0;i--)&#xD;&#xA;            {&#xD;&#xA;                if(all - (1LL << (n-i+1)) +1 <= kod)&#xD;&#xA;                {&#xD;&#xA;                    res.push_back(i);&#xD;&#xA;                    left = n-i;&#xD;&#xA;                    kod -= all - (1LL << (n-i+1)) +1;&#xD;&#xA;                    break;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Also this code stores the result in long long which is only enough for graphs with less than 64 elements. A graph with 64 nodes is `(2^64)^64` or has about 1280 **digits** so maybe a big number. Still the algorithm I describe will work really fast and I believe you should be able to hash and 'unhash' graphs with a lot of vertices.&#xD;&#xA;&#xD;&#xA;Also have a look at [this question][1].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/14160942/perfect-minimal-hash-for-mathematical-combinations/14160991#14160991";;added 24 characters in body
35113177;14560509;812912;5;27f44370-15fb-425a-81ec-dc83624673fb;2013-01-28 12:32:11.0;"A unique representation of the graph can be given by the neighbourhood list. For each vertex create a list with all it's neighbours. Write all the lists one after the other appending the number of neighbours for each list to the front. Also keep the neighbours sorted in ascending order to make the representation unique for each graph. So for example assume you have the graph:&#xD;&#xA;&#xD;&#xA;    1->2, 1->5&#xD;&#xA;    2->1, 2->4&#xD;&#xA;    3->4&#xD;&#xA;    5->3&#xD;&#xA;&#xD;&#xA;What I propose is that you transform this to `({2,2,5}, {2,1,4}, {1,4}, {0}, {1,3})`, here the curly brackets being only to visualize the representation, not part of the python's syntax. So the list is in fact: `(2,2,5, 2,1,4, 1,4, 0, 1,3)`.&#xD;&#xA;&#xD;&#xA;Now to compute the unique hash, you need to order these representations somehow and assign a unique number to them. I suggest you do something like a lexicographical sort to do that. Lets assume you have two sequences `(a1, b1_1, b_1_2,...b_1_a1,a2, b_2_1, b_2_2,...b_2_a2,...an, b_n_1, b_n_2,...b_n_an)` and  `(c1, d1_1, d_1_2,...d_1_c1,c2, d_2_1, d_2_2,...d_2_c2,...cn, d_n_1, d_n_2,...d_n_cn)`, Here c and a are the number of neighbours for each vertex and b_i_j and d_k_l are the corresponding neighbours. For the ordering first compare the sequnces `(a1,a2,...an)` and `(c1,c2, ...,cn)` and if they are different use this to compare the sequences. If these sequences are different, compare the lists from left to right first comparing lexicographically `(b_1_1, b_1_2...b_1_a1)` to `(d_1_1, d_1_2...d_1_c1)` and so on until the first missmatch.&#xD;&#xA;&#xD;&#xA;In fact what I propose to use as hash the lexicographical number of a word of size `N` over the alphabet that is formed by all possible selections of subsets of elements of `{1,2,3,...N}`. The neighbourhood list for a given vertex is a letter over this alphabet e.g. `{2,2,5}` is the subset consisting of two elements of the set, namely `2` and `5`.&#xD;&#xA;&#xD;&#xA;The _alphabet_(set of possible _letters_) for the set `{1,2,3}` would be(ordered _lexicographically_):&#xD;&#xA;&#xD;&#xA;`{0}, {1,1}, {1,2}, {1,3}, {2, 1, 2}, {2, 1, 3}, {2, 2, 3}, {3, 1, 2, 3}` &#xD;&#xA;&#xD;&#xA;First number like above is the number of elements in the given subset and the remaining numbers- the subset itself. So form all the 3 _letter words_ from this alphabet and you will get all the possible directed graphs with 3 vertices.&#xD;&#xA;&#xD;&#xA;Now the number of subsets of the set `{1,2,3,....N}` is `2^N` and thus the number of _letters_ of this alphabet is `2^N`. Now we code each directed graph of `N` nodes with a _word_ with exactly `N` _letters_ from this _alphabet_ and thus the number of possible hash codes is precisely: `(2^N)^N`. This is to show that the hash code grows **really** fast with the increase of `N`. Also this is the number of possible different directed graphs with `N` nodes so what I suggest is optimal hashing in the sense it is bijection and no smaller hash can be unique. &#xD;&#xA;&#xD;&#xA;There is a linear algorithm to get a given subset number in the the lexicographical ordering of all subsets of a given set, in this case `{1,2,....N}`. Here is the code I have written for coding/decoding a subset in number and vice versa. It is written in `C++` but quite easy to understand I hope. For the hashing you will need only the code function but as the hash I propose is reversable I add the decode function - you will be able to reconstruct the graph from the hash which is quite cool I think:&#xD;&#xA;&#xD;&#xA;    typedef long long ll;&#xD;&#xA;    &#xD;&#xA;    // Returns the number in the lexicographical order of all combinations of n numbers&#xD;&#xA;    // of the provided combination. &#xD;&#xA;    ll code(vector<int> a,int n)&#xD;&#xA;    {&#xD;&#xA;        sort(a.begin(),a.end());  // not needed if the set you pass is already sorted.&#xD;&#xA;        int cur = 0;&#xD;&#xA;        int m = a.size();&#xD;&#xA;    &#xD;&#xA;        ll res =0;&#xD;&#xA;        for(int i=0;i<a.size();i++)&#xD;&#xA;        {&#xD;&#xA;            if(a[i] == cur+1)&#xD;&#xA;            {&#xD;&#xA;                res++;&#xD;&#xA;                cur = a[i];&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                res++;&#xD;&#xA;                int number_of_greater_nums = n - a[i];&#xD;&#xA;                for(int j = a[i]-1,increment=1;j>cur;j--,increment++)&#xD;&#xA;                    res += 1LL << (number_of_greater_nums+increment);&#xD;&#xA;                cur = a[i];&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;    // Takes the lexicographical code of a combination of n numbers and returns the &#xD;&#xA;    // combination&#xD;&#xA;    vector<int> decode(ll kod, int n)&#xD;&#xA;    {&#xD;&#xA;        vector<int> res;&#xD;&#xA;        int cur = 0;&#xD;&#xA;    &#xD;&#xA;        int left = n; // Out of how many numbers are we left to choose.&#xD;&#xA;        while(kod)&#xD;&#xA;        {&#xD;&#xA;            ll all = 1LL << left;// how many are the total combinations&#xD;&#xA;            for(int i=n;i>=0;i--)&#xD;&#xA;            {&#xD;&#xA;                if(all - (1LL << (n-i+1)) +1 <= kod)&#xD;&#xA;                {&#xD;&#xA;                    res.push_back(i);&#xD;&#xA;                    left = n-i;&#xD;&#xA;                    kod -= all - (1LL << (n-i+1)) +1;&#xD;&#xA;                    break;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Also this code stores the result in `long long` variable,  which is only enough for graphs with less than 64 elements. All possible hashes of graphs with 64 nodes will be `(2^64)^64`. This number has about 1280 **digits** so maybe is a big number. Still the algorithm I describe will work really fast and I believe you should be able to hash and 'unhash' graphs with a lot of vertices.&#xD;&#xA;&#xD;&#xA;Also have a look at [this question][1].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/14160942/perfect-minimal-hash-for-mathematical-combinations/14160991#14160991";;deleted 211 characters in body
35113625;14560509;812912;5;87fdc12d-08eb-4399-844e-4e1ea24f12f8;2013-01-28 12:40:53.0;"I will describe an algorithm to hash an arbitrary directed graph, not taking into account that the graph is acyclic. In fact even counting the acyclic graphs of a given order is a very complicated task and I believe here this will only make the hashing significantly more complicated and thus slower. &#xD;&#xA;&#xD;&#xA;A unique representation of the graph can be given by the neighbourhood list. For each vertex create a list with all it's neighbours. Write all the lists one after the other appending the number of neighbours for each list to the front. Also keep the neighbours sorted in ascending order to make the representation unique for each graph. So for example assume you have the graph:&#xD;&#xA;&#xD;&#xA;    1->2, 1->5&#xD;&#xA;    2->1, 2->4&#xD;&#xA;    3->4&#xD;&#xA;    5->3&#xD;&#xA;&#xD;&#xA;What I propose is that you transform this to `({2,2,5}, {2,1,4}, {1,4}, {0}, {1,3})`, here the curly brackets being only to visualize the representation, not part of the python's syntax. So the list is in fact: `(2,2,5, 2,1,4, 1,4, 0, 1,3)`.&#xD;&#xA;&#xD;&#xA;Now to compute the unique hash, you need to order these representations somehow and assign a unique number to them. I suggest you do something like a lexicographical sort to do that. Lets assume you have two sequences `(a1, b1_1, b_1_2,...b_1_a1,a2, b_2_1, b_2_2,...b_2_a2,...an, b_n_1, b_n_2,...b_n_an)` and  `(c1, d1_1, d_1_2,...d_1_c1,c2, d_2_1, d_2_2,...d_2_c2,...cn, d_n_1, d_n_2,...d_n_cn)`, Here c and a are the number of neighbours for each vertex and b_i_j and d_k_l are the corresponding neighbours. For the ordering first compare the sequnces `(a1,a2,...an)` and `(c1,c2, ...,cn)` and if they are different use this to compare the sequences. If these sequences are different, compare the lists from left to right first comparing lexicographically `(b_1_1, b_1_2...b_1_a1)` to `(d_1_1, d_1_2...d_1_c1)` and so on until the first missmatch.&#xD;&#xA;&#xD;&#xA;In fact what I propose to use as hash the lexicographical number of a word of size `N` over the alphabet that is formed by all possible selections of subsets of elements of `{1,2,3,...N}`. The neighbourhood list for a given vertex is a letter over this alphabet e.g. `{2,2,5}` is the subset consisting of two elements of the set, namely `2` and `5`.&#xD;&#xA;&#xD;&#xA;The _alphabet_(set of possible _letters_) for the set `{1,2,3}` would be(ordered _lexicographically_):&#xD;&#xA;&#xD;&#xA;`{0}, {1,1}, {1,2}, {1,3}, {2, 1, 2}, {2, 1, 3}, {2, 2, 3}, {3, 1, 2, 3}` &#xD;&#xA;&#xD;&#xA;First number like above is the number of elements in the given subset and the remaining numbers- the subset itself. So form all the 3 _letter words_ from this alphabet and you will get all the possible directed graphs with 3 vertices.&#xD;&#xA;&#xD;&#xA;Now the number of subsets of the set `{1,2,3,....N}` is `2^N` and thus the number of _letters_ of this alphabet is `2^N`. Now we code each directed graph of `N` nodes with a _word_ with exactly `N` _letters_ from this _alphabet_ and thus the number of possible hash codes is precisely: `(2^N)^N`. This is to show that the hash code grows **really** fast with the increase of `N`. Also this is the number of possible different directed graphs with `N` nodes so what I suggest is optimal hashing in the sense it is bijection and no smaller hash can be unique. &#xD;&#xA;&#xD;&#xA;There is a linear algorithm to get a given subset number in the the lexicographical ordering of all subsets of a given set, in this case `{1,2,....N}`. Here is the code I have written for coding/decoding a subset in number and vice versa. It is written in `C++` but quite easy to understand I hope. For the hashing you will need only the code function but as the hash I propose is reversable I add the decode function - you will be able to reconstruct the graph from the hash which is quite cool I think:&#xD;&#xA;&#xD;&#xA;    typedef long long ll;&#xD;&#xA;    &#xD;&#xA;    // Returns the number in the lexicographical order of all combinations of n numbers&#xD;&#xA;    // of the provided combination. &#xD;&#xA;    ll code(vector<int> a,int n)&#xD;&#xA;    {&#xD;&#xA;        sort(a.begin(),a.end());  // not needed if the set you pass is already sorted.&#xD;&#xA;        int cur = 0;&#xD;&#xA;        int m = a.size();&#xD;&#xA;    &#xD;&#xA;        ll res =0;&#xD;&#xA;        for(int i=0;i<a.size();i++)&#xD;&#xA;        {&#xD;&#xA;            if(a[i] == cur+1)&#xD;&#xA;            {&#xD;&#xA;                res++;&#xD;&#xA;                cur = a[i];&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                res++;&#xD;&#xA;                int number_of_greater_nums = n - a[i];&#xD;&#xA;                for(int j = a[i]-1,increment=1;j>cur;j--,increment++)&#xD;&#xA;                    res += 1LL << (number_of_greater_nums+increment);&#xD;&#xA;                cur = a[i];&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;    // Takes the lexicographical code of a combination of n numbers and returns the &#xD;&#xA;    // combination&#xD;&#xA;    vector<int> decode(ll kod, int n)&#xD;&#xA;    {&#xD;&#xA;        vector<int> res;&#xD;&#xA;        int cur = 0;&#xD;&#xA;    &#xD;&#xA;        int left = n; // Out of how many numbers are we left to choose.&#xD;&#xA;        while(kod)&#xD;&#xA;        {&#xD;&#xA;            ll all = 1LL << left;// how many are the total combinations&#xD;&#xA;            for(int i=n;i>=0;i--)&#xD;&#xA;            {&#xD;&#xA;                if(all - (1LL << (n-i+1)) +1 <= kod)&#xD;&#xA;                {&#xD;&#xA;                    res.push_back(i);&#xD;&#xA;                    left = n-i;&#xD;&#xA;                    kod -= all - (1LL << (n-i+1)) +1;&#xD;&#xA;                    break;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Also this code stores the result in `long long` variable,  which is only enough for graphs with less than 64 elements. All possible hashes of graphs with 64 nodes will be `(2^64)^64`. This number has about 1280 **digits** so maybe is a big number. Still the algorithm I describe will work really fast and I believe you should be able to hash and 'unhash' graphs with a lot of vertices.&#xD;&#xA;&#xD;&#xA;Also have a look at [this question][1].&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/14160942/perfect-minimal-hash-for-mathematical-combinations/14160991#14160991";;added 303 characters in body
147256528;14560509;-1;5;94e5dba6-0e7d-42b8-b4f7-f37c49be9b4d;2017-05-23 12:17:17.0;"I will describe an algorithm to hash an arbitrary directed graph, not taking into account that the graph is acyclic. In fact even counting the acyclic graphs of a given order is a very complicated task and I believe here this will only make the hashing significantly more complicated and thus slower. &#xD;&#xA;&#xD;&#xA;A unique representation of the graph can be given by the neighbourhood list. For each vertex create a list with all it's neighbours. Write all the lists one after the other appending the number of neighbours for each list to the front. Also keep the neighbours sorted in ascending order to make the representation unique for each graph. So for example assume you have the graph:&#xD;&#xA;&#xD;&#xA;    1->2, 1->5&#xD;&#xA;    2->1, 2->4&#xD;&#xA;    3->4&#xD;&#xA;    5->3&#xD;&#xA;&#xD;&#xA;What I propose is that you transform this to `({2,2,5}, {2,1,4}, {1,4}, {0}, {1,3})`, here the curly brackets being only to visualize the representation, not part of the python's syntax. So the list is in fact: `(2,2,5, 2,1,4, 1,4, 0, 1,3)`.&#xD;&#xA;&#xD;&#xA;Now to compute the unique hash, you need to order these representations somehow and assign a unique number to them. I suggest you do something like a lexicographical sort to do that. Lets assume you have two sequences `(a1, b1_1, b_1_2,...b_1_a1,a2, b_2_1, b_2_2,...b_2_a2,...an, b_n_1, b_n_2,...b_n_an)` and  `(c1, d1_1, d_1_2,...d_1_c1,c2, d_2_1, d_2_2,...d_2_c2,...cn, d_n_1, d_n_2,...d_n_cn)`, Here c and a are the number of neighbours for each vertex and b_i_j and d_k_l are the corresponding neighbours. For the ordering first compare the sequnces `(a1,a2,...an)` and `(c1,c2, ...,cn)` and if they are different use this to compare the sequences. If these sequences are different, compare the lists from left to right first comparing lexicographically `(b_1_1, b_1_2...b_1_a1)` to `(d_1_1, d_1_2...d_1_c1)` and so on until the first missmatch.&#xD;&#xA;&#xD;&#xA;In fact what I propose to use as hash the lexicographical number of a word of size `N` over the alphabet that is formed by all possible selections of subsets of elements of `{1,2,3,...N}`. The neighbourhood list for a given vertex is a letter over this alphabet e.g. `{2,2,5}` is the subset consisting of two elements of the set, namely `2` and `5`.&#xD;&#xA;&#xD;&#xA;The _alphabet_(set of possible _letters_) for the set `{1,2,3}` would be(ordered _lexicographically_):&#xD;&#xA;&#xD;&#xA;`{0}, {1,1}, {1,2}, {1,3}, {2, 1, 2}, {2, 1, 3}, {2, 2, 3}, {3, 1, 2, 3}` &#xD;&#xA;&#xD;&#xA;First number like above is the number of elements in the given subset and the remaining numbers- the subset itself. So form all the 3 _letter words_ from this alphabet and you will get all the possible directed graphs with 3 vertices.&#xD;&#xA;&#xD;&#xA;Now the number of subsets of the set `{1,2,3,....N}` is `2^N` and thus the number of _letters_ of this alphabet is `2^N`. Now we code each directed graph of `N` nodes with a _word_ with exactly `N` _letters_ from this _alphabet_ and thus the number of possible hash codes is precisely: `(2^N)^N`. This is to show that the hash code grows **really** fast with the increase of `N`. Also this is the number of possible different directed graphs with `N` nodes so what I suggest is optimal hashing in the sense it is bijection and no smaller hash can be unique. &#xD;&#xA;&#xD;&#xA;There is a linear algorithm to get a given subset number in the the lexicographical ordering of all subsets of a given set, in this case `{1,2,....N}`. Here is the code I have written for coding/decoding a subset in number and vice versa. It is written in `C++` but quite easy to understand I hope. For the hashing you will need only the code function but as the hash I propose is reversable I add the decode function - you will be able to reconstruct the graph from the hash which is quite cool I think:&#xD;&#xA;&#xD;&#xA;    typedef long long ll;&#xD;&#xA;    &#xD;&#xA;    // Returns the number in the lexicographical order of all combinations of n numbers&#xD;&#xA;    // of the provided combination. &#xD;&#xA;    ll code(vector<int> a,int n)&#xD;&#xA;    {&#xD;&#xA;        sort(a.begin(),a.end());  // not needed if the set you pass is already sorted.&#xD;&#xA;        int cur = 0;&#xD;&#xA;        int m = a.size();&#xD;&#xA;    &#xD;&#xA;        ll res =0;&#xD;&#xA;        for(int i=0;i<a.size();i++)&#xD;&#xA;        {&#xD;&#xA;            if(a[i] == cur+1)&#xD;&#xA;            {&#xD;&#xA;                res++;&#xD;&#xA;                cur = a[i];&#xD;&#xA;                continue;&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                res++;&#xD;&#xA;                int number_of_greater_nums = n - a[i];&#xD;&#xA;                for(int j = a[i]-1,increment=1;j>cur;j--,increment++)&#xD;&#xA;                    res += 1LL << (number_of_greater_nums+increment);&#xD;&#xA;                cur = a[i];&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;    // Takes the lexicographical code of a combination of n numbers and returns the &#xD;&#xA;    // combination&#xD;&#xA;    vector<int> decode(ll kod, int n)&#xD;&#xA;    {&#xD;&#xA;        vector<int> res;&#xD;&#xA;        int cur = 0;&#xD;&#xA;    &#xD;&#xA;        int left = n; // Out of how many numbers are we left to choose.&#xD;&#xA;        while(kod)&#xD;&#xA;        {&#xD;&#xA;            ll all = 1LL << left;// how many are the total combinations&#xD;&#xA;            for(int i=n;i>=0;i--)&#xD;&#xA;            {&#xD;&#xA;                if(all - (1LL << (n-i+1)) +1 <= kod)&#xD;&#xA;                {&#xD;&#xA;                    res.push_back(i);&#xD;&#xA;                    left = n-i;&#xD;&#xA;                    kod -= all - (1LL << (n-i+1)) +1;&#xD;&#xA;                    break;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Also this code stores the result in `long long` variable,  which is only enough for graphs with less than 64 elements. All possible hashes of graphs with 64 nodes will be `(2^64)^64`. This number has about 1280 **digits** so maybe is a big number. Still the algorithm I describe will work really fast and I believe you should be able to hash and 'unhash' graphs with a lot of vertices.&#xD;&#xA;&#xD;&#xA;Also have a look at [this question][1].&#xD;&#xA;&#xD;&#xA;  [1]: https://stackoverflow.com/questions/14160942/perfect-minimal-hash-for-mathematical-combinations/14160991#14160991";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
