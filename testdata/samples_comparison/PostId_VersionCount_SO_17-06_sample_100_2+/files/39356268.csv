Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
126541972;39356268;895245;2;04cc7ff9-04b9-4009-9c2c-552ba364db17;2016-09-06 19:13:23.0;"**GLFW, Mesa, Ubuntu 16.04**&#xD;&#xA;&#xD;&#xA;This was not easy to setup on Ubuntu 14.04, but not it just works.&#xD;&#xA;&#xD;&#xA;    sudo apt-get install libglfw3-dev libgles2-mesa-dev&#xD;&#xA;    gcc glfw_triangle.c -lGLESv2 -lglfw -lGLEW&#xD;&#xA;&#xD;&#xA;Output:&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/zTbFX.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Source:&#xD;&#xA;&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    &#xD;&#xA;    #define GLEW_STATIC&#xD;&#xA;    #include <GL/glew.h>&#xD;&#xA;    &#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;    &#xD;&#xA;    static const GLuint WIDTH = 800;&#xD;&#xA;    static const GLuint HEIGHT = 600;&#xD;&#xA;    static const GLchar* vertex_shader_source =&#xD;&#xA;        ""#version 330 core\\n""&#xD;&#xA;        ""layout (location = 0) in vec3 position;\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_Position = vec4(position, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLchar* fragment_shader_source =&#xD;&#xA;        ""#version 330 core\\n""&#xD;&#xA;        ""out vec4 color;\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   color = vec4(1.0f, 0.0f, 0.0f, 1.0f);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLfloat vertices[] = {&#xD;&#xA;         0.0f,  0.5f, 0.0f,&#xD;&#xA;         0.5f, -0.5f, 0.0f,&#xD;&#xA;        -0.5f, -0.5f, 0.0f,&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    GLint common_get_shader_program(const char *vertex_shader_source, const char *fragment_shader_source) {&#xD;&#xA;        enum Consts {INFOLOG_LEN = 512};&#xD;&#xA;        GLchar infoLog[INFOLOG_LEN];&#xD;&#xA;        GLint fragment_shader;&#xD;&#xA;        GLint shader_program;&#xD;&#xA;        GLint success;&#xD;&#xA;        GLint vertex_shader;&#xD;&#xA;    &#xD;&#xA;        /* Vertex shader */&#xD;&#xA;        vertex_shader = glCreateShader(GL_VERTEX_SHADER);&#xD;&#xA;        glShaderSource(vertex_shader, 1, &vertex_shader_source, NULL);&#xD;&#xA;        glCompileShader(vertex_shader);&#xD;&#xA;        glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(vertex_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Fragment shader */&#xD;&#xA;        fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);&#xD;&#xA;        glShaderSource(fragment_shader, 1, &fragment_shader_source, NULL);&#xD;&#xA;        glCompileShader(fragment_shader);&#xD;&#xA;        glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(fragment_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Link shaders */&#xD;&#xA;        shader_program = glCreateProgram();&#xD;&#xA;        glAttachShader(shader_program, vertex_shader);&#xD;&#xA;        glAttachShader(shader_program, fragment_shader);&#xD;&#xA;        glLinkProgram(shader_program);&#xD;&#xA;        glGetProgramiv(shader_program, GL_LINK_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetProgramInfoLog(shader_program, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::PROGRAM::LINKING_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        glDeleteShader(vertex_shader);&#xD;&#xA;        glDeleteShader(fragment_shader);&#xD;&#xA;        return shader_program;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;        GLint shader_program, vbo, vao;;&#xD;&#xA;        GLFWwindow* window;&#xD;&#xA;    &#xD;&#xA;        shader_program = common_get_shader_program(vertex_shader_source, fragment_shader_source);&#xD;&#xA;        glfwInit();&#xD;&#xA;        window = glfwCreateWindow(WIDTH, HEIGHT, __FILE__, NULL, NULL);&#xD;&#xA;        glfwMakeContextCurrent(window);&#xD;&#xA;        glewExperimental = GL_TRUE;&#xD;&#xA;        glewInit();&#xD;&#xA;        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;        glViewport(0, 0, WIDTH, HEIGHT);&#xD;&#xA;    &#xD;&#xA;        glGenVertexArrays(1, &vao);&#xD;&#xA;        glGenBuffers(1, &vbo);&#xD;&#xA;        glBindVertexArray(vao);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, vbo);&#xD;&#xA;        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#xD;&#xA;        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0);&#xD;&#xA;        glEnableVertexAttribArray(0);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, 0);&#xD;&#xA;        glBindVertexArray(0);&#xD;&#xA;    &#xD;&#xA;        while (!glfwWindowShouldClose(window)) {&#xD;&#xA;            glfwPollEvents();&#xD;&#xA;            glClear(GL_COLOR_BUFFER_BIT);&#xD;&#xA;            glUseProgram(shader_program);&#xD;&#xA;            glBindVertexArray(vao);&#xD;&#xA;            glDrawArrays(GL_TRIANGLES, 0, 3);&#xD;&#xA;            glBindVertexArray(0);&#xD;&#xA;            glfwSwapBuffers(window);&#xD;&#xA;        }&#xD;&#xA;        glDeleteVertexArrays(1, &vao);&#xD;&#xA;        glDeleteBuffers(1, &vbo);&#xD;&#xA;        glfwTerminate();&#xD;&#xA;        return EXIT_SUCCESS;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The key line lines of code are:&#xD;&#xA;&#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;&#xD;&#xA;`GLFW_INCLUDE_ES2` is documented at: http://www.glfw.org/docs/latest/build_guide.html#build_macros and a quick look at the source shows that it forwards to GLES:&#xD;&#xA;&#xD;&#xA;     #elif defined(GLFW_INCLUDE_ES2)&#xD;&#xA;      #include <GLES2/gl2.h>&#xD;&#xA;      #if defined(GLFW_INCLUDE_GLEXT)&#xD;&#xA;       #include <GLES2/gl2ext.h>&#xD;&#xA;      #endif&#xD;&#xA;&#xD;&#xA;This source seems to be is in the common subset of GLES and OpenGL (like much of GLES), and also compiles with `-lGL` if we remove the `#define GLFW_INCLUDE_ES2`.&#xD;&#xA;&#xD;&#xA;If we add things which are not in GLES like immediate rendering `glBegin`, link fails as expected.";;
126544138;39356268;895245;5;434e8316-ab31-419b-aef2-f713d43fdf84;2016-09-06 19:51:57.0;"**GLFW, Mesa, Ubuntu 16.04 AMD64**&#xD;&#xA;&#xD;&#xA;This was not easy to setup on Ubuntu 14.04, but not it just works.&#xD;&#xA;&#xD;&#xA;    sudo apt-get install libglfw3-dev libgles2-mesa-dev&#xD;&#xA;    gcc glfw_triangle.c -lGLESv2 -lglfw -lGLEW&#xD;&#xA;&#xD;&#xA;Output:&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/zTbFX.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Source:&#xD;&#xA;&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    &#xD;&#xA;    #define GLEW_STATIC&#xD;&#xA;    #include <GL/glew.h>&#xD;&#xA;    &#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;    &#xD;&#xA;    static const GLuint WIDTH = 800;&#xD;&#xA;    static const GLuint HEIGHT = 600;&#xD;&#xA;    static const GLchar* vertex_shader_source =&#xD;&#xA;        ""#version 330 core\\n""&#xD;&#xA;        ""layout (location = 0) in vec3 position;\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_Position = vec4(position, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLchar* fragment_shader_source =&#xD;&#xA;        ""#version 330 core\\n""&#xD;&#xA;        ""out vec4 color;\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   color = vec4(1.0f, 0.0f, 0.0f, 1.0f);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLfloat vertices[] = {&#xD;&#xA;         0.0f,  0.5f, 0.0f,&#xD;&#xA;         0.5f, -0.5f, 0.0f,&#xD;&#xA;        -0.5f, -0.5f, 0.0f,&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    GLint common_get_shader_program(const char *vertex_shader_source, const char *fragment_shader_source) {&#xD;&#xA;        enum Consts {INFOLOG_LEN = 512};&#xD;&#xA;        GLchar infoLog[INFOLOG_LEN];&#xD;&#xA;        GLint fragment_shader;&#xD;&#xA;        GLint shader_program;&#xD;&#xA;        GLint success;&#xD;&#xA;        GLint vertex_shader;&#xD;&#xA;    &#xD;&#xA;        /* Vertex shader */&#xD;&#xA;        vertex_shader = glCreateShader(GL_VERTEX_SHADER);&#xD;&#xA;        glShaderSource(vertex_shader, 1, &vertex_shader_source, NULL);&#xD;&#xA;        glCompileShader(vertex_shader);&#xD;&#xA;        glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(vertex_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Fragment shader */&#xD;&#xA;        fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);&#xD;&#xA;        glShaderSource(fragment_shader, 1, &fragment_shader_source, NULL);&#xD;&#xA;        glCompileShader(fragment_shader);&#xD;&#xA;        glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(fragment_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Link shaders */&#xD;&#xA;        shader_program = glCreateProgram();&#xD;&#xA;        glAttachShader(shader_program, vertex_shader);&#xD;&#xA;        glAttachShader(shader_program, fragment_shader);&#xD;&#xA;        glLinkProgram(shader_program);&#xD;&#xA;        glGetProgramiv(shader_program, GL_LINK_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetProgramInfoLog(shader_program, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::PROGRAM::LINKING_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        glDeleteShader(vertex_shader);&#xD;&#xA;        glDeleteShader(fragment_shader);&#xD;&#xA;        return shader_program;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;        GLint shader_program, vbo, vao;;&#xD;&#xA;        GLFWwindow* window;&#xD;&#xA;    &#xD;&#xA;        shader_program = common_get_shader_program(vertex_shader_source, fragment_shader_source);&#xD;&#xA;        glfwInit();&#xD;&#xA;        window = glfwCreateWindow(WIDTH, HEIGHT, __FILE__, NULL, NULL);&#xD;&#xA;        glfwMakeContextCurrent(window);&#xD;&#xA;        glewExperimental = GL_TRUE;&#xD;&#xA;        glewInit();&#xD;&#xA;        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;        glViewport(0, 0, WIDTH, HEIGHT);&#xD;&#xA;    &#xD;&#xA;        glGenVertexArrays(1, &vao);&#xD;&#xA;        glGenBuffers(1, &vbo);&#xD;&#xA;        glBindVertexArray(vao);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, vbo);&#xD;&#xA;        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#xD;&#xA;        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0);&#xD;&#xA;        glEnableVertexAttribArray(0);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, 0);&#xD;&#xA;        glBindVertexArray(0);&#xD;&#xA;    &#xD;&#xA;        while (!glfwWindowShouldClose(window)) {&#xD;&#xA;            glfwPollEvents();&#xD;&#xA;            glClear(GL_COLOR_BUFFER_BIT);&#xD;&#xA;            glUseProgram(shader_program);&#xD;&#xA;            glBindVertexArray(vao);&#xD;&#xA;            glDrawArrays(GL_TRIANGLES, 0, 3);&#xD;&#xA;            glBindVertexArray(0);&#xD;&#xA;            glfwSwapBuffers(window);&#xD;&#xA;        }&#xD;&#xA;        glDeleteVertexArrays(1, &vao);&#xD;&#xA;        glDeleteBuffers(1, &vbo);&#xD;&#xA;        glfwTerminate();&#xD;&#xA;        return EXIT_SUCCESS;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The key line lines of code are:&#xD;&#xA;&#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;&#xD;&#xA;`GLFW_INCLUDE_ES2` is documented at: http://www.glfw.org/docs/latest/build_guide.html#build_macros and a quick look at the source shows that it forwards to GLES:&#xD;&#xA;&#xD;&#xA;     #elif defined(GLFW_INCLUDE_ES2)&#xD;&#xA;      #include <GLES2/gl2.h>&#xD;&#xA;      #if defined(GLFW_INCLUDE_GLEXT)&#xD;&#xA;       #include <GLES2/gl2ext.h>&#xD;&#xA;      #endif&#xD;&#xA;&#xD;&#xA;This source seems to be is in the common subset of GLES and OpenGL (like much of GLES), and also compiles with `-lGL` if we remove the `#define GLFW_INCLUDE_ES2`.&#xD;&#xA;&#xD;&#xA;If we add things which are not in GLES like immediate rendering `glBegin`, link fails as expected.";;added 6 characters in body
126549081;39356268;895245;5;37c68b1b-7384-493e-b616-a3393af60c6c;2016-09-06 21:27:47.0;"**GLFW, Mesa, Ubuntu 16.04 AMD64**&#xD;&#xA;&#xD;&#xA;This was not easy to setup on Ubuntu 14.04, but not it just works.&#xD;&#xA;&#xD;&#xA;    sudo apt-get install libglfw3-dev libgles2-mesa-dev&#xD;&#xA;    gcc glfw_triangle.c -lGLESv2 -lglfw -lGLEW&#xD;&#xA;&#xD;&#xA;Output:&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/zTbFX.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Source:&#xD;&#xA;&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    &#xD;&#xA;    #define GLEW_STATIC&#xD;&#xA;    #include <GL/glew.h>&#xD;&#xA;    &#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;    &#xD;&#xA;    static const GLuint WIDTH = 800;&#xD;&#xA;    static const GLuint HEIGHT = 600;&#xD;&#xA;    static const GLchar* vertex_shader_source =&#xD;&#xA;        ""#version 330 core\\n""&#xD;&#xA;        ""layout (location = 0) in vec3 position;\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_Position = vec4(position, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLchar* fragment_shader_source =&#xD;&#xA;        ""#version 330 core\\n""&#xD;&#xA;        ""out vec4 color;\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   color = vec4(1.0f, 0.0f, 0.0f, 1.0f);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLfloat vertices[] = {&#xD;&#xA;         0.0f,  0.5f, 0.0f,&#xD;&#xA;         0.5f, -0.5f, 0.0f,&#xD;&#xA;        -0.5f, -0.5f, 0.0f,&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    GLint common_get_shader_program(const char *vertex_shader_source, const char *fragment_shader_source) {&#xD;&#xA;        enum Consts {INFOLOG_LEN = 512};&#xD;&#xA;        GLchar infoLog[INFOLOG_LEN];&#xD;&#xA;        GLint fragment_shader;&#xD;&#xA;        GLint shader_program;&#xD;&#xA;        GLint success;&#xD;&#xA;        GLint vertex_shader;&#xD;&#xA;    &#xD;&#xA;        /* Vertex shader */&#xD;&#xA;        vertex_shader = glCreateShader(GL_VERTEX_SHADER);&#xD;&#xA;        glShaderSource(vertex_shader, 1, &vertex_shader_source, NULL);&#xD;&#xA;        glCompileShader(vertex_shader);&#xD;&#xA;        glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(vertex_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Fragment shader */&#xD;&#xA;        fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);&#xD;&#xA;        glShaderSource(fragment_shader, 1, &fragment_shader_source, NULL);&#xD;&#xA;        glCompileShader(fragment_shader);&#xD;&#xA;        glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(fragment_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Link shaders */&#xD;&#xA;        shader_program = glCreateProgram();&#xD;&#xA;        glAttachShader(shader_program, vertex_shader);&#xD;&#xA;        glAttachShader(shader_program, fragment_shader);&#xD;&#xA;        glLinkProgram(shader_program);&#xD;&#xA;        glGetProgramiv(shader_program, GL_LINK_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetProgramInfoLog(shader_program, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::PROGRAM::LINKING_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        glDeleteShader(vertex_shader);&#xD;&#xA;        glDeleteShader(fragment_shader);&#xD;&#xA;        return shader_program;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;        GLint shader_program, vbo, vao;;&#xD;&#xA;        GLFWwindow* window;&#xD;&#xA;    &#xD;&#xA;        shader_program = common_get_shader_program(vertex_shader_source, fragment_shader_source);&#xD;&#xA;        glfwInit();&#xD;&#xA;        window = glfwCreateWindow(WIDTH, HEIGHT, __FILE__, NULL, NULL);&#xD;&#xA;        glfwMakeContextCurrent(window);&#xD;&#xA;        glewExperimental = GL_TRUE;&#xD;&#xA;        glewInit();&#xD;&#xA;        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;        glViewport(0, 0, WIDTH, HEIGHT);&#xD;&#xA;    &#xD;&#xA;        glGenVertexArrays(1, &vao);&#xD;&#xA;        glGenBuffers(1, &vbo);&#xD;&#xA;        glBindVertexArray(vao);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, vbo);&#xD;&#xA;        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#xD;&#xA;        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0);&#xD;&#xA;        glEnableVertexAttribArray(0);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, 0);&#xD;&#xA;        glBindVertexArray(0);&#xD;&#xA;    &#xD;&#xA;        while (!glfwWindowShouldClose(window)) {&#xD;&#xA;            glfwPollEvents();&#xD;&#xA;            glClear(GL_COLOR_BUFFER_BIT);&#xD;&#xA;            glUseProgram(shader_program);&#xD;&#xA;            glBindVertexArray(vao);&#xD;&#xA;            glDrawArrays(GL_TRIANGLES, 0, 3);&#xD;&#xA;            glBindVertexArray(0);&#xD;&#xA;            glfwSwapBuffers(window);&#xD;&#xA;        }&#xD;&#xA;        glDeleteVertexArrays(1, &vao);&#xD;&#xA;        glDeleteBuffers(1, &vbo);&#xD;&#xA;        glfwTerminate();&#xD;&#xA;        return EXIT_SUCCESS;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The key line lines of code are:&#xD;&#xA;&#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;&#xD;&#xA;`GLFW_INCLUDE_ES2` is documented at: http://www.glfw.org/docs/latest/build_guide.html#build_macros and a quick look at the source shows that it forwards to GLES:&#xD;&#xA;&#xD;&#xA;     #elif defined(GLFW_INCLUDE_ES2)&#xD;&#xA;      #include <GLES2/gl2.h>&#xD;&#xA;      #if defined(GLFW_INCLUDE_GLEXT)&#xD;&#xA;       #include <GLES2/gl2ext.h>&#xD;&#xA;      #endif&#xD;&#xA;&#xD;&#xA;This source seems to be is in the common subset of GLES and OpenGL (like much of GLES), and also compiles with `-lGL` if we remove the `#define GLFW_INCLUDE_ES2`.&#xD;&#xA;&#xD;&#xA;If we add things which are not in GLES like immediate rendering `glBegin`, link fails as expected.&#xD;&#xA;&#xD;&#xA;See also: http://askubuntu.com/questions/244133/how-do-i-get-egl-and-opengles-libraries-for-ubuntu-running-on-virtualbox";;added 124 characters in body
126563777;39356268;44729;5;f7cf51bd-a32e-4180-a5c9-66059e195efe;2016-09-07 05:27:40.0;"**GLFW, Mesa, Ubuntu 16.04 AMD64**&#xD;&#xA;&#xD;&#xA;This was not easy to setup on Ubuntu 14.04, but not it just works.&#xD;&#xA;&#xD;&#xA;    sudo apt-get install libglfw3-dev libgles2-mesa-dev&#xD;&#xA;    gcc glfw_triangle.c -lGLESv2 -lglfw -lGLEW&#xD;&#xA;&#xD;&#xA;Output:&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/zTbFX.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Source:&#xD;&#xA;&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    &#xD;&#xA;    #define GLEW_STATIC&#xD;&#xA;    #include <GL/glew.h>&#xD;&#xA;    &#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;    &#xD;&#xA;    static const GLuint WIDTH = 800;&#xD;&#xA;    static const GLuint HEIGHT = 600;&#xD;&#xA;    static const GLchar* vertex_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""attribute vec3 position;\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_Position = vec4(position, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLchar* fragment_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLfloat vertices[] = {&#xD;&#xA;         0.0f,  0.5f, 0.0f,&#xD;&#xA;         0.5f, -0.5f, 0.0f,&#xD;&#xA;        -0.5f, -0.5f, 0.0f,&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    GLint common_get_shader_program(const char *vertex_shader_source, const char *fragment_shader_source) {&#xD;&#xA;        enum Consts {INFOLOG_LEN = 512};&#xD;&#xA;        GLchar infoLog[INFOLOG_LEN];&#xD;&#xA;        GLint fragment_shader;&#xD;&#xA;        GLint shader_program;&#xD;&#xA;        GLint success;&#xD;&#xA;        GLint vertex_shader;&#xD;&#xA;    &#xD;&#xA;        /* Vertex shader */&#xD;&#xA;        vertex_shader = glCreateShader(GL_VERTEX_SHADER);&#xD;&#xA;        glShaderSource(vertex_shader, 1, &vertex_shader_source, NULL);&#xD;&#xA;        glCompileShader(vertex_shader);&#xD;&#xA;        glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(vertex_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Fragment shader */&#xD;&#xA;        fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);&#xD;&#xA;        glShaderSource(fragment_shader, 1, &fragment_shader_source, NULL);&#xD;&#xA;        glCompileShader(fragment_shader);&#xD;&#xA;        glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(fragment_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Link shaders */&#xD;&#xA;        shader_program = glCreateProgram();&#xD;&#xA;        glAttachShader(shader_program, vertex_shader);&#xD;&#xA;        glAttachShader(shader_program, fragment_shader);&#xD;&#xA;        glLinkProgram(shader_program);&#xD;&#xA;        glGetProgramiv(shader_program, GL_LINK_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetProgramInfoLog(shader_program, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::PROGRAM::LINKING_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        glDeleteShader(vertex_shader);&#xD;&#xA;        glDeleteShader(fragment_shader);&#xD;&#xA;        return shader_program;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;        GLuint shader_program, vbo;&#xD;&#xA;        GLint pos;&#xD;&#xA;        GLFWwindow* window;&#xD;&#xA;    &#xD;&#xA;        glfwInit();&#xD;&#xA;        window = glfwCreateWindow(WIDTH, HEIGHT, __FILE__, NULL, NULL);&#xD;&#xA;        glfwMakeContextCurrent(window);&#xD;&#xA;        glewExperimental = GL_TRUE;&#xD;&#xA;        glewInit();&#xD;&#xA;    &#xD;&#xA;        shader_program = common_get_shader_program(vertex_shader_source, fragment_shader_source);&#xD;&#xA;        pos = glGetAttribLocation( shader_program, ""position"" );&#xD;&#xA;        &#xD;&#xA;        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;        glViewport(0, 0, WIDTH, HEIGHT);&#xD;&#xA;    &#xD;&#xA;        glGenBuffers(1, &vbo);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, vbo);&#xD;&#xA;        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#xD;&#xA;        glVertexAttribPointer(pos, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0);&#xD;&#xA;        glEnableVertexAttribArray(pos);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, 0);&#xD;&#xA;    &#xD;&#xA;        while (!glfwWindowShouldClose(window)) {&#xD;&#xA;            glfwPollEvents();&#xD;&#xA;            glClear(GL_COLOR_BUFFER_BIT);&#xD;&#xA;            glUseProgram(shader_program);&#xD;&#xA;            glDrawArrays(GL_TRIANGLES, 0, 3);&#xD;&#xA;            glfwSwapBuffers(window);&#xD;&#xA;        }&#xD;&#xA;        glDeleteBuffers(1, &vbo);&#xD;&#xA;        glfwTerminate();&#xD;&#xA;        return EXIT_SUCCESS;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The key line lines of code are:&#xD;&#xA;&#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;&#xD;&#xA;`GLFW_INCLUDE_ES2` is documented at: http://www.glfw.org/docs/latest/build_guide.html#build_macros and a quick look at the source shows that it forwards to GLES:&#xD;&#xA;&#xD;&#xA;     #elif defined(GLFW_INCLUDE_ES2)&#xD;&#xA;      #include <GLES2/gl2.h>&#xD;&#xA;      #if defined(GLFW_INCLUDE_GLEXT)&#xD;&#xA;       #include <GLES2/gl2ext.h>&#xD;&#xA;      #endif&#xD;&#xA;&#xD;&#xA;This source seems to be is in the common subset of GLES and OpenGL (like much of GLES), and also compiles with `-lGL` if we remove the `#define GLFW_INCLUDE_ES2`.&#xD;&#xA;&#xD;&#xA;If we add things which are not in GLES like immediate rendering `glBegin`, link fails as expected.&#xD;&#xA;&#xD;&#xA;See also: http://askubuntu.com/questions/244133/how-do-i-get-egl-and-opengles-libraries-for-ubuntu-running-on-virtualbox&#xD;&#xA;";;Reworked shaders for #version 100
126564429;39356268;44729;5;8fb7c287-f189-42c0-9e3e-adf31ff4c607;2016-09-07 05:41:59.0;"**GLFW, Mesa, Ubuntu 16.04 AMD64**&#xD;&#xA;&#xD;&#xA;This was not easy to setup on Ubuntu 14.04, but not it just works.&#xD;&#xA;&#xD;&#xA;    sudo apt-get install libglfw3-dev libgles2-mesa-dev&#xD;&#xA;    gcc glfw_triangle.c -lGLESv2 -lglfw&#xD;&#xA;&#xD;&#xA;Output:&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/zTbFX.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Source:&#xD;&#xA;&#xD;&#xA;#include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;&#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;&#xD;&#xA;    static const GLuint WIDTH = 800;&#xD;&#xA;    static const GLuint HEIGHT = 600;&#xD;&#xA;    static const GLchar* vertex_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""attribute vec3 position;\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_Position = vec4(position, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLchar* fragment_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLfloat vertices[] = {&#xD;&#xA;         0.0f,  0.5f, 0.0f,&#xD;&#xA;         0.5f, -0.5f, 0.0f,&#xD;&#xA;        -0.5f, -0.5f, 0.0f,&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    GLint common_get_shader_program(const char *vertex_shader_source, const char *fragment_shader_source) {&#xD;&#xA;        enum Consts {INFOLOG_LEN = 512};&#xD;&#xA;        GLchar infoLog[INFOLOG_LEN];&#xD;&#xA;        GLint fragment_shader;&#xD;&#xA;        GLint shader_program;&#xD;&#xA;        GLint success;&#xD;&#xA;        GLint vertex_shader;&#xD;&#xA;&#xD;&#xA;        /* Vertex shader */&#xD;&#xA;        vertex_shader = glCreateShader(GL_VERTEX_SHADER);&#xD;&#xA;        glShaderSource(vertex_shader, 1, &vertex_shader_source, NULL);&#xD;&#xA;        glCompileShader(vertex_shader);&#xD;&#xA;        glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(vertex_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        /* Fragment shader */&#xD;&#xA;        fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);&#xD;&#xA;        glShaderSource(fragment_shader, 1, &fragment_shader_source, NULL);&#xD;&#xA;        glCompileShader(fragment_shader);&#xD;&#xA;        glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(fragment_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        /* Link shaders */&#xD;&#xA;        shader_program = glCreateProgram();&#xD;&#xA;        glAttachShader(shader_program, vertex_shader);&#xD;&#xA;        glAttachShader(shader_program, fragment_shader);&#xD;&#xA;        glLinkProgram(shader_program);&#xD;&#xA;        glGetProgramiv(shader_program, GL_LINK_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetProgramInfoLog(shader_program, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::PROGRAM::LINKING_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        glDeleteShader(vertex_shader);&#xD;&#xA;        glDeleteShader(fragment_shader);&#xD;&#xA;        return shader_program;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    int main(void) {&#xD;&#xA;        GLuint shader_program, vbo;&#xD;&#xA;        GLint pos;&#xD;&#xA;        GLFWwindow* window;&#xD;&#xA;&#xD;&#xA;        glfwInit();&#xD;&#xA;        glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);&#xD;&#xA;        window = glfwCreateWindow(WIDTH, HEIGHT, __FILE__, NULL, NULL);&#xD;&#xA;        glfwMakeContextCurrent(window);&#xD;&#xA;&#xD;&#xA;        printf(""GL_VERSION  : %s\\n"", glGetString(GL_VERSION) );&#xD;&#xA;        printf(""GL_RENDERER : %s\\n"", glGetString(GL_RENDERER) );&#xD;&#xA;&#xD;&#xA;        shader_program = common_get_shader_program(vertex_shader_source, fragment_shader_source);&#xD;&#xA;        pos = glGetAttribLocation( shader_program, ""position"" );&#xD;&#xA;        &#xD;&#xA;        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;        glViewport(0, 0, WIDTH, HEIGHT);&#xD;&#xA;&#xD;&#xA;        glGenBuffers(1, &vbo);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, vbo);&#xD;&#xA;        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#xD;&#xA;        glVertexAttribPointer(pos, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0);&#xD;&#xA;        glEnableVertexAttribArray(pos);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, 0);&#xD;&#xA;&#xD;&#xA;        while (!glfwWindowShouldClose(window)) {&#xD;&#xA;            glfwPollEvents();&#xD;&#xA;            glClear(GL_COLOR_BUFFER_BIT);&#xD;&#xA;            glUseProgram(shader_program);&#xD;&#xA;            glDrawArrays(GL_TRIANGLES, 0, 3);&#xD;&#xA;            glfwSwapBuffers(window);&#xD;&#xA;        }&#xD;&#xA;        glDeleteBuffers(1, &vbo);&#xD;&#xA;        glfwTerminate();&#xD;&#xA;        return EXIT_SUCCESS;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The key line lines of code are:&#xD;&#xA;&#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;&#xD;&#xA;`GLFW_INCLUDE_ES2` is documented at: http://www.glfw.org/docs/latest/build_guide.html#build_macros and a quick look at the source shows that it forwards to GLES:&#xD;&#xA;&#xD;&#xA;     #elif defined(GLFW_INCLUDE_ES2)&#xD;&#xA;      #include <GLES2/gl2.h>&#xD;&#xA;      #if defined(GLFW_INCLUDE_GLEXT)&#xD;&#xA;       #include <GLES2/gl2ext.h>&#xD;&#xA;      #endif&#xD;&#xA;&#xD;&#xA;This source seems to be is in the common subset of GLES and OpenGL (like much of GLES), and also compiles with `-lGL` if we remove the `#define GLFW_INCLUDE_ES2`.&#xD;&#xA;&#xD;&#xA;If we add things which are not in GLES like immediate rendering `glBegin`, link fails as expected.&#xD;&#xA;&#xD;&#xA;See also: http://askubuntu.com/questions/244133/how-do-i-get-egl-and-opengles-libraries-for-ubuntu-running-on-virtualbox&#xD;&#xA;";;Don't really *need* GLEW on Linux
126569432;39356268;895245;5;c5dd02e3-0c9a-4cc0-802d-cb74b4f70db4;2016-09-07 07:03:30.0;"**GLFW, Mesa, Ubuntu 16.04 AMD64**&#xD;&#xA;&#xD;&#xA;This was not easy to setup on Ubuntu 14.04, but not it just works.&#xD;&#xA;&#xD;&#xA;    sudo apt-get install libglfw3-dev libgles2-mesa-dev&#xD;&#xA;    gcc glfw_triangle.c -lGLESv2 -lglfw&#xD;&#xA;&#xD;&#xA;Output:&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/zTbFX.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Source:&#xD;&#xA;&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    &#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;    &#xD;&#xA;    static const GLuint WIDTH = 800;&#xD;&#xA;    static const GLuint HEIGHT = 600;&#xD;&#xA;    static const GLchar* vertex_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""attribute vec3 position;\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_Position = vec4(position, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLchar* fragment_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLfloat vertices[] = {&#xD;&#xA;            0.0f,  0.5f, 0.0f,&#xD;&#xA;            0.5f, -0.5f, 0.0f,&#xD;&#xA;        -0.5f, -0.5f, 0.0f,&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    GLint common_get_shader_program(const char *vertex_shader_source, const char *fragment_shader_source) {&#xD;&#xA;        enum Consts {INFOLOG_LEN = 512};&#xD;&#xA;        GLchar infoLog[INFOLOG_LEN];&#xD;&#xA;        GLint fragment_shader;&#xD;&#xA;        GLint shader_program;&#xD;&#xA;        GLint success;&#xD;&#xA;        GLint vertex_shader;&#xD;&#xA;    &#xD;&#xA;        /* Vertex shader */&#xD;&#xA;        vertex_shader = glCreateShader(GL_VERTEX_SHADER);&#xD;&#xA;        glShaderSource(vertex_shader, 1, &vertex_shader_source, NULL);&#xD;&#xA;        glCompileShader(vertex_shader);&#xD;&#xA;        glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(vertex_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Fragment shader */&#xD;&#xA;        fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);&#xD;&#xA;        glShaderSource(fragment_shader, 1, &fragment_shader_source, NULL);&#xD;&#xA;        glCompileShader(fragment_shader);&#xD;&#xA;        glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(fragment_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Link shaders */&#xD;&#xA;        shader_program = glCreateProgram();&#xD;&#xA;        glAttachShader(shader_program, vertex_shader);&#xD;&#xA;        glAttachShader(shader_program, fragment_shader);&#xD;&#xA;        glLinkProgram(shader_program);&#xD;&#xA;        glGetProgramiv(shader_program, GL_LINK_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetProgramInfoLog(shader_program, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::PROGRAM::LINKING_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        glDeleteShader(vertex_shader);&#xD;&#xA;        glDeleteShader(fragment_shader);&#xD;&#xA;        return shader_program;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;        GLuint shader_program, vbo;&#xD;&#xA;        GLint pos;&#xD;&#xA;        GLFWwindow* window;&#xD;&#xA;    &#xD;&#xA;        glfwInit();&#xD;&#xA;        glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);&#xD;&#xA;        window = glfwCreateWindow(WIDTH, HEIGHT, __FILE__, NULL, NULL);&#xD;&#xA;        glfwMakeContextCurrent(window);&#xD;&#xA;    &#xD;&#xA;        printf(""GL_VERSION  : %s\\n"", glGetString(GL_VERSION) );&#xD;&#xA;        printf(""GL_RENDERER : %s\\n"", glGetString(GL_RENDERER) );&#xD;&#xA;    &#xD;&#xA;        shader_program = common_get_shader_program(vertex_shader_source, fragment_shader_source);&#xD;&#xA;        pos = glGetAttribLocation(shader_program, ""position"");&#xD;&#xA;    &#xD;&#xA;        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;        glViewport(0, 0, WIDTH, HEIGHT);&#xD;&#xA;    &#xD;&#xA;        glGenBuffers(1, &vbo);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, vbo);&#xD;&#xA;        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#xD;&#xA;        glVertexAttribPointer(pos, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0);&#xD;&#xA;        glEnableVertexAttribArray(pos);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, 0);&#xD;&#xA;    &#xD;&#xA;        while (!glfwWindowShouldClose(window)) {&#xD;&#xA;            glfwPollEvents();&#xD;&#xA;            glClear(GL_COLOR_BUFFER_BIT);&#xD;&#xA;            glUseProgram(shader_program);&#xD;&#xA;            glDrawArrays(GL_TRIANGLES, 0, 3);&#xD;&#xA;            glfwSwapBuffers(window);&#xD;&#xA;        }&#xD;&#xA;        glDeleteBuffers(1, &vbo);&#xD;&#xA;        glfwTerminate();&#xD;&#xA;        return EXIT_SUCCESS;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The key line lines of code are:&#xD;&#xA;&#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;&#xD;&#xA;`GLFW_INCLUDE_ES2` is documented at: http://www.glfw.org/docs/latest/build_guide.html#build_macros and a quick look at the source shows that it forwards to GLES:&#xD;&#xA;&#xD;&#xA;     #elif defined(GLFW_INCLUDE_ES2)&#xD;&#xA;      #include <GLES2/gl2.h>&#xD;&#xA;      #if defined(GLFW_INCLUDE_GLEXT)&#xD;&#xA;       #include <GLES2/gl2ext.h>&#xD;&#xA;      #endif&#xD;&#xA;&#xD;&#xA;This source seems to be is in the common subset of GLES and OpenGL (like much of GLES), and also compiles with `-lGL` if we remove the `#define GLFW_INCLUDE_ES2`.&#xD;&#xA;&#xD;&#xA;If we add things which are not in GLES like immediate rendering `glBegin`, link fails as expected.&#xD;&#xA;&#xD;&#xA;See also: http://askubuntu.com/questions/244133/how-do-i-get-egl-and-opengles-libraries-for-ubuntu-running-on-virtualbox&#xD;&#xA;&#xD;&#xA;";;added 4 characters in body
126569905;39356268;895245;5;e32af6e3-8e41-4411-817c-9cf806154237;2016-09-07 07:09:50.0;"**GLFW, Mesa, Ubuntu 16.04 AMD64**&#xD;&#xA;&#xD;&#xA;This was not easy to setup on Ubuntu 14.04, but not it just works.&#xD;&#xA;&#xD;&#xA;    sudo apt-get install libglfw3-dev libgles2-mesa-dev&#xD;&#xA;    gcc glfw_triangle.c -lGLESv2 -lglfw&#xD;&#xA;&#xD;&#xA;Output:&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/zTbFX.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Source:&#xD;&#xA;&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    &#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;    &#xD;&#xA;    static const GLuint WIDTH = 800;&#xD;&#xA;    static const GLuint HEIGHT = 600;&#xD;&#xA;    static const GLchar* vertex_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""attribute vec3 position;\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_Position = vec4(position, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLchar* fragment_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLfloat vertices[] = {&#xD;&#xA;            0.0f,  0.5f, 0.0f,&#xD;&#xA;            0.5f, -0.5f, 0.0f,&#xD;&#xA;        -0.5f, -0.5f, 0.0f,&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    GLint common_get_shader_program(const char *vertex_shader_source, const char *fragment_shader_source) {&#xD;&#xA;        enum Consts {INFOLOG_LEN = 512};&#xD;&#xA;        GLchar infoLog[INFOLOG_LEN];&#xD;&#xA;        GLint fragment_shader;&#xD;&#xA;        GLint shader_program;&#xD;&#xA;        GLint success;&#xD;&#xA;        GLint vertex_shader;&#xD;&#xA;    &#xD;&#xA;        /* Vertex shader */&#xD;&#xA;        vertex_shader = glCreateShader(GL_VERTEX_SHADER);&#xD;&#xA;        glShaderSource(vertex_shader, 1, &vertex_shader_source, NULL);&#xD;&#xA;        glCompileShader(vertex_shader);&#xD;&#xA;        glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(vertex_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Fragment shader */&#xD;&#xA;        fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);&#xD;&#xA;        glShaderSource(fragment_shader, 1, &fragment_shader_source, NULL);&#xD;&#xA;        glCompileShader(fragment_shader);&#xD;&#xA;        glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(fragment_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Link shaders */&#xD;&#xA;        shader_program = glCreateProgram();&#xD;&#xA;        glAttachShader(shader_program, vertex_shader);&#xD;&#xA;        glAttachShader(shader_program, fragment_shader);&#xD;&#xA;        glLinkProgram(shader_program);&#xD;&#xA;        glGetProgramiv(shader_program, GL_LINK_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetProgramInfoLog(shader_program, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::PROGRAM::LINKING_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        glDeleteShader(vertex_shader);&#xD;&#xA;        glDeleteShader(fragment_shader);&#xD;&#xA;        return shader_program;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;        GLuint shader_program, vbo;&#xD;&#xA;        GLint pos;&#xD;&#xA;        GLFWwindow* window;&#xD;&#xA;    &#xD;&#xA;        glfwInit();&#xD;&#xA;        glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);&#xD;&#xA;        window = glfwCreateWindow(WIDTH, HEIGHT, __FILE__, NULL, NULL);&#xD;&#xA;        glfwMakeContextCurrent(window);&#xD;&#xA;    &#xD;&#xA;        printf(""GL_VERSION  : %s\\n"", glGetString(GL_VERSION) );&#xD;&#xA;        printf(""GL_RENDERER : %s\\n"", glGetString(GL_RENDERER) );&#xD;&#xA;    &#xD;&#xA;        shader_program = common_get_shader_program(vertex_shader_source, fragment_shader_source);&#xD;&#xA;        pos = glGetAttribLocation(shader_program, ""position"");&#xD;&#xA;    &#xD;&#xA;        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;        glViewport(0, 0, WIDTH, HEIGHT);&#xD;&#xA;    &#xD;&#xA;        glGenBuffers(1, &vbo);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, vbo);&#xD;&#xA;        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#xD;&#xA;        glVertexAttribPointer(pos, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0);&#xD;&#xA;        glEnableVertexAttribArray(pos);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, 0);&#xD;&#xA;    &#xD;&#xA;        while (!glfwWindowShouldClose(window)) {&#xD;&#xA;            glfwPollEvents();&#xD;&#xA;            glClear(GL_COLOR_BUFFER_BIT);&#xD;&#xA;            glUseProgram(shader_program);&#xD;&#xA;            glDrawArrays(GL_TRIANGLES, 0, 3);&#xD;&#xA;            glfwSwapBuffers(window);&#xD;&#xA;        }&#xD;&#xA;        glDeleteBuffers(1, &vbo);&#xD;&#xA;        glfwTerminate();&#xD;&#xA;        return EXIT_SUCCESS;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The key line lines of code are:&#xD;&#xA;&#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;&#xD;&#xA;`GLFW_INCLUDE_ES2` is documented at: http://www.glfw.org/docs/latest/build_guide.html#build_macros and a quick look at the source shows that it forwards to GLES:&#xD;&#xA;&#xD;&#xA;     #elif defined(GLFW_INCLUDE_ES2)&#xD;&#xA;      #include <GLES2/gl2.h>&#xD;&#xA;      #if defined(GLFW_INCLUDE_GLEXT)&#xD;&#xA;       #include <GLES2/gl2ext.h>&#xD;&#xA;      #endif&#xD;&#xA;&#xD;&#xA;This source seems to be is in the common subset of GLES and OpenGL (like much of GLES), and also compiles with `-lGL` if we remove the `#define GLFW_INCLUDE_ES2`.&#xD;&#xA;&#xD;&#xA;If we add things which are not in GLES like immediate rendering `glBegin`, link fails as expected.&#xD;&#xA;&#xD;&#xA;See also: http://askubuntu.com/questions/244133/how-do-i-get-egl-and-opengles-libraries-for-ubuntu-running-on-virtualbox&#xD;&#xA;&#xD;&#xA;Credits: [genpfult](http://stackoverflow.com/questions/3809236/how-to-develop-opengl-es-gles-2-0-applications-on-linux/39356268?noredirect=1#comment66052787_39356268) made the code much more correct.";;added 199 characters in body
126570395;39356268;895245;5;cc881374-b822-4de2-816e-ed1dde57e45d;2016-09-07 07:15:48.0;"**GLFW, Mesa, Ubuntu 16.04 AMD64**&#xD;&#xA;&#xD;&#xA;This was not easy to setup on Ubuntu 14.04, but now it just works.&#xD;&#xA;&#xD;&#xA;    sudo apt-get install libglfw3-dev libgles2-mesa-dev&#xD;&#xA;    gcc glfw_triangle.c -lGLESv2 -lglfw&#xD;&#xA;&#xD;&#xA;Output:&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/zTbFX.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Source:&#xD;&#xA;&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    &#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;    &#xD;&#xA;    static const GLuint WIDTH = 800;&#xD;&#xA;    static const GLuint HEIGHT = 600;&#xD;&#xA;    static const GLchar* vertex_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""attribute vec3 position;\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_Position = vec4(position, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLchar* fragment_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLfloat vertices[] = {&#xD;&#xA;            0.0f,  0.5f, 0.0f,&#xD;&#xA;            0.5f, -0.5f, 0.0f,&#xD;&#xA;        -0.5f, -0.5f, 0.0f,&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    GLint common_get_shader_program(const char *vertex_shader_source, const char *fragment_shader_source) {&#xD;&#xA;        enum Consts {INFOLOG_LEN = 512};&#xD;&#xA;        GLchar infoLog[INFOLOG_LEN];&#xD;&#xA;        GLint fragment_shader;&#xD;&#xA;        GLint shader_program;&#xD;&#xA;        GLint success;&#xD;&#xA;        GLint vertex_shader;&#xD;&#xA;    &#xD;&#xA;        /* Vertex shader */&#xD;&#xA;        vertex_shader = glCreateShader(GL_VERTEX_SHADER);&#xD;&#xA;        glShaderSource(vertex_shader, 1, &vertex_shader_source, NULL);&#xD;&#xA;        glCompileShader(vertex_shader);&#xD;&#xA;        glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(vertex_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Fragment shader */&#xD;&#xA;        fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);&#xD;&#xA;        glShaderSource(fragment_shader, 1, &fragment_shader_source, NULL);&#xD;&#xA;        glCompileShader(fragment_shader);&#xD;&#xA;        glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(fragment_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Link shaders */&#xD;&#xA;        shader_program = glCreateProgram();&#xD;&#xA;        glAttachShader(shader_program, vertex_shader);&#xD;&#xA;        glAttachShader(shader_program, fragment_shader);&#xD;&#xA;        glLinkProgram(shader_program);&#xD;&#xA;        glGetProgramiv(shader_program, GL_LINK_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetProgramInfoLog(shader_program, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::PROGRAM::LINKING_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        glDeleteShader(vertex_shader);&#xD;&#xA;        glDeleteShader(fragment_shader);&#xD;&#xA;        return shader_program;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;        GLuint shader_program, vbo;&#xD;&#xA;        GLint pos;&#xD;&#xA;        GLFWwindow* window;&#xD;&#xA;    &#xD;&#xA;        glfwInit();&#xD;&#xA;        glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);&#xD;&#xA;        window = glfwCreateWindow(WIDTH, HEIGHT, __FILE__, NULL, NULL);&#xD;&#xA;        glfwMakeContextCurrent(window);&#xD;&#xA;    &#xD;&#xA;        printf(""GL_VERSION  : %s\\n"", glGetString(GL_VERSION) );&#xD;&#xA;        printf(""GL_RENDERER : %s\\n"", glGetString(GL_RENDERER) );&#xD;&#xA;    &#xD;&#xA;        shader_program = common_get_shader_program(vertex_shader_source, fragment_shader_source);&#xD;&#xA;        pos = glGetAttribLocation(shader_program, ""position"");&#xD;&#xA;    &#xD;&#xA;        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;        glViewport(0, 0, WIDTH, HEIGHT);&#xD;&#xA;    &#xD;&#xA;        glGenBuffers(1, &vbo);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, vbo);&#xD;&#xA;        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#xD;&#xA;        glVertexAttribPointer(pos, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0);&#xD;&#xA;        glEnableVertexAttribArray(pos);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, 0);&#xD;&#xA;    &#xD;&#xA;        while (!glfwWindowShouldClose(window)) {&#xD;&#xA;            glfwPollEvents();&#xD;&#xA;            glClear(GL_COLOR_BUFFER_BIT);&#xD;&#xA;            glUseProgram(shader_program);&#xD;&#xA;            glDrawArrays(GL_TRIANGLES, 0, 3);&#xD;&#xA;            glfwSwapBuffers(window);&#xD;&#xA;        }&#xD;&#xA;        glDeleteBuffers(1, &vbo);&#xD;&#xA;        glfwTerminate();&#xD;&#xA;        return EXIT_SUCCESS;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The key line lines of code are:&#xD;&#xA;&#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;&#xD;&#xA;`GLFW_INCLUDE_ES2` is documented at: http://www.glfw.org/docs/latest/build_guide.html#build_macros and a quick look at the source shows that it forwards to GLES:&#xD;&#xA;&#xD;&#xA;     #elif defined(GLFW_INCLUDE_ES2)&#xD;&#xA;      #include <GLES2/gl2.h>&#xD;&#xA;      #if defined(GLFW_INCLUDE_GLEXT)&#xD;&#xA;       #include <GLES2/gl2ext.h>&#xD;&#xA;      #endif&#xD;&#xA;&#xD;&#xA;This source seems to be is in the common subset of GLES and OpenGL (like much of GLES), and also compiles with `-lGL` if we remove the `#define GLFW_INCLUDE_ES2`.&#xD;&#xA;&#xD;&#xA;If we add things which are not in GLES like immediate rendering `glBegin`, link fails as expected.&#xD;&#xA;&#xD;&#xA;See also: http://askubuntu.com/questions/244133/how-do-i-get-egl-and-opengles-libraries-for-ubuntu-running-on-virtualbox&#xD;&#xA;&#xD;&#xA;Credits: [genpfult](http://stackoverflow.com/questions/3809236/how-to-develop-opengl-es-gles-2-0-applications-on-linux/39356268?noredirect=1#comment66052787_39356268) made the code much more correct.";;edited body
126650884;39356268;895245;5;f2c7d608-28d0-4cce-8b49-994924f281f2;2016-09-08 06:31:03.0;"**GLFW, Mesa, Ubuntu 16.04 AMD64**&#xD;&#xA;&#xD;&#xA;This was not easy to setup on Ubuntu 14.04, but now it just works.&#xD;&#xA;&#xD;&#xA;    sudo apt-get install libglfw3-dev libgles2-mesa-dev&#xD;&#xA;    gcc glfw_triangle.c -lGLESv2 -lglfw&#xD;&#xA;&#xD;&#xA;Output:&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/zTbFX.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Source:&#xD;&#xA;&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    &#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;    &#xD;&#xA;    static const GLuint WIDTH = 800;&#xD;&#xA;    static const GLuint HEIGHT = 600;&#xD;&#xA;    static const GLchar* vertex_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""attribute vec3 position;\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_Position = vec4(position, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLchar* fragment_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLfloat vertices[] = {&#xD;&#xA;            0.0f,  0.5f, 0.0f,&#xD;&#xA;            0.5f, -0.5f, 0.0f,&#xD;&#xA;        -0.5f, -0.5f, 0.0f,&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    GLint common_get_shader_program(const char *vertex_shader_source, const char *fragment_shader_source) {&#xD;&#xA;        enum Consts {INFOLOG_LEN = 512};&#xD;&#xA;        GLchar infoLog[INFOLOG_LEN];&#xD;&#xA;        GLint fragment_shader;&#xD;&#xA;        GLint shader_program;&#xD;&#xA;        GLint success;&#xD;&#xA;        GLint vertex_shader;&#xD;&#xA;    &#xD;&#xA;        /* Vertex shader */&#xD;&#xA;        vertex_shader = glCreateShader(GL_VERTEX_SHADER);&#xD;&#xA;        glShaderSource(vertex_shader, 1, &vertex_shader_source, NULL);&#xD;&#xA;        glCompileShader(vertex_shader);&#xD;&#xA;        glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(vertex_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Fragment shader */&#xD;&#xA;        fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);&#xD;&#xA;        glShaderSource(fragment_shader, 1, &fragment_shader_source, NULL);&#xD;&#xA;        glCompileShader(fragment_shader);&#xD;&#xA;        glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(fragment_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Link shaders */&#xD;&#xA;        shader_program = glCreateProgram();&#xD;&#xA;        glAttachShader(shader_program, vertex_shader);&#xD;&#xA;        glAttachShader(shader_program, fragment_shader);&#xD;&#xA;        glLinkProgram(shader_program);&#xD;&#xA;        glGetProgramiv(shader_program, GL_LINK_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetProgramInfoLog(shader_program, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::PROGRAM::LINKING_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        glDeleteShader(vertex_shader);&#xD;&#xA;        glDeleteShader(fragment_shader);&#xD;&#xA;        return shader_program;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;        GLuint shader_program, vbo;&#xD;&#xA;        GLint pos;&#xD;&#xA;        GLFWwindow* window;&#xD;&#xA;    &#xD;&#xA;        glfwInit();&#xD;&#xA;        glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);&#xD;&#xA;        window = glfwCreateWindow(WIDTH, HEIGHT, __FILE__, NULL, NULL);&#xD;&#xA;        glfwMakeContextCurrent(window);&#xD;&#xA;    &#xD;&#xA;        printf(""GL_VERSION  : %s\\n"", glGetString(GL_VERSION) );&#xD;&#xA;        printf(""GL_RENDERER : %s\\n"", glGetString(GL_RENDERER) );&#xD;&#xA;    &#xD;&#xA;        shader_program = common_get_shader_program(vertex_shader_source, fragment_shader_source);&#xD;&#xA;        pos = glGetAttribLocation(shader_program, ""position"");&#xD;&#xA;    &#xD;&#xA;        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;        glViewport(0, 0, WIDTH, HEIGHT);&#xD;&#xA;    &#xD;&#xA;        glGenBuffers(1, &vbo);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, vbo);&#xD;&#xA;        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#xD;&#xA;        glVertexAttribPointer(pos, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0);&#xD;&#xA;        glEnableVertexAttribArray(pos);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, 0);&#xD;&#xA;    &#xD;&#xA;        while (!glfwWindowShouldClose(window)) {&#xD;&#xA;            glfwPollEvents();&#xD;&#xA;            glClear(GL_COLOR_BUFFER_BIT);&#xD;&#xA;            glUseProgram(shader_program);&#xD;&#xA;            glDrawArrays(GL_TRIANGLES, 0, 3);&#xD;&#xA;            glfwSwapBuffers(window);&#xD;&#xA;        }&#xD;&#xA;        glDeleteBuffers(1, &vbo);&#xD;&#xA;        glfwTerminate();&#xD;&#xA;        return EXIT_SUCCESS;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The key line lines of code are:&#xD;&#xA;&#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;&#xD;&#xA;`GLFW_INCLUDE_ES2` is documented at: http://www.glfw.org/docs/latest/build_guide.html#build_macros and a quick look at the source shows that it forwards to GLES:&#xD;&#xA;&#xD;&#xA;     #elif defined(GLFW_INCLUDE_ES2)&#xD;&#xA;      #include <GLES2/gl2.h>&#xD;&#xA;      #if defined(GLFW_INCLUDE_GLEXT)&#xD;&#xA;       #include <GLES2/gl2ext.h>&#xD;&#xA;      #endif&#xD;&#xA;&#xD;&#xA;This source seems to be is in the common subset of GLES and OpenGL (like much of GLES), and also compiles with `-lGL` if we remove the `#define GLFW_INCLUDE_ES2`.&#xD;&#xA;&#xD;&#xA;If we add things which are not in GLES like immediate rendering `glBegin`, link fails as expected.&#xD;&#xA;&#xD;&#xA;See also: http://askubuntu.com/questions/244133/how-do-i-get-egl-and-opengles-libraries-for-ubuntu-running-on-virtualbox&#xD;&#xA;&#xD;&#xA;Credits: [genpfult](http://stackoverflow.com/questions/3809236/how-to-develop-opengl-es-gles-2-0-applications-on-linux/39356268?noredirect=1#comment66052787_39356268) made the code much more correct.&#xD;&#xA;&#xD;&#xA;**ARM Mali OpenGL ES SDK**&#xD;&#xA;&#xD;&#xA;- download from: http://malideveloper.arm.com/resources/sdks/opengl-es-sdk-for-linux/&#xD;&#xA;- open the documentation HTML on a browser&#xD;&#xA;- follow the ""Quick Start Guide"", it's simple&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/DSIUC.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Contains several interesting open source examples + windowing system boilerplate (X11 + EGL).&#xD;&#xA;&#xD;&#xA;The build system supports easy cross compilation for ARM / Mali SoCs, but I haven't tested that yet. &#xD;&#xA;&#xD;&#xA;The key component included seems to be the ""OpenGL ES Emulator"" http://malideveloper.arm.com/resources/tools/opengl-es-emulator/ which ""maps OpenGL ES 3.2 API calls to the OpenGL API"". But that does not ship with source, only precompiled.&#xD;&#xA;&#xD;&#xA;Uses a custom enterprisey EULA that appears to be permissive, but yeah, ask your lawyer.&#xD;&#xA;";;added 689 characters in body
126819984;39356268;895245;5;9866aa7f-4ca4-4e10-8d5c-8f24476de1a2;2016-09-10 14:37:55.0;"**GLFW, Mesa, Ubuntu 16.04 AMD64**&#xD;&#xA;&#xD;&#xA;This was not easy to setup on Ubuntu 14.04, but now it just works.&#xD;&#xA;&#xD;&#xA;    sudo apt-get install libglfw3-dev libgles2-mesa-dev&#xD;&#xA;    gcc glfw_triangle.c -lGLESv2 -lglfw&#xD;&#xA;&#xD;&#xA;Output:&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/zTbFX.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Source:&#xD;&#xA;&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    &#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;    &#xD;&#xA;    static const GLuint WIDTH = 800;&#xD;&#xA;    static const GLuint HEIGHT = 600;&#xD;&#xA;    static const GLchar* vertex_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""attribute vec3 position;\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_Position = vec4(position, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLchar* fragment_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLfloat vertices[] = {&#xD;&#xA;            0.0f,  0.5f, 0.0f,&#xD;&#xA;            0.5f, -0.5f, 0.0f,&#xD;&#xA;        -0.5f, -0.5f, 0.0f,&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    GLint common_get_shader_program(const char *vertex_shader_source, const char *fragment_shader_source) {&#xD;&#xA;        enum Consts {INFOLOG_LEN = 512};&#xD;&#xA;        GLchar infoLog[INFOLOG_LEN];&#xD;&#xA;        GLint fragment_shader;&#xD;&#xA;        GLint shader_program;&#xD;&#xA;        GLint success;&#xD;&#xA;        GLint vertex_shader;&#xD;&#xA;    &#xD;&#xA;        /* Vertex shader */&#xD;&#xA;        vertex_shader = glCreateShader(GL_VERTEX_SHADER);&#xD;&#xA;        glShaderSource(vertex_shader, 1, &vertex_shader_source, NULL);&#xD;&#xA;        glCompileShader(vertex_shader);&#xD;&#xA;        glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(vertex_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Fragment shader */&#xD;&#xA;        fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);&#xD;&#xA;        glShaderSource(fragment_shader, 1, &fragment_shader_source, NULL);&#xD;&#xA;        glCompileShader(fragment_shader);&#xD;&#xA;        glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(fragment_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Link shaders */&#xD;&#xA;        shader_program = glCreateProgram();&#xD;&#xA;        glAttachShader(shader_program, vertex_shader);&#xD;&#xA;        glAttachShader(shader_program, fragment_shader);&#xD;&#xA;        glLinkProgram(shader_program);&#xD;&#xA;        glGetProgramiv(shader_program, GL_LINK_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetProgramInfoLog(shader_program, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::PROGRAM::LINKING_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        glDeleteShader(vertex_shader);&#xD;&#xA;        glDeleteShader(fragment_shader);&#xD;&#xA;        return shader_program;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;        GLuint shader_program, vbo;&#xD;&#xA;        GLint pos;&#xD;&#xA;        GLFWwindow* window;&#xD;&#xA;    &#xD;&#xA;        glfwInit();&#xD;&#xA;        glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);&#xD;&#xA;        window = glfwCreateWindow(WIDTH, HEIGHT, __FILE__, NULL, NULL);&#xD;&#xA;        glfwMakeContextCurrent(window);&#xD;&#xA;    &#xD;&#xA;        printf(""GL_VERSION  : %s\\n"", glGetString(GL_VERSION) );&#xD;&#xA;        printf(""GL_RENDERER : %s\\n"", glGetString(GL_RENDERER) );&#xD;&#xA;    &#xD;&#xA;        shader_program = common_get_shader_program(vertex_shader_source, fragment_shader_source);&#xD;&#xA;        pos = glGetAttribLocation(shader_program, ""position"");&#xD;&#xA;    &#xD;&#xA;        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;        glViewport(0, 0, WIDTH, HEIGHT);&#xD;&#xA;    &#xD;&#xA;        glGenBuffers(1, &vbo);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, vbo);&#xD;&#xA;        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#xD;&#xA;        glVertexAttribPointer(pos, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0);&#xD;&#xA;        glEnableVertexAttribArray(pos);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, 0);&#xD;&#xA;    &#xD;&#xA;        while (!glfwWindowShouldClose(window)) {&#xD;&#xA;            glfwPollEvents();&#xD;&#xA;            glClear(GL_COLOR_BUFFER_BIT);&#xD;&#xA;            glUseProgram(shader_program);&#xD;&#xA;            glDrawArrays(GL_TRIANGLES, 0, 3);&#xD;&#xA;            glfwSwapBuffers(window);&#xD;&#xA;        }&#xD;&#xA;        glDeleteBuffers(1, &vbo);&#xD;&#xA;        glfwTerminate();&#xD;&#xA;        return EXIT_SUCCESS;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The key line lines of code are:&#xD;&#xA;&#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;&#xD;&#xA;`GLFW_INCLUDE_ES2` is documented at: http://www.glfw.org/docs/latest/build_guide.html#build_macros and a quick look at the source shows that it forwards to GLES:&#xD;&#xA;&#xD;&#xA;     #elif defined(GLFW_INCLUDE_ES2)&#xD;&#xA;      #include <GLES2/gl2.h>&#xD;&#xA;      #if defined(GLFW_INCLUDE_GLEXT)&#xD;&#xA;       #include <GLES2/gl2ext.h>&#xD;&#xA;      #endif&#xD;&#xA;&#xD;&#xA;This source seems to be is in the common subset of GLES and OpenGL (like much of GLES), and also compiles with `-lGL` if we remove the `#define GLFW_INCLUDE_ES2`.&#xD;&#xA;&#xD;&#xA;If we add things which are not in GLES like immediate rendering `glBegin`, link fails as expected.&#xD;&#xA;&#xD;&#xA;See also: http://askubuntu.com/questions/244133/how-do-i-get-egl-and-opengles-libraries-for-ubuntu-running-on-virtualbox&#xD;&#xA;&#xD;&#xA;Credits: [genpfult](http://stackoverflow.com/questions/3809236/how-to-develop-opengl-es-gles-2-0-applications-on-linux/39356268?noredirect=1#comment66052787_39356268) made the code much more correct.&#xD;&#xA;&#xD;&#xA;**ARM Mali OpenGL ES SDK**&#xD;&#xA;&#xD;&#xA;- download from: http://malideveloper.arm.com/resources/sdks/opengl-es-sdk-for-linux/&#xD;&#xA;- open the documentation HTML on a browser&#xD;&#xA;- follow the ""Quick Start Guide"", it's simple&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/DSIUC.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Contains several interesting open source examples + windowing system boilerplate (X11 + EGL).&#xD;&#xA;&#xD;&#xA;The build system supports easy cross compilation for ARM / Mali SoCs, but I haven't tested that yet. &#xD;&#xA;&#xD;&#xA;The key component included seems to be the ""OpenGL ES Emulator"" http://malideveloper.arm.com/resources/tools/opengl-es-emulator/ which ""maps OpenGL ES 3.2 API calls to the OpenGL API"". But that does not ship with source, only precompiled.&#xD;&#xA;&#xD;&#xA;Uses a custom enterprisey EULA that appears to be permissive, but yeah, ask your lawyer.&#xD;&#xA;&#xD;&#xA;Tested on SDK v2.4.4.";;added 23 characters in body
141042995;39356268;895245;5;119f23d9-6b21-4801-9420-c669dd9bf6e9;2017-03-20 09:40:39.0;"**GLFW, Mesa, Ubuntu 16.04 AMD64**&#xD;&#xA;&#xD;&#xA;This was not easy to setup on Ubuntu 14.04, but now it just works.&#xD;&#xA;&#xD;&#xA;    sudo apt-get install libglfw3-dev libgles2-mesa-dev&#xD;&#xA;    gcc glfw_triangle.c -lGLESv2 -lglfw&#xD;&#xA;&#xD;&#xA;Output:&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/zTbFX.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Source:&#xD;&#xA;&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    &#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;    &#xD;&#xA;    static const GLuint WIDTH = 800;&#xD;&#xA;    static const GLuint HEIGHT = 600;&#xD;&#xA;    static const GLchar* vertex_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""attribute vec3 position;\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_Position = vec4(position, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLchar* fragment_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLfloat vertices[] = {&#xD;&#xA;         0.0f,  0.5f, 0.0f,&#xD;&#xA;         0.5f, -0.5f, 0.0f,&#xD;&#xA;        -0.5f, -0.5f, 0.0f,&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    GLint common_get_shader_program(const char *vertex_shader_source, const char *fragment_shader_source) {&#xD;&#xA;        enum Consts {INFOLOG_LEN = 512};&#xD;&#xA;        GLchar infoLog[INFOLOG_LEN];&#xD;&#xA;        GLint fragment_shader;&#xD;&#xA;        GLint shader_program;&#xD;&#xA;        GLint success;&#xD;&#xA;        GLint vertex_shader;&#xD;&#xA;    &#xD;&#xA;        /* Vertex shader */&#xD;&#xA;        vertex_shader = glCreateShader(GL_VERTEX_SHADER);&#xD;&#xA;        glShaderSource(vertex_shader, 1, &vertex_shader_source, NULL);&#xD;&#xA;        glCompileShader(vertex_shader);&#xD;&#xA;        glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(vertex_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Fragment shader */&#xD;&#xA;        fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);&#xD;&#xA;        glShaderSource(fragment_shader, 1, &fragment_shader_source, NULL);&#xD;&#xA;        glCompileShader(fragment_shader);&#xD;&#xA;        glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(fragment_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Link shaders */&#xD;&#xA;        shader_program = glCreateProgram();&#xD;&#xA;        glAttachShader(shader_program, vertex_shader);&#xD;&#xA;        glAttachShader(shader_program, fragment_shader);&#xD;&#xA;        glLinkProgram(shader_program);&#xD;&#xA;        glGetProgramiv(shader_program, GL_LINK_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetProgramInfoLog(shader_program, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::PROGRAM::LINKING_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        glDeleteShader(vertex_shader);&#xD;&#xA;        glDeleteShader(fragment_shader);&#xD;&#xA;        return shader_program;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;        GLuint shader_program, vbo;&#xD;&#xA;        GLint pos;&#xD;&#xA;        GLFWwindow* window;&#xD;&#xA;    &#xD;&#xA;        glfwInit();&#xD;&#xA;        glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);&#xD;&#xA;        window = glfwCreateWindow(WIDTH, HEIGHT, __FILE__, NULL, NULL);&#xD;&#xA;        glfwMakeContextCurrent(window);&#xD;&#xA;    &#xD;&#xA;        printf(""GL_VERSION  : %s\\n"", glGetString(GL_VERSION) );&#xD;&#xA;        printf(""GL_RENDERER : %s\\n"", glGetString(GL_RENDERER) );&#xD;&#xA;    &#xD;&#xA;        shader_program = common_get_shader_program(vertex_shader_source, fragment_shader_source);&#xD;&#xA;        pos = glGetAttribLocation(shader_program, ""position"");&#xD;&#xA;    &#xD;&#xA;        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;        glViewport(0, 0, WIDTH, HEIGHT);&#xD;&#xA;    &#xD;&#xA;        glGenBuffers(1, &vbo);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, vbo);&#xD;&#xA;        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#xD;&#xA;        glVertexAttribPointer(pos, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0);&#xD;&#xA;        glEnableVertexAttribArray(pos);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, 0);&#xD;&#xA;    &#xD;&#xA;        while (!glfwWindowShouldClose(window)) {&#xD;&#xA;            glfwPollEvents();&#xD;&#xA;            glClear(GL_COLOR_BUFFER_BIT);&#xD;&#xA;            glUseProgram(shader_program);&#xD;&#xA;            glDrawArrays(GL_TRIANGLES, 0, 3);&#xD;&#xA;            glfwSwapBuffers(window);&#xD;&#xA;        }&#xD;&#xA;        glDeleteBuffers(1, &vbo);&#xD;&#xA;        glfwTerminate();&#xD;&#xA;        return EXIT_SUCCESS;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The key line lines of code are:&#xD;&#xA;&#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;&#xD;&#xA;`GLFW_INCLUDE_ES2` is documented at: http://www.glfw.org/docs/latest/build_guide.html#build_macros and a quick look at the source shows that it forwards to GLES:&#xD;&#xA;&#xD;&#xA;     #elif defined(GLFW_INCLUDE_ES2)&#xD;&#xA;      #include <GLES2/gl2.h>&#xD;&#xA;      #if defined(GLFW_INCLUDE_GLEXT)&#xD;&#xA;       #include <GLES2/gl2ext.h>&#xD;&#xA;      #endif&#xD;&#xA;&#xD;&#xA;This source seems to be written in the common subset of GLES and OpenGL (like much of GLES), and also compiles with `-lGL` if we remove the `#define GLFW_INCLUDE_ES2`.&#xD;&#xA;&#xD;&#xA;If we add things which are not in GLES like immediate rendering `glBegin`, link fails as expected.&#xD;&#xA;&#xD;&#xA;See also: http://askubuntu.com/questions/244133/how-do-i-get-egl-and-opengles-libraries-for-ubuntu-running-on-virtualbox&#xD;&#xA;&#xD;&#xA;Credits: [genpfult](http://stackoverflow.com/questions/3809236/how-to-develop-opengl-es-gles-2-0-applications-on-linux/39356268?noredirect=1#comment66052787_39356268) made the code much more correct.&#xD;&#xA;&#xD;&#xA;**ARM Mali OpenGL ES SDK**&#xD;&#xA;&#xD;&#xA;- download from: http://malideveloper.arm.com/resources/sdks/opengl-es-sdk-for-linux/&#xD;&#xA;- open the documentation HTML on a browser&#xD;&#xA;- follow the ""Quick Start Guide"", it's simple&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/DSIUC.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Contains several interesting open source examples + windowing system boilerplate (X11 + EGL).&#xD;&#xA;&#xD;&#xA;The build system supports easy cross compilation for ARM / Mali SoCs, but I haven't tested that yet. &#xD;&#xA;&#xD;&#xA;The key component included seems to be the ""OpenGL ES Emulator"" http://malideveloper.arm.com/resources/tools/opengl-es-emulator/ which ""maps OpenGL ES 3.2 API calls to the OpenGL API"". But that does not ship with source, only precompiled.&#xD;&#xA;&#xD;&#xA;Uses a custom enterprisey EULA that appears to be permissive, but yeah, ask your lawyer.&#xD;&#xA;&#xD;&#xA;Tested on SDK v2.4.4.";;added 5 characters in body
143034285;39356268;-1;5;03890465-876d-4fe2-a48f-a8f38643aba2;2017-04-13 12:22:48.0;"**GLFW, Mesa, Ubuntu 16.04 AMD64**&#xD;&#xA;&#xD;&#xA;This was not easy to setup on Ubuntu 14.04, but now it just works.&#xD;&#xA;&#xD;&#xA;    sudo apt-get install libglfw3-dev libgles2-mesa-dev&#xD;&#xA;    gcc glfw_triangle.c -lGLESv2 -lglfw&#xD;&#xA;&#xD;&#xA;Output:&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/zTbFX.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Source:&#xD;&#xA;&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    &#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;    &#xD;&#xA;    static const GLuint WIDTH = 800;&#xD;&#xA;    static const GLuint HEIGHT = 600;&#xD;&#xA;    static const GLchar* vertex_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""attribute vec3 position;\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_Position = vec4(position, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLchar* fragment_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLfloat vertices[] = {&#xD;&#xA;         0.0f,  0.5f, 0.0f,&#xD;&#xA;         0.5f, -0.5f, 0.0f,&#xD;&#xA;        -0.5f, -0.5f, 0.0f,&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    GLint common_get_shader_program(const char *vertex_shader_source, const char *fragment_shader_source) {&#xD;&#xA;        enum Consts {INFOLOG_LEN = 512};&#xD;&#xA;        GLchar infoLog[INFOLOG_LEN];&#xD;&#xA;        GLint fragment_shader;&#xD;&#xA;        GLint shader_program;&#xD;&#xA;        GLint success;&#xD;&#xA;        GLint vertex_shader;&#xD;&#xA;    &#xD;&#xA;        /* Vertex shader */&#xD;&#xA;        vertex_shader = glCreateShader(GL_VERTEX_SHADER);&#xD;&#xA;        glShaderSource(vertex_shader, 1, &vertex_shader_source, NULL);&#xD;&#xA;        glCompileShader(vertex_shader);&#xD;&#xA;        glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(vertex_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Fragment shader */&#xD;&#xA;        fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);&#xD;&#xA;        glShaderSource(fragment_shader, 1, &fragment_shader_source, NULL);&#xD;&#xA;        glCompileShader(fragment_shader);&#xD;&#xA;        glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(fragment_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Link shaders */&#xD;&#xA;        shader_program = glCreateProgram();&#xD;&#xA;        glAttachShader(shader_program, vertex_shader);&#xD;&#xA;        glAttachShader(shader_program, fragment_shader);&#xD;&#xA;        glLinkProgram(shader_program);&#xD;&#xA;        glGetProgramiv(shader_program, GL_LINK_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetProgramInfoLog(shader_program, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::PROGRAM::LINKING_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        glDeleteShader(vertex_shader);&#xD;&#xA;        glDeleteShader(fragment_shader);&#xD;&#xA;        return shader_program;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;        GLuint shader_program, vbo;&#xD;&#xA;        GLint pos;&#xD;&#xA;        GLFWwindow* window;&#xD;&#xA;    &#xD;&#xA;        glfwInit();&#xD;&#xA;        glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);&#xD;&#xA;        window = glfwCreateWindow(WIDTH, HEIGHT, __FILE__, NULL, NULL);&#xD;&#xA;        glfwMakeContextCurrent(window);&#xD;&#xA;    &#xD;&#xA;        printf(""GL_VERSION  : %s\\n"", glGetString(GL_VERSION) );&#xD;&#xA;        printf(""GL_RENDERER : %s\\n"", glGetString(GL_RENDERER) );&#xD;&#xA;    &#xD;&#xA;        shader_program = common_get_shader_program(vertex_shader_source, fragment_shader_source);&#xD;&#xA;        pos = glGetAttribLocation(shader_program, ""position"");&#xD;&#xA;    &#xD;&#xA;        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;        glViewport(0, 0, WIDTH, HEIGHT);&#xD;&#xA;    &#xD;&#xA;        glGenBuffers(1, &vbo);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, vbo);&#xD;&#xA;        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#xD;&#xA;        glVertexAttribPointer(pos, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0);&#xD;&#xA;        glEnableVertexAttribArray(pos);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, 0);&#xD;&#xA;    &#xD;&#xA;        while (!glfwWindowShouldClose(window)) {&#xD;&#xA;            glfwPollEvents();&#xD;&#xA;            glClear(GL_COLOR_BUFFER_BIT);&#xD;&#xA;            glUseProgram(shader_program);&#xD;&#xA;            glDrawArrays(GL_TRIANGLES, 0, 3);&#xD;&#xA;            glfwSwapBuffers(window);&#xD;&#xA;        }&#xD;&#xA;        glDeleteBuffers(1, &vbo);&#xD;&#xA;        glfwTerminate();&#xD;&#xA;        return EXIT_SUCCESS;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The key line lines of code are:&#xD;&#xA;&#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;&#xD;&#xA;`GLFW_INCLUDE_ES2` is documented at: http://www.glfw.org/docs/latest/build_guide.html#build_macros and a quick look at the source shows that it forwards to GLES:&#xD;&#xA;&#xD;&#xA;     #elif defined(GLFW_INCLUDE_ES2)&#xD;&#xA;      #include <GLES2/gl2.h>&#xD;&#xA;      #if defined(GLFW_INCLUDE_GLEXT)&#xD;&#xA;       #include <GLES2/gl2ext.h>&#xD;&#xA;      #endif&#xD;&#xA;&#xD;&#xA;This source seems to be written in the common subset of GLES and OpenGL (like much of GLES), and also compiles with `-lGL` if we remove the `#define GLFW_INCLUDE_ES2`.&#xD;&#xA;&#xD;&#xA;If we add things which are not in GLES like immediate rendering `glBegin`, link fails as expected.&#xD;&#xA;&#xD;&#xA;See also: https://askubuntu.com/questions/244133/how-do-i-get-egl-and-opengles-libraries-for-ubuntu-running-on-virtualbox&#xD;&#xA;&#xD;&#xA;Credits: [genpfult](http://stackoverflow.com/questions/3809236/how-to-develop-opengl-es-gles-2-0-applications-on-linux/39356268?noredirect=1#comment66052787_39356268) made the code much more correct.&#xD;&#xA;&#xD;&#xA;**ARM Mali OpenGL ES SDK**&#xD;&#xA;&#xD;&#xA;- download from: http://malideveloper.arm.com/resources/sdks/opengl-es-sdk-for-linux/&#xD;&#xA;- open the documentation HTML on a browser&#xD;&#xA;- follow the ""Quick Start Guide"", it's simple&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/DSIUC.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Contains several interesting open source examples + windowing system boilerplate (X11 + EGL).&#xD;&#xA;&#xD;&#xA;The build system supports easy cross compilation for ARM / Mali SoCs, but I haven't tested that yet. &#xD;&#xA;&#xD;&#xA;The key component included seems to be the ""OpenGL ES Emulator"" http://malideveloper.arm.com/resources/tools/opengl-es-emulator/ which ""maps OpenGL ES 3.2 API calls to the OpenGL API"". But that does not ship with source, only precompiled.&#xD;&#xA;&#xD;&#xA;Uses a custom enterprisey EULA that appears to be permissive, but yeah, ask your lawyer.&#xD;&#xA;&#xD;&#xA;Tested on SDK v2.4.4.";;replaced http://askubuntu.com/ with https://askubuntu.com/
147650558;39356268;-1;5;ffa4cbe2-47c7-466e-a329-76d52e0a5e4d;2017-05-23 12:32:22.0;"**GLFW, Mesa, Ubuntu 16.04 AMD64**&#xD;&#xA;&#xD;&#xA;This was not easy to setup on Ubuntu 14.04, but now it just works.&#xD;&#xA;&#xD;&#xA;    sudo apt-get install libglfw3-dev libgles2-mesa-dev&#xD;&#xA;    gcc glfw_triangle.c -lGLESv2 -lglfw&#xD;&#xA;&#xD;&#xA;Output:&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/zTbFX.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Source:&#xD;&#xA;&#xD;&#xA;    #include <stdio.h>&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    &#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;    &#xD;&#xA;    static const GLuint WIDTH = 800;&#xD;&#xA;    static const GLuint HEIGHT = 600;&#xD;&#xA;    static const GLchar* vertex_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""attribute vec3 position;\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_Position = vec4(position, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLchar* fragment_shader_source =&#xD;&#xA;        ""#version 100\\n""&#xD;&#xA;        ""void main() {\\n""&#xD;&#xA;        ""   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n""&#xD;&#xA;        ""}\\n"";&#xD;&#xA;    static const GLfloat vertices[] = {&#xD;&#xA;         0.0f,  0.5f, 0.0f,&#xD;&#xA;         0.5f, -0.5f, 0.0f,&#xD;&#xA;        -0.5f, -0.5f, 0.0f,&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    GLint common_get_shader_program(const char *vertex_shader_source, const char *fragment_shader_source) {&#xD;&#xA;        enum Consts {INFOLOG_LEN = 512};&#xD;&#xA;        GLchar infoLog[INFOLOG_LEN];&#xD;&#xA;        GLint fragment_shader;&#xD;&#xA;        GLint shader_program;&#xD;&#xA;        GLint success;&#xD;&#xA;        GLint vertex_shader;&#xD;&#xA;    &#xD;&#xA;        /* Vertex shader */&#xD;&#xA;        vertex_shader = glCreateShader(GL_VERTEX_SHADER);&#xD;&#xA;        glShaderSource(vertex_shader, 1, &vertex_shader_source, NULL);&#xD;&#xA;        glCompileShader(vertex_shader);&#xD;&#xA;        glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(vertex_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Fragment shader */&#xD;&#xA;        fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);&#xD;&#xA;        glShaderSource(fragment_shader, 1, &fragment_shader_source, NULL);&#xD;&#xA;        glCompileShader(fragment_shader);&#xD;&#xA;        glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetShaderInfoLog(fragment_shader, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /* Link shaders */&#xD;&#xA;        shader_program = glCreateProgram();&#xD;&#xA;        glAttachShader(shader_program, vertex_shader);&#xD;&#xA;        glAttachShader(shader_program, fragment_shader);&#xD;&#xA;        glLinkProgram(shader_program);&#xD;&#xA;        glGetProgramiv(shader_program, GL_LINK_STATUS, &success);&#xD;&#xA;        if (!success) {&#xD;&#xA;            glGetProgramInfoLog(shader_program, INFOLOG_LEN, NULL, infoLog);&#xD;&#xA;            printf(""ERROR::SHADER::PROGRAM::LINKING_FAILED\\n%s\\n"", infoLog);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        glDeleteShader(vertex_shader);&#xD;&#xA;        glDeleteShader(fragment_shader);&#xD;&#xA;        return shader_program;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int main(void) {&#xD;&#xA;        GLuint shader_program, vbo;&#xD;&#xA;        GLint pos;&#xD;&#xA;        GLFWwindow* window;&#xD;&#xA;    &#xD;&#xA;        glfwInit();&#xD;&#xA;        glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);&#xD;&#xA;        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);&#xD;&#xA;        window = glfwCreateWindow(WIDTH, HEIGHT, __FILE__, NULL, NULL);&#xD;&#xA;        glfwMakeContextCurrent(window);&#xD;&#xA;    &#xD;&#xA;        printf(""GL_VERSION  : %s\\n"", glGetString(GL_VERSION) );&#xD;&#xA;        printf(""GL_RENDERER : %s\\n"", glGetString(GL_RENDERER) );&#xD;&#xA;    &#xD;&#xA;        shader_program = common_get_shader_program(vertex_shader_source, fragment_shader_source);&#xD;&#xA;        pos = glGetAttribLocation(shader_program, ""position"");&#xD;&#xA;    &#xD;&#xA;        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;        glViewport(0, 0, WIDTH, HEIGHT);&#xD;&#xA;    &#xD;&#xA;        glGenBuffers(1, &vbo);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, vbo);&#xD;&#xA;        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#xD;&#xA;        glVertexAttribPointer(pos, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0);&#xD;&#xA;        glEnableVertexAttribArray(pos);&#xD;&#xA;        glBindBuffer(GL_ARRAY_BUFFER, 0);&#xD;&#xA;    &#xD;&#xA;        while (!glfwWindowShouldClose(window)) {&#xD;&#xA;            glfwPollEvents();&#xD;&#xA;            glClear(GL_COLOR_BUFFER_BIT);&#xD;&#xA;            glUseProgram(shader_program);&#xD;&#xA;            glDrawArrays(GL_TRIANGLES, 0, 3);&#xD;&#xA;            glfwSwapBuffers(window);&#xD;&#xA;        }&#xD;&#xA;        glDeleteBuffers(1, &vbo);&#xD;&#xA;        glfwTerminate();&#xD;&#xA;        return EXIT_SUCCESS;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The key line lines of code are:&#xD;&#xA;&#xD;&#xA;    #define GLFW_INCLUDE_ES2&#xD;&#xA;    #include <GLFW/glfw3.h>&#xD;&#xA;&#xD;&#xA;`GLFW_INCLUDE_ES2` is documented at: http://www.glfw.org/docs/latest/build_guide.html#build_macros and a quick look at the source shows that it forwards to GLES:&#xD;&#xA;&#xD;&#xA;     #elif defined(GLFW_INCLUDE_ES2)&#xD;&#xA;      #include <GLES2/gl2.h>&#xD;&#xA;      #if defined(GLFW_INCLUDE_GLEXT)&#xD;&#xA;       #include <GLES2/gl2ext.h>&#xD;&#xA;      #endif&#xD;&#xA;&#xD;&#xA;This source seems to be written in the common subset of GLES and OpenGL (like much of GLES), and also compiles with `-lGL` if we remove the `#define GLFW_INCLUDE_ES2`.&#xD;&#xA;&#xD;&#xA;If we add things which are not in GLES like immediate rendering `glBegin`, link fails as expected.&#xD;&#xA;&#xD;&#xA;See also: https://askubuntu.com/questions/244133/how-do-i-get-egl-and-opengles-libraries-for-ubuntu-running-on-virtualbox&#xD;&#xA;&#xD;&#xA;Credits: [genpfult](https://stackoverflow.com/questions/3809236/how-to-develop-opengl-es-gles-2-0-applications-on-linux/39356268?noredirect=1#comment66052787_39356268) made the code much more correct.&#xD;&#xA;&#xD;&#xA;**ARM Mali OpenGL ES SDK**&#xD;&#xA;&#xD;&#xA;- download from: http://malideveloper.arm.com/resources/sdks/opengl-es-sdk-for-linux/&#xD;&#xA;- open the documentation HTML on a browser&#xD;&#xA;- follow the ""Quick Start Guide"", it's simple&#xD;&#xA;&#xD;&#xA;<img src=""http://i.stack.imgur.com/DSIUC.png"" width=""300"" />&#xD;&#xA;&#xD;&#xA;Contains several interesting open source examples + windowing system boilerplate (X11 + EGL).&#xD;&#xA;&#xD;&#xA;The build system supports easy cross compilation for ARM / Mali SoCs, but I haven't tested that yet. &#xD;&#xA;&#xD;&#xA;The key component included seems to be the ""OpenGL ES Emulator"" http://malideveloper.arm.com/resources/tools/opengl-es-emulator/ which ""maps OpenGL ES 3.2 API calls to the OpenGL API"". But that does not ship with source, only precompiled.&#xD;&#xA;&#xD;&#xA;Uses a custom enterprisey EULA that appears to be permissive, but yeah, ask your lawyer.&#xD;&#xA;&#xD;&#xA;Tested on SDK v2.4.4.";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
