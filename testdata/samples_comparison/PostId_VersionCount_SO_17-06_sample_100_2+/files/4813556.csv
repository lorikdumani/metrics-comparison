Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
10195837;4813556;328397;2;90fe591c-6515-4095-baa5-b87ae0d3c91d;2011-01-27 06:53:42.0;"I have some environmental sensors and I want to detect sudden changes in temperature, and slow trends over time... however I'd like to do most of the math based on what's in memory with the following parameters:&#xD;&#xA;&#xD;&#xA;(note: Items in parens are Realtime Computed as data is added)&#xD;&#xA;&#xD;&#xA; - 5 minute  (derivative, max, min, avg) + 36 datapoints for most current 3 hours&#xD;&#xA; - 10 minute (derivative, max, min, avg) + 0 datapoints, calc  is based on 5min sample&#xD;&#xA; - 30 minute (derivative, max, min, avg) + 0 datapoints, calc is based on 5 min sample&#xD;&#xA; - Hourly  (derivative, max, min, avg) + 24 datapoints for most current 1 day&#xD;&#xA; - Daily    (derivative, max,min,avg) + 32 datapoints for most current  month&#xD;&#xA; - Monthly   (derivative, max,min,avg) + 12 datapoints for past year&#xD;&#xA;&#xD;&#xA;Each datapoint is a two byte float.  So each sensor will consume up to 124 Floats, plus the 24 calculated variables.  I'd like to support as many sensors as the .NET embededd device will permit.&#xD;&#xA;&#xD;&#xA;Since I'm using an embedded device for this project, my memory is constrained and so is my IO and CPU power.  &#xD;&#xA;&#xD;&#xA;How would you go about implementing this in .NET?  So far, I've created a couple of structs and called it a ""TrackableFloat"" where the insertion of a value causes the old one to drop off the array and a recalculation is done.  &#xD;&#xA;&#xD;&#xA;The only thing that makes this more complicated than it would otherwise be, is that if for some reason the sensor does not report back data, then that one specific value needs to be excluded from the realtime calulations.&#xD;&#xA;&#xD;&#xA;When all is said and done, if any of the values: (derivative, max,min,avg) reach a pre defined setting, then a .NET event fires &#xD;&#xA;&#xD;&#xA;I think someone out there will think this is an interesting problem, and would love to hear how they would approach implementing it.&#xD;&#xA;&#xD;&#xA;Would you use a Class or a Struct?  &#xD;&#xA;How would you trigger the calculations? (Events most likely)&#xD;&#xA;How would the alerts be triggered?&#xD;&#xA;How would you store the data, in tiers? &#xD;&#xA;Is there a library that already does something like this?  (maybe that should be my first question )";;
10195905;4813556;328397;5;5554d023-53c8-4275-a4d6-1f6daa06b376;2011-01-27 07:00:19.0;"I have some environmental sensors and I want to detect sudden changes in temperature, and slow trends over time... however I'd like to do most of the math based on what's in memory with the following parameters:&#xD;&#xA;&#xD;&#xA;(note: Items in parens are computed in realtime as data is added)&#xD;&#xA;&#xD;&#xA; - 5 minute  (derivative, max, min, avg) + 36 datapoints for most current 3 hours&#xD;&#xA; - 10 minute (derivative, max, min, avg) + 0 datapoints, calc  is based on 5min sample&#xD;&#xA; - 30 minute (derivative, max, min, avg) + 0 datapoints, calc is based on 5 min sample&#xD;&#xA; - Hourly  (derivative, max, min, avg) + 24 datapoints for most current 1 day&#xD;&#xA; - Daily    (derivative, max,min,avg) + 32 datapoints for most current  month&#xD;&#xA; - Monthly   (derivative, max,min,avg) + 12 datapoints for past year&#xD;&#xA;&#xD;&#xA;Each datapoint is a two byte float.  So each sensor will consume up to 124 Floats, plus the 24 calculated variables.  I'd like to support as many sensors as the .NET embededd device will permit.&#xD;&#xA;&#xD;&#xA;Since I'm using an embedded device for this project, my memory is constrained and so is my IO and CPU power.  &#xD;&#xA;&#xD;&#xA;How would you go about implementing this in .NET?  So far, I've created a couple of structs and called it a ""`TrackableFloat`"" where the insertion of a value causes the old one to drop off the array and a recalculation is done.  &#xD;&#xA;&#xD;&#xA;The only thing that makes this more complicated than it would otherwise be, is that if for some reason the sensor does not report back data, then that one specific value needs to be excluded from the realtime calulations.&#xD;&#xA;&#xD;&#xA;When all is said and done, if any of the values: (derivative, max,min,avg) reach a pre defined setting, then a .NET event fires &#xD;&#xA;&#xD;&#xA;I think someone out there will think this is an interesting problem, and would love to hear how they would approach implementing it.&#xD;&#xA;&#xD;&#xA; 1. Would you use a Class or a Struct?  &#xD;&#xA;&#xD;&#xA; 2. How would you trigger the calculations? (Events most likely)&#xD;&#xA;&#xD;&#xA; 3. How would the alerts be triggered?&#xD;&#xA;&#xD;&#xA; 4. How would you store the data, in tiers? &#xD;&#xA;&#xD;&#xA; 5. Is there a library that already does something like this?  (maybe that should be my first question )";;"added 8 characters in body; added 22 characters in body; edited title; edited title; added 3 characters in body"
10196002;4813556;328397;5;1563281d-fd81-402e-80f9-26771948fb94;2011-01-27 07:06:29.0;"I have some environmental sensors and I want to detect sudden changes in temperature, and slow trends over time... however I'd like to do most of the math based on what's in memory with the following parameters:&#xD;&#xA;&#xD;&#xA;(note: Items in parens are computed in realtime as data is added)&#xD;&#xA;&#xD;&#xA; - 5 minute  (derivative, max, min, avg) + 36 datapoints for most current 3 hours&#xD;&#xA; - 10 minute (derivative, max, min, avg) + 0 datapoints, calc  is based on 5min sample&#xD;&#xA; - 30 minute (derivative, max, min, avg) + 0 datapoints, calc is based on 5 min sample&#xD;&#xA; - Hourly  (derivative, max, min, avg) + 24 datapoints for most current 1 day&#xD;&#xA; - Daily    (derivative, max,min,avg) + 32 datapoints for most current  month&#xD;&#xA; - Monthly   (derivative, max,min,avg) + 12 datapoints for past year&#xD;&#xA;&#xD;&#xA;Each datapoint is a two byte float.  So each sensor will consume up to 124 Floats, plus the 24 calculated variables.  I'd like to support as many sensors as the .NET embededd device will permit.&#xD;&#xA;&#xD;&#xA;Since I'm using an embedded device for this project, my memory is constrained and so is my IO and CPU power.  &#xD;&#xA;&#xD;&#xA;How would you go about implementing this in .NET?  So far, I've created a couple of structs and called it a ""`TrackableFloat`"" where the insertion of a value causes the old one to drop off the array and a recalculation is done.  &#xD;&#xA;&#xD;&#xA;> The only thing that makes this more&#xD;&#xA;> complicated than it would be, is that&#xD;&#xA;> for any sensor does not report back&#xD;&#xA;> data, then that datapoint needs to be&#xD;&#xA;> excluded/ignored from all subsequent&#xD;&#xA;> realtime calulations.&#xD;&#xA;&#xD;&#xA;When all is said and done, if any of the values: (derivative, max,min,avg) reach a pre defined setting, then a .NET event fires &#xD;&#xA;&#xD;&#xA;I think someone out there will think this is an interesting problem, and would love to hear how they would approach implementing it.&#xD;&#xA;&#xD;&#xA; 1. Would you use a Class or a Struct?  &#xD;&#xA;&#xD;&#xA; 2. How would you trigger the calculations? (Events most likely)&#xD;&#xA;&#xD;&#xA; 3. How would the alerts be triggered?&#xD;&#xA;&#xD;&#xA; 4. How would you store the data, in tiers? &#xD;&#xA;&#xD;&#xA; 5. Is there a library that already does something like this?  (maybe that should be my first question )";;added 2 characters in body
10196168;4813556;328397;5;7a2e54bb-563a-45ed-b204-ff09b3740d8d;2011-01-27 07:19:28.0;"I have some environmental sensors and I want to detect sudden changes in temperature, and slow trends over time... however I'd like to do most of the math based on what's in memory with parameters that may look like this: (subject to change)&#xD;&#xA;&#xD;&#xA;(note: Items in parens are computed in realtime as data is added)&#xD;&#xA;&#xD;&#xA; - 5 minute  (derivative, max, min, avg) + 36 datapoints for most current 3 hours&#xD;&#xA; - 10 minute (derivative, max, min, avg) + 0 datapoints, calc  is based on 5min sample&#xD;&#xA; - 30 minute (derivative, max, min, avg) + 0 datapoints, calc is based on 5 min sample&#xD;&#xA; - Hourly  (derivative, max, min, avg) + 24 datapoints for most current 1 day&#xD;&#xA; - Daily    (derivative, max,min,avg) + 32 datapoints for most current  month&#xD;&#xA; - Monthly   (derivative, max,min,avg) + 12 datapoints for past year&#xD;&#xA;&#xD;&#xA;Each datapoint is a two byte float.  So each sensor will consume up to 124 Floats, plus the 24 calculated variables.  I'd like to support as many sensors as the .NET embededd device will permit.&#xD;&#xA;&#xD;&#xA;Since I'm using an embedded device for this project, my memory is constrained and so is my IO and CPU power.  &#xD;&#xA;&#xD;&#xA;How would you go about implementing this in .NET?  So far, I've created a couple of structs and called it a ""`TrackableFloat`"" where the insertion of a value causes the old one to drop off the array and a recalculation is done.  &#xD;&#xA;&#xD;&#xA;> The only thing that makes this more&#xD;&#xA;> complicated than it would be, is that&#xD;&#xA;> for any sensor does not report back&#xD;&#xA;> data, then that datapoint needs to be&#xD;&#xA;> excluded/ignored from all subsequent&#xD;&#xA;> realtime calulations.&#xD;&#xA;&#xD;&#xA;When all is said and done, if any of the values: (derivative, max,min,avg) reach a pre defined setting, then a .NET event fires &#xD;&#xA;&#xD;&#xA;I think someone out there will think this is an interesting problem, and would love to hear how they would approach implementing it.&#xD;&#xA;&#xD;&#xA; 1. Would you use a Class or a Struct?  &#xD;&#xA;&#xD;&#xA; 2. How would you trigger the calculations? (Events most likely)&#xD;&#xA;&#xD;&#xA; 3. How would the alerts be triggered?&#xD;&#xA;&#xD;&#xA; 4. How would you store the data, in tiers? &#xD;&#xA;&#xD;&#xA; 5. Is there a library that already does something like this?  (maybe that should be my first question )";;added 30 characters in body
10208477;4813556;328397;5;d065a7f6-d2ed-4ce4-86f9-162b2dda19c8;2011-01-27 16:41:57.0;"I have some environmental sensors and I want to detect sudden changes in temperature, and slow trends over time... however I'd like to do most of the math based on what's in memory with parameters that may look like this: (subject to change)&#xD;&#xA;&#xD;&#xA;(note: Items in parens are computed in realtime as data is added)&#xD;&#xA;&#xD;&#xA; - 5 minute  (derivative, max, min, avg) + 36 datapoints for most current 3 hours&#xD;&#xA; - 10 minute (derivative, max, min, avg) + 0 datapoints, calc  is based on 5min sample&#xD;&#xA; - 30 minute (derivative, max, min, avg) + 0 datapoints, calc is based on 5 min sample&#xD;&#xA; - Hourly  (derivative, max, min, avg) + 24 datapoints for most current 1 day&#xD;&#xA; - Daily    (derivative, max,min,avg) + 32 datapoints for most current  month&#xD;&#xA; - Monthly   (derivative, max,min,avg) + 12 datapoints for past year&#xD;&#xA;&#xD;&#xA;Each datapoint is a two byte float.  So each sensor will consume up to 124 Floats, plus the 24 calculated variables.  I'd like to support as many sensors as the .NET embededd device will permit.&#xD;&#xA;&#xD;&#xA;Since I'm using an embedded device for this project, my memory is constrained and so is my IO and CPU power.  &#xD;&#xA;&#xD;&#xA;How would you go about implementing this in .NET?  So far, I've created a couple of structs and called it a ""`TrackableFloat`"" where the insertion of a value causes the old one to drop off the array and a recalculation is done.  &#xD;&#xA;&#xD;&#xA;> The only thing that makes this more&#xD;&#xA;> complicated than it would be, is that&#xD;&#xA;> for any sensor does not report back&#xD;&#xA;> data, then that datapoint needs to be&#xD;&#xA;> excluded/ignored from all subsequent&#xD;&#xA;> realtime calulations.&#xD;&#xA;&#xD;&#xA;When all is said and done, if any of the values: (derivative, max,min,avg) reach a pre defined setting, then a .NET event fires &#xD;&#xA;&#xD;&#xA;I think someone out there will think this is an interesting problem, and would love to hear how they would approach implementing it.&#xD;&#xA;&#xD;&#xA; 1. Would you use a Class or a Struct?  &#xD;&#xA;&#xD;&#xA; 2. How would you trigger the calculations? (Events most likely)&#xD;&#xA;&#xD;&#xA; 3. How would the alerts be triggered?&#xD;&#xA;&#xD;&#xA; 4. How would you store the data, in tiers? &#xD;&#xA;&#xD;&#xA; 5. Is there a library that already does something like this?  (maybe that should be my first question )&#xD;&#xA;&#xD;&#xA; 6. How would you efficiently calculate the derivative?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Here is my first crack at this.  Would be interested in hearing your thoughts.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;        enum UnitToTrackEnum&#xD;&#xA;        {&#xD;&#xA;            Minute,&#xD;&#xA;            FiveMinute,&#xD;&#xA;            TenMinute,&#xD;&#xA;            FifteenMinute,&#xD;&#xA;            Hour,&#xD;&#xA;            Day,&#xD;&#xA;            Week,&#xD;&#xA;            Month,&#xD;&#xA;            unknown&#xD;&#xA;        }&#xD;&#xA;        class TrackableFloat&#xD;&#xA;        {&#xD;&#xA;            object Gate = new object();&#xD;&#xA;    &#xD;&#xA;            UnitToTrackEnum trackingMode = UnitToTrackEnum.unknown;&#xD;&#xA;            int ValidInts = 0;&#xD;&#xA;            float[] IntsToTrack;&#xD;&#xA;    &#xD;&#xA;            public TrackableFloat(int HistoryLength, UnitToTrackEnum unitToTrack)&#xD;&#xA;            {&#xD;&#xA;                if (unitToTrack == UnitToTrackEnum.unknown)&#xD;&#xA;                    throw new InvalidOperationException(""You must not have an unknown measure of time to track."");&#xD;&#xA;    &#xD;&#xA;                IntsToTrack = new float[HistoryLength];&#xD;&#xA;    &#xD;&#xA;                foreach (var i in IntsToTrack)&#xD;&#xA;                {&#xD;&#xA;                    float[i] = float.MaxValue;&#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;                trackingMode = unitToTrack;&#xD;&#xA;    &#xD;&#xA;                Min = float.MaxValue;&#xD;&#xA;                Max = float.MinValue;&#xD;&#xA;                Sum = 0;&#xD;&#xA;            }&#xD;&#xA;            public void Add(DateTime dt, float value)&#xD;&#xA;            {&#xD;&#xA;                int RoundedDTUnit = 0;&#xD;&#xA;    &#xD;&#xA;                switch (trackingMode)&#xD;&#xA;                {&#xD;&#xA;                    case UnitToTrackEnum.Minute:&#xD;&#xA;                        {&#xD;&#xA;                            RoundedDTUnit = dt.Minute;&#xD;&#xA;                            break;&#xD;&#xA;                        }&#xD;&#xA;                    case UnitToTrackEnum.FiveMinute:&#xD;&#xA;                        {&#xD;&#xA;                            RoundedDTUnit = System.Math.Abs(dt.Minute / 5);&#xD;&#xA;                            break;&#xD;&#xA;                        }&#xD;&#xA;                    case UnitToTrackEnum.TenMinute:&#xD;&#xA;                        {&#xD;&#xA;                            RoundedDTUnit = System.Math.Abs(dt.Minute / 10);&#xD;&#xA;                            break;&#xD;&#xA;                        }&#xD;&#xA;                    case UnitToTrackEnum.FifteenMinute:&#xD;&#xA;                        {&#xD;&#xA;                            RoundedDTUnit = System.Math.Abs(dt.Minute / 15);&#xD;&#xA;                            break;&#xD;&#xA;                        }&#xD;&#xA;                    case UnitToTrackEnum.Hour:&#xD;&#xA;                        {&#xD;&#xA;                            RoundedDTUnit = dt.Hour;&#xD;&#xA;                            break;&#xD;&#xA;                        }&#xD;&#xA;                    case UnitToTrackEnum.Day:&#xD;&#xA;                        {&#xD;&#xA;                            RoundedDTUnit = dt.Day;&#xD;&#xA;                            break;&#xD;&#xA;                        }&#xD;&#xA;                    case UnitToTrackEnum.Week:&#xD;&#xA;                        {&#xD;&#xA;                            //RoundedDTUnit = System.Math.Abs( );&#xD;&#xA;                            break;&#xD;&#xA;                        }&#xD;&#xA;                    case UnitToTrackEnum.Month:&#xD;&#xA;                        {&#xD;&#xA;                            RoundedDTUnit = dt.Month;&#xD;&#xA;                            break;&#xD;&#xA;                        }&#xD;&#xA;                    case UnitToTrackEnum.unknown:&#xD;&#xA;                        {&#xD;&#xA;                            throw new InvalidOperationException(""You must not have an unknown measure of time to track."");&#xD;&#xA;                        }&#xD;&#xA;                    default:&#xD;&#xA;                        break;&#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;                if (IntsToTrack.Length < RoundedDTUnit)&#xD;&#xA;                {&#xD;&#xA;                    if (value == float.MaxValue || value == float.MinValue)&#xD;&#xA;                    {&#xD;&#xA;                        // If invalid data...&#xD;&#xA;                        lock (Gate)&#xD;&#xA;                        {&#xD;&#xA;                            // Get rid of old data...&#xD;&#xA;                            var OldValue = IntsToTrack[RoundedDTUnit];&#xD;&#xA;                            if (OldValue != float.MaxValue || OldValue != float.MinValue)&#xD;&#xA;                            {&#xD;&#xA;                                Sum -= OldValue;&#xD;&#xA;                                ValidInts--;&#xD;&#xA;    &#xD;&#xA;                                if (OldValue == Max || OldValue == Min)&#xD;&#xA;                                    RefreshMaxMin();&#xD;&#xA;                            }&#xD;&#xA;    &#xD;&#xA;                            // Save new data&#xD;&#xA;                            IntsToTrack[RoundedDTUnit] = value;&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                    else&#xD;&#xA;                    {&#xD;&#xA;                        lock (Gate)&#xD;&#xA;                        {&#xD;&#xA;                            // Get rid of old data...&#xD;&#xA;                            var OldValue = IntsToTrack[RoundedDTUnit];&#xD;&#xA;                            if (OldValue != float.MaxValue || OldValue != float.MinValue)&#xD;&#xA;                            {&#xD;&#xA;                                Sum -= OldValue;&#xD;&#xA;                                ValidInts--;&#xD;&#xA;                            }&#xD;&#xA;    &#xD;&#xA;                            // Save new data&#xD;&#xA;                            IntsToTrack[RoundedDTUnit] = value;&#xD;&#xA;                            Sum += value;&#xD;&#xA;                            ValidInts++;&#xD;&#xA;    &#xD;&#xA;                            if (value < Min)&#xD;&#xA;                                Min = value;&#xD;&#xA;    &#xD;&#xA;                            if (value > Max)&#xD;&#xA;                                Max = value;&#xD;&#xA;    &#xD;&#xA;                            if (OldValue == Max || OldValue == Min)&#xD;&#xA;                                RefreshMaxMin();&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;                else&#xD;&#xA;                {&#xD;&#xA;                    throw new IndexOutOfRangeException(""Index "" + RoundedDTUnit + "" is out of range for tracking mode: "" + trackingMode.ToString());&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            public float Sum { get; set; }&#xD;&#xA;            public float Average&#xD;&#xA;            {&#xD;&#xA;                get&#xD;&#xA;                {&#xD;&#xA;                    if (ValidInts > 0)&#xD;&#xA;                        return Sum / ValidInts;&#xD;&#xA;                    else&#xD;&#xA;                        return float.MaxValue;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            public float Min { get; set; }&#xD;&#xA;            public float Max { get; set; }&#xD;&#xA;            public float Derivative { get; set; }&#xD;&#xA;    &#xD;&#xA;            public void RefreshCounters()&#xD;&#xA;            {&#xD;&#xA;                lock (Gate)&#xD;&#xA;                {&#xD;&#xA;                    float sum = 0;&#xD;&#xA;                    ValidInts = 0;&#xD;&#xA;    &#xD;&#xA;                    Min = float.MaxValue;&#xD;&#xA;                    Max = float.MinValue;&#xD;&#xA;    &#xD;&#xA;                    foreach (var i in IntsToTrack)&#xD;&#xA;                    {&#xD;&#xA;                        if (i != float.MaxValue || i != float.MinValue)&#xD;&#xA;                        {&#xD;&#xA;                            if (Min == float.MaxValue)&#xD;&#xA;                            {&#xD;&#xA;                                Min = i;&#xD;&#xA;                                Max = i;&#xD;&#xA;                            }&#xD;&#xA;    &#xD;&#xA;                            sum += i;&#xD;&#xA;                            ValidInts++;&#xD;&#xA;    &#xD;&#xA;                            if (i < Min)&#xD;&#xA;                                Min = i;&#xD;&#xA;    &#xD;&#xA;                            if (i > Max)&#xD;&#xA;                                Max = i;&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                    Sum = sum;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            public void RefreshMaxMin()&#xD;&#xA;            {&#xD;&#xA;                if (ValidInts > 0)&#xD;&#xA;                {&#xD;&#xA;                    Min = float.MaxValue;&#xD;&#xA;                    Max = float.MinValue;&#xD;&#xA;    &#xD;&#xA;                    lock (Gate)&#xD;&#xA;                    {&#xD;&#xA;                        foreach (var i in IntsToTrack)&#xD;&#xA;                        {&#xD;&#xA;                            if (i != float.MaxValue || i != float.MinValue)&#xD;&#xA;                            {&#xD;&#xA;                                if (i < Min)&#xD;&#xA;                                    Min = i;&#xD;&#xA;    &#xD;&#xA;                                if (i > Max)&#xD;&#xA;                                    Max = i;&#xD;&#xA;                            }&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }";;"added 7919 characters in body; added 62 characters in body"
10208612;4813556;328397;5;fea7cedb-8699-4f6b-9407-344b539c481e;2011-01-27 16:47:04.0;"I have some environmental sensors and I want to detect sudden changes in temperature, and slow trends over time... however I'd like to do most of the math based on what's in memory with parameters that may look like this: (subject to change)&#xD;&#xA;&#xD;&#xA;(note: Items in parens are computed in realtime as data is added)&#xD;&#xA;&#xD;&#xA; - 5 minute  (derivative, max, min, avg) + 36 datapoints for most current 3 hours&#xD;&#xA; - 10 minute (derivative, max, min, avg) + 0 datapoints, calc  is based on 5min sample&#xD;&#xA; - 30 minute (derivative, max, min, avg) + 0 datapoints, calc is based on 5 min sample&#xD;&#xA; - Hourly  (derivative, max, min, avg) + 24 datapoints for most current 1 day&#xD;&#xA; - Daily    (derivative, max,min,avg) + 32 datapoints for most current  month&#xD;&#xA; - Monthly   (derivative, max,min,avg) + 12 datapoints for past year&#xD;&#xA;&#xD;&#xA;Each datapoint is a two byte float.  So each sensor will consume up to 124 Floats, plus the 24 calculated variables.  I'd like to support as many sensors as the .NET embededd device will permit.&#xD;&#xA;&#xD;&#xA;Since I'm using an embedded device for this project, my memory is constrained and so is my IO and CPU power.  &#xD;&#xA;&#xD;&#xA;How would you go about implementing this in .NET?  So far, I've created a couple of structs and called it a ""`TrackableFloat`"" where the insertion of a value causes the old one to drop off the array and a recalculation is done.  &#xD;&#xA;&#xD;&#xA;> The only thing that makes this more&#xD;&#xA;> complicated than it would be, is that&#xD;&#xA;> for any sensor does not report back&#xD;&#xA;> data, then that datapoint needs to be&#xD;&#xA;> excluded/ignored from all subsequent&#xD;&#xA;> realtime calulations.&#xD;&#xA;&#xD;&#xA;When all is said and done, if any of the values: (derivative, max,min,avg) reach a pre defined setting, then a .NET event fires &#xD;&#xA;&#xD;&#xA;I think someone out there will think this is an interesting problem, and would love to hear how they would approach implementing it.&#xD;&#xA;&#xD;&#xA; 1. Would you use a Class or a Struct?  &#xD;&#xA;&#xD;&#xA; 2. How would you trigger the calculations? (Events most likely)&#xD;&#xA;&#xD;&#xA; 3. How would the alerts be triggered?&#xD;&#xA;&#xD;&#xA; 4. How would you store the data, in tiers? &#xD;&#xA;&#xD;&#xA; 5. Is there a library that already does something like this?  (maybe that should be my first question )&#xD;&#xA;&#xD;&#xA; 6. How would you efficiently calculate the derivative?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Here is my first crack at this.  Would be interested in hearing your thoughts.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;      enum UnitToTrackEnum&#xD;&#xA;    {&#xD;&#xA;        Minute,&#xD;&#xA;        FiveMinute,&#xD;&#xA;        TenMinute,&#xD;&#xA;        FifteenMinute,&#xD;&#xA;        Hour,&#xD;&#xA;        Day,&#xD;&#xA;        Week,&#xD;&#xA;        Month,&#xD;&#xA;        unknown&#xD;&#xA;    }&#xD;&#xA;    class TrackableFloat&#xD;&#xA;    {&#xD;&#xA;        object Gate = new object();&#xD;&#xA;&#xD;&#xA;        UnitToTrackEnum trackingMode = UnitToTrackEnum.unknown;&#xD;&#xA;        int ValidFloats = 0;&#xD;&#xA;        float[] FloatsToTrack;&#xD;&#xA;&#xD;&#xA;        public TrackableFloat(int HistoryLength, UnitToTrackEnum unitToTrack)&#xD;&#xA;        {&#xD;&#xA;            if (unitToTrack == UnitToTrackEnum.unknown)&#xD;&#xA;                throw new InvalidOperationException(""You must not have an unknown measure of time to track."");&#xD;&#xA;&#xD;&#xA;            FloatsToTrack = new float[HistoryLength];&#xD;&#xA;&#xD;&#xA;            foreach (var i in FloatsToTrack)&#xD;&#xA;            {&#xD;&#xA;                float[i] = float.MaxValue;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;            trackingMode = unitToTrack;&#xD;&#xA;&#xD;&#xA;            Min = float.MaxValue;&#xD;&#xA;            Max = float.MinValue;&#xD;&#xA;            Sum = 0;&#xD;&#xA;        }&#xD;&#xA;        public void Add(DateTime dt, float value)&#xD;&#xA;        {&#xD;&#xA;            int RoundedDTUnit = 0;&#xD;&#xA;&#xD;&#xA;            switch (trackingMode)&#xD;&#xA;            {&#xD;&#xA;                case UnitToTrackEnum.Minute:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = dt.Minute;&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.FiveMinute:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = System.Math.Abs(dt.Minute / 5);&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.TenMinute:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = System.Math.Abs(dt.Minute / 10);&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.FifteenMinute:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = System.Math.Abs(dt.Minute / 15);&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.Hour:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = dt.Hour;&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.Day:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = dt.Day;&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.Week:&#xD;&#xA;                    {&#xD;&#xA;                        //RoundedDTUnit = System.Math.Abs( );&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.Month:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = dt.Month;&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.unknown:&#xD;&#xA;                    {&#xD;&#xA;                        throw new InvalidOperationException(""You must not have an unknown measure of time to track."");&#xD;&#xA;                    }&#xD;&#xA;                default:&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;            if (FloatsToTrack.Length < RoundedDTUnit)&#xD;&#xA;            {&#xD;&#xA;                if (value == float.MaxValue || value == float.MinValue)&#xD;&#xA;                {&#xD;&#xA;                    // If invalid data...&#xD;&#xA;                    lock (Gate)&#xD;&#xA;                    {&#xD;&#xA;                        // Get rid of old data...&#xD;&#xA;                        var OldValue = FloatsToTrack[RoundedDTUnit];&#xD;&#xA;                        if (OldValue != float.MaxValue || OldValue != float.MinValue)&#xD;&#xA;                        {&#xD;&#xA;                            Sum -= OldValue;&#xD;&#xA;                            ValidFloats--;&#xD;&#xA;&#xD;&#xA;                            if (OldValue == Max || OldValue == Min)&#xD;&#xA;                                RefreshMaxMin();&#xD;&#xA;                        }&#xD;&#xA;&#xD;&#xA;                        // Save new data&#xD;&#xA;                        FloatsToTrack[RoundedDTUnit] = value;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;                else&#xD;&#xA;                {&#xD;&#xA;                    lock (Gate)&#xD;&#xA;                    {&#xD;&#xA;                        // Get rid of old data...&#xD;&#xA;                        var OldValue = FloatsToTrack[RoundedDTUnit];&#xD;&#xA;                        if (OldValue != float.MaxValue || OldValue != float.MinValue)&#xD;&#xA;                        {&#xD;&#xA;                            Sum -= OldValue;&#xD;&#xA;                            ValidFloats--;&#xD;&#xA;                        }&#xD;&#xA;&#xD;&#xA;                        // Save new data&#xD;&#xA;                        FloatsToTrack[RoundedDTUnit] = value;&#xD;&#xA;                        Sum += value;&#xD;&#xA;                        ValidFloats++;&#xD;&#xA;&#xD;&#xA;                        if (value < Min)&#xD;&#xA;                            Min = value;&#xD;&#xA;&#xD;&#xA;                        if (value > Max)&#xD;&#xA;                            Max = value;&#xD;&#xA;&#xD;&#xA;                        if (OldValue == Max || OldValue == Min)&#xD;&#xA;                            RefreshMaxMin();&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                throw new IndexOutOfRangeException(""Index "" + RoundedDTUnit + "" is out of range for tracking mode: "" + trackingMode.ToString());&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public float Sum { get; set; }&#xD;&#xA;        public float Average&#xD;&#xA;        {&#xD;&#xA;            get&#xD;&#xA;            {&#xD;&#xA;                if (ValidFloats > 0)&#xD;&#xA;                    return Sum / ValidFloats;&#xD;&#xA;                else&#xD;&#xA;                    return float.MaxValue;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        public float Min { get; set; }&#xD;&#xA;        public float Max { get; set; }&#xD;&#xA;        public float Derivative { get; set; }&#xD;&#xA;&#xD;&#xA;        public void RefreshCounters()&#xD;&#xA;        {&#xD;&#xA;            lock (Gate)&#xD;&#xA;            {&#xD;&#xA;                float sum = 0;&#xD;&#xA;                ValidFloats = 0;&#xD;&#xA;&#xD;&#xA;                Min = float.MaxValue;&#xD;&#xA;                Max = float.MinValue;&#xD;&#xA;&#xD;&#xA;                foreach (var i in FloatsToTrack)&#xD;&#xA;                {&#xD;&#xA;                    if (i != float.MaxValue || i != float.MinValue)&#xD;&#xA;                    {&#xD;&#xA;                        if (Min == float.MaxValue)&#xD;&#xA;                        {&#xD;&#xA;                            Min = i;&#xD;&#xA;                            Max = i;&#xD;&#xA;                        }&#xD;&#xA;&#xD;&#xA;                        sum += i;&#xD;&#xA;                        ValidFloats++;&#xD;&#xA;&#xD;&#xA;                        if (i < Min)&#xD;&#xA;                            Min = i;&#xD;&#xA;&#xD;&#xA;                        if (i > Max)&#xD;&#xA;                            Max = i;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;                Sum = sum;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        public void RefreshMaxMin()&#xD;&#xA;        {&#xD;&#xA;            if (ValidFloats > 0)&#xD;&#xA;            {&#xD;&#xA;                Min = float.MaxValue;&#xD;&#xA;                Max = float.MinValue;&#xD;&#xA;&#xD;&#xA;                lock (Gate)&#xD;&#xA;                {&#xD;&#xA;                    foreach (var i in FloatsToTrack)&#xD;&#xA;                    {&#xD;&#xA;                        if (i != float.MaxValue || i != float.MinValue)&#xD;&#xA;                        {&#xD;&#xA;                            if (i < Min)&#xD;&#xA;                                Min = i;&#xD;&#xA;&#xD;&#xA;                            if (i > Max)&#xD;&#xA;                                Max = i;&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }";;deleted 848 characters in body
10208991;4813556;328397;5;8fadf8e2-571c-47ab-9bc8-d60bdae7bfea;2011-01-27 16:59:40.0;"I have some environmental sensors and I want to detect sudden changes in temperature, and slow trends over time... however I'd like to do most of the math based on what's in memory with parameters that may look like this: (subject to change)&#xD;&#xA;&#xD;&#xA;(note: Items in parens are computed in realtime as data is added)&#xD;&#xA;&#xD;&#xA; - 5 minute  (derivative, max, min, avg) + 36 datapoints for most current 3 hours&#xD;&#xA; - 10 minute (derivative, max, min, avg) + 0 datapoints, calc  is based on 5min sample&#xD;&#xA; - 30 minute (derivative, max, min, avg) + 0 datapoints, calc is based on 5 min sample&#xD;&#xA; - Hourly  (derivative, max, min, avg) + 24 datapoints for most current 1 day&#xD;&#xA; - Daily    (derivative, max,min,avg) + 32 datapoints for most current  month&#xD;&#xA; - Monthly   (derivative, max,min,avg) + 12 datapoints for past year&#xD;&#xA;&#xD;&#xA;Each datapoint is a two byte float.  So each sensor will consume up to 124 Floats, plus the 24 calculated variables.  I'd like to support as many sensors as the .NET embededd device will permit.&#xD;&#xA;&#xD;&#xA;Since I'm using an embedded device for this project, my memory is constrained and so is my IO and CPU power.  &#xD;&#xA;&#xD;&#xA;How would you go about implementing this in .NET?  So far, I've created a couple of structs and called it a ""`TrackableFloat`"" where the insertion of a value causes the old one to drop off the array and a recalculation is done.  &#xD;&#xA;&#xD;&#xA;> The only thing that makes this more&#xD;&#xA;> complicated than it would be, is that&#xD;&#xA;> for any sensor does not report back&#xD;&#xA;> data, then that datapoint needs to be&#xD;&#xA;> excluded/ignored from all subsequent&#xD;&#xA;> realtime calulations.&#xD;&#xA;&#xD;&#xA;When all is said and done, if any of the values: (derivative, max,min,avg) reach a pre defined setting, then a .NET event fires &#xD;&#xA;&#xD;&#xA;I think someone out there will think this is an interesting problem, and would love to hear how they would approach implementing it.&#xD;&#xA;&#xD;&#xA; 1. Would you use a Class or a Struct?  &#xD;&#xA;&#xD;&#xA; 2. How would you trigger the calculations? (Events most likely)&#xD;&#xA;&#xD;&#xA; 3. How would the alerts be triggered?&#xD;&#xA;&#xD;&#xA; 4. How would you store the data, in tiers? &#xD;&#xA;&#xD;&#xA; 5. Is there a library that already does something like this?  (maybe that should be my first question )&#xD;&#xA;&#xD;&#xA; 6. How would you efficiently calculate the derivative?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Here is my first crack at this.  Would be interested in hearing your thoughts.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;    enum UnitToTrackEnum&#xD;&#xA;    {&#xD;&#xA;        Minute,&#xD;&#xA;        FiveMinute,&#xD;&#xA;        TenMinute,&#xD;&#xA;        FifteenMinute,&#xD;&#xA;        Hour,&#xD;&#xA;        Day,&#xD;&#xA;        Week,&#xD;&#xA;        Month,&#xD;&#xA;        unknown&#xD;&#xA;    }&#xD;&#xA;    class TrackableFloat&#xD;&#xA;    {&#xD;&#xA;        object Gate = new object();&#xD;&#xA;&#xD;&#xA;        UnitToTrackEnum trackingMode = UnitToTrackEnum.unknown;&#xD;&#xA;        int ValidFloats = 0;&#xD;&#xA;        float[] FloatsToTrack;&#xD;&#xA;&#xD;&#xA;        public TrackableFloat(int HistoryLength, UnitToTrackEnum unitToTrack)&#xD;&#xA;        {&#xD;&#xA;            if (unitToTrack == UnitToTrackEnum.unknown)&#xD;&#xA;                throw new InvalidOperationException(""You must not have an unknown measure of time to track."");&#xD;&#xA;&#xD;&#xA;            FloatsToTrack = new float[HistoryLength];&#xD;&#xA;&#xD;&#xA;            foreach (var i in FloatsToTrack)&#xD;&#xA;            {&#xD;&#xA;                float[i] = float.MaxValue;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;            trackingMode = unitToTrack;&#xD;&#xA;&#xD;&#xA;            Min = float.MaxValue;&#xD;&#xA;            Max = float.MinValue;&#xD;&#xA;            Sum = 0;&#xD;&#xA;        }&#xD;&#xA;        public void Add(DateTime dt, float value)&#xD;&#xA;        {&#xD;&#xA;            int RoundedDTUnit = 0;&#xD;&#xA;&#xD;&#xA;            switch (trackingMode)&#xD;&#xA;            {&#xD;&#xA;                case UnitToTrackEnum.Minute:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = dt.Minute;&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.FiveMinute:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = System.Math.Abs(dt.Minute / 5);&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.TenMinute:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = System.Math.Abs(dt.Minute / 10);&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.FifteenMinute:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = System.Math.Abs(dt.Minute / 15);&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.Hour:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = dt.Hour;&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.Day:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = dt.Day;&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.Week:&#xD;&#xA;                    {&#xD;&#xA;                        //RoundedDTUnit = System.Math.Abs( );&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.Month:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = dt.Month;&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.unknown:&#xD;&#xA;                    {&#xD;&#xA;                        throw new InvalidOperationException(""You must not have an unknown measure of time to track."");&#xD;&#xA;                    }&#xD;&#xA;                default:&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;            bool DoRefreshMaxMin = false;&#xD;&#xA;            if (FloatsToTrack.Length < RoundedDTUnit)&#xD;&#xA;            {&#xD;&#xA;                if (value == float.MaxValue || value == float.MinValue)&#xD;&#xA;                {&#xD;&#xA;                    // If invalid data...&#xD;&#xA;                    lock (Gate)&#xD;&#xA;                    {&#xD;&#xA;                        // Get rid of old data...&#xD;&#xA;                        var OldValue = FloatsToTrack[RoundedDTUnit];&#xD;&#xA;                        if (OldValue != float.MaxValue || OldValue != float.MinValue)&#xD;&#xA;                        {&#xD;&#xA;                            Sum -= OldValue;&#xD;&#xA;                            ValidFloats--;&#xD;&#xA;&#xD;&#xA;                            if (OldValue == Max || OldValue == Min)&#xD;&#xA;                                DoRefreshMaxMin = true;&#xD;&#xA;                        }&#xD;&#xA;&#xD;&#xA;                        // Save new data&#xD;&#xA;                        FloatsToTrack[RoundedDTUnit] = value;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;                else&#xD;&#xA;                {&#xD;&#xA;                    lock (Gate)&#xD;&#xA;                    {&#xD;&#xA;                        // Get rid of old data...&#xD;&#xA;                        var OldValue = FloatsToTrack[RoundedDTUnit];&#xD;&#xA;                        if (OldValue != float.MaxValue || OldValue != float.MinValue)&#xD;&#xA;                        {&#xD;&#xA;                            Sum -= OldValue;&#xD;&#xA;                            ValidFloats--;&#xD;&#xA;                        }&#xD;&#xA;&#xD;&#xA;                        // Save new data&#xD;&#xA;                        FloatsToTrack[RoundedDTUnit] = value;&#xD;&#xA;                        Sum += value;&#xD;&#xA;                        ValidFloats++;&#xD;&#xA;&#xD;&#xA;                        if (value < Min)&#xD;&#xA;                            Min = value;&#xD;&#xA;&#xD;&#xA;                        if (value > Max)&#xD;&#xA;                            Max = value;&#xD;&#xA;&#xD;&#xA;                        if (OldValue == Max || OldValue == Min)&#xD;&#xA;                            DoRefreshMaxMin = true;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                // Function is placed here to avoid a deadlock&#xD;&#xA;                if (DoRefreshMaxMin == true)&#xD;&#xA;                    RefreshMaxMin();&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                throw new IndexOutOfRangeException(""Index "" + RoundedDTUnit + "" is out of range for tracking mode: "" + trackingMode.ToString());&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public float Sum { get; set; }&#xD;&#xA;        public float Average&#xD;&#xA;        {&#xD;&#xA;            get&#xD;&#xA;            {&#xD;&#xA;                if (ValidFloats > 0)&#xD;&#xA;                    return Sum / ValidFloats;&#xD;&#xA;                else&#xD;&#xA;                    return float.MaxValue;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        public float Min { get; set; }&#xD;&#xA;        public float Max { get; set; }&#xD;&#xA;        public float Derivative { get; set; }&#xD;&#xA;&#xD;&#xA;        public void RefreshCounters()&#xD;&#xA;        {&#xD;&#xA;            lock (Gate)&#xD;&#xA;            {&#xD;&#xA;                float sum = 0;&#xD;&#xA;                ValidFloats = 0;&#xD;&#xA;&#xD;&#xA;                Min = float.MaxValue;&#xD;&#xA;                Max = float.MinValue;&#xD;&#xA;&#xD;&#xA;                foreach (var i in FloatsToTrack)&#xD;&#xA;                {&#xD;&#xA;                    if (i != float.MaxValue || i != float.MinValue)&#xD;&#xA;                    {&#xD;&#xA;                        if (Min == float.MaxValue)&#xD;&#xA;                        {&#xD;&#xA;                            Min = i;&#xD;&#xA;                            Max = i;&#xD;&#xA;                        }&#xD;&#xA;&#xD;&#xA;                        sum += i;&#xD;&#xA;                        ValidFloats++;&#xD;&#xA;&#xD;&#xA;                        if (i < Min)&#xD;&#xA;                            Min = i;&#xD;&#xA;&#xD;&#xA;                        if (i > Max)&#xD;&#xA;                            Max = i;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;                Sum = sum;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        public void RefreshMaxMin()&#xD;&#xA;        {&#xD;&#xA;            if (ValidFloats > 0)&#xD;&#xA;            {&#xD;&#xA;                Min = float.MaxValue;&#xD;&#xA;                Max = float.MinValue;&#xD;&#xA;&#xD;&#xA;                lock (Gate)&#xD;&#xA;                {&#xD;&#xA;                    foreach (var i in FloatsToTrack)&#xD;&#xA;                    {&#xD;&#xA;                        if (i != float.MaxValue || i != float.MinValue)&#xD;&#xA;                        {&#xD;&#xA;                            if (i < Min)&#xD;&#xA;                                Min = i;&#xD;&#xA;&#xD;&#xA;                            if (i > Max)&#xD;&#xA;                                Max = i;&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }";;fixed deadlock.. oops
10210107;4813556;328397;5;9fb1f042-cd72-4650-a8a3-419d9bad4947;2011-01-27 17:45:21.0;"I have some environmental sensors and I want to detect sudden changes in temperature, and slow trends over time... however I'd like to do most of the math based on what's in memory with parameters that may look like this: (subject to change)&#xD;&#xA;&#xD;&#xA;(note: Items in parens are computed in realtime as data is added)&#xD;&#xA;&#xD;&#xA; - 5 minute  (derivative, max, min, avg) + 36 datapoints for most current 3 hours&#xD;&#xA; - 10 minute (derivative, max, min, avg) + 0 datapoints, calc  is based on 5min sample&#xD;&#xA; - 30 minute (derivative, max, min, avg) + 0 datapoints, calc is based on 5 min sample&#xD;&#xA; - Hourly  (derivative, max, min, avg) + 24 datapoints for most current 1 day&#xD;&#xA; - Daily    (derivative, max,min,avg) + 32 datapoints for most current  month&#xD;&#xA; - Monthly   (derivative, max,min,avg) + 12 datapoints for past year&#xD;&#xA;&#xD;&#xA;Each datapoint is a two byte float.  So each sensor will consume up to 124 Floats, plus the 24 calculated variables.  I'd like to support as many sensors as the .NET embededd device will permit.&#xD;&#xA;&#xD;&#xA;Since I'm using an embedded device for this project, my memory is constrained and so is my IO and CPU power.  &#xD;&#xA;&#xD;&#xA;How would you go about implementing this in .NET?  So far, I've created a couple of structs and called it a ""`TrackableFloat`"" where the insertion of a value causes the old one to drop off the array and a recalculation is done.  &#xD;&#xA;&#xD;&#xA;> The only thing that makes this more&#xD;&#xA;> complicated than it would be, is that&#xD;&#xA;> for any sensor does not report back&#xD;&#xA;> data, then that datapoint needs to be&#xD;&#xA;> excluded/ignored from all subsequent&#xD;&#xA;> realtime calulations.&#xD;&#xA;&#xD;&#xA;When all is said and done, if any of the values: (derivative, max,min,avg) reach a pre defined setting, then a .NET event fires &#xD;&#xA;&#xD;&#xA;I think someone out there will think this is an interesting problem, and would love to hear how they would approach implementing it.&#xD;&#xA;&#xD;&#xA; 1. Would you use a Class or a Struct?  &#xD;&#xA;&#xD;&#xA; 2. How would you trigger the calculations? (Events most likely)&#xD;&#xA;&#xD;&#xA; 3. How would the alerts be triggered?&#xD;&#xA;&#xD;&#xA; 4. How would you store the data, in tiers? &#xD;&#xA;&#xD;&#xA; 5. Is there a library that already does something like this?  (maybe that should be my first question )&#xD;&#xA;&#xD;&#xA; 6. How would you efficiently calculate the derivative?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Here is my first crack at this, and it doesn't completely hit the spec, but is very efficient.  Would be interested in hearing your thoughts.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;    enum UnitToTrackEnum&#xD;&#xA;    {&#xD;&#xA;        Minute,&#xD;&#xA;        FiveMinute,&#xD;&#xA;        TenMinute,&#xD;&#xA;        FifteenMinute,&#xD;&#xA;        Hour,&#xD;&#xA;        Day,&#xD;&#xA;        Week,&#xD;&#xA;        Month,&#xD;&#xA;        unknown&#xD;&#xA;    }&#xD;&#xA;    class TrackableFloat&#xD;&#xA;    {&#xD;&#xA;        object Gate = new object();&#xD;&#xA;&#xD;&#xA;        UnitToTrackEnum trackingMode = UnitToTrackEnum.unknown;&#xD;&#xA;        int ValidFloats = 0;&#xD;&#xA;        float[] FloatsToTrack;&#xD;&#xA;&#xD;&#xA;        public TrackableFloat(int HistoryLength, UnitToTrackEnum unitToTrack)&#xD;&#xA;        {&#xD;&#xA;            if (unitToTrack == UnitToTrackEnum.unknown)&#xD;&#xA;                throw new InvalidOperationException(""You must not have an unknown measure of time to track."");&#xD;&#xA;&#xD;&#xA;            FloatsToTrack = new float[HistoryLength];&#xD;&#xA;&#xD;&#xA;            foreach (var i in FloatsToTrack)&#xD;&#xA;            {&#xD;&#xA;                float[i] = float.MaxValue;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;            trackingMode = unitToTrack;&#xD;&#xA;&#xD;&#xA;            Min = float.MaxValue;&#xD;&#xA;            Max = float.MinValue;&#xD;&#xA;            Sum = 0;&#xD;&#xA;        }&#xD;&#xA;        public void Add(DateTime dt, float value)&#xD;&#xA;        {&#xD;&#xA;            int RoundedDTUnit = 0;&#xD;&#xA;&#xD;&#xA;            switch (trackingMode)&#xD;&#xA;            {&#xD;&#xA;                case UnitToTrackEnum.Minute:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = dt.Minute;&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.FiveMinute:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = System.Math.Abs(dt.Minute / 5);&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.TenMinute:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = System.Math.Abs(dt.Minute / 10);&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.FifteenMinute:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = System.Math.Abs(dt.Minute / 15);&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.Hour:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = dt.Hour;&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.Day:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = dt.Day;&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.Week:&#xD;&#xA;                    {&#xD;&#xA;                        //RoundedDTUnit = System.Math.Abs( );&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.Month:&#xD;&#xA;                    {&#xD;&#xA;                        RoundedDTUnit = dt.Month;&#xD;&#xA;                        break;&#xD;&#xA;                    }&#xD;&#xA;                case UnitToTrackEnum.unknown:&#xD;&#xA;                    {&#xD;&#xA;                        throw new InvalidOperationException(""You must not have an unknown measure of time to track."");&#xD;&#xA;                    }&#xD;&#xA;                default:&#xD;&#xA;                    break;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;            bool DoRefreshMaxMin = false;&#xD;&#xA;            if (FloatsToTrack.Length < RoundedDTUnit)&#xD;&#xA;            {&#xD;&#xA;                if (value == float.MaxValue || value == float.MinValue)&#xD;&#xA;                {&#xD;&#xA;                    // If invalid data...&#xD;&#xA;                    lock (Gate)&#xD;&#xA;                    {&#xD;&#xA;                        // Get rid of old data...&#xD;&#xA;                        var OldValue = FloatsToTrack[RoundedDTUnit];&#xD;&#xA;                        if (OldValue != float.MaxValue || OldValue != float.MinValue)&#xD;&#xA;                        {&#xD;&#xA;                            Sum -= OldValue;&#xD;&#xA;                            ValidFloats--;&#xD;&#xA;&#xD;&#xA;                            if (OldValue == Max || OldValue == Min)&#xD;&#xA;                                DoRefreshMaxMin = true;&#xD;&#xA;                        }&#xD;&#xA;&#xD;&#xA;                        // Save new data&#xD;&#xA;                        FloatsToTrack[RoundedDTUnit] = value;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;                else&#xD;&#xA;                {&#xD;&#xA;                    lock (Gate)&#xD;&#xA;                    {&#xD;&#xA;                        // Get rid of old data...&#xD;&#xA;                        var OldValue = FloatsToTrack[RoundedDTUnit];&#xD;&#xA;                        if (OldValue != float.MaxValue || OldValue != float.MinValue)&#xD;&#xA;                        {&#xD;&#xA;                            Sum -= OldValue;&#xD;&#xA;                            ValidFloats--;&#xD;&#xA;                        }&#xD;&#xA;&#xD;&#xA;                        // Save new data&#xD;&#xA;                        FloatsToTrack[RoundedDTUnit] = value;&#xD;&#xA;                        Sum += value;&#xD;&#xA;                        ValidFloats++;&#xD;&#xA;&#xD;&#xA;                        if (value < Min)&#xD;&#xA;                            Min = value;&#xD;&#xA;&#xD;&#xA;                        if (value > Max)&#xD;&#xA;                            Max = value;&#xD;&#xA;&#xD;&#xA;                        if (OldValue == Max || OldValue == Min)&#xD;&#xA;                            DoRefreshMaxMin = true;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                // Function is placed here to avoid a deadlock&#xD;&#xA;                if (DoRefreshMaxMin == true)&#xD;&#xA;                    RefreshMaxMin();&#xD;&#xA;            }&#xD;&#xA;            else&#xD;&#xA;            {&#xD;&#xA;                throw new IndexOutOfRangeException(""Index "" + RoundedDTUnit + "" is out of range for tracking mode: "" + trackingMode.ToString());&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public float Sum { get; set; }&#xD;&#xA;        public float Average&#xD;&#xA;        {&#xD;&#xA;            get&#xD;&#xA;            {&#xD;&#xA;                if (ValidFloats > 0)&#xD;&#xA;                    return Sum / ValidFloats;&#xD;&#xA;                else&#xD;&#xA;                    return float.MaxValue;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        public float Min { get; set; }&#xD;&#xA;        public float Max { get; set; }&#xD;&#xA;        public float Derivative { get; set; }&#xD;&#xA;&#xD;&#xA;        public void RefreshCounters()&#xD;&#xA;        {&#xD;&#xA;            lock (Gate)&#xD;&#xA;            {&#xD;&#xA;                float sum = 0;&#xD;&#xA;                ValidFloats = 0;&#xD;&#xA;&#xD;&#xA;                Min = float.MaxValue;&#xD;&#xA;                Max = float.MinValue;&#xD;&#xA;&#xD;&#xA;                foreach (var i in FloatsToTrack)&#xD;&#xA;                {&#xD;&#xA;                    if (i != float.MaxValue || i != float.MinValue)&#xD;&#xA;                    {&#xD;&#xA;                        if (Min == float.MaxValue)&#xD;&#xA;                        {&#xD;&#xA;                            Min = i;&#xD;&#xA;                            Max = i;&#xD;&#xA;                        }&#xD;&#xA;&#xD;&#xA;                        sum += i;&#xD;&#xA;                        ValidFloats++;&#xD;&#xA;&#xD;&#xA;                        if (i < Min)&#xD;&#xA;                            Min = i;&#xD;&#xA;&#xD;&#xA;                        if (i > Max)&#xD;&#xA;                            Max = i;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;                Sum = sum;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        public void RefreshMaxMin()&#xD;&#xA;        {&#xD;&#xA;            if (ValidFloats > 0)&#xD;&#xA;            {&#xD;&#xA;                Min = float.MaxValue;&#xD;&#xA;                Max = float.MinValue;&#xD;&#xA;&#xD;&#xA;                lock (Gate)&#xD;&#xA;                {&#xD;&#xA;                    foreach (var i in FloatsToTrack)&#xD;&#xA;                    {&#xD;&#xA;                        if (i != float.MaxValue || i != float.MinValue)&#xD;&#xA;                        {&#xD;&#xA;                            if (i < Min)&#xD;&#xA;                                Min = i;&#xD;&#xA;&#xD;&#xA;                            if (i > Max)&#xD;&#xA;                                Max = i;&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }";;added 63 characters in body
