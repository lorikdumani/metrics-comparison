Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
138139630;42176585;4924539;2;bea2d24e-c6e7-41d2-b487-14a603b021a6;2017-02-11 13:46:55.0;"Java 6 uses merge sort to compare two objects in Collections.sort() whereas Java 1.7 uses Timsort&#xD;&#xA;&#xD;&#xA;I have this class for object to sort&#xD;&#xA;&#xD;&#xA;    Class ObjectSort &#xD;&#xA;    {&#xD;&#xA;        String Name = """";&#xD;&#xA;        int priority = 0;&#xD;&#xA;&#xD;&#xA;        public ObjectSort (String name, int priority)&#xD;&#xA;        {&#xD;&#xA;            this.Name = Name;&#xD;&#xA;            this.priority = priority;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public getPriority()&#xD;&#xA;        {&#xD;&#xA;            return priority;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;and my test class is&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    TestClass &#xD;&#xA;    {&#xD;&#xA;         ...main()&#xD;&#xA;        {&#xD;&#xA;          List<ObjectSort> sorted = new ArrayList<ObjectSort> ();&#xD;&#xA;          sorted.add (""Table"", 99);&#xD;&#xA;          sorted.add (""Chair"", 1);&#xD;&#xA;          Collections.sort(sorted, new Comparator ());&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;     // inner class to define comparator logic&#xD;&#xA;     private static final class Comparator implements  java.util.Comparator<ObjectSort>&#xD;&#xA;	 {&#xD;&#xA;		@Override&#xD;&#xA;		public int compare (ObjectSort f1, ObjectSort f2)&#xD;&#xA;		{&#xD;&#xA;			try&#xD;&#xA;			{&#xD;&#xA;				// Get the allocation priorities&#xD;&#xA;				int priority1 = f1.getPriority ();&#xD;&#xA;				int priority2 = f2.getPriority ();&#xD;&#xA;&#xD;&#xA;				if (priority1 == priority2)&#xD;&#xA;					return 0;&#xD;&#xA;				else&#xD;&#xA;					return (priority1 > priority2 ? 1 : 0);&#xD;&#xA;			}&#xD;&#xA;			catch (Exception e)&#xD;&#xA;			{&#xD;&#xA;				// Shouldn't happen, because we have the objects OK and there's no database activity&#xD;&#xA;				// happening here.&#xD;&#xA;				assert true;&#xD;&#xA;			}&#xD;&#xA;			return 0;&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Now when we run the code in java 1.6, it sorts it correctly, Chair comes BEFORE table that is it is sorting it is ASCENDING order, which I want.&#xD;&#xA;&#xD;&#xA;But where the code is run in Java 1.7, it does not sort it at all, Table comes before Chair. I checked and 1.6 uses merge sort whereas 1.7 is using Timsort. Please help me tell what is wrong in my code ?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Thanks!&#xD;&#xA;&#xD;&#xA;Aiden";;
138139796;42176585;4924539;5;818dde93-9726-4551-9fe5-3be12eeae045;2017-02-11 13:50:16.0;"Java 6 uses merge sort to compare two objects in Collections.sort() whereas Java 1.7 uses Timsort&#xD;&#xA;&#xD;&#xA;I have this class for object to sort&#xD;&#xA;&#xD;&#xA;    Class ObjectSort &#xD;&#xA;    {&#xD;&#xA;        String Name = """";&#xD;&#xA;        int priority = 0;&#xD;&#xA;&#xD;&#xA;        public ObjectSort (String name, int priority)&#xD;&#xA;        {&#xD;&#xA;            this.Name = Name;&#xD;&#xA;            this.priority = priority;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public getPriority()&#xD;&#xA;        {&#xD;&#xA;            return priority;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;and my test class is&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    TestClass &#xD;&#xA;    {&#xD;&#xA;         ...main()&#xD;&#xA;        {&#xD;&#xA;          List<ObjectSort> sorted = new ArrayList<ObjectSort> ();&#xD;&#xA;          sorted.add (""Table"", 99);&#xD;&#xA;          sorted.add (""Chair"", 1);&#xD;&#xA;          Collections.sort(sorted, new Comparator ());&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;     // inner class to define comparator logic&#xD;&#xA;     private static final class Comparator implements  java.util.Comparator<ObjectSort>&#xD;&#xA;	 {&#xD;&#xA;		@Override&#xD;&#xA;		public int compare (ObjectSort f1, ObjectSort f2)&#xD;&#xA;		{&#xD;&#xA;			try&#xD;&#xA;			{&#xD;&#xA;				// Get the allocation priorities&#xD;&#xA;				int priority1 = f1.getPriority ();&#xD;&#xA;				int priority2 = f2.getPriority ();&#xD;&#xA;&#xD;&#xA;				if (priority1 == priority2)&#xD;&#xA;					return 0;&#xD;&#xA;				else&#xD;&#xA;					return (priority1 > priority2 ? 1 : 0);&#xD;&#xA;			}&#xD;&#xA;			catch (Exception e)&#xD;&#xA;			{&#xD;&#xA;				// Shouldn't happen, because we have the objects OK and there's no database activity&#xD;&#xA;				// happening here.&#xD;&#xA;				assert true;&#xD;&#xA;			}&#xD;&#xA;			return 0;&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Now when we run the code in java 1.6, it sorts it correctly, Chair comes BEFORE table that is it is sorting it is ASCENDING order, which I want.&#xD;&#xA;&#xD;&#xA;But where the code is run in Java 1.7, it does not sort it at all, Table comes before Chair. I checked and 1.6 uses merge sort whereas 1.7 is using Timsort. Please help me tell what is wrong in my code ?&#xD;&#xA;&#xD;&#xA;UPDATE&#xD;&#xA;In 1.7 in variable f1, Chair comes during code execution whereas in 1.6 Table comes! &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Thanks!&#xD;&#xA;&#xD;&#xA;Aiden";;execution behavior
