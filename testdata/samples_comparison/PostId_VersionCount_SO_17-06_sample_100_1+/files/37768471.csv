Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
120225379;37768471;699305;2;9fb5eeb5-f82e-48ac-bb06-be9388d8fa6d;2016-06-11 21:01:08.0;"Since the first four (now last four) of the fields are never going to contain spaces or need any quoting, let's forget about the csv library and use python's awesome string handling directly. Here is a simple generator that splits each line into five columns, no more.&#xD;&#xA;&#xD;&#xA;    def splitfields(filename):&#xD;&#xA;        """"""Generator that parses the data correctly into fields""""""&#xD;&#xA;        for line in data:&#xD;&#xA;            fields = line.rsplit(maxsplit=4)&#xD;&#xA;            fields[0] = fields[0].strip()&#xD;&#xA;            yield fields&#xD;&#xA;            &#xD;&#xA;    with open(""myfile.dat"") as data:&#xD;&#xA;        frame = pd.DataFrame(splitfields(data))&#xD;&#xA;&#xD;&#xA;The above is for the format in the updated question, which has the free text on the left. (For the original format, just use `line.split` instead of `line.rsplit`.)&#xD;&#xA;&#xD;&#xA;         # review text                          user        item     time   rating      (the header is added by me for explanation, not in the text file&#xD;&#xA;            I love this phone as it is easy to used  isjiad123    TYh23hs9     13160032    5    &#xD;&#xA;           Suck restaurant                           hjf2329ccc    TGjsk123     14423321    3     &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;
120225524;37768471;699305;5;9544ce31-18bf-4d6c-82c9-8109c5332745;2016-06-11 21:06:09.0;"Since the first four (now last four) of the fields are never going to contain spaces or need any quoting, let's forget about the csv library and use python's awesome string handling directly. Here is a simple generator that splits each line into five columns, courtesy of the `maxsplit` argument.&#xD;&#xA;&#xD;&#xA;    def splitfields(data):&#xD;&#xA;        """"""Generator that parses the data correctly into fields""""""&#xD;&#xA;        for line in data:&#xD;&#xA;            fields = line.rsplit(maxsplit=4)&#xD;&#xA;            fields[0] = fields[0].strip()   # trim line-initial spaces&#xD;&#xA;            yield fields&#xD;&#xA;            &#xD;&#xA;    with open(""myfile.dat"") as data:&#xD;&#xA;        frame = pd.DataFrame(splitfields(data))&#xD;&#xA;&#xD;&#xA;The above is for the format in the updated question, which has the free text on the left. (For the original format, use `line.split` instead of `line.rsplit` and strip the last field, not the first.)&#xD;&#xA;&#xD;&#xA;         # review text                          user        item     time   rating      (the header is added by me for explanation, not in the text file&#xD;&#xA;            I love this phone as it is easy to used  isjiad123    TYh23hs9     13160032    5    &#xD;&#xA;           Suck restaurant                           hjf2329ccc    TGjsk123     14423321    3     &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added 26 characters in body
120225703;37768471;699305;5;8bc83d31-961b-4b94-89e8-a94ab9c123d9;2016-06-11 21:11:55.0;"Since the first four (now last four) of the fields are never going to contain spaces or need any quoting, let's forget about the csv library and use python's awesome string handling directly. Here is a simple generator that splits each line into five columns, courtesy of the `maxsplit` argument.&#xD;&#xA;&#xD;&#xA;    def splitfields(data):&#xD;&#xA;        """"""Generator that parses the data correctly into fields""""""&#xD;&#xA;        for line in data:&#xD;&#xA;            fields = line.rsplit(maxsplit=4)&#xD;&#xA;            fields[0] = fields[0].strip()   # trim line-initial spaces&#xD;&#xA;            yield fields&#xD;&#xA;            &#xD;&#xA;    with open(""myfile.dat"") as data:&#xD;&#xA;        frame = pd.DataFrame(splitfields(data))&#xD;&#xA;&#xD;&#xA;The above is for the format in the updated question, which has the free text on the left. (For the original format, use `line.split` instead of `line.rsplit` and strip the last field, not the first.)&#xD;&#xA;&#xD;&#xA;        I love this phone as it is easy to used  isjiad123    TYh23hs9     13160032    5    &#xD;&#xA;      Suck restaurant                           hjf2329ccc    TGjsk123     14423321    3     &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;deleted 76 characters in body
120265792;37768471;699305;5;f8280a45-54d3-4eb7-a55b-46b373857baf;2016-06-12 19:47:52.0;"Since the first four (now last four) of the fields are never going to contain spaces or need any quoting, let's forget about the csv library and use python's awesome string handling directly. Here is a simple generator that splits each line into five columns, courtesy of the `maxsplit` argument.&#xD;&#xA;&#xD;&#xA;    def splitfields(data):&#xD;&#xA;        """"""Generator that parses the data correctly into fields""""""&#xD;&#xA;        for line in data:&#xD;&#xA;            fields = line.rsplit(maxsplit=4)&#xD;&#xA;            fields[0] = fields[0].strip()   # trim line-initial spaces&#xD;&#xA;            yield fields&#xD;&#xA;            &#xD;&#xA;    with open(""myfile.dat"") as data:&#xD;&#xA;        frame = pd.DataFrame(splitfields(data))&#xD;&#xA;&#xD;&#xA;Using a generator avoids building a large ordinary array in memory, only to hand it over to the `DataFrame` constructor. As each line of input is read from the file, it is parsed and immediately added to the dataframe.&#xD;&#xA;&#xD;&#xA;The above is for the format in the updated question, which has the free text on the left. (For the original format, use `line.split` instead of `line.rsplit` and strip the last field, not the first.)&#xD;&#xA;&#xD;&#xA;        I love this phone as it is easy to used  isjiad123    TYh23hs9     13160032    5    &#xD;&#xA;      Suck restaurant                           hjf2329ccc    TGjsk123     14423321    3&#xD;&#xA;";;added 213 characters in body
120266107;37768471;699305;5;1dc4ad8f-43b0-43e1-ae47-82212486decb;2016-06-12 19:55:51.0;"Since the first four (now last four) of the fields are never going to contain spaces or need any quoting, let's forget about the csv library and use python's awesome string handling directly. Here is a simple generator that splits each line into five columns, courtesy of the `maxsplit` argument.&#xD;&#xA;&#xD;&#xA;    def splitfields(data):&#xD;&#xA;        """"""Generator that parses the data correctly into fields""""""&#xD;&#xA;        for line in data:&#xD;&#xA;            fields = line.rsplit(maxsplit=4)&#xD;&#xA;            fields[0] = fields[0].strip()   # trim line-initial spaces&#xD;&#xA;            yield fields&#xD;&#xA;            &#xD;&#xA;    with open(""myfile.dat"") as data:&#xD;&#xA;        frame = pd.DataFrame(splitfields(data))&#xD;&#xA;&#xD;&#xA;Using a generator avoids building a large ordinary array in memory only to hand it over to the `DataFrame` constructor. As each line of input is read from the file, it is parsed and immediately added to the dataframe.&#xD;&#xA;&#xD;&#xA;The above is for the format in the updated question, which has the free text on the left. (For the original format, use `line.split` instead of `line.rsplit` and strip the last field, not the first.)&#xD;&#xA;&#xD;&#xA;<!-- language: lang-none -->&#xD;&#xA;&#xD;&#xA;        I love this phone as it is easy to used  isjiad123    TYh23hs9     13160032    5    &#xD;&#xA;      Suck restaurant                           hjf2329ccc    TGjsk123     14423321    3&#xD;&#xA;";;added 213 characters in body
120321990;37768471;699305;5;ca177b77-22b2-42a4-90da-c97c06a60495;2016-06-13 14:38:11.0;"Since the first four (now last four) of the fields are never going to contain spaces or need to be surrounded by quotes, let's forget about the csv library and use python's awesome string handling directly. Here is a simple generator that splits each line into five columns, courtesy of the `maxsplit` argument.&#xD;&#xA;&#xD;&#xA;    def splitfields(data):&#xD;&#xA;        """"""Generator that parses the data correctly into fields""""""&#xD;&#xA;        for line in data:&#xD;&#xA;            fields = line.rsplit(maxsplit=4)&#xD;&#xA;            fields[0] = fields[0].strip()   # trim line-initial spaces&#xD;&#xA;            yield fields&#xD;&#xA;            &#xD;&#xA;    with open(""myfile.dat"") as data:&#xD;&#xA;        frame = pd.DataFrame(splitfields(data))&#xD;&#xA;&#xD;&#xA;Using a generator avoids building a large ordinary array in memory only to hand it over to the `DataFrame` constructor. As each line of input is read from the file, it is parsed and immediately added to the dataframe.&#xD;&#xA;&#xD;&#xA;The above is for the format in the updated question, which has the free text on the left. (For the original format, use `line.split` instead of `line.rsplit` and strip the last field, not the first.)&#xD;&#xA;&#xD;&#xA;<!-- language: lang-none -->&#xD;&#xA;&#xD;&#xA;        I love this phone as it is easy to used  isjiad123    TYh23hs9     13160032    5    &#xD;&#xA;      Suck restaurant                           hjf2329ccc    TGjsk123     14423321    3&#xD;&#xA;&#xD;&#xA;There's more you could do depending on what the data actually looks like: If the fields are separated by exactly four spaces (as it seems from your example), you could split on `""    ""` instead of splitting on all whitespace. That would also work correctly if some other fields can contain spaces. In general, pre-parsing like this is flexible and extensible; I leave the code simple since there's no evidence from your question that more is needed.";;added 466 characters in body
120322473;37768471;699305;5;08e738ab-9c1b-4b1f-a474-65c1ba580434;2016-06-13 14:43:45.0;"Since the first four (now last four) of the fields are never going to contain spaces or need to be surrounded by quotes, let's forget about the csv library and use python's awesome string handling directly. Here is a one-liner that splits each line into exactly five columns, courtesy of the `maxsplit` argument to `rsplit()`:&#xD;&#xA;&#xD;&#xA;    with open(""myfile.dat"") as data:&#xD;&#xA;        frame = pd.DataFrame(line.strip().rsplit(maxsplit=4) for line in data)&#xD;&#xA;&#xD;&#xA;I prefer to unpack the above into a generator function that is easier to understand, and extend if necessary:&#xD;&#xA;&#xD;&#xA;    def splitfields(data):&#xD;&#xA;        """"""Generator that parses the data correctly into fields""""""&#xD;&#xA;        for line in data:&#xD;&#xA;            fields = line.rsplit(maxsplit=4)&#xD;&#xA;            fields[0] = fields[0].strip()   # trim line-initial spaces&#xD;&#xA;            yield fields&#xD;&#xA;    &#xD;&#xA;    with open(""myfile.dat"") as data:&#xD;&#xA;        frame = pd.DataFrame(splitfields(data))&#xD;&#xA;&#xD;&#xA;Both versions avoid building a large ordinary array in memory only to hand it over to the `DataFrame` constructor. As each line of input is read from the file, it is parsed and immediately added to the dataframe.&#xD;&#xA;&#xD;&#xA;The above is for the format in the updated question, which has the free text on the left. (For the original format, use `line.split` instead of `line.rsplit` and strip the last field, not the first.)&#xD;&#xA;&#xD;&#xA;<!-- language: lang-none -->&#xD;&#xA;&#xD;&#xA;        I love this phone as it is easy to used  isjiad123    TYh23hs9     13160032    5    &#xD;&#xA;      Suck restaurant                           hjf2329ccc    TGjsk123     14423321    3&#xD;&#xA;&#xD;&#xA;There's more you could do depending on what the data actually looks like: If the fields are separated by exactly four spaces (as it seems from your example), you could split on `""    ""` instead of splitting on all whitespace. That would also work correctly if some other fields can contain spaces. In general, pre-parsing like this is flexible and extensible; I leave the code simple since there's no evidence from your question that more is needed.";;added 466 characters in body
120350913;37768471;699305;5;45e24fc3-bfac-4048-b6a7-158d3d411d0a;2016-06-13 21:50:52.0;"Since the first four (now last four) of the fields are never going to contain spaces or need to be surrounded by quotes, let's forget about the csv library and use python's awesome string handling directly. Here is a one-liner that splits each line into exactly five columns, courtesy of the `maxsplit` argument to `rsplit()`:&#xD;&#xA;&#xD;&#xA;    with open(""myfile.dat"") as data:&#xD;&#xA;        frame = pd.DataFrame(line.strip().rsplit(maxsplit=4) for line in data)&#xD;&#xA;&#xD;&#xA;The above should solve your problem, but I prefer to unpack it into a generator function that is easier to understand, and can be extended if necessary:&#xD;&#xA;&#xD;&#xA;    def splitfields(data):&#xD;&#xA;        """"""Generator that parses the data correctly into fields""""""&#xD;&#xA;        for line in data:&#xD;&#xA;            fields = line.rsplit(maxsplit=4)&#xD;&#xA;            fields[0] = fields[0].strip()   # trim line-initial spaces&#xD;&#xA;            yield fields&#xD;&#xA;    &#xD;&#xA;    with open(""myfile.dat"") as data:&#xD;&#xA;        frame = pd.DataFrame(splitfields(data))&#xD;&#xA;&#xD;&#xA;Both versions avoid having to build a large ordinary array in memory only to hand it over to the `DataFrame` constructor. As each line of input is read from the file, it is parsed and immediately added to the dataframe.&#xD;&#xA;&#xD;&#xA;The above is for the format in the updated question, which has the free text on the left. (For the original format, use `line.split` instead of `line.rsplit` and strip the last field, not the first.)&#xD;&#xA;&#xD;&#xA;<!-- language: lang-none -->&#xD;&#xA;&#xD;&#xA;        I love this phone as it is easy to used  isjiad123    TYh23hs9     13160032    5    &#xD;&#xA;      Suck restaurant                           hjf2329ccc    TGjsk123     14423321    3&#xD;&#xA;&#xD;&#xA;There's more you could do depending on what the data actually looks like: If the fields are separated by exactly four spaces (as it seems from your example), you could split on `""    ""` instead of splitting on all whitespace. That would also work correctly if some other fields can contain spaces. In general, pre-parsing like this is flexible and extensible; I leave the code simple since there's no evidence from your question that more is needed.";;added 43 characters in body
