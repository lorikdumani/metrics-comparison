Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
45272370;18200150;812034;2;07997770-579f-4947-97b3-05b348e96e21;2013-08-13 03:23:11.0;"In most of programming languages that supports mutable variables, one can easily implement something like this (Java example given):&#xD;&#xA;&#xD;&#xA;	interface Accepter<T> {&#xD;&#xA;		void accept(T t);&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	<T> T getFromDoubleAccepter(Accepter<Accepter<T>> acc){&#xD;&#xA;		final List<T> l = new ArrayList<T>();&#xD;&#xA;		acc.accept(new Accepter<T>(){&#xD;&#xA;&#xD;&#xA;			@Override&#xD;&#xA;			public void accept(T t) {&#xD;&#xA;				l.add(t);&#xD;&#xA;			}&#xD;&#xA;			&#xD;&#xA;		});&#xD;&#xA;		return l.get(0); //Not being called? Exception!&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;I think the equivalent type signature in Haskell shall be&#xD;&#xA;&#xD;&#xA;    getFromDoubleAccepter :: (forall b.(a->b)->b) -> a&#xD;&#xA;&#xD;&#xA;But I have no idea how to implement this. There are possible solutions I can think of. Although I don't know how each of them solves the problem, I can rate and order them by prospected difficulties:&#xD;&#xA;&#xD;&#xA;* `Cont` or `ContT` monad. This considered to be easiest.&#xD;&#xA;&#xD;&#xA;* `RWS` monad or similar.&#xD;&#xA;&#xD;&#xA;* Any other monads. ""pure"" monads like `Maybe` considered harder.&#xD;&#xA;&#xD;&#xA;* Use only standard ""pure"" functional features like lazy evaluation, pattern, fixed point contaminator, etc. This is considered the hardest or even impossible.&#xD;&#xA;&#xD;&#xA;I would like to see answers using any above techniques, and prefer harder ways.&#xD;&#xA;&#xD;&#xA;**Note** there there should not be any modification on the type signature, and it should do the same thing that the Java code do.";;
45272874;18200150;476803;5;8e20cc3d-7289-4024-8eb8-75908dc4d05f;2013-08-13 03:46:52.0;"In most of programming languages that support mutable variables, one can easily implement something like this *Java* example:&#xD;&#xA;&#xD;&#xA;<!-- language: lang-java -->&#xD;&#xA;&#xD;&#xA;	interface Accepter<T> {&#xD;&#xA;		void accept(T t);&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	<T> T getFromDoubleAccepter(Accepter<Accepter<T>> acc){&#xD;&#xA;		final List<T> l = new ArrayList<T>();&#xD;&#xA;		acc.accept(new Accepter<T>(){&#xD;&#xA;&#xD;&#xA;			@Override&#xD;&#xA;			public void accept(T t) {&#xD;&#xA;				l.add(t);&#xD;&#xA;			}&#xD;&#xA;			&#xD;&#xA;		});&#xD;&#xA;		return l.get(0); //Not being called? Exception!&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;I think the equivalent type signature in *Haskell* should be&#xD;&#xA;&#xD;&#xA;    getFromDoubleAccepter :: (forall b. (a -> b) -> b) -> a&#xD;&#xA;&#xD;&#xA;But I have no idea how to implement this. There are several possible solutions I can think of. Although I don't know how each of them would work, I can rate and order them by prospected difficulties:&#xD;&#xA;&#xD;&#xA;* `Cont` or `ContT` monad. This I consider to be easiest.&#xD;&#xA;&#xD;&#xA;* `RWS` monad or similar.&#xD;&#xA;&#xD;&#xA;* Any other monads. *Pure* monads like `Maybe` I consider harder.&#xD;&#xA;&#xD;&#xA;* Use only standard *pure* functional features like lazy evaluation, pattern-matching, the fixed point contaminator, etc. This I consider the hardest (or even impossible).&#xD;&#xA;&#xD;&#xA;I would like to see answers using any of the above techniques (and prefer harder ways).&#xD;&#xA;&#xD;&#xA;**Note:** There should not be any modification of the type signature, and the solution should do the same thing that the *Java* code does.";;improved formatting
45272979;18200150;812034;5;d5247552-a7a1-4d4d-8ec4-110d7696ec74;2013-08-13 03:53:31.0;"In most of programming languages that support mutable variables, one can easily implement something like this *Java* example:&#xD;&#xA;&#xD;&#xA;<!-- language: lang-java -->&#xD;&#xA;&#xD;&#xA;	interface Accepter<T> {&#xD;&#xA;		void accept(T t);&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	<T> T getFromDoubleAccepter(Accepter<Accepter<T>> acc){&#xD;&#xA;		final List<T> l = new ArrayList<T>();&#xD;&#xA;		acc.accept(new Accepter<T>(){&#xD;&#xA;&#xD;&#xA;			@Override&#xD;&#xA;			public void accept(T t) {&#xD;&#xA;				l.add(t);&#xD;&#xA;			}&#xD;&#xA;			&#xD;&#xA;		});&#xD;&#xA;		return l.get(0); //Not being called? Exception!&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;Just for those do not understand Java, the above code receives something can can be provided a function that takes one parameter, and it supposed to grape this parameter as the final result.&#xD;&#xA;&#xD;&#xA;This is not like `callCC`: there is no control flow alternation. Only the inner function's parameter is concerned. &#xD;&#xA;&#xD;&#xA;I think the equivalent type signature in *Haskell* should be&#xD;&#xA;&#xD;&#xA;    getFromDoubleAccepter :: (forall b. (a -> b) -> b) -> a&#xD;&#xA;&#xD;&#xA;So, if someone can gives you a function `(a -> b) -> b` for a type of your choice, he MUST already have an `a` in hand. So your job is to give them a ""callback"", and than keep whatever they sends you in mind, once they returned to you, return **that** value to your caller.&#xD;&#xA;&#xD;&#xA;But I have no idea how to implement this. There are several possible solutions I can think of. Although I don't know how each of them would work, I can rate and order them by prospected difficulties:&#xD;&#xA;&#xD;&#xA;* `Cont` or `ContT` monad. This I consider to be easiest.&#xD;&#xA;&#xD;&#xA;* `RWS` monad or similar.&#xD;&#xA;&#xD;&#xA;* Any other monads. *Pure* monads like `Maybe` I consider harder.&#xD;&#xA;&#xD;&#xA;* Use only standard *pure* functional features like lazy evaluation, pattern-matching, the fixed point contaminator, etc. This I consider the hardest (or even impossible).&#xD;&#xA;&#xD;&#xA;I would like to see answers using any of the above techniques (and prefer harder ways).&#xD;&#xA;&#xD;&#xA;**Note:** There should not be any modification of the type signature, and the solution should do the same thing that the *Java* code does.";;added 586 characters in body
45276007;18200150;812034;5;47b0052b-d0f5-4e13-b1ca-329e3eed74f8;2013-08-13 05:46:00.0;"In most of programming languages that support mutable variables, one can easily implement something like this *Java* example:&#xD;&#xA;&#xD;&#xA;<!-- language: lang-java -->&#xD;&#xA;&#xD;&#xA;	interface Accepter<T> {&#xD;&#xA;		void accept(T t);&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	<T> T getFromDoubleAccepter(Accepter<Accepter<T>> acc){&#xD;&#xA;		final List<T> l = new ArrayList<T>();&#xD;&#xA;		acc.accept(new Accepter<T>(){&#xD;&#xA;&#xD;&#xA;			@Override&#xD;&#xA;			public void accept(T t) {&#xD;&#xA;				l.add(t);&#xD;&#xA;			}&#xD;&#xA;			&#xD;&#xA;		});&#xD;&#xA;		return l.get(0); //Not being called? Exception!&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;Just for those do not understand Java, the above code receives something can can be provided a function that takes one parameter, and it supposed to grape this parameter as the final result.&#xD;&#xA;&#xD;&#xA;This is not like `callCC`: there is no control flow alternation. Only the inner function's parameter is concerned. &#xD;&#xA;&#xD;&#xA;I think the equivalent type signature in *Haskell* should be&#xD;&#xA;&#xD;&#xA;    getFromDoubleAccepter :: (forall b. (a -> b) -> b) -> a&#xD;&#xA;&#xD;&#xA;So, if someone can gives you a function `(a -> b) -> b` for a type of your choice, he MUST already have an `a` in hand. So your job is to give them a ""callback"", and than keep whatever they sends you in mind, once they returned to you, return **that** value to your caller.&#xD;&#xA;&#xD;&#xA;But I have no idea how to implement this. There are several possible solutions I can think of. Although I don't know how each of them would work, I can rate and order them by prospected difficulties:&#xD;&#xA;&#xD;&#xA;* `Cont` or `ContT` monad. This I consider to be easiest.&#xD;&#xA;&#xD;&#xA;* `RWS` monad or similar.&#xD;&#xA;&#xD;&#xA;* Any other monads. *Pure* monads like `Maybe` I consider harder.&#xD;&#xA;&#xD;&#xA;* Use only standard *pure* functional features like lazy evaluation, pattern-matching, the fixed point contaminator, etc. This I consider the hardest (or even impossible).&#xD;&#xA;&#xD;&#xA;I would like to see answers using any of the above techniques (and prefer harder ways).&#xD;&#xA;&#xD;&#xA;**Note:** There should not be any modification of the type signature, and the solution should do the same thing that the *Java* code does.&#xD;&#xA;&#xD;&#xA;**UPDATE**&#xD;&#xA;&#xD;&#xA;Once I seen somebody commented out `getFromDoubleAccepter f = f id` I realize that I have made something wrong. Basically I use `forall` just to make the game easier but it looks like this twist makes it too easy. Actually, the above type signature **forces** the caller to pass back whatever we gave them, so if we choose `a` as `b` then that implementation gives the same expected result, but it is just... not expected.&#xD;&#xA;&#xD;&#xA;Actually what came up to my mind is a type signature like:&#xD;&#xA;&#xD;&#xA;    getFromDoubleAccepter :: ((a -> ()) -> ()) -> a&#xD;&#xA;&#xD;&#xA;And this time it is harder. &#xD;&#xA;&#xD;&#xA;Another comment writer asks for reasoning. Let's look at a similar function&#xD;&#xA;&#xD;&#xA;    getFunctionFromAccepter :: (((a -> b) -> b) -> b) -> a -> b&#xD;&#xA;&#xD;&#xA;This one have an naive solution:&#xD;&#xA;&#xD;&#xA;    getFunctionFromAccepter f = \\a -> f $ \\x -> x a&#xD;&#xA;&#xD;&#xA;But in the following test code it fails on the third:&#xD;&#xA;&#xD;&#xA;    exeMain = do&#xD;&#xA;        print $ getFunctionFromAccepter (\\f -> f (\\x -> 10)) ""Example 1"" -- 10&#xD;&#xA;        print $ getFunctionFromAccepter (\\f -> 20) ""Example 2"" -- 20&#xD;&#xA;        print $ getFunctionFromAccepter (\\f -> 10 + f (\\x -> 30)) ""Example 3"" --40, should be 30&#xD;&#xA;&#xD;&#xA;In the failing case, we pass a function that returns `30`, and we expect to get that function back. However the final result in turn to be `40`, so it fails.&#xD;&#xA;So, Are there any way to implement doing **Just** that thing I wanted?";;added 1211 characters in body
45276330;18200150;812034;5;5407026e-12db-4078-80e0-bd5de9181be4;2013-08-13 05:54:53.0;"In most of programming languages that support mutable variables, one can easily implement something like this *Java* example:&#xD;&#xA;&#xD;&#xA;<!-- language: lang-java -->&#xD;&#xA;&#xD;&#xA;	interface Accepter<T> {&#xD;&#xA;		void accept(T t);&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	<T> T getFromDoubleAccepter(Accepter<Accepter<T>> acc){&#xD;&#xA;		final List<T> l = new ArrayList<T>();&#xD;&#xA;		acc.accept(new Accepter<T>(){&#xD;&#xA;&#xD;&#xA;			@Override&#xD;&#xA;			public void accept(T t) {&#xD;&#xA;				l.add(t);&#xD;&#xA;			}&#xD;&#xA;			&#xD;&#xA;		});&#xD;&#xA;		return l.get(0); //Not being called? Exception!&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;Just for those do not understand Java, the above code receives something can can be provided a function that takes one parameter, and it supposed to grape this parameter as the final result.&#xD;&#xA;&#xD;&#xA;This is not like `callCC`: there is no control flow alternation. Only the inner function's parameter is concerned. &#xD;&#xA;&#xD;&#xA;I think the equivalent type signature in *Haskell* should be&#xD;&#xA;&#xD;&#xA;    getFromDoubleAccepter :: (forall b. (a -> b) -> b) -> a&#xD;&#xA;&#xD;&#xA;So, if someone can gives you a function `(a -> b) -> b` for a type of your choice, he MUST already have an `a` in hand. So your job is to give them a ""callback"", and than keep whatever they sends you in mind, once they returned to you, return **that** value to your caller.&#xD;&#xA;&#xD;&#xA;But I have no idea how to implement this. There are several possible solutions I can think of. Although I don't know how each of them would work, I can rate and order them by prospected difficulties:&#xD;&#xA;&#xD;&#xA;* `Cont` or `ContT` monad. This I consider to be easiest.&#xD;&#xA;&#xD;&#xA;* `RWS` monad or similar.&#xD;&#xA;&#xD;&#xA;* Any other monads. *Pure* monads like `Maybe` I consider harder.&#xD;&#xA;&#xD;&#xA;* Use only standard *pure* functional features like lazy evaluation, pattern-matching, the fixed point contaminator, etc. This I consider the hardest (or even impossible).&#xD;&#xA;&#xD;&#xA;I would like to see answers using any of the above techniques (and prefer harder ways).&#xD;&#xA;&#xD;&#xA;**Note:** There should not be any modification of the type signature, and the solution should do the same thing that the *Java* code does.&#xD;&#xA;&#xD;&#xA;**UPDATE**&#xD;&#xA;&#xD;&#xA;Once I seen somebody commented out `getFromDoubleAccepter f = f id` I realize that I have made something wrong. Basically I use `forall` just to make the game easier but it looks like this twist makes it too easy. Actually, the above type signature **forces** the caller to pass back whatever we gave them, so if we choose `a` as `b` then that implementation gives the same expected result, but it is just... not expected.&#xD;&#xA;&#xD;&#xA;Actually what came up to my mind is a type signature like:&#xD;&#xA;&#xD;&#xA;    getFromDoubleAccepter :: ((a -> ()) -> ()) -> a&#xD;&#xA;&#xD;&#xA;And this time it is harder. &#xD;&#xA;&#xD;&#xA;Another comment writer asks for reasoning. Let's look at a similar function&#xD;&#xA;&#xD;&#xA;    getFunctionFromAccepter :: (((a -> b) -> b) -> b) -> a -> b&#xD;&#xA;&#xD;&#xA;This one have an naive solution:&#xD;&#xA;&#xD;&#xA;    getFunctionFromAccepter f = \\a -> f $ \\x -> x a&#xD;&#xA;&#xD;&#xA;But in the following test code it fails on the third:&#xD;&#xA;&#xD;&#xA;    exeMain = do&#xD;&#xA;        print $ getFunctionFromAccepter (\\f -> f (\\x -> 10)) ""Example 1"" -- 10&#xD;&#xA;        print $ getFunctionFromAccepter (\\f -> 20) ""Example 2"" -- 20&#xD;&#xA;        print $ getFunctionFromAccepter (\\f -> 10 + f (\\x -> 30)) ""Example 3"" --40, should be 30&#xD;&#xA;&#xD;&#xA;In the failing case, we pass a function that returns `30`, and we expect to get that function back. However the final result is in turn `40`, so it fails. Are there any way to implement doing **Just** that thing I wanted?";;deleted 8 characters in body
45276605;18200150;812034;5;92e84019-3bab-4d8a-a56f-5edddeda52b4;2013-08-13 06:02:04.0;"In most of programming languages that support mutable variables, one can easily implement something like this *Java* example:&#xD;&#xA;&#xD;&#xA;<!-- language: lang-java -->&#xD;&#xA;&#xD;&#xA;	interface Accepter<T> {&#xD;&#xA;		void accept(T t);&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	<T> T getFromDoubleAccepter(Accepter<Accepter<T>> acc){&#xD;&#xA;		final List<T> l = new ArrayList<T>();&#xD;&#xA;		acc.accept(new Accepter<T>(){&#xD;&#xA;&#xD;&#xA;			@Override&#xD;&#xA;			public void accept(T t) {&#xD;&#xA;				l.add(t);&#xD;&#xA;			}&#xD;&#xA;			&#xD;&#xA;		});&#xD;&#xA;		return l.get(0); //Not being called? Exception!&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;Just for those do not understand Java, the above code receives something can can be provided a function that takes one parameter, and it supposed to grape this parameter as the final result.&#xD;&#xA;&#xD;&#xA;This is not like `callCC`: there is no control flow alternation. Only the inner function's parameter is concerned. &#xD;&#xA;&#xD;&#xA;I think the equivalent type signature in *Haskell* should be&#xD;&#xA;&#xD;&#xA;    getFromDoubleAccepter :: (forall b. (a -> b) -> b) -> a&#xD;&#xA;&#xD;&#xA;So, if someone can gives you a function `(a -> b) -> b` for a type of your choice, he MUST already have an `a` in hand. So your job is to give them a ""callback"", and than keep whatever they sends you in mind, once they returned to you, return **that** value to your caller.&#xD;&#xA;&#xD;&#xA;But I have no idea how to implement this. There are several possible solutions I can think of. Although I don't know how each of them would work, I can rate and order them by prospected difficulties:&#xD;&#xA;&#xD;&#xA;* `Cont` or `ContT` monad. This I consider to be easiest.&#xD;&#xA;&#xD;&#xA;* `RWS` monad or similar.&#xD;&#xA;&#xD;&#xA;* Any other monads. *Pure* monads like `Maybe` I consider harder.&#xD;&#xA;&#xD;&#xA;* Use only standard *pure* functional features like lazy evaluation, pattern-matching, the fixed point contaminator, etc. This I consider the hardest (or even impossible).&#xD;&#xA;&#xD;&#xA;I would like to see answers using any of the above techniques (and prefer harder ways).&#xD;&#xA;&#xD;&#xA;**Note:** There should not be any modification of the type signature, and the solution should do the same thing that the *Java* code does.&#xD;&#xA;&#xD;&#xA;**UPDATE**&#xD;&#xA;&#xD;&#xA;Once I seen somebody commented out `getFromDoubleAccepter f = f id` I realize that I have made something wrong. Basically I use `forall` just to make the game easier but it looks like this twist makes it too easy. Actually, the above type signature **forces** the caller to pass back whatever we gave them, so if we choose `a` as `b` then that implementation gives the same expected result, but it is just... not expected.&#xD;&#xA;&#xD;&#xA;Actually what came up to my mind is a type signature like:&#xD;&#xA;&#xD;&#xA;    getFromDoubleAccepter :: ((a -> ()) -> ()) -> a&#xD;&#xA;&#xD;&#xA;And this time it is harder. &#xD;&#xA;&#xD;&#xA;Another comment writer asks for reasoning. Let's look at a similar function&#xD;&#xA;&#xD;&#xA;    getFunctionFromAccepter :: (((a -> b) -> b) -> b) -> a -> b&#xD;&#xA;&#xD;&#xA;This one have an naive solution:&#xD;&#xA;&#xD;&#xA;    getFunctionFromAccepter f = \\a -> f $ \\x -> x a&#xD;&#xA;&#xD;&#xA;But in the following test code it fails on the third:&#xD;&#xA;&#xD;&#xA;    exeMain = do&#xD;&#xA;        print $ getFunctionFromAccepter (\\f -> f (\\x -> 10)) ""Example 1"" -- 10&#xD;&#xA;        print $ getFunctionFromAccepter (\\f -> 20) ""Example 2"" -- 20&#xD;&#xA;        print $ getFunctionFromAccepter (\\f -> 10 + f (\\x -> 30)) ""Example 3"" --40, should be 30&#xD;&#xA;&#xD;&#xA;In the failing case, we pass a function that returns `30`, and we expect to get that function back. However the final result is in turn `40`, so it fails. Are there any way to implement doing **Just** that thing I wanted?&#xD;&#xA;&#xD;&#xA;If this can be done in Haskell there are a lot of interesting sequences. For example, tuples is then a definable type, since we can say something like `type (a,b) = (a->b->())->()` and implement `fst` and `snd` in term of this.";;deleted 8 characters in body
45277030;18200150;812034;5;a13f5798-017a-4fe7-9375-e7dd90f34f6d;2013-08-13 06:14:11.0;"In most of programming languages that support mutable variables, one can easily implement something like this *Java* example:&#xD;&#xA;&#xD;&#xA;<!-- language: lang-java -->&#xD;&#xA;&#xD;&#xA;	interface Accepter<T> {&#xD;&#xA;		void accept(T t);&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	<T> T getFromDoubleAccepter(Accepter<Accepter<T>> acc){&#xD;&#xA;		final List<T> l = new ArrayList<T>();&#xD;&#xA;		acc.accept(new Accepter<T>(){&#xD;&#xA;&#xD;&#xA;			@Override&#xD;&#xA;			public void accept(T t) {&#xD;&#xA;				l.add(t);&#xD;&#xA;			}&#xD;&#xA;			&#xD;&#xA;		});&#xD;&#xA;		return l.get(0); //Not being called? Exception!&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;Just for those do not understand Java, the above code receives something can can be provided a function that takes one parameter, and it supposed to grape this parameter as the final result.&#xD;&#xA;&#xD;&#xA;This is not like `callCC`: there is no control flow alternation. Only the inner function's parameter is concerned. &#xD;&#xA;&#xD;&#xA;I think the equivalent type signature in *Haskell* should be&#xD;&#xA;&#xD;&#xA;    getFromDoubleAccepter :: (forall b. (a -> b) -> b) -> a&#xD;&#xA;&#xD;&#xA;So, if someone can gives you a function `(a -> b) -> b` for a type of your choice, he MUST already have an `a` in hand. So your job is to give them a ""callback"", and than keep whatever they sends you in mind, once they returned to you, return **that** value to your caller.&#xD;&#xA;&#xD;&#xA;But I have no idea how to implement this. There are several possible solutions I can think of. Although I don't know how each of them would work, I can rate and order them by prospected difficulties:&#xD;&#xA;&#xD;&#xA;* `Cont` or `ContT` monad. This I consider to be easiest.&#xD;&#xA;&#xD;&#xA;* `RWS` monad or similar.&#xD;&#xA;&#xD;&#xA;* Any other monads. *Pure* monads like `Maybe` I consider harder.&#xD;&#xA;&#xD;&#xA;* Use only standard *pure* functional features like lazy evaluation, pattern-matching, the fixed point contaminator, etc. This I consider the hardest (or even impossible).&#xD;&#xA;&#xD;&#xA;I would like to see answers using any of the above techniques (and prefer harder ways).&#xD;&#xA;&#xD;&#xA;**Note:** There should not be any modification of the type signature, and the solution should do the same thing that the *Java* code does.&#xD;&#xA;&#xD;&#xA;**UPDATE**&#xD;&#xA;&#xD;&#xA;Once I seen somebody commented out `getFromDoubleAccepter f = f id` I realize that I have made something wrong. Basically I use `forall` just to make the game easier but it looks like this twist makes it too easy. Actually, the above type signature **forces** the caller to pass back whatever we gave them, so if we choose `a` as `b` then that implementation gives the same expected result, but it is just... not expected.&#xD;&#xA;&#xD;&#xA;Actually what came up to my mind is a type signature like:&#xD;&#xA;&#xD;&#xA;    getFromDoubleAccepter :: ((a -> ()) -> ()) -> a&#xD;&#xA;&#xD;&#xA;And this time it is harder. &#xD;&#xA;&#xD;&#xA;Another comment writer asks for reasoning. Let's look at a similar function&#xD;&#xA;&#xD;&#xA;    getFunctionFromAccepter :: (((a -> b) -> b) -> b) -> a -> b&#xD;&#xA;&#xD;&#xA;This one have an naive solution:&#xD;&#xA;&#xD;&#xA;    getFunctionFromAccepter f = \\a -> f $ \\x -> x a&#xD;&#xA;&#xD;&#xA;But in the following test code it fails on the third:&#xD;&#xA;&#xD;&#xA;    exeMain = do&#xD;&#xA;        print $ getFunctionFromAccepter (\\f -> f (\\x -> 10)) ""Example 1"" -- 10&#xD;&#xA;        print $ getFunctionFromAccepter (\\f -> 20) ""Example 2"" -- 20&#xD;&#xA;        print $ getFunctionFromAccepter (\\f -> 10 + f (\\x -> 30)) ""Example 3"" --40, should be 30&#xD;&#xA;&#xD;&#xA;In the failing case, we pass a function that returns `30`, and we expect to get that function back. However the final result is in turn `40`, so it fails. Are there any way to implement doing **Just** that thing I wanted?&#xD;&#xA;&#xD;&#xA;If this can be done in Haskell there are a lot of interesting sequences. For example, tuples (or other ""algebraic"" types) can be defined as functions as well, since we can say something like `type (a,b) = (a->b->())->()` and implement `fst` and `snd` in term of this.";;added 40 characters in body
45277574;18200150;812034;5;74cece97-bcb2-4c16-a043-2a0bff277704;2013-08-13 06:28:28.0;"In most of programming languages that support mutable variables, one can easily implement something like this *Java* example:&#xD;&#xA;&#xD;&#xA;<!-- language: lang-java -->&#xD;&#xA;&#xD;&#xA;	interface Accepter<T> {&#xD;&#xA;		void accept(T t);&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	<T> T getFromDoubleAccepter(Accepter<Accepter<T>> acc){&#xD;&#xA;		final List<T> l = new ArrayList<T>();&#xD;&#xA;		acc.accept(new Accepter<T>(){&#xD;&#xA;&#xD;&#xA;			@Override&#xD;&#xA;			public void accept(T t) {&#xD;&#xA;				l.add(t);&#xD;&#xA;			}&#xD;&#xA;			&#xD;&#xA;		});&#xD;&#xA;		return l.get(0); //Not being called? Exception!&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;Just for those do not understand Java, the above code receives something can can be provided a function that takes one parameter, and it supposed to grape this parameter as the final result.&#xD;&#xA;&#xD;&#xA;This is not like `callCC`: there is no control flow alternation. Only the inner function's parameter is concerned. &#xD;&#xA;&#xD;&#xA;I think the equivalent type signature in *Haskell* should be&#xD;&#xA;&#xD;&#xA;    getFromDoubleAccepter :: (forall b. (a -> b) -> b) -> a&#xD;&#xA;&#xD;&#xA;So, if someone can gives you a function `(a -> b) -> b` for a type of your choice, he MUST already have an `a` in hand. So your job is to give them a ""callback"", and than keep whatever they sends you in mind, once they returned to you, return **that** value to your caller.&#xD;&#xA;&#xD;&#xA;But I have no idea how to implement this. There are several possible solutions I can think of. Although I don't know how each of them would work, I can rate and order them by prospected difficulties:&#xD;&#xA;&#xD;&#xA;* `Cont` or `ContT` monad. This I consider to be easiest.&#xD;&#xA;&#xD;&#xA;* `RWS` monad or similar.&#xD;&#xA;&#xD;&#xA;* Any other monads. *Pure* monads like `Maybe` I consider harder.&#xD;&#xA;&#xD;&#xA;* Use only standard *pure* functional features like lazy evaluation, pattern-matching, the fixed point contaminator, etc. This I consider the hardest (or even impossible).&#xD;&#xA;&#xD;&#xA;I would like to see answers using any of the above techniques (and prefer harder ways).&#xD;&#xA;&#xD;&#xA;**Note:** There should not be any modification of the type signature, and the solution should do the same thing that the *Java* code does.&#xD;&#xA;&#xD;&#xA;**UPDATE**&#xD;&#xA;&#xD;&#xA;Once I seen somebody commented out `getFromDoubleAccepter f = f id` I realize that I have made something wrong. Basically I use `forall` just to make the game easier but it looks like this twist makes it too easy. Actually, the above type signature **forces** the caller to pass back whatever we gave them, so if we choose `a` as `b` then that implementation gives the same expected result, but it is just... not expected.&#xD;&#xA;&#xD;&#xA;Actually what came up to my mind is a type signature like:&#xD;&#xA;&#xD;&#xA;    getFromDoubleAccepter :: ((a -> ()) -> ()) -> a&#xD;&#xA;&#xD;&#xA;And this time it is harder. &#xD;&#xA;&#xD;&#xA;Another comment writer asks for reasoning. Let's look at a similar function&#xD;&#xA;&#xD;&#xA;    getFunctionFromAccepter :: (((a -> b) -> b) -> b) -> a -> b&#xD;&#xA;&#xD;&#xA;This one have an naive solution:&#xD;&#xA;&#xD;&#xA;    getFunctionFromAccepter f = \\a -> f $ \\x -> x a&#xD;&#xA;&#xD;&#xA;But in the following test code it fails on the third:&#xD;&#xA;&#xD;&#xA;    exeMain = do&#xD;&#xA;        print $ getFunctionFromAccepter (\\f -> f (\\x -> 10)) ""Example 1"" -- 10&#xD;&#xA;        print $ getFunctionFromAccepter (\\f -> 20) ""Example 2"" -- 20&#xD;&#xA;        print $ getFunctionFromAccepter (\\f -> 10 + f (\\x -> 30)) ""Example 3"" --40, should be 30&#xD;&#xA;&#xD;&#xA;In the failing case, we pass a function that returns `30`, and we expect to get that function back. However the final result is in turn `40`, so it fails. Are there any way to implement doing **Just** that thing I wanted?&#xD;&#xA;&#xD;&#xA;If this can be done in Haskell there are a lot of interesting sequences. For example, tuples (or other ""algebraic"" types) can be defined as functions as well, since we can say something like `type (a,b) = (a->b->())->()` and implement `fst` and `snd` in term of this. And this, is the way I used in a couple of other languages that do not have native ""tuple"" support but features ""closure"".";;added 127 characters in body
