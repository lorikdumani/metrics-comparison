Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
96316559;31730617;2410359;2;ca9253dc-6dae-4c4e-bea6-1f2210d8415b;2015-07-30 17:44:04.0;"To generate a _unique number_ in a range of 15 or 16 bits from larger numbers (11 bytes or 88 bits) is a [hash function](https://en.wikipedia.org/wiki/Hash_function) and prone to collisions as happened with OP's generated number 23860.&#xD;&#xA;&#xD;&#xA;Using `srand() / rand()` is a method but has weakness _for consistency_: 1) Portability: same data on different platforms may yield different numbers as C specifies little about `rand()` method.  2) As it requires 2 functions sharing a global state variable, code must insure another thread/interrupt does not mess things up or that these calls mess up consistency in other functions using `rand()`.  &#xD;&#xA;&#xD;&#xA;I found _consistency_ important as being able to use the same test code on multiple platform.  Thus a significant advantage in code maintenance.&#xD;&#xA;&#xD;&#xA;[@mattinbits](http://stackoverflow.com/a/31710288/2410359) well recommends a good  8/16 bit solution.  Why re-invent the wheel?  Yet I do not drive on chariot tires, so ...&#xD;&#xA;&#xD;&#xA;If OP does not appear to really need a identifier in the _entire_ range of [0...32767] or [0...65536] (Did OP mean 65535?), consider a simple portable repeatable hash method that relies on `%` by a [prime](http://www.onlineconversion.com/prime.htm) near 32767 to well mix up the bits.&#xD;&#xA;&#xD;&#xA;    // return numbers 0 ... 32748&#xD;&#xA;    int Hash15(const unsigned char ID[11]) {&#xD;&#xA;      unsigned long long Upper;&#xD;&#xA;      unsigned long Lower;&#xD;&#xA;      Upper = (ID[0]*1ULL<<56) | (ID[1]*1ULL<<48) | (ID[2]*1ULL<<40) | (ID[3]*1ULL<<32) |&#xD;&#xA;          (ID[4]*1UL<<24)  | (ID[5]*1UL<<16) | (ID[6]*1U<<8) | ID[7];&#xD;&#xA;      Lower = (ID[8]*1UL<<16) | (ID[9]*1U<<8) | ID[10];&#xD;&#xA;      // Greatest prime <= 32768&#xD;&#xA;      #define Prime_LE_32768 32749&#xD;&#xA;      return (Upper ^ Lower) % Prime_LE_32768;&#xD;&#xA;    }&#xD;&#xA;      ";;
96316992;31730617;2410359;5;ec403e14-935b-489b-bb02-fd7c279d6766;2015-07-30 17:51:05.0;"To generate a _unique number_ in a range of 15 or 16 bits from larger numbers (11 bytes or 88 bits) is a [hash function](https://en.wikipedia.org/wiki/Hash_function) and prone to collisions as happened with OP's generated number 23860.&#xD;&#xA;&#xD;&#xA;Using `srand() / rand()` is a method but has weakness _for consistency_: 1) Portability: same data on different platforms may yield different numbers as C specifies little about `rand()` method.  2) As it requires 2 functions sharing a global state variable, code must insure another thread/interrupt does not mess things up or that these calls mess up consistency in other functions using `rand()`.  &#xD;&#xA;&#xD;&#xA;I found _consistency_ important as being able to use the same test code on multiple platforms: a significant advantage in code maintenance.&#xD;&#xA;&#xD;&#xA;[@mattinbits](http://stackoverflow.com/a/31710288/2410359) well recommends a good  8/16 bit solution.  Why re-invent the wheel?  Yet I do not drive on chariot tires, so ...&#xD;&#xA;&#xD;&#xA;If OP does not appear to really need a identifier in the _entire_ range of [0...32767] or [0...65536] (Did OP mean 65535?), consider a simple portable repeatable hash method that relies on `%` by a [prime](http://www.onlineconversion.com/prime.htm) near the limit to well mix up the bits.&#xD;&#xA;&#xD;&#xA;    // return numbers 0 ... 32748 or 0 ... 65536&#xD;&#xA;    int Hash(const unsigned char ID[11]) {&#xD;&#xA;      unsigned long long Upper;&#xD;&#xA;      unsigned long Lower;&#xD;&#xA;      Upper = (ID[0]*1ULL<<56) | (ID[1]*1ULL<<48) | (ID[2]*1ULL<<40) | (ID[3]*1ULL<<32) |&#xD;&#xA;          (ID[4]*1UL<<24)  | (ID[5]*1UL<<16) | (ID[6]*1U<<8) | ID[7];&#xD;&#xA;      Lower = (ID[8]*1UL<<16) | (ID[9]*1U<<8) | ID[10];&#xD;&#xA;      // Greatest prime <= 32768&#xD;&#xA;      #define Prime_LE_32768 32749&#xD;&#xA;      return (Upper ^ Lower) % Prime_LE_32768;&#xD;&#xA;&#xD;&#xA;      // or &#xD;&#xA;      // Greatest prime <= 65537&#xD;&#xA;      #define Prime_LE_65537 65537&#xD;&#xA;      return (Upper ^ Lower) % Prime_LE_65537;&#xD;&#xA;    }&#xD;&#xA;      ";;added 142 characters in body
96317579;31730617;2410359;5;b2b6652f-765b-4d05-bb8a-18a01f7bbc44;2015-07-30 18:00:05.0;"To generate a _unique number_ in a range of 15 or 16 bits from larger numbers (11 bytes or 88 bits) is a [hash function](https://en.wikipedia.org/wiki/Hash_function) and prone to collisions as happened with OP's generated number 23860.&#xD;&#xA;&#xD;&#xA;Summing all the 11 bytes is very weak as the sum of the 11 bytes is in the range of 0 to 11*255 or 2805 with very uneven distribution.  So code only generates 2806 different seeds for `srand()`.  It would have been better to use a wider integer grouping than 8-bit.  Recommend 64-bit groups exclusive-or'd with each other.&#xD;&#xA;&#xD;&#xA;Using `srand() / rand()` is a method but has weakness _for consistency_: 1) Portability: same data on different platforms may yield different numbers as C specifies little about `rand()` method.  2) As it requires 2 functions sharing a global state variable, code must insure another thread/interrupt does not mess things up or that these calls mess up consistency in other functions using `rand()`.  &#xD;&#xA;&#xD;&#xA;I found _consistency_ important as being able to use the same test code on multiple platforms: a significant advantage in code maintenance.&#xD;&#xA;&#xD;&#xA;[@mattinbits](http://stackoverflow.com/a/31710288/2410359) well recommends a good  8/16 bit solution.  Why re-invent the wheel?  Yet I do not drive on chariot tires, so ...&#xD;&#xA;&#xD;&#xA;If OP does not appear to really need a identifier in the _entire_ range of [0...32767] or [0...65536] (Did OP mean 65535?), consider a simple portable repeatable hash method that relies on `%` by a [prime](http://www.onlineconversion.com/prime.htm) near the limit to well mix up the bits.&#xD;&#xA;&#xD;&#xA;    // return numbers 0 ... 32748 or 0 ... 65536&#xD;&#xA;    unsigned long Hash(const unsigned char ID[11]) {&#xD;&#xA;      unsigned long long Upper;&#xD;&#xA;      unsigned long Lower;&#xD;&#xA;      Upper = (ID[0]*1ULL<<56) | (ID[1]*1ULL<<48) | (ID[2]*1ULL<<40) | (ID[3]*1ULL<<32) |&#xD;&#xA;          (ID[4]*1UL<<24)  | (ID[5]*1UL<<16) | (ID[6]*1U<<8) | ID[7];&#xD;&#xA;      Lower = (ID[8]*1UL<<16) | (ID[9]*1U<<8) | ID[10];&#xD;&#xA;      // Greatest prime <= 32768&#xD;&#xA;      #define Prime_LE_32768 32749&#xD;&#xA;      return (Upper ^ Lower) % Prime_LE_32768;&#xD;&#xA;&#xD;&#xA;      // or &#xD;&#xA;      // Greatest prime <= 65537&#xD;&#xA;      #define Prime_LE_65537 65537&#xD;&#xA;      return (Upper ^ Lower) % Prime_LE_65537;&#xD;&#xA;    }&#xD;&#xA;      ";;added 296 characters in body
96318107;31730617;2410359;5;33ef747a-8cff-45fa-90c7-0cfd5f76a5ba;2015-07-30 18:07:40.0;"To generate a _unique number_ in a range of 15 or 16 bits from larger numbers (11 bytes or 88 bits) is a [hash function](https://en.wikipedia.org/wiki/Hash_function) and prone to collisions as happened with OP's generated number 23860.&#xD;&#xA;&#xD;&#xA;Summing all the 11 bytes is very weak as the sum of the 11 bytes is in the range of 0 to 11*255 or 2805 with very uneven distribution.  So code only generates 2806 different seeds for `srand()`.  It would have been better to use a wider integer grouping than 8-bit.  Recommend 64-bit groups exclusive-or'd with each other.&#xD;&#xA;&#xD;&#xA;Using `srand() / rand()` is a method but has weakness _for consistency_: 1) Portability: same data on different platforms may yield different numbers as C specifies little about `rand()` method.  2) As it requires 2 functions sharing a global state variable, code must insure another thread/interrupt does not mess things up or that these calls mess up consistency in other functions using `rand()`.  A big problem with `rand()` is on systems where `RAND_MAX` is 32767, its minimum specified value, and code is attempting [0...65536].&#xD;&#xA;&#xD;&#xA;I found _consistency_ important as being able to use the same test code on multiple platforms: a significant advantage in code maintenance.&#xD;&#xA;&#xD;&#xA;[@mattinbits](http://stackoverflow.com/a/31710288/2410359) well recommends a good  8/16 bit solution.  Why re-invent the wheel?  Yet I do not drive on chariot tires, so ...&#xD;&#xA;&#xD;&#xA;If OP does not appear to really need a identifier in the _entire_ range of [0...32767] or [0...65536] (Did OP mean 65535?), consider a simple portable repeatable hash method that relies on `%` by a [prime](http://www.onlineconversion.com/prime.htm) near the limit to well mix up the bits.&#xD;&#xA;&#xD;&#xA;    // return numbers 0 ... 32748 or 0 ... 65536&#xD;&#xA;    unsigned long Hash(const unsigned char ID[11]) {&#xD;&#xA;      unsigned long long Upper;&#xD;&#xA;      unsigned long Lower;&#xD;&#xA;      Upper = (ID[0]*1ULL<<56) | (ID[1]*1ULL<<48) | (ID[2]*1ULL<<40) | (ID[3]*1ULL<<32) |&#xD;&#xA;          (ID[4]*1UL<<24)  | (ID[5]*1UL<<16) | (ID[6]*1U<<8) | ID[7];&#xD;&#xA;      Lower = (ID[8]*1UL<<16) | (ID[9]*1U<<8) | ID[10];&#xD;&#xA;      // Greatest prime <= 32768&#xD;&#xA;      #define Prime_LE_32768 32749&#xD;&#xA;      return (Upper ^ Lower) % Prime_LE_32768;&#xD;&#xA;&#xD;&#xA;      // or &#xD;&#xA;      // Greatest prime <= 65537&#xD;&#xA;      #define Prime_LE_65537 65537&#xD;&#xA;      return (Upper ^ Lower) % Prime_LE_65537;&#xD;&#xA;    }&#xD;&#xA;      ";;added 296 characters in body
96333242;31730617;2410359;5;23c96163-4b2d-4759-8e94-91e02da32f75;2015-07-30 22:15:17.0;"To generate a _unique number_ in a range of 15 or 16 bits from larger numbers (11 bytes or 88 bits) is a [hash function](https://en.wikipedia.org/wiki/Hash_function) and prone to collisions as happened with OP's generated number 23860.&#xD;&#xA;&#xD;&#xA;Summing all the 11 bytes is very weak as the sum of the 11 bytes is in the range of 0 to 11*255 or 2805 with very uneven distribution.  So code only generates 2806 different seeds for `srand()`.  It would have been better to use a wider integer grouping than 8-bit.  Recommend 64-bit groups exclusive-or'd with each other.&#xD;&#xA;&#xD;&#xA;Using `srand() / rand()` is a method but has weakness _for consistency_: 1) Portability: same data on different platforms may yield different numbers as C specifies little about `rand()` method.  2) As it requires 2 functions sharing a global state variable, code must insure another thread/interrupt does not mess things up or that these calls mess up consistency in other functions using `rand()`.  A big problem with `rand()` is on systems where `RAND_MAX` is 32767, its minimum specified value, and code is attempting [0...65536].&#xD;&#xA;&#xD;&#xA;I found _consistency_ important as being able to use the same test code on multiple platforms: a significant advantage in code maintenance.&#xD;&#xA;&#xD;&#xA;[@mattinbits](http://stackoverflow.com/a/31710288/2410359) well recommends a good  8/16 bit solution.  Why re-invent the wheel?  Yet I do not drive on chariot tires, so ...&#xD;&#xA;&#xD;&#xA;If OP does not appear to really need a identifier in the _entire_ range of [0...32767] or [0...65536] (Did OP mean 65535?), consider a simple portable repeatable hash method that relies on `%` by a [prime](http://www.onlineconversion.com/prime.htm) near the limit to well mix up the bits.&#xD;&#xA;&#xD;&#xA;    // return numbers 0 ... 32748 or 0 ... 65536&#xD;&#xA;    unsigned long Hash(const unsigned char ID[11]) {&#xD;&#xA;      unsigned long long Upper;&#xD;&#xA;      unsigned long Lower;&#xD;&#xA;      Upper = (ID[0]*1ULL<<56) | (ID[1]*1ULL<<48) | (ID[2]*1ULL<<40) | (ID[3]*1ULL<<32) |&#xD;&#xA;          (ID[4]*1UL<<24)  | (ID[5]*1UL<<16) | (ID[6]*1U<<8) | ID[7];&#xD;&#xA;      Lower = (ID[8]*1UL<<16) | (ID[9]*1U<<8) | ID[10];&#xD;&#xA;      // Greatest prime <= 32768&#xD;&#xA;      #define Prime_LE_32768 32749&#xD;&#xA;      return (Upper ^ Lower) % Prime_LE_32768;&#xD;&#xA;&#xD;&#xA;      // or &#xD;&#xA;      // Greatest prime <= 65537&#xD;&#xA;      #define Prime_LE_65537 65537&#xD;&#xA;      return (Upper ^ Lower) % Prime_LE_65537;&#xD;&#xA;    }&#xD;&#xA;      &#xD;&#xA;&#xD;&#xA;[Edit]&#xD;&#xA;&#xD;&#xA;    unsigned Hash(const unsigned char ID[11], unsigned prime) {&#xD;&#xA;      unsigned long long Upper;&#xD;&#xA;      unsigned long Lower;&#xD;&#xA;      Upper = (ID[0] * 1ULL << 56) | (ID[1] * 1ULL << 48) | (ID[2] * 1ULL << 40)&#xD;&#xA;          | (ID[3] * 1ULL << 32) | (ID[4] * 1UL << 24) | (ID[5] * 1UL << 16)&#xD;&#xA;          | (ID[6] * 1U << 8) | ID[7];&#xD;&#xA;      Lower = (ID[8] * 1UL << 16) | (ID[9] * 1U << 8) | ID[10];&#xD;&#xA;      return (Upper ^ Lower) % prime;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    const unsigned char ID[][11] = {&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x02, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x06, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x0A, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x0E, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0A, 0x00, 0x14, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0A, 0x00, 0x1C, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x09, 0x00, 0x23, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0A, 0x00, 0x24, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x0E, 0x1D, 0x00, 0x1A, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x09, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x33, 0x31, 0x35, 0x39, 0x04, 0x10, 0x00, 0x20, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x33, 0x31, 0x35, 0x39, 0x04, 0x18, 0x00, 0x1C, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x0F, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x13, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x17, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x1F, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0A, 0x00, 0x25, 0x00 },&#xD;&#xA;        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };&#xD;&#xA;    &#xD;&#xA;    #define Prime_LE_32768 32749&#xD;&#xA;    #define Prime_LE_65536 65521u&#xD;&#xA;    void test() {&#xD;&#xA;      int i, j;&#xD;&#xA;      for (i = 0; i < sizeof ID / sizeof ID[0]; i++) {&#xD;&#xA;        const char *comma = """";&#xD;&#xA;        for (j = 0; j < 11; j++) {&#xD;&#xA;          printf(""%s%02X"", comma, ID[i][j]);&#xD;&#xA;          comma = ""-"";&#xD;&#xA;        }&#xD;&#xA;        printf("" %5u"", Hash(ID[i], Prime_LE_32768));&#xD;&#xA;        printf("" %5u\\n"", Hash(ID[i], Prime_LE_65536));&#xD;&#xA;      }&#xD;&#xA;      puts("""");&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;> Output&#xD;&#xA;&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-02-00  1205 13786&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-06-00   181 12762&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-0A-00  3253 15834&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-0E-00  2229 14810&#xD;&#xA;    34-57-36-31-38-39-15-0A-00-14-00 28318  8150&#xD;&#xA;    34-57-36-31-38-39-15-0A-00-1C-00 30366 10198&#xD;&#xA;    34-57-36-31-38-39-15-09-00-23-00  9136 21717&#xD;&#xA;    34-57-36-31-38-39-15-0A-00-24-00  7857 20438&#xD;&#xA;    34-57-36-31-38-39-0E-1D-00-1A-00   452 13033&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-09-00  2485 15066&#xD;&#xA;    34-57-33-31-35-39-04-10-00-20-00 12574 29359&#xD;&#xA;    34-57-33-31-35-39-04-18-00-1C-00  9510 26295&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-0F-00  1973 14554&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-13-00 29602  9434&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-17-00 28578  8410&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-1F-00 30626 10458&#xD;&#xA;    34-57-36-31-38-39-15-0A-00-25-00  7601 20182&#xD;&#xA;    00-00-00-00-00-00-00-00-00-00-00     0     0";;added 3287 characters in body
96333523;31730617;2410359;5;d162e66b-c5ea-492d-9cca-7f276d44e234;2015-07-30 22:23:08.0;"To generate a _unique number_ in a range of 15 or 16 bits from larger numbers (11 bytes or 88 bits) is a [hash function](https://en.wikipedia.org/wiki/Hash_function) and prone to collisions as happened with OP's generated number 23860.&#xD;&#xA;&#xD;&#xA;Summing all the 11 bytes is very weak as the sum of the 11 bytes is in the range of 0 to 11*255 or 2805 with very uneven distribution.  So code only generates 2806 different seeds for `srand()`.  It would have been better to use a wider integer grouping than 8-bit.  Recommend 64-bit groups exclusive-or'd with each other.&#xD;&#xA;&#xD;&#xA;Using `srand() / rand()` is a method but has weakness _for consistency_: 1) Portability: same data on different platforms may yield different numbers as C specifies little about `rand()` method.  2) As it requires 2 functions sharing a global state variable, code must insure another thread/interrupt does not mess things up or that these calls mess up consistency in other functions using `rand()`.  A big problem with `rand()` is on systems where `RAND_MAX` is 32767, its minimum specified value, and code is attempting [0...65536].&#xD;&#xA;&#xD;&#xA;I found _consistency_ important as being able to use the same test code on multiple platforms: a significant advantage in code maintenance.&#xD;&#xA;&#xD;&#xA;[@mattinbits](http://stackoverflow.com/a/31710288/2410359) well recommends a good  8/16 bit solution.  Why re-invent the wheel?  Yet I do not drive on chariot tires, so ...&#xD;&#xA;&#xD;&#xA;If OP does not appear to really need a identifier in the _entire_ range of [0...32767] or [0...65536] (Did OP mean 65535?), consider a simple portable repeatable hash method that relies on `%` by a [prime](http://www.onlineconversion.com/prime.htm) near the limit to well mix up the bits.&#xD;&#xA;&#xD;&#xA;    // return numbers 0 ... 32748 or 0 ... 65536&#xD;&#xA;    unsigned long Hash(const unsigned char ID[11]) {&#xD;&#xA;      unsigned long long Upper;&#xD;&#xA;      unsigned long Lower;&#xD;&#xA;      Upper = (ID[0]*1ULL<<56) | (ID[1]*1ULL<<48) | (ID[2]*1ULL<<40) | (ID[3]*1ULL<<32) |&#xD;&#xA;          (ID[4]*1UL<<24)  | (ID[5]*1UL<<16) | (ID[6]*1U<<8) | ID[7];&#xD;&#xA;      Lower = (ID[8]*1UL<<16) | (ID[9]*1U<<8) | ID[10];&#xD;&#xA;      // Greatest prime <= 32768&#xD;&#xA;      #define Prime_LE_32768 32749&#xD;&#xA;      return (Upper ^ Lower) % Prime_LE_32768;&#xD;&#xA;&#xD;&#xA;      // or &#xD;&#xA;      // Greatest prime <= 65537&#xD;&#xA;      #define Prime_LE_65537 65537&#xD;&#xA;      return (Upper ^ Lower) % Prime_LE_65537;&#xD;&#xA;    }&#xD;&#xA;      &#xD;&#xA;&#xD;&#xA;[Edit] with potential simplifications.&#xD;&#xA;&#xD;&#xA;    unsigned Hash(const uint8_t ID[11], unsigned prime) {&#xD;&#xA;      uint64_t H[2] = {0};&#xD;&#xA;      memcpy(H, ID, 11);&#xD;&#xA;      return (H[0] ^ H[1]) % prime;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    const unsigned char ID[][11] = {&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x02, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x06, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x0A, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x0E, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0A, 0x00, 0x14, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0A, 0x00, 0x1C, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x09, 0x00, 0x23, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0A, 0x00, 0x24, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x0E, 0x1D, 0x00, 0x1A, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x09, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x33, 0x31, 0x35, 0x39, 0x04, 0x10, 0x00, 0x20, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x33, 0x31, 0x35, 0x39, 0x04, 0x18, 0x00, 0x1C, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x0F, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x13, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x17, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x1F, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0A, 0x00, 0x25, 0x00 },&#xD;&#xA;        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };&#xD;&#xA;    &#xD;&#xA;    #define Prime_LE_32768 32749&#xD;&#xA;    #define Prime_LE_65536 65521u&#xD;&#xA;    void test() {&#xD;&#xA;      int i, j;&#xD;&#xA;      for (i = 0; i < sizeof ID / sizeof ID[0]; i++) {&#xD;&#xA;        const char *comma = """";&#xD;&#xA;        for (j = 0; j < 11; j++) {&#xD;&#xA;          printf(""%s%02X"", comma, ID[i][j]);&#xD;&#xA;          comma = ""-"";&#xD;&#xA;        }&#xD;&#xA;        printf("" %5u"", Hash(ID[i], Prime_LE_32768));&#xD;&#xA;        printf("" %5u\\n"", Hash(ID[i], Prime_LE_65536));&#xD;&#xA;      }&#xD;&#xA;      puts("""");&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;> Output&#xD;&#xA;&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-02-00 14759 13938&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-06-00 13735 12914&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-0A-00 16807 15986&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-0E-00 15783 14962&#xD;&#xA;    34-57-36-31-38-39-15-0A-00-14-00 18507 25943&#xD;&#xA;    34-57-36-31-38-39-15-0A-00-1C-00 20555 27991&#xD;&#xA;    34-57-36-31-38-39-15-09-00-23-00   391 26260&#xD;&#xA;    34-57-36-31-38-39-15-0A-00-24-00 30795 38231&#xD;&#xA;    34-57-36-31-38-39-0E-1D-00-1A-00 23009 40628&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-09-00 17063 16242&#xD;&#xA;    34-57-33-31-35-39-04-10-00-20-00 31736 54522&#xD;&#xA;    34-57-33-31-35-39-04-18-00-1C-00  3760 10032&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-0F-00 15527 14706&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-13-00 10407  9586&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-17-00  9383  8562&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-1F-00 11431 10610&#xD;&#xA;    34-57-36-31-38-39-15-0A-00-25-00 30539 37975&#xD;&#xA;    00-00-00-00-00-00-00-00-00-00-00     0     0";;deleted 248 characters in body
147660999;31730617;-1;5;ee86515e-b01f-47a9-92b5-ff92e8e1ab8c;2017-05-23 12:32:48.0;"To generate a _unique number_ in a range of 15 or 16 bits from larger numbers (11 bytes or 88 bits) is a [hash function](https://en.wikipedia.org/wiki/Hash_function) and prone to collisions as happened with OP's generated number 23860.&#xD;&#xA;&#xD;&#xA;Summing all the 11 bytes is very weak as the sum of the 11 bytes is in the range of 0 to 11*255 or 2805 with very uneven distribution.  So code only generates 2806 different seeds for `srand()`.  It would have been better to use a wider integer grouping than 8-bit.  Recommend 64-bit groups exclusive-or'd with each other.&#xD;&#xA;&#xD;&#xA;Using `srand() / rand()` is a method but has weakness _for consistency_: 1) Portability: same data on different platforms may yield different numbers as C specifies little about `rand()` method.  2) As it requires 2 functions sharing a global state variable, code must insure another thread/interrupt does not mess things up or that these calls mess up consistency in other functions using `rand()`.  A big problem with `rand()` is on systems where `RAND_MAX` is 32767, its minimum specified value, and code is attempting [0...65536].&#xD;&#xA;&#xD;&#xA;I found _consistency_ important as being able to use the same test code on multiple platforms: a significant advantage in code maintenance.&#xD;&#xA;&#xD;&#xA;[@mattinbits](https://stackoverflow.com/a/31710288/2410359) well recommends a good  8/16 bit solution.  Why re-invent the wheel?  Yet I do not drive on chariot tires, so ...&#xD;&#xA;&#xD;&#xA;If OP does not appear to really need a identifier in the _entire_ range of [0...32767] or [0...65536] (Did OP mean 65535?), consider a simple portable repeatable hash method that relies on `%` by a [prime](http://www.onlineconversion.com/prime.htm) near the limit to well mix up the bits.&#xD;&#xA;&#xD;&#xA;    // return numbers 0 ... 32748 or 0 ... 65536&#xD;&#xA;    unsigned long Hash(const unsigned char ID[11]) {&#xD;&#xA;      unsigned long long Upper;&#xD;&#xA;      unsigned long Lower;&#xD;&#xA;      Upper = (ID[0]*1ULL<<56) | (ID[1]*1ULL<<48) | (ID[2]*1ULL<<40) | (ID[3]*1ULL<<32) |&#xD;&#xA;          (ID[4]*1UL<<24)  | (ID[5]*1UL<<16) | (ID[6]*1U<<8) | ID[7];&#xD;&#xA;      Lower = (ID[8]*1UL<<16) | (ID[9]*1U<<8) | ID[10];&#xD;&#xA;      // Greatest prime <= 32768&#xD;&#xA;      #define Prime_LE_32768 32749&#xD;&#xA;      return (Upper ^ Lower) % Prime_LE_32768;&#xD;&#xA;&#xD;&#xA;      // or &#xD;&#xA;      // Greatest prime <= 65537&#xD;&#xA;      #define Prime_LE_65537 65537&#xD;&#xA;      return (Upper ^ Lower) % Prime_LE_65537;&#xD;&#xA;    }&#xD;&#xA;      &#xD;&#xA;&#xD;&#xA;[Edit] with potential simplifications.&#xD;&#xA;&#xD;&#xA;    unsigned Hash(const uint8_t ID[11], unsigned prime) {&#xD;&#xA;      uint64_t H[2] = {0};&#xD;&#xA;      memcpy(H, ID, 11);&#xD;&#xA;      return (H[0] ^ H[1]) % prime;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    const unsigned char ID[][11] = {&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x02, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x06, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x0A, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x0E, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0A, 0x00, 0x14, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0A, 0x00, 0x1C, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x09, 0x00, 0x23, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0A, 0x00, 0x24, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x0E, 0x1D, 0x00, 0x1A, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x09, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x33, 0x31, 0x35, 0x39, 0x04, 0x10, 0x00, 0x20, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x33, 0x31, 0x35, 0x39, 0x04, 0x18, 0x00, 0x1C, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x0F, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x13, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x17, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0E, 0x00, 0x1F, 0x00 },&#xD;&#xA;        { 0x34, 0x57, 0x36, 0x31, 0x38, 0x39, 0x15, 0x0A, 0x00, 0x25, 0x00 },&#xD;&#xA;        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };&#xD;&#xA;    &#xD;&#xA;    #define Prime_LE_32768 32749&#xD;&#xA;    #define Prime_LE_65536 65521u&#xD;&#xA;    void test() {&#xD;&#xA;      int i, j;&#xD;&#xA;      for (i = 0; i < sizeof ID / sizeof ID[0]; i++) {&#xD;&#xA;        const char *comma = """";&#xD;&#xA;        for (j = 0; j < 11; j++) {&#xD;&#xA;          printf(""%s%02X"", comma, ID[i][j]);&#xD;&#xA;          comma = ""-"";&#xD;&#xA;        }&#xD;&#xA;        printf("" %5u"", Hash(ID[i], Prime_LE_32768));&#xD;&#xA;        printf("" %5u\\n"", Hash(ID[i], Prime_LE_65536));&#xD;&#xA;      }&#xD;&#xA;      puts("""");&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;> Output&#xD;&#xA;&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-02-00 14759 13938&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-06-00 13735 12914&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-0A-00 16807 15986&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-0E-00 15783 14962&#xD;&#xA;    34-57-36-31-38-39-15-0A-00-14-00 18507 25943&#xD;&#xA;    34-57-36-31-38-39-15-0A-00-1C-00 20555 27991&#xD;&#xA;    34-57-36-31-38-39-15-09-00-23-00   391 26260&#xD;&#xA;    34-57-36-31-38-39-15-0A-00-24-00 30795 38231&#xD;&#xA;    34-57-36-31-38-39-0E-1D-00-1A-00 23009 40628&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-09-00 17063 16242&#xD;&#xA;    34-57-33-31-35-39-04-10-00-20-00 31736 54522&#xD;&#xA;    34-57-33-31-35-39-04-18-00-1C-00  3760 10032&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-0F-00 15527 14706&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-13-00 10407  9586&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-17-00  9383  8562&#xD;&#xA;    34-57-36-31-38-39-15-0E-00-1F-00 11431 10610&#xD;&#xA;    34-57-36-31-38-39-15-0A-00-25-00 30539 37975&#xD;&#xA;    00-00-00-00-00-00-00-00-00-00-00     0     0";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
