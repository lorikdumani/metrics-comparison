Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
98526195;32292973;4907604;2;85e1c602-8c59-45aa-a75d-c53796606425;2015-08-30 03:48:50.0;"It seemed like a straightforward enough problem, but I spent hours on the wrong track before finally figuring out the correct logic. To find all permutations of a string with multiple repeated characters, while keeping identical characters seperated:&#xD;&#xA;&#xD;&#xA;Start with a string like:  &#xD;&#xA;> abcdabc&#xD;&#xA;&#xD;&#xA;Seperate the first occurances from the repeats:  &#xD;&#xA;> firsts: abcd  &#xD;&#xA;> repeats: abc&#xD;&#xA;&#xD;&#xA;Find all permutations of the firsts:&#xD;&#xA;&#xD;&#xA;> abcd   abdc   adbc   adcb   ...&#xD;&#xA;&#xD;&#xA;Then, one by one, insert the repeats into each permutation, following these rules:  &#xD;&#xA;&#xD;&#xA;>  - Start with the repeated character whose original comes first in the firsts  &#xD;&#xA;> e.g. when inserting `abc` into `dbac`, use `b` first&#xD;&#xA;>  - Put the repeat two places or more after the first occurance  &#xD;&#xA;> e.g. when inserting `b` into `dbac`, results are `dbabc` and `dbacb`&#xD;&#xA;>  - Then recurse for each result with the remaining repeated characters&#xD;&#xA;&#xD;&#xA;I've seen this question with one repeated character, where the number of permutations of `abcdefa` where the two a's are kept seperate is given as 3600. However, this way of counting considers `abcdefa` and `abcdefa` to be two distinct permutations, ""because the a's are swapped"". In my opinion, this is just one permutation and its double, and the correct answer is 1800; this is also the result that the algorithm below would return in that case.&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function seperatedPermutations(str) {&#xD;&#xA;        var total = 0, firsts = """", repeats = """";&#xD;&#xA;        for (var i = 0; i < str.length; i++) {&#xD;&#xA;            char = str.charAt(i);&#xD;&#xA;            if (str.indexOf(char) == i) firsts += char; else repeats += char;&#xD;&#xA;        }&#xD;&#xA;        var firsts = stringPermutator(firsts);&#xD;&#xA;        for (var i = 0; i < firsts.length; i++) {&#xD;&#xA;            insertRepeats(firsts[i], repeats);&#xD;&#xA;        }&#xD;&#xA;        alert(total + "" permutations found (see console)"");&#xD;&#xA;&#xD;&#xA;        // RECURSIVE CHARACTER INSERTER&#xD;&#xA;        function insertRepeats(firsts, repeats) {&#xD;&#xA;            var pos = -1;&#xD;&#xA;            for (var i = 0; i < firsts.length, pos < 0; i++) {&#xD;&#xA;                pos = repeats.indexOf(firsts.charAt(i));&#xD;&#xA;            }&#xD;&#xA;            var char = repeats.charAt(pos);&#xD;&#xA;            for (var i = firsts.indexOf(char) + 2; i <= firsts.length; i++) {&#xD;&#xA;                var combi = firsts.slice(0, i) + char + firsts.slice(i);&#xD;&#xA;                if (repeats.length > 1) {&#xD;&#xA;                    insertRepeats(combi, repeats.slice(0, pos) + repeats.slice(pos + 1));&#xD;&#xA;                } else {&#xD;&#xA;                    console.log(combi);&#xD;&#xA;                    ++total;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        // STRING PERMUTATOR (after Filip Nguyen)&#xD;&#xA;        function stringPermutator(str) {&#xD;&#xA;            var fact = [1], permutations = [];&#xD;&#xA;            for (var i = 1; i <= str.length; i++) fact[i] = i * fact[i - 1];&#xD;&#xA;            for (var i = 0; i < fact[str.length]; i++) {&#xD;&#xA;                var perm = """", temp = str, code = i;&#xD;&#xA;                for (var pos = str.length; pos > 0; pos--) {&#xD;&#xA;                    var sel = code / fact[pos - 1];&#xD;&#xA;                    perm += temp.charAt(sel);&#xD;&#xA;                    code = code % fact[pos - 1];&#xD;&#xA;                    temp = temp.substring(0, sel) + temp.substring(sel + 1);&#xD;&#xA;                }&#xD;&#xA;                permutations.push(perm);&#xD;&#xA;            }&#xD;&#xA;            return permutations;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    seperatedPermutations(""abcdac"");&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;";;
98526522;32292973;4907604;5;8833beb7-dd8e-4691-bc93-36971e411a71;2015-08-30 04:04:28.0;"It seemed like a straightforward enough problem, but I spent hours on the wrong track before finally figuring out the correct logic. To find all permutations of a string with one or multiple repeated characters, while keeping identical characters seperated:&#xD;&#xA;&#xD;&#xA;Start with a string like:  &#xD;&#xA;> abcdabc&#xD;&#xA;&#xD;&#xA;Seperate the first occurances from the repeats:  &#xD;&#xA;> firsts: abcd  &#xD;&#xA;> repeats: abc&#xD;&#xA;&#xD;&#xA;Find all permutations of the firsts:&#xD;&#xA;&#xD;&#xA;> abcd   abdc   adbc   adcb   ...&#xD;&#xA;&#xD;&#xA;Then, one by one, insert the repeats into each permutation, following these rules:  &#xD;&#xA;&#xD;&#xA;>  - Start with the repeated character whose original comes first in the firsts  &#xD;&#xA;> e.g. when inserting `abc` into `dbac`, use `b` first&#xD;&#xA;>  - Put the repeat two places or more after the first occurance  &#xD;&#xA;> e.g. when inserting `b` into `dbac`, results are `dbabc` and `dbacb`&#xD;&#xA;>  - Then recurse for each result with the remaining repeated characters&#xD;&#xA;&#xD;&#xA;I've seen this question with one repeated character, where the number of permutations of `abcdefa` where the two a's are kept seperate is given as 3600. However, this way of counting considers `abcdefa` and `abcdefa` to be two distinct permutations, ""because the a's are swapped"". In my opinion, this is just one permutation and its double, and the correct answer is 1800; this is also the result that the algorithm below would return in that case.&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function seperatedPermutations(str) {&#xD;&#xA;        var total = 0, firsts = """", repeats = """";&#xD;&#xA;        for (var i = 0; i < str.length; i++) {&#xD;&#xA;            char = str.charAt(i);&#xD;&#xA;            if (str.indexOf(char) == i) firsts += char; else repeats += char;&#xD;&#xA;        }&#xD;&#xA;        var firsts = stringPermutator(firsts);&#xD;&#xA;        for (var i = 0; i < firsts.length; i++) {&#xD;&#xA;            insertRepeats(firsts[i], repeats);&#xD;&#xA;        }&#xD;&#xA;        alert(total + "" permutations found (see console)"");&#xD;&#xA;&#xD;&#xA;        // RECURSIVE CHARACTER INSERTER&#xD;&#xA;        function insertRepeats(firsts, repeats) {&#xD;&#xA;            var pos = -1;&#xD;&#xA;            for (var i = 0; i < firsts.length, pos < 0; i++) {&#xD;&#xA;                pos = repeats.indexOf(firsts.charAt(i));&#xD;&#xA;            }&#xD;&#xA;            var char = repeats.charAt(pos);&#xD;&#xA;            for (var i = firsts.indexOf(char) + 2; i <= firsts.length; i++) {&#xD;&#xA;                var combi = firsts.slice(0, i) + char + firsts.slice(i);&#xD;&#xA;                if (repeats.length > 1) {&#xD;&#xA;                    insertRepeats(combi, repeats.slice(0, pos) + repeats.slice(pos + 1));&#xD;&#xA;                } else {&#xD;&#xA;                    console.log(combi);&#xD;&#xA;                    ++total;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        // STRING PERMUTATOR (after Filip Nguyen)&#xD;&#xA;        function stringPermutator(str) {&#xD;&#xA;            var fact = [1], permutations = [];&#xD;&#xA;            for (var i = 1; i <= str.length; i++) fact[i] = i * fact[i - 1];&#xD;&#xA;            for (var i = 0; i < fact[str.length]; i++) {&#xD;&#xA;                var perm = """", temp = str, code = i;&#xD;&#xA;                for (var pos = str.length; pos > 0; pos--) {&#xD;&#xA;                    var sel = code / fact[pos - 1];&#xD;&#xA;                    perm += temp.charAt(sel);&#xD;&#xA;                    code = code % fact[pos - 1];&#xD;&#xA;                    temp = temp.substring(0, sel) + temp.substring(sel + 1);&#xD;&#xA;                }&#xD;&#xA;                permutations.push(perm);&#xD;&#xA;            }&#xD;&#xA;            return permutations;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    seperatedPermutations(""abcdac"");&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;";;clarified that it also works for 1 repeated character
98526691;32292973;4907604;5;d60b848c-923e-449e-9250-d491431533f5;2015-08-30 04:14:17.0;"It seemed like a straightforward enough problem, but I spent hours on the wrong track before finally figuring out the correct logic. To find all permutations of a string with one or multiple repeated characters, while keeping identical characters seperated:&#xD;&#xA;&#xD;&#xA;Start with a string like:  &#xD;&#xA;> abcdabc&#xD;&#xA;&#xD;&#xA;Seperate the first occurances from the repeats:  &#xD;&#xA;> firsts: abcd  &#xD;&#xA;> repeats: abc&#xD;&#xA;&#xD;&#xA;Find all permutations of the firsts:&#xD;&#xA;&#xD;&#xA;> abcd   abdc   adbc   adcb   ...&#xD;&#xA;&#xD;&#xA;Then, one by one, insert the repeats into each permutation, following these rules:  &#xD;&#xA;&#xD;&#xA;>  - Start with the repeated character whose original comes first in the firsts  &#xD;&#xA;> e.g. when inserting `abc` into `dbac`, use `b` first&#xD;&#xA;>  - Put the repeat two places or more after the first occurance  &#xD;&#xA;> e.g. when inserting `b` into `dbac`, results are `dbabc` and `dbacb`&#xD;&#xA;>  - Then recurse for each result with the remaining repeated characters&#xD;&#xA;&#xD;&#xA;I've seen this question with one repeated character, where the number of permutations of `abcdefa` where the two a's are kept seperate is given as 3600. However, this way of counting considers `abcdefa` and `abcdefa` to be two distinct permutations, ""because the a's are swapped"". In my opinion, this is just one permutation and its double, and the correct answer is 1800; this is also the result that the algorithm below would return in that case.&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function seperatedPermutations(str) {&#xD;&#xA;        var total = 0, firsts = """", repeats = """";&#xD;&#xA;        for (var i = 0; i < str.length; i++) {&#xD;&#xA;            char = str.charAt(i);&#xD;&#xA;            if (str.indexOf(char) == i) firsts += char; else repeats += char;&#xD;&#xA;        }&#xD;&#xA;        var firsts = stringPermutator(firsts);&#xD;&#xA;        for (var i = 0; i < firsts.length; i++) {&#xD;&#xA;            insertRepeats(firsts[i], repeats);&#xD;&#xA;        }&#xD;&#xA;        alert(total + "" permutations found for "" + str + "" (see console)"");&#xD;&#xA;&#xD;&#xA;        // RECURSIVE CHARACTER INSERTER&#xD;&#xA;        function insertRepeats(firsts, repeats) {&#xD;&#xA;            var pos = -1;&#xD;&#xA;            for (var i = 0; i < firsts.length, pos < 0; i++) {&#xD;&#xA;                pos = repeats.indexOf(firsts.charAt(i));&#xD;&#xA;            }&#xD;&#xA;            var char = repeats.charAt(pos);&#xD;&#xA;            for (var i = firsts.indexOf(char) + 2; i <= firsts.length; i++) {&#xD;&#xA;                var combi = firsts.slice(0, i) + char + firsts.slice(i);&#xD;&#xA;                if (repeats.length > 1) {&#xD;&#xA;                    insertRepeats(combi, repeats.slice(0, pos) + repeats.slice(pos + 1));&#xD;&#xA;                } else {&#xD;&#xA;                    console.log(combi);&#xD;&#xA;                    ++total;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        // STRING PERMUTATOR (after Filip Nguyen)&#xD;&#xA;        function stringPermutator(str) {&#xD;&#xA;            var fact = [1], permutations = [];&#xD;&#xA;            for (var i = 1; i <= str.length; i++) fact[i] = i * fact[i - 1];&#xD;&#xA;            for (var i = 0; i < fact[str.length]; i++) {&#xD;&#xA;                var perm = """", temp = str, code = i;&#xD;&#xA;                for (var pos = str.length; pos > 0; pos--) {&#xD;&#xA;                    var sel = code / fact[pos - 1];&#xD;&#xA;                    perm += temp.charAt(sel);&#xD;&#xA;                    code = code % fact[pos - 1];&#xD;&#xA;                    temp = temp.substring(0, sel) + temp.substring(sel + 1);&#xD;&#xA;                }&#xD;&#xA;                permutations.push(perm);&#xD;&#xA;            }&#xD;&#xA;            return permutations;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    seperatedPermutations(""abcdac"");&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;";;improved display of result in code
98526960;32292973;4907604;5;51b6bb0f-e01a-4c56-9145-4c81d336cab2;2015-08-30 04:28:59.0;"It seemed like a straightforward enough problem, but I spent hours on the wrong track before finally figuring out the correct logic. To find all permutations of a string with one or multiple repeated characters, while keeping identical characters seperated:&#xD;&#xA;&#xD;&#xA;Start with a string like:  &#xD;&#xA;> abcdabc&#xD;&#xA;&#xD;&#xA;Seperate the first occurances from the repeats:  &#xD;&#xA;> firsts: abcd  &#xD;&#xA;> repeats: abc&#xD;&#xA;&#xD;&#xA;Find all permutations of the firsts:&#xD;&#xA;&#xD;&#xA;> abcd   abdc   adbc   adcb   ...&#xD;&#xA;&#xD;&#xA;Then, one by one, insert the repeats into each permutation, following these rules:  &#xD;&#xA;&#xD;&#xA;>  - Start with the repeated character whose original comes first in the firsts  &#xD;&#xA;> e.g. when inserting `abc` into `dbac`, use `b` first&#xD;&#xA;>  - Put the repeat two places or more after the first occurance  &#xD;&#xA;> e.g. when inserting `b` into `dbac`, results are `dbabc` and `dbacb`&#xD;&#xA;>  - Then recurse for each result with the remaining repeated characters&#xD;&#xA;&#xD;&#xA;I've seen this question with one repeated character, where the number of permutations of `abcdefa` where the two a's are kept seperate is given as 3600. However, this way of counting considers `abcdefa` and `abcdefa` to be two distinct permutations, ""because the a's are swapped"". In my opinion, this is just one permutation and its double, and the correct answer is 1800; the algorithm below will return both results.  &#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function seperatedPermutations(str) {&#xD;&#xA;        var total = 0, firsts = """", repeats = """";&#xD;&#xA;        for (var i = 0; i < str.length; i++) {&#xD;&#xA;            char = str.charAt(i);&#xD;&#xA;            if (str.indexOf(char) == i) firsts += char; else repeats += char;&#xD;&#xA;        }&#xD;&#xA;        var firsts = stringPermutator(firsts);&#xD;&#xA;        for (var i = 0; i < firsts.length; i++) {&#xD;&#xA;            insertRepeats(firsts[i], repeats);&#xD;&#xA;        }&#xD;&#xA;        alert(total + "" permutations found for "" + str + "".\\nOr "" + (Math.pow(2, repeats.length) * total) + "", depending on how you count.\\n(see console)"");&#xD;&#xA;&#xD;&#xA;        // RECURSIVE CHARACTER INSERTER&#xD;&#xA;        function insertRepeats(firsts, repeats) {&#xD;&#xA;            var pos = -1;&#xD;&#xA;            for (var i = 0; i < firsts.length, pos < 0; i++) {&#xD;&#xA;                pos = repeats.indexOf(firsts.charAt(i));&#xD;&#xA;            }&#xD;&#xA;            var char = repeats.charAt(pos);&#xD;&#xA;            for (var i = firsts.indexOf(char) + 2; i <= firsts.length; i++) {&#xD;&#xA;                var combi = firsts.slice(0, i) + char + firsts.slice(i);&#xD;&#xA;                if (repeats.length > 1) {&#xD;&#xA;                    insertRepeats(combi, repeats.slice(0, pos) + repeats.slice(pos + 1));&#xD;&#xA;                } else {&#xD;&#xA;                    console.log(combi);&#xD;&#xA;                    ++total;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        // STRING PERMUTATOR (after Filip Nguyen)&#xD;&#xA;        function stringPermutator(str) {&#xD;&#xA;            var fact = [1], permutations = [];&#xD;&#xA;            for (var i = 1; i <= str.length; i++) fact[i] = i * fact[i - 1];&#xD;&#xA;            for (var i = 0; i < fact[str.length]; i++) {&#xD;&#xA;                var perm = """", temp = str, code = i;&#xD;&#xA;                for (var pos = str.length; pos > 0; pos--) {&#xD;&#xA;                    var sel = code / fact[pos - 1];&#xD;&#xA;                    perm += temp.charAt(sel);&#xD;&#xA;                    code = code % fact[pos - 1];&#xD;&#xA;                    temp = temp.substring(0, sel) + temp.substring(sel + 1);&#xD;&#xA;                }&#xD;&#xA;                permutations.push(perm);&#xD;&#xA;            }&#xD;&#xA;            return permutations;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    seperatedPermutations(""abfdefa"");&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;";;added count for identical permutations to code
98530986;32292973;4907604;5;ea07fe0c-4f7b-4b2d-88b8-2fb98ab4b741;2015-08-30 07:23:27.0;"It seemed like a straightforward enough problem, but I spent hours on the wrong track before finally figuring out the correct logic. To find all permutations of a string with one or multiple repeated characters, while keeping identical characters seperated:&#xD;&#xA;&#xD;&#xA;Start with a string like:  &#xD;&#xA;> abcdabc&#xD;&#xA;&#xD;&#xA;Seperate the first occurances from the repeats:  &#xD;&#xA;> firsts: abcd  &#xD;&#xA;> repeats: abc&#xD;&#xA;&#xD;&#xA;Find all permutations of the firsts:&#xD;&#xA;&#xD;&#xA;> abcd   abdc   adbc   adcb   ...&#xD;&#xA;&#xD;&#xA;Then, one by one, insert the repeats into each permutation, following these rules:  &#xD;&#xA;&#xD;&#xA;>  - Start with the repeated character whose original comes first in the firsts  &#xD;&#xA;> e.g. when inserting `abc` into `dbac`, use `b` first&#xD;&#xA;>  - Put the repeat two places or more after the first occurance  &#xD;&#xA;> e.g. when inserting `b` into `dbac`, results are `dbabc` and `dbacb`&#xD;&#xA;>  - Then recurse for each result with the remaining repeated characters&#xD;&#xA;&#xD;&#xA;A calculation based on this logic of the number of results for a string like `abfdefa`, with 5 ""first"" characters and 2 repeated characters (A and F) , would be:&#xD;&#xA;&#xD;&#xA;>  - The 5 ""first"" characters create 5! = 120 permutations  &#xD;&#xA;>  - Each character can be in 5 positions, with 24 permutations each:  &#xD;&#xA;`A****` (24)  &#xD;&#xA;`*A***` (24)  &#xD;&#xA;`**A**` (24)  &#xD;&#xA;`***A*` (24)  &#xD;&#xA;`****A` (24)  &#xD;&#xA;>  - For each of these positions, the repeat character has to come at least 2 places after its ""first"", so that makes 4, 3, 2 and 1 places respectively (for the last position, a repeat is impossible). With the repeated character inserted, this makes 240 permutations:  &#xD;&#xA;`A*****` (24 * 4)  &#xD;&#xA;`*A****` (24 * 3)  &#xD;&#xA;`**A***` (24 * 2)  &#xD;&#xA;`***A**` (24 * 1)  &#xD;&#xA;>  - In each of these cases, the second character that will be repeated could be in 6 places, and the repeat character would have 5, 4, 3, 2, and 1 place to go. However, the second (F) character cannot be in the same place as the first (A) character, so one of the combinations is always impossible:  &#xD;&#xA;`A******` (24 * 4 * (0+4+3+2+1)) = 24 * 4 * 10 = 960  &#xD;&#xA;`*A*****` (24 * 3 * (5+0+3+2+1)) = 24 * 3 * 11 = 792  &#xD;&#xA;`**A****` (24 * 2 * (5+4+0+2+1)) = 24 * 2 * 12 = 576  &#xD;&#xA;`***A***` (24 * 1 * (5+4+3+0+1)) = 24 * 1 * 13 = 312  &#xD;&#xA;>  - And 960 + 792 + 576 + 312 = 2640, the expected result.&#xD;&#xA;&#xD;&#xA;I've seen this question with one repeated character, where the number of permutations of `abcdefa` where the two a's are kept seperate is given as 3600. However, this way of counting considers `abcdefa` and `abcdefa` to be two distinct permutations, ""because the a's are swapped"". In my opinion, this is just one permutation and its double, and the correct answer is 1800; the algorithm below will return both results.  &#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function seperatedPermutations(str) {&#xD;&#xA;        var total = 0, firsts = """", repeats = """";&#xD;&#xA;        for (var i = 0; i < str.length; i++) {&#xD;&#xA;            char = str.charAt(i);&#xD;&#xA;            if (str.indexOf(char) == i) firsts += char; else repeats += char;&#xD;&#xA;        }&#xD;&#xA;        var firsts = stringPermutator(firsts);&#xD;&#xA;        for (var i = 0; i < firsts.length; i++) {&#xD;&#xA;            insertRepeats(firsts[i], repeats);&#xD;&#xA;        }&#xD;&#xA;        alert(total + "" permutations found for "" + str + "".\\nOr "" + (Math.pow(2, repeats.length) * total) + "", depending on how you count.\\n(see console)"");&#xD;&#xA;&#xD;&#xA;        // RECURSIVE CHARACTER INSERTER&#xD;&#xA;        function insertRepeats(firsts, repeats) {&#xD;&#xA;            var pos = -1;&#xD;&#xA;            for (var i = 0; i < firsts.length, pos < 0; i++) {&#xD;&#xA;                pos = repeats.indexOf(firsts.charAt(i));&#xD;&#xA;            }&#xD;&#xA;            var char = repeats.charAt(pos);&#xD;&#xA;            for (var i = firsts.indexOf(char) + 2; i <= firsts.length; i++) {&#xD;&#xA;                var combi = firsts.slice(0, i) + char + firsts.slice(i);&#xD;&#xA;                if (repeats.length > 1) {&#xD;&#xA;                    insertRepeats(combi, repeats.slice(0, pos) + repeats.slice(pos + 1));&#xD;&#xA;                } else {&#xD;&#xA;                    console.log(combi);&#xD;&#xA;                    ++total;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        // STRING PERMUTATOR (after Filip Nguyen)&#xD;&#xA;        function stringPermutator(str) {&#xD;&#xA;            var fact = [1], permutations = [];&#xD;&#xA;            for (var i = 1; i <= str.length; i++) fact[i] = i * fact[i - 1];&#xD;&#xA;            for (var i = 0; i < fact[str.length]; i++) {&#xD;&#xA;                var perm = """", temp = str, code = i;&#xD;&#xA;                for (var pos = str.length; pos > 0; pos--) {&#xD;&#xA;                    var sel = code / fact[pos - 1];&#xD;&#xA;                    perm += temp.charAt(sel);&#xD;&#xA;                    code = code % fact[pos - 1];&#xD;&#xA;                    temp = temp.substring(0, sel) + temp.substring(sel + 1);&#xD;&#xA;                }&#xD;&#xA;                permutations.push(perm);&#xD;&#xA;            }&#xD;&#xA;            return permutations;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    seperatedPermutations(""abfdefa"");&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;";;added calculation of the number of permutations
98532762;32292973;4907604;5;dc3ae268-a5a9-4954-9a48-a3715ea5003f;2015-08-30 08:29:08.0;"It seemed like a straightforward enough problem, but I spent hours on the wrong track before finally figuring out the correct logic. To find all permutations of a string with one or multiple repeated characters, while keeping identical characters seperated:&#xD;&#xA;&#xD;&#xA;Start with a string like:  &#xD;&#xA;> abcdabc&#xD;&#xA;&#xD;&#xA;Seperate the first occurances from the repeats:  &#xD;&#xA;> firsts: abcd  &#xD;&#xA;> repeats: abc&#xD;&#xA;&#xD;&#xA;Find all permutations of the firsts:&#xD;&#xA;&#xD;&#xA;> abcd   abdc   adbc   adcb   ...&#xD;&#xA;&#xD;&#xA;Then, one by one, insert the repeats into each permutation, following these rules:  &#xD;&#xA;&#xD;&#xA;>  - Start with the repeated character whose original comes first in the firsts  &#xD;&#xA;> e.g. when inserting `abc` into `dbac`, use `b` first&#xD;&#xA;>  - Put the repeat two places or more after the first occurance  &#xD;&#xA;> e.g. when inserting `b` into `dbac`, results are `dbabc` and `dbacb`&#xD;&#xA;>  - Then recurse for each result with the remaining repeated characters&#xD;&#xA;&#xD;&#xA;I've seen this question with one repeated character, where the number of permutations of `abcdefa` where the two a's are kept seperate is given as 3600. However, this way of counting considers `abcdefa` and `abcdefa` to be two distinct permutations, ""because the a's are swapped"". In my opinion, this is just one permutation and its double, and the correct answer is 1800; the algorithm below will return both results.  &#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function seperatedPermutations(str) {&#xD;&#xA;        var total = 0, firsts = """", repeats = """";&#xD;&#xA;        for (var i = 0; i < str.length; i++) {&#xD;&#xA;            char = str.charAt(i);&#xD;&#xA;            if (str.indexOf(char) == i) firsts += char; else repeats += char;&#xD;&#xA;        }&#xD;&#xA;        var firsts = stringPermutator(firsts);&#xD;&#xA;        for (var i = 0; i < firsts.length; i++) {&#xD;&#xA;            insertRepeats(firsts[i], repeats);&#xD;&#xA;        }&#xD;&#xA;        alert(total + "" permutations found for "" + str + "".\\nOr "" + (Math.pow(2, repeats.length) * total) + "", depending on how you count.\\n(see console)"");&#xD;&#xA;&#xD;&#xA;        // RECURSIVE CHARACTER INSERTER&#xD;&#xA;        function insertRepeats(firsts, repeats) {&#xD;&#xA;            var pos = -1;&#xD;&#xA;            for (var i = 0; i < firsts.length, pos < 0; i++) {&#xD;&#xA;                pos = repeats.indexOf(firsts.charAt(i));&#xD;&#xA;            }&#xD;&#xA;            var char = repeats.charAt(pos);&#xD;&#xA;            for (var i = firsts.indexOf(char) + 2; i <= firsts.length; i++) {&#xD;&#xA;                var combi = firsts.slice(0, i) + char + firsts.slice(i);&#xD;&#xA;                if (repeats.length > 1) {&#xD;&#xA;                    insertRepeats(combi, repeats.slice(0, pos) + repeats.slice(pos + 1));&#xD;&#xA;                } else {&#xD;&#xA;                    console.log(combi);&#xD;&#xA;                    ++total;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        // STRING PERMUTATOR (after Filip Nguyen)&#xD;&#xA;        function stringPermutator(str) {&#xD;&#xA;            var fact = [1], permutations = [];&#xD;&#xA;            for (var i = 1; i <= str.length; i++) fact[i] = i * fact[i - 1];&#xD;&#xA;            for (var i = 0; i < fact[str.length]; i++) {&#xD;&#xA;                var perm = """", temp = str, code = i;&#xD;&#xA;                for (var pos = str.length; pos > 0; pos--) {&#xD;&#xA;                    var sel = code / fact[pos - 1];&#xD;&#xA;                    perm += temp.charAt(sel);&#xD;&#xA;                    code = code % fact[pos - 1];&#xD;&#xA;                    temp = temp.substring(0, sel) + temp.substring(sel + 1);&#xD;&#xA;                }&#xD;&#xA;                permutations.push(perm);&#xD;&#xA;            }&#xD;&#xA;            return permutations;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    seperatedPermutations(""abfdefa"");&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;A calculation based on this logic of the number of results for a string like `abfdefa`, with 5 ""first"" characters and 2 repeated characters (A and F) , would be:&#xD;&#xA;&#xD;&#xA;>  - The 5 ""first"" characters create 5! = 120 permutations  &#xD;&#xA;>  - Each character can be in 5 positions, with 24 permutations each:  &#xD;&#xA;`A****` (24)  &#xD;&#xA;`*A***` (24)  &#xD;&#xA;`**A**` (24)  &#xD;&#xA;`***A*` (24)  &#xD;&#xA;`****A` (24)  &#xD;&#xA;>  - For each of these positions, the repeat character has to come at least 2 places after its ""first"", so that makes 4, 3, 2 and 1 places respectively (for the last position, a repeat is impossible). With the repeated character inserted, this makes 240 permutations:  &#xD;&#xA;`A*****` (24 * 4)  &#xD;&#xA;`*A****` (24 * 3)  &#xD;&#xA;`**A***` (24 * 2)  &#xD;&#xA;`***A**` (24 * 1)  &#xD;&#xA;>  - In each of these cases, the second character that will be repeated could be in 6 places, and the repeat character would have 5, 4, 3, 2, and 1 place to go. However, the second (F) character cannot be in the same place as the first (A) character, so one of the combinations is always impossible:  &#xD;&#xA;`A******` (24 * 4 * (0+4+3+2+1)) = 24 * 4 * 10 = 960  &#xD;&#xA;`*A*****` (24 * 3 * (5+0+3+2+1)) = 24 * 3 * 11 = 792  &#xD;&#xA;`**A****` (24 * 2 * (5+4+0+2+1)) = 24 * 2 * 12 = 576  &#xD;&#xA;`***A***` (24 * 1 * (5+4+3+0+1)) = 24 * 1 * 13 = 312  &#xD;&#xA;>  - And 960 + 792 + 576 + 312 = 2640, the expected result.&#xD;&#xA;&#xD;&#xA;Or, for any string like `abfdefa` with 2 repeats:  &#xD;&#xA;[![formula for 2 repeats][1]][1]  &#xD;&#xA;where F is the number of ""firsts"".&#xD;&#xA;&#xD;&#xA;To calculate the total without identical permutations (which I think makes more sense) you'd divide this number by 2^R, where R is the number or repeats.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/qxviT.png";;added calculation of total formula
98544064;32292973;4907604;5;a371dca1-83d5-405e-86e4-4d23adafa7c6;2015-08-30 14:20:59.0;"It seemed like a straightforward enough problem, but I spent hours on the wrong track before finally figuring out the correct logic. To find all permutations of a string with one or multiple repeated characters, while keeping identical characters seperated:&#xD;&#xA;&#xD;&#xA;Start with a string like:  &#xD;&#xA;> abcdabc&#xD;&#xA;&#xD;&#xA;Seperate the first occurances from the repeats:  &#xD;&#xA;> firsts: abcd  &#xD;&#xA;> repeats: abc&#xD;&#xA;&#xD;&#xA;Find all permutations of the firsts:&#xD;&#xA;&#xD;&#xA;> abcd   abdc   adbc   adcb   ...&#xD;&#xA;&#xD;&#xA;Then, one by one, insert the repeats into each permutation, following these rules:  &#xD;&#xA;&#xD;&#xA;>  - Start with the repeated character whose original comes first in the firsts  &#xD;&#xA;> e.g. when inserting `abc` into `dbac`, use `b` first&#xD;&#xA;>  - Put the repeat two places or more after the first occurance  &#xD;&#xA;> e.g. when inserting `b` into `dbac`, results are `dbabc` and `dbacb`&#xD;&#xA;>  - Then recurse for each result with the remaining repeated characters&#xD;&#xA;&#xD;&#xA;I've seen this question with one repeated character, where the number of permutations of `abcdefa` where the two a's are kept seperate is given as 3600. However, this way of counting considers `abcdefa` and `abcdefa` to be two distinct permutations, ""because the a's are swapped"". In my opinion, this is just one permutation and its double, and the correct answer is 1800; the algorithm below will return both results.  &#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function seperatedPermutations(str) {&#xD;&#xA;        var total = 0, firsts = """", repeats = """";&#xD;&#xA;        for (var i = 0; i < str.length; i++) {&#xD;&#xA;            char = str.charAt(i);&#xD;&#xA;            if (str.indexOf(char) == i) firsts += char; else repeats += char;&#xD;&#xA;        }&#xD;&#xA;        var firsts = stringPermutator(firsts);&#xD;&#xA;        for (var i = 0; i < firsts.length; i++) {&#xD;&#xA;            insertRepeats(firsts[i], repeats);&#xD;&#xA;        }&#xD;&#xA;        alert(""Permutations of \\"""" + str + ""\\""\\ntotal: "" + (Math.pow(2, repeats.length) * total) + "", unique: "" + total + ""\\n(see console)"");&#xD;&#xA;&#xD;&#xA;        // RECURSIVE CHARACTER INSERTER&#xD;&#xA;        function insertRepeats(firsts, repeats) {&#xD;&#xA;            var pos = -1;&#xD;&#xA;            for (var i = 0; i < firsts.length, pos < 0; i++) {&#xD;&#xA;                pos = repeats.indexOf(firsts.charAt(i));&#xD;&#xA;            }&#xD;&#xA;            var char = repeats.charAt(pos);&#xD;&#xA;            for (var i = firsts.indexOf(char) + 2; i <= firsts.length; i++) {&#xD;&#xA;                var combi = firsts.slice(0, i) + char + firsts.slice(i);&#xD;&#xA;                if (repeats.length > 1) {&#xD;&#xA;                    insertRepeats(combi, repeats.slice(0, pos) + repeats.slice(pos + 1));&#xD;&#xA;                } else {&#xD;&#xA;                    console.log(combi);&#xD;&#xA;                    ++total;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        // STRING PERMUTATOR (after Filip Nguyen)&#xD;&#xA;        function stringPermutator(str) {&#xD;&#xA;            var fact = [1], permutations = [];&#xD;&#xA;            for (var i = 1; i <= str.length; i++) fact[i] = i * fact[i - 1];&#xD;&#xA;            for (var i = 0; i < fact[str.length]; i++) {&#xD;&#xA;                var perm = """", temp = str, code = i;&#xD;&#xA;                for (var pos = str.length; pos > 0; pos--) {&#xD;&#xA;                    var sel = code / fact[pos - 1];&#xD;&#xA;                    perm += temp.charAt(sel);&#xD;&#xA;                    code = code % fact[pos - 1];&#xD;&#xA;                    temp = temp.substring(0, sel) + temp.substring(sel + 1);&#xD;&#xA;                }&#xD;&#xA;                permutations.push(perm);&#xD;&#xA;            }&#xD;&#xA;            return permutations;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    seperatedPermutations(""abfdefa"");&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;A calculation based on this logic of the number of results for a string like `abfdefa`, with 5 ""first"" characters and 2 repeated characters (A and F) , would be:&#xD;&#xA;&#xD;&#xA;>  - The 5 ""first"" characters create 5! = 120 permutations  &#xD;&#xA;>  - Each character can be in 5 positions, with 24 permutations each:  &#xD;&#xA;`A****` (24)  &#xD;&#xA;`*A***` (24)  &#xD;&#xA;`**A**` (24)  &#xD;&#xA;`***A*` (24)  &#xD;&#xA;`****A` (24)  &#xD;&#xA;>  - For each of these positions, the repeat character has to come at least 2 places after its ""first"", so that makes 4, 3, 2 and 1 places respectively (for the last position, a repeat is impossible). With the repeated character inserted, this makes 240 permutations:  &#xD;&#xA;`A*****` (24 * 4)  &#xD;&#xA;`*A****` (24 * 3)  &#xD;&#xA;`**A***` (24 * 2)  &#xD;&#xA;`***A**` (24 * 1)  &#xD;&#xA;>  - In each of these cases, the second character that will be repeated could be in 6 places, and the repeat character would have 5, 4, 3, 2, and 1 place to go. However, the second (F) character cannot be in the same place as the first (A) character, so one of the combinations is always impossible:  &#xD;&#xA;`A******` (24 * 4 * (0+4+3+2+1)) = 24 * 4 * 10 = 960  &#xD;&#xA;`*A*****` (24 * 3 * (5+0+3+2+1)) = 24 * 3 * 11 = 792  &#xD;&#xA;`**A****` (24 * 2 * (5+4+0+2+1)) = 24 * 2 * 12 = 576  &#xD;&#xA;`***A***` (24 * 1 * (5+4+3+0+1)) = 24 * 1 * 13 = 312  &#xD;&#xA;>  - And 960 + 792 + 576 + 312 = 2640, the expected result.&#xD;&#xA;&#xD;&#xA;Or, for any string like `abfdefa` with 2 repeats:  &#xD;&#xA;[![formula for 2 repeats][1]][1]  &#xD;&#xA;where F is the number of ""firsts"".&#xD;&#xA;&#xD;&#xA;To calculate the total without identical permutations (which I think makes more sense) you'd divide this number by 2^R, where R is the number or repeats.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/qxviT.png";;improved result reporting in code
110729840;32292973;4907604;5;4bcb2306-ad7e-4fbb-854c-1da9d0c58f2a;2016-02-12 20:58:56.0;"It seemed like a straightforward enough problem, but I spent hours on the wrong track before finally figuring out the correct logic. To find all permutations of a string with one or multiple repeated characters, while keeping identical characters seperated:&#xD;&#xA;&#xD;&#xA;Start with a string like:  &#xD;&#xA;> abcdabc&#xD;&#xA;&#xD;&#xA;Seperate the first occurances from the repeats:  &#xD;&#xA;> firsts: abcd  &#xD;&#xA;> repeats: abc&#xD;&#xA;&#xD;&#xA;Find all permutations of the firsts:&#xD;&#xA;&#xD;&#xA;> abcd   abdc   adbc   adcb   ...&#xD;&#xA;&#xD;&#xA;Then, one by one, insert the repeats into each permutation, following these rules:  &#xD;&#xA;&#xD;&#xA;>  - Start with the repeated character whose original comes first in the firsts  &#xD;&#xA;> e.g. when inserting `abc` into `dbac`, use `b` first&#xD;&#xA;>  - Put the repeat two places or more after the first occurance  &#xD;&#xA;> e.g. when inserting `b` into `dbac`, results are `dbabc` and `dbacb`&#xD;&#xA;>  - Then recurse for each result with the remaining repeated characters&#xD;&#xA;&#xD;&#xA;I've seen this question with one repeated character, where the number of permutations of `abcdefa` where the two a's are kept seperate is given as 3600. However, this way of counting considers `abcdefa` and `abcdefa` to be two distinct permutations, ""because the a's are swapped"". In my opinion, this is just one permutation and its double, and the correct answer is 1800; the algorithm below will return both results.  &#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function seperatedPermutations(str) {&#xD;&#xA;        var total = 0, firsts = """", repeats = """";&#xD;&#xA;        for (var i = 0; i < str.length; i++) {&#xD;&#xA;            char = str.charAt(i);&#xD;&#xA;            if (str.indexOf(char) == i) firsts += char; else repeats += char;&#xD;&#xA;        }&#xD;&#xA;        var firsts = stringPermutator(firsts);&#xD;&#xA;        for (var i = 0; i < firsts.length; i++) {&#xD;&#xA;            insertRepeats(firsts[i], repeats);&#xD;&#xA;        }&#xD;&#xA;        alert(""Permutations of \\"""" + str + ""\\""\\ntotal: "" + (Math.pow(2, repeats.length) * total) + "", unique: "" + total);&#xD;&#xA;&#xD;&#xA;        // RECURSIVE CHARACTER INSERTER&#xD;&#xA;        function insertRepeats(firsts, repeats) {&#xD;&#xA;            var pos = -1;&#xD;&#xA;            for (var i = 0; i < firsts.length, pos < 0; i++) {&#xD;&#xA;                pos = repeats.indexOf(firsts.charAt(i));&#xD;&#xA;            }&#xD;&#xA;            var char = repeats.charAt(pos);&#xD;&#xA;            for (var i = firsts.indexOf(char) + 2; i <= firsts.length; i++) {&#xD;&#xA;                var combi = firsts.slice(0, i) + char + firsts.slice(i);&#xD;&#xA;                if (repeats.length > 1) {&#xD;&#xA;                    insertRepeats(combi, repeats.slice(0, pos) + repeats.slice(pos + 1));&#xD;&#xA;                } else {&#xD;&#xA;                    document.write(combi + ""<BR>"");&#xD;&#xA;                    ++total;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        // STRING PERMUTATOR (after Filip Nguyen)&#xD;&#xA;        function stringPermutator(str) {&#xD;&#xA;            var fact = [1], permutations = [];&#xD;&#xA;            for (var i = 1; i <= str.length; i++) fact[i] = i * fact[i - 1];&#xD;&#xA;            for (var i = 0; i < fact[str.length]; i++) {&#xD;&#xA;                var perm = """", temp = str, code = i;&#xD;&#xA;                for (var pos = str.length; pos > 0; pos--) {&#xD;&#xA;                    var sel = code / fact[pos - 1];&#xD;&#xA;                    perm += temp.charAt(sel);&#xD;&#xA;                    code = code % fact[pos - 1];&#xD;&#xA;                    temp = temp.substring(0, sel) + temp.substring(sel + 1);&#xD;&#xA;                }&#xD;&#xA;                permutations.push(perm);&#xD;&#xA;            }&#xD;&#xA;            return permutations;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    seperatedPermutations(""abfdefa"");&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;A calculation based on this logic of the number of results for a string like `abfdefa`, with 5 ""first"" characters and 2 repeated characters (A and F) , would be:&#xD;&#xA;&#xD;&#xA;>  - The 5 ""first"" characters create 5! = 120 permutations  &#xD;&#xA;>  - Each character can be in 5 positions, with 24 permutations each:  &#xD;&#xA;`A****` (24)  &#xD;&#xA;`*A***` (24)  &#xD;&#xA;`**A**` (24)  &#xD;&#xA;`***A*` (24)  &#xD;&#xA;`****A` (24)  &#xD;&#xA;>  - For each of these positions, the repeat character has to come at least 2 places after its ""first"", so that makes 4, 3, 2 and 1 places respectively (for the last position, a repeat is impossible). With the repeated character inserted, this makes 240 permutations:  &#xD;&#xA;`A*****` (24 * 4)  &#xD;&#xA;`*A****` (24 * 3)  &#xD;&#xA;`**A***` (24 * 2)  &#xD;&#xA;`***A**` (24 * 1)  &#xD;&#xA;>  - In each of these cases, the second character that will be repeated could be in 6 places, and the repeat character would have 5, 4, 3, 2, and 1 place to go. However, the second (F) character cannot be in the same place as the first (A) character, so one of the combinations is always impossible:  &#xD;&#xA;`A******` (24 * 4 * (0+4+3+2+1)) = 24 * 4 * 10 = 960  &#xD;&#xA;`*A*****` (24 * 3 * (5+0+3+2+1)) = 24 * 3 * 11 = 792  &#xD;&#xA;`**A****` (24 * 2 * (5+4+0+2+1)) = 24 * 2 * 12 = 576  &#xD;&#xA;`***A***` (24 * 1 * (5+4+3+0+1)) = 24 * 1 * 13 = 312  &#xD;&#xA;>  - And 960 + 792 + 576 + 312 = 2640, the expected result.&#xD;&#xA;&#xD;&#xA;Or, for any string like `abfdefa` with 2 repeats:  &#xD;&#xA;[![formula for 2 repeats][1]][1]  &#xD;&#xA;where F is the number of ""firsts"".&#xD;&#xA;&#xD;&#xA;To calculate the total without identical permutations (which I think makes more sense) you'd divide this number by 2^R, where R is the number or repeats.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/qxviT.png";;changed console output to html output
