Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
88794166;29812009;4769313;2;a18857a0-5aa8-427f-9689-451772f9ca9d;2015-04-23 01:32:06.0;"I'm searching for an algorithm to multiply two integer number that be better than that indicated below. Have you a good idea about that? (The MCU where this code runs has not mul/div operator)&#xD;&#xA;&#xD;&#xA;    uint16_t umul16_(uint16_t a, uint16_t b)&#xD;&#xA;    {&#xD;&#xA;        uint16_t res=0;&#xD;&#xA;    &#xD;&#xA;        while (b) {&#xD;&#xA;            if ( (b & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;            b>>=1;&#xD;&#xA;            a+=a;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This algorithm, when compiled for AT Tiny 85/84 using the avr-gcc compiler, is almost identical to the algorithm __mulhi3 that the avr-gcc generates.&#xD;&#xA;&#xD;&#xA;avr-gcc algorithm:&#xD;&#xA;&#xD;&#xA;    00000106 <__mulhi3>:&#xD;&#xA;     106:	00 24       	eor	r0, r0&#xD;&#xA;     108:	55 27       	eor	r21, r21&#xD;&#xA;     10a:	04 c0       	rjmp	.+8      	; 0x114 <__mulhi3+0xe>&#xD;&#xA;     10c:	08 0e       	add	r0, r24&#xD;&#xA;     10e:	59 1f       	adc	r21, r25&#xD;&#xA;     110:	88 0f       	add	r24, r24&#xD;&#xA;     112:	99 1f       	adc	r25, r25&#xD;&#xA;     114:	00 97       	sbiw	r24, 0x00	; 0&#xD;&#xA;     116:	29 f0       	breq	.+10     	; 0x122 <__mulhi3+0x1c>&#xD;&#xA;     118:	76 95       	lsr	r23&#xD;&#xA;     11a:	67 95       	ror	r22&#xD;&#xA;     11c:	b8 f3       	brcs	.-18     	; 0x10c <__mulhi3+0x6>&#xD;&#xA;     11e:	71 05       	cpc	r23, r1&#xD;&#xA;     120:	b9 f7       	brne	.-18     	; 0x110 <__mulhi3+0xa>&#xD;&#xA;     122:	80 2d       	mov	r24, r0&#xD;&#xA;     124:	95 2f       	mov	r25, r21&#xD;&#xA;     126:	08 95       	ret&#xD;&#xA;&#xD;&#xA;umul16_ algorithm:&#xD;&#xA;&#xD;&#xA;    00000044 <umul16_>:&#xD;&#xA;      44:	20 e0       	ldi	r18, 0x00	; 0&#xD;&#xA;      46:	30 e0       	ldi	r19, 0x00	; 0&#xD;&#xA;      48:	61 15       	cp	r22, r1&#xD;&#xA;      4a:	71 05       	cpc	r23, r1&#xD;&#xA;      4c:	49 f0       	breq	.+18     	; 0x60 <umul16_+0x1c>&#xD;&#xA;      4e:	60 ff       	sbrs	r22, 0&#xD;&#xA;      50:	02 c0       	rjmp	.+4      	; 0x56 <umul16_+0x12>&#xD;&#xA;      52:	28 0f       	add	r18, r24&#xD;&#xA;      54:	39 1f       	adc	r19, r25&#xD;&#xA;      56:	76 95       	lsr	r23&#xD;&#xA;      58:	67 95       	ror	r22&#xD;&#xA;      5a:	88 0f       	add	r24, r24&#xD;&#xA;      5c:	99 1f       	adc	r25, r25&#xD;&#xA;      5e:	f4 cf       	rjmp	.-24     	; 0x48 <umul16_+0x4>&#xD;&#xA;      60:	c9 01       	movw	r24, r18&#xD;&#xA;      62:	08 95       	ret&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;
88795838;29812009;4769313;5;134410cf-d6c8-4662-a57a-73857b94370d;2015-04-23 02:18:43.0;"I'm searching for an algorithm to multiply two integer number that be better than that indicated below. Have you a good idea about that? (The MCU - AT Tiny 84/85 or similar - where this code runs has not mul/div operator)&#xD;&#xA;&#xD;&#xA;    uint16_t umul16_(uint16_t a, uint16_t b)&#xD;&#xA;    {&#xD;&#xA;        uint16_t res=0;&#xD;&#xA;    &#xD;&#xA;        while (b) {&#xD;&#xA;            if ( (b & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;            b>>=1;&#xD;&#xA;            a+=a;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This algorithm, when compiled for AT Tiny 85/84 using the avr-gcc compiler, is almost identical to the algorithm __mulhi3 that the avr-gcc generates.&#xD;&#xA;&#xD;&#xA;avr-gcc algorithm:&#xD;&#xA;&#xD;&#xA;    00000106 <__mulhi3>:&#xD;&#xA;     106:	00 24       	eor	r0, r0&#xD;&#xA;     108:	55 27       	eor	r21, r21&#xD;&#xA;     10a:	04 c0       	rjmp	.+8      	; 0x114 <__mulhi3+0xe>&#xD;&#xA;     10c:	08 0e       	add	r0, r24&#xD;&#xA;     10e:	59 1f       	adc	r21, r25&#xD;&#xA;     110:	88 0f       	add	r24, r24&#xD;&#xA;     112:	99 1f       	adc	r25, r25&#xD;&#xA;     114:	00 97       	sbiw	r24, 0x00	; 0&#xD;&#xA;     116:	29 f0       	breq	.+10     	; 0x122 <__mulhi3+0x1c>&#xD;&#xA;     118:	76 95       	lsr	r23&#xD;&#xA;     11a:	67 95       	ror	r22&#xD;&#xA;     11c:	b8 f3       	brcs	.-18     	; 0x10c <__mulhi3+0x6>&#xD;&#xA;     11e:	71 05       	cpc	r23, r1&#xD;&#xA;     120:	b9 f7       	brne	.-18     	; 0x110 <__mulhi3+0xa>&#xD;&#xA;     122:	80 2d       	mov	r24, r0&#xD;&#xA;     124:	95 2f       	mov	r25, r21&#xD;&#xA;     126:	08 95       	ret&#xD;&#xA;&#xD;&#xA;umul16_ algorithm:&#xD;&#xA;&#xD;&#xA;    00000044 <umul16_>:&#xD;&#xA;      44:	20 e0       	ldi	r18, 0x00	; 0&#xD;&#xA;      46:	30 e0       	ldi	r19, 0x00	; 0&#xD;&#xA;      48:	61 15       	cp	r22, r1&#xD;&#xA;      4a:	71 05       	cpc	r23, r1&#xD;&#xA;      4c:	49 f0       	breq	.+18     	; 0x60 <umul16_+0x1c>&#xD;&#xA;      4e:	60 ff       	sbrs	r22, 0&#xD;&#xA;      50:	02 c0       	rjmp	.+4      	; 0x56 <umul16_+0x12>&#xD;&#xA;      52:	28 0f       	add	r18, r24&#xD;&#xA;      54:	39 1f       	adc	r19, r25&#xD;&#xA;      56:	76 95       	lsr	r23&#xD;&#xA;      58:	67 95       	ror	r22&#xD;&#xA;      5a:	88 0f       	add	r24, r24&#xD;&#xA;      5c:	99 1f       	adc	r25, r25&#xD;&#xA;      5e:	f4 cf       	rjmp	.-24     	; 0x48 <umul16_+0x4>&#xD;&#xA;      60:	c9 01       	movw	r24, r18&#xD;&#xA;      62:	08 95       	ret&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added 29 characters in body
88799858;29812009;4769313;5;0d216ff1-654e-46bd-a30a-4c47861ac566;2015-04-23 04:03:44.0;"I'm searching for an algorithm to multiply two integer numbers that be better than that indicated below. Have you a good idea about that? (The MCU - AT Tiny 84/85 or similar - where this code runs has not mul/div operator)&#xD;&#xA;&#xD;&#xA;    uint16_t umul16_(uint16_t a, uint16_t b)&#xD;&#xA;    {&#xD;&#xA;        uint16_t res=0;&#xD;&#xA;    &#xD;&#xA;        while (b) {&#xD;&#xA;            if ( (b & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;            b>>=1;&#xD;&#xA;            a+=a;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This algorithm, when compiled for AT Tiny 85/84 using the avr-gcc compiler, is almost identical to the algorithm __mulhi3 that the avr-gcc generates.&#xD;&#xA;&#xD;&#xA;avr-gcc algorithm:&#xD;&#xA;&#xD;&#xA;    00000106 <__mulhi3>:&#xD;&#xA;     106:	00 24       	eor	r0, r0&#xD;&#xA;     108:	55 27       	eor	r21, r21&#xD;&#xA;     10a:	04 c0       	rjmp	.+8      	; 0x114 <__mulhi3+0xe>&#xD;&#xA;     10c:	08 0e       	add	r0, r24&#xD;&#xA;     10e:	59 1f       	adc	r21, r25&#xD;&#xA;     110:	88 0f       	add	r24, r24&#xD;&#xA;     112:	99 1f       	adc	r25, r25&#xD;&#xA;     114:	00 97       	sbiw	r24, 0x00	; 0&#xD;&#xA;     116:	29 f0       	breq	.+10     	; 0x122 <__mulhi3+0x1c>&#xD;&#xA;     118:	76 95       	lsr	r23&#xD;&#xA;     11a:	67 95       	ror	r22&#xD;&#xA;     11c:	b8 f3       	brcs	.-18     	; 0x10c <__mulhi3+0x6>&#xD;&#xA;     11e:	71 05       	cpc	r23, r1&#xD;&#xA;     120:	b9 f7       	brne	.-18     	; 0x110 <__mulhi3+0xa>&#xD;&#xA;     122:	80 2d       	mov	r24, r0&#xD;&#xA;     124:	95 2f       	mov	r25, r21&#xD;&#xA;     126:	08 95       	ret&#xD;&#xA;&#xD;&#xA;umul16_ algorithm:&#xD;&#xA;&#xD;&#xA;    00000044 <umul16_>:&#xD;&#xA;      44:	20 e0       	ldi	r18, 0x00	; 0&#xD;&#xA;      46:	30 e0       	ldi	r19, 0x00	; 0&#xD;&#xA;      48:	61 15       	cp	r22, r1&#xD;&#xA;      4a:	71 05       	cpc	r23, r1&#xD;&#xA;      4c:	49 f0       	breq	.+18     	; 0x60 <umul16_+0x1c>&#xD;&#xA;      4e:	60 ff       	sbrs	r22, 0&#xD;&#xA;      50:	02 c0       	rjmp	.+4      	; 0x56 <umul16_+0x12>&#xD;&#xA;      52:	28 0f       	add	r18, r24&#xD;&#xA;      54:	39 1f       	adc	r19, r25&#xD;&#xA;      56:	76 95       	lsr	r23&#xD;&#xA;      58:	67 95       	ror	r22&#xD;&#xA;      5a:	88 0f       	add	r24, r24&#xD;&#xA;      5c:	99 1f       	adc	r25, r25&#xD;&#xA;      5e:	f4 cf       	rjmp	.-24     	; 0x48 <umul16_+0x4>&#xD;&#xA;      60:	c9 01       	movw	r24, r18&#xD;&#xA;      62:	08 95       	ret&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added 1 character in body
88815436;29812009;908515;5;816dd39c-47fb-424f-a133-5fb05ea256c3;2015-04-23 08:22:36.0;"I'm searching for an algorithm to multiply two integer numbers that is better than the one below. Do you have a good idea about that? (The MCU - AT Tiny 84/85 or similar - where this code runs has no mul/div operator)&#xD;&#xA;&#xD;&#xA;    uint16_t umul16_(uint16_t a, uint16_t b)&#xD;&#xA;    {&#xD;&#xA;        uint16_t res=0;&#xD;&#xA;    &#xD;&#xA;        while (b) {&#xD;&#xA;            if ( (b & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;            b>>=1;&#xD;&#xA;            a+=a;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This algorithm, when compiled for AT Tiny 85/84 using the avr-gcc compiler, is almost identical to the algorithm __mulhi3 the avr-gcc generates.&#xD;&#xA;&#xD;&#xA;avr-gcc algorithm:&#xD;&#xA;&#xD;&#xA;    00000106 <__mulhi3>:&#xD;&#xA;     106:	00 24       	eor	r0, r0&#xD;&#xA;     108:	55 27       	eor	r21, r21&#xD;&#xA;     10a:	04 c0       	rjmp	.+8      	; 0x114 <__mulhi3+0xe>&#xD;&#xA;     10c:	08 0e       	add	r0, r24&#xD;&#xA;     10e:	59 1f       	adc	r21, r25&#xD;&#xA;     110:	88 0f       	add	r24, r24&#xD;&#xA;     112:	99 1f       	adc	r25, r25&#xD;&#xA;     114:	00 97       	sbiw	r24, 0x00	; 0&#xD;&#xA;     116:	29 f0       	breq	.+10     	; 0x122 <__mulhi3+0x1c>&#xD;&#xA;     118:	76 95       	lsr	r23&#xD;&#xA;     11a:	67 95       	ror	r22&#xD;&#xA;     11c:	b8 f3       	brcs	.-18     	; 0x10c <__mulhi3+0x6>&#xD;&#xA;     11e:	71 05       	cpc	r23, r1&#xD;&#xA;     120:	b9 f7       	brne	.-18     	; 0x110 <__mulhi3+0xa>&#xD;&#xA;     122:	80 2d       	mov	r24, r0&#xD;&#xA;     124:	95 2f       	mov	r25, r21&#xD;&#xA;     126:	08 95       	ret&#xD;&#xA;&#xD;&#xA;umul16_ algorithm:&#xD;&#xA;&#xD;&#xA;    00000044 <umul16_>:&#xD;&#xA;      44:	20 e0       	ldi	r18, 0x00	; 0&#xD;&#xA;      46:	30 e0       	ldi	r19, 0x00	; 0&#xD;&#xA;      48:	61 15       	cp	r22, r1&#xD;&#xA;      4a:	71 05       	cpc	r23, r1&#xD;&#xA;      4c:	49 f0       	breq	.+18     	; 0x60 <umul16_+0x1c>&#xD;&#xA;      4e:	60 ff       	sbrs	r22, 0&#xD;&#xA;      50:	02 c0       	rjmp	.+4      	; 0x56 <umul16_+0x12>&#xD;&#xA;      52:	28 0f       	add	r18, r24&#xD;&#xA;      54:	39 1f       	adc	r19, r25&#xD;&#xA;      56:	76 95       	lsr	r23&#xD;&#xA;      58:	67 95       	ror	r22&#xD;&#xA;      5a:	88 0f       	add	r24, r24&#xD;&#xA;      5c:	99 1f       	adc	r25, r25&#xD;&#xA;      5e:	f4 cf       	rjmp	.-24     	; 0x48 <umul16_+0x4>&#xD;&#xA;      60:	c9 01       	movw	r24, r18&#xD;&#xA;      62:	08 95       	ret&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;grammar
88970895;29812009;2436175;5;d8bf62d2-c1ee-43f6-a1f8-cc6f1b17d5a5;2015-04-24 22:25:38.0;"I'm searching for an algorithm to multiply two integer numbers that is better than the one below. Do you have a good idea about that? (The MCU - AT Tiny 84/85 or similar - where this code runs has no mul/div operator)&#xD;&#xA;&#xD;&#xA;    uint16_t umul16_(uint16_t a, uint16_t b)&#xD;&#xA;    {&#xD;&#xA;        uint16_t res=0;&#xD;&#xA;    &#xD;&#xA;        while (b) {&#xD;&#xA;            if ( (b & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;            b>>=1;&#xD;&#xA;            a+=a;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This algorithm, when compiled for AT Tiny 85/84 using the avr-gcc compiler, is almost identical to the algorithm __mulhi3 the avr-gcc generates.&#xD;&#xA;&#xD;&#xA;avr-gcc algorithm:&#xD;&#xA;&#xD;&#xA;    00000106 <__mulhi3>:&#xD;&#xA;     106:	00 24       	eor	r0, r0&#xD;&#xA;     108:	55 27       	eor	r21, r21&#xD;&#xA;     10a:	04 c0       	rjmp	.+8      	; 0x114 <__mulhi3+0xe>&#xD;&#xA;     10c:	08 0e       	add	r0, r24&#xD;&#xA;     10e:	59 1f       	adc	r21, r25&#xD;&#xA;     110:	88 0f       	add	r24, r24&#xD;&#xA;     112:	99 1f       	adc	r25, r25&#xD;&#xA;     114:	00 97       	sbiw	r24, 0x00	; 0&#xD;&#xA;     116:	29 f0       	breq	.+10     	; 0x122 <__mulhi3+0x1c>&#xD;&#xA;     118:	76 95       	lsr	r23&#xD;&#xA;     11a:	67 95       	ror	r22&#xD;&#xA;     11c:	b8 f3       	brcs	.-18     	; 0x10c <__mulhi3+0x6>&#xD;&#xA;     11e:	71 05       	cpc	r23, r1&#xD;&#xA;     120:	b9 f7       	brne	.-18     	; 0x110 <__mulhi3+0xa>&#xD;&#xA;     122:	80 2d       	mov	r24, r0&#xD;&#xA;     124:	95 2f       	mov	r25, r21&#xD;&#xA;     126:	08 95       	ret&#xD;&#xA;&#xD;&#xA;umul16_ algorithm:&#xD;&#xA;&#xD;&#xA;    00000044 <umul16_>:&#xD;&#xA;      44:	20 e0       	ldi	r18, 0x00	; 0&#xD;&#xA;      46:	30 e0       	ldi	r19, 0x00	; 0&#xD;&#xA;      48:	61 15       	cp	r22, r1&#xD;&#xA;      4a:	71 05       	cpc	r23, r1&#xD;&#xA;      4c:	49 f0       	breq	.+18     	; 0x60 <umul16_+0x1c>&#xD;&#xA;      4e:	60 ff       	sbrs	r22, 0&#xD;&#xA;      50:	02 c0       	rjmp	.+4      	; 0x56 <umul16_+0x12>&#xD;&#xA;      52:	28 0f       	add	r18, r24&#xD;&#xA;      54:	39 1f       	adc	r19, r25&#xD;&#xA;      56:	76 95       	lsr	r23&#xD;&#xA;      58:	67 95       	ror	r22&#xD;&#xA;      5a:	88 0f       	add	r24, r24&#xD;&#xA;      5c:	99 1f       	adc	r25, r25&#xD;&#xA;      5e:	f4 cf       	rjmp	.-24     	; 0x48 <umul16_+0x4>&#xD;&#xA;      60:	c9 01       	movw	r24, r18&#xD;&#xA;      62:	08 95       	ret&#xD;&#xA;&#xD;&#xA;<hr/>&#xD;&#xA;**Edit:** The instruction set is available [here](http://www.atmel.com/Images/8006S.pdf).&#xD;&#xA;";;added 96 characters in body
89035268;29812009;4769313;5;59f27f8b-1339-46ff-bb03-3fe972db3521;2015-04-26 00:57:51.0;"I'm searching for an algorithm to multiply two integer numbers that is better than the one below. Do you have a good idea about that? (The MCU - AT Tiny 84/85 or similar - where this code runs has no mul/div operator)&#xD;&#xA;&#xD;&#xA;    uint16_t umul16_(uint16_t a, uint16_t b)&#xD;&#xA;    {&#xD;&#xA;        uint16_t res=0;&#xD;&#xA;    &#xD;&#xA;        while (b) {&#xD;&#xA;            if ( (b & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;            b>>=1;&#xD;&#xA;            a+=a;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This algorithm, when compiled for AT Tiny 85/84 using the avr-gcc compiler, is almost identical to the algorithm __mulhi3 the avr-gcc generates.&#xD;&#xA;&#xD;&#xA;avr-gcc algorithm:&#xD;&#xA;&#xD;&#xA;    00000106 <__mulhi3>:&#xD;&#xA;     106:	00 24       	eor	r0, r0&#xD;&#xA;     108:	55 27       	eor	r21, r21&#xD;&#xA;     10a:	04 c0       	rjmp	.+8      	; 0x114 <__mulhi3+0xe>&#xD;&#xA;     10c:	08 0e       	add	r0, r24&#xD;&#xA;     10e:	59 1f       	adc	r21, r25&#xD;&#xA;     110:	88 0f       	add	r24, r24&#xD;&#xA;     112:	99 1f       	adc	r25, r25&#xD;&#xA;     114:	00 97       	sbiw	r24, 0x00	; 0&#xD;&#xA;     116:	29 f0       	breq	.+10     	; 0x122 <__mulhi3+0x1c>&#xD;&#xA;     118:	76 95       	lsr	r23&#xD;&#xA;     11a:	67 95       	ror	r22&#xD;&#xA;     11c:	b8 f3       	brcs	.-18     	; 0x10c <__mulhi3+0x6>&#xD;&#xA;     11e:	71 05       	cpc	r23, r1&#xD;&#xA;     120:	b9 f7       	brne	.-18     	; 0x110 <__mulhi3+0xa>&#xD;&#xA;     122:	80 2d       	mov	r24, r0&#xD;&#xA;     124:	95 2f       	mov	r25, r21&#xD;&#xA;     126:	08 95       	ret&#xD;&#xA;&#xD;&#xA;umul16_ algorithm:&#xD;&#xA;&#xD;&#xA;    00000044 <umul16_>:&#xD;&#xA;      44:	20 e0       	ldi	r18, 0x00	; 0&#xD;&#xA;      46:	30 e0       	ldi	r19, 0x00	; 0&#xD;&#xA;      48:	61 15       	cp	r22, r1&#xD;&#xA;      4a:	71 05       	cpc	r23, r1&#xD;&#xA;      4c:	49 f0       	breq	.+18     	; 0x60 <umul16_+0x1c>&#xD;&#xA;      4e:	60 ff       	sbrs	r22, 0&#xD;&#xA;      50:	02 c0       	rjmp	.+4      	; 0x56 <umul16_+0x12>&#xD;&#xA;      52:	28 0f       	add	r18, r24&#xD;&#xA;      54:	39 1f       	adc	r19, r25&#xD;&#xA;      56:	76 95       	lsr	r23&#xD;&#xA;      58:	67 95       	ror	r22&#xD;&#xA;      5a:	88 0f       	add	r24, r24&#xD;&#xA;      5c:	99 1f       	adc	r25, r25&#xD;&#xA;      5e:	f4 cf       	rjmp	.-24     	; 0x48 <umul16_+0x4>&#xD;&#xA;      60:	c9 01       	movw	r24, r18&#xD;&#xA;      62:	08 95       	ret&#xD;&#xA;&#xD;&#xA;<hr/>&#xD;&#xA;**Edit:** The instruction set is available [here](http://www.atmel.com/Images/8006S.pdf).&#xD;&#xA;&#xD;&#xA;April 26, 2015&#xD;&#xA;&#xD;&#xA;I've written a simple benchmark for almost all the code you (and also I) wrote!&#xD;&#xA;&#xD;&#xA;I've written a function (umul16_avr) that should be the translation of the code the AVR generates for the multiplication (I hope it's correct!)&#xD;&#xA;&#xD;&#xA;The results are formatted so the first field is a label-name for the routine, the second is a time in usec. (see the code that follows the results to link the functions with the labels)&#xD;&#xA;&#xD;&#xA;Here are the benchmark results on an ATmega168 16Mhz (compiled with avr-gcc -Os) :&#xD;&#xA;&#xD;&#xA;    avr  1078580&#xD;&#xA;    ant4 1114568&#xD;&#xA;    ant5 1118404&#xD;&#xA;    unro 1132304&#xD;&#xA;    basw 1163808&#xD;&#xA;    base 1165632&#xD;&#xA;    basl 1222412&#xD;&#xA;    unrl 1292244&#xD;&#xA;    vesw 1363604&#xD;&#xA;    vect 1373376&#xD;&#xA;    ----------------&#xD;&#xA;    avr  1078216&#xD;&#xA;    ant4 1114592&#xD;&#xA;    ant5 1118316&#xD;&#xA;    unro 1132464&#xD;&#xA;    basw 1164072&#xD;&#xA;    base 1165640&#xD;&#xA;    basl 1221980&#xD;&#xA;    unrl 1292208&#xD;&#xA;    vesw 1364288&#xD;&#xA;    vect 1373584&#xD;&#xA;    ----------------&#xD;&#xA;    [...]&#xD;&#xA;&#xD;&#xA;Here are the benchmark results on my Intel I3 2.4GHz (compiled with gcc -O2)&#xD;&#xA;&#xD;&#xA;    avr  408104&#xD;&#xA;    base 515006&#xD;&#xA;    ant4 522369&#xD;&#xA;    basw 547531&#xD;&#xA;    unrl 550278&#xD;&#xA;    vect 648548&#xD;&#xA;    basl 653037&#xD;&#xA;    vesw 654661&#xD;&#xA;    ant5 827930&#xD;&#xA;    unro 855820&#xD;&#xA;    ----------------&#xD;&#xA;    avr  408390&#xD;&#xA;    base 515838&#xD;&#xA;    ant4 550381&#xD;&#xA;    basw 551334&#xD;&#xA;    unrl 556447&#xD;&#xA;    vesw 641729&#xD;&#xA;    vect 647695&#xD;&#xA;    basl 653741&#xD;&#xA;    ant5 829905&#xD;&#xA;    unro 863286&#xD;&#xA;    [...]&#xD;&#xA;&#xD;&#xA;Here the benchmark on my Intel I3 without gcc optimization&#xD;&#xA;&#xD;&#xA;    avr  533664&#xD;&#xA;    vect 953624&#xD;&#xA;    vesw 1025501&#xD;&#xA;    unro 1138897&#xD;&#xA;    unrl 1275428&#xD;&#xA;    ant5 1419721&#xD;&#xA;    ant4 1474709&#xD;&#xA;    base 1556936&#xD;&#xA;    basw 1575208&#xD;&#xA;    basl 1720379&#xD;&#xA;&#xD;&#xA;The avr label seems the winner!&#xD;&#xA;&#xD;&#xA;In the following is the benchmark function (the type test_t is defined in umul.h - that also follows - I used this typedef to easily test other integer types where's possible):&#xD;&#xA;&#xD;&#xA;    typedef test_t fn_t(test_t a,test_t b);&#xD;&#xA;    &#xD;&#xA;    typedef struct fntest_s {&#xD;&#xA;        fn_t * fn;&#xD;&#xA;        char * msg;&#xD;&#xA;    } fntest_t;&#xD;&#xA;    &#xD;&#xA;    void umultry()&#xD;&#xA;    {&#xD;&#xA;    #ifdef __AVR__&#xD;&#xA;    #define RUNS 10000&#xD;&#xA;    char strbuf[40];&#xD;&#xA;    #else&#xD;&#xA;    #define RUNS 10000000&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;        int i,j,k;&#xD;&#xA;        uint32_t x;&#xD;&#xA;    &#xD;&#xA;        test_t ix,iy;&#xD;&#xA;        static test_t z[16];&#xD;&#xA;    &#xD;&#xA;        fntest_t fnt[]={&#xD;&#xA;            {umul16_base,(char *)""base""},&#xD;&#xA;            {umul16_baseandlogic,(char *)""basl""},&#xD;&#xA;            {umul16_baseswap,(char *)""basw""},&#xD;&#xA;            {umul16_Antonio4,(char *)""ant4""},&#xD;&#xA;            {umul16_Antonio5,(char *)""ant5""},&#xD;&#xA;            {umul16_avr,(char *)""avr ""},&#xD;&#xA;            {umul16_unrolled,(char *)""unro""},&#xD;&#xA;            {umul16_unrolledandlogic,(char *)""unrl""},&#xD;&#xA;            {umul16_vect,(char *)""vect""},&#xD;&#xA;            {umul16_vectswap,(char *)""vesw""}&#xD;&#xA;        };&#xD;&#xA;    &#xD;&#xA;        for(j=0;j<5;j++) {&#xD;&#xA;            k=sizeof(fnt)/sizeof(fntest_t)-1;&#xD;&#xA;            for(;k>=0;k--) {&#xD;&#xA;                x=micros();srand(x);&#xD;&#xA;                for(i=0;i<RUNS;i++) {&#xD;&#xA;                    ix=rand();iy=rand();&#xD;&#xA;                    z[i&0xF]=fnt[k].fn(ix,iy);&#xD;&#xA;                }&#xD;&#xA;    #ifdef __AVR__&#xD;&#xA;                sprintf(strbuf,""%s %lu\\n"",fnt[k].msg, micros()-x);&#xD;&#xA;                Serial.print(strbuf);&#xD;&#xA;    #else&#xD;&#xA;                printf(""%s %lu\\n"",fnt[k].msg, micros()-x);&#xD;&#xA;    #endif&#xD;&#xA;            }&#xD;&#xA;            for(i=0;i<16;i++) {&#xD;&#xA;                z[0]+=z[i]; /* To avoid warn unused */&#xD;&#xA;            }&#xD;&#xA;    #ifdef __AVR__&#xD;&#xA;            Serial.println(""----------------"");&#xD;&#xA;    #else&#xD;&#xA;            puts(""----------------"");&#xD;&#xA;    #endif&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On the AVR I use Serial.print because the printf and puts functions in my library fail!&#xD;&#xA;&#xD;&#xA;Here the code of the umul functions() (The umul16_avr contains the worst code you had never seen, but it seems the fastest!) :&#xD;&#xA;&#xD;&#xA;        #include ""umul.h""&#xD;&#xA;        &#xD;&#xA;        uint16_t umul16_unrolled(uint16_t a, uint16_t b)&#xD;&#xA;        {&#xD;&#xA;        uint16_t result=0;&#xD;&#xA;        &#xD;&#xA;        #define UMUL16_STEP(a, b, shift) \\&#xD;&#xA;            if ((b) & (1U << (shift))) result += (a<<shift);&#xD;&#xA;        &#xD;&#xA;            UMUL16_STEP(a, b, 0);&#xD;&#xA;            UMUL16_STEP(a, b, 1);&#xD;&#xA;            UMUL16_STEP(a, b, 2);&#xD;&#xA;            UMUL16_STEP(a, b, 3);&#xD;&#xA;            UMUL16_STEP(a, b, 4);&#xD;&#xA;            UMUL16_STEP(a, b, 5);&#xD;&#xA;            UMUL16_STEP(a, b, 6);&#xD;&#xA;            UMUL16_STEP(a, b, 7);&#xD;&#xA;            UMUL16_STEP(a, b, 8);&#xD;&#xA;            UMUL16_STEP(a, b, 9);&#xD;&#xA;            UMUL16_STEP(a, b, 10);&#xD;&#xA;            UMUL16_STEP(a, b, 11);&#xD;&#xA;            UMUL16_STEP(a, b, 12);&#xD;&#xA;            UMUL16_STEP(a, b, 13);&#xD;&#xA;            UMUL16_STEP(a, b, 14);&#xD;&#xA;            UMUL16_STEP(a, b, 15);&#xD;&#xA;        &#xD;&#xA;            return result;&#xD;&#xA;        #undef UMUL16_STEP&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        test_t umul16_unrolledandlogic(test_t a, test_t b)&#xD;&#xA;        {&#xD;&#xA;        test_t result=0;&#xD;&#xA;        #define UMUL16_STEP(a, b, shift) \\&#xD;&#xA;        /*    if ((b) & (1U << (shift))) result += (a<<shift);*/\\&#xD;&#xA;            result+=  ((0 - !(!((b&(1U<<(shift)))))) & (a<<(shift)));&#xD;&#xA;        &#xD;&#xA;            UMUL16_STEP(a, b, 0);&#xD;&#xA;            UMUL16_STEP(a, b, 1);&#xD;&#xA;            UMUL16_STEP(a, b, 2);&#xD;&#xA;            UMUL16_STEP(a, b, 3);&#xD;&#xA;            UMUL16_STEP(a, b, 4);&#xD;&#xA;            UMUL16_STEP(a, b, 5);&#xD;&#xA;            UMUL16_STEP(a, b, 6);&#xD;&#xA;            UMUL16_STEP(a, b, 7);&#xD;&#xA;            UMUL16_STEP(a, b, 8);&#xD;&#xA;            UMUL16_STEP(a, b, 9);&#xD;&#xA;            UMUL16_STEP(a, b, 10);&#xD;&#xA;            UMUL16_STEP(a, b, 11);&#xD;&#xA;            UMUL16_STEP(a, b, 12);&#xD;&#xA;            UMUL16_STEP(a, b, 13);&#xD;&#xA;            UMUL16_STEP(a, b, 14);&#xD;&#xA;            UMUL16_STEP(a, b, 15);&#xD;&#xA;        &#xD;&#xA;            return result;&#xD;&#xA;        #undef UMUL16_STEP&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        test_t umul16_Antonio5(test_t a, test_t b)&#xD;&#xA;        {&#xD;&#xA;            test_t res = 0;&#xD;&#xA;        &#xD;&#xA;            uint8_t b0 = b & 0xff; //This should be optimized away&#xD;&#xA;            uint8_t b1 = b >>8; //This should be optimized away&#xD;&#xA;        &#xD;&#xA;            //Swapping probably doesn't make much sense anymore&#xD;&#xA;            if ( (b1 & 1) )&#xD;&#xA;                res+=(test_t)((uint8_t)(a && 0xff))*256;&#xD;&#xA;            //Hopefully the compiler understands it has simply to add the low 8bit register of a to the high 8bit register of res&#xD;&#xA;        &#xD;&#xA;            if ( (b0 & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;        &#xD;&#xA;            b1>>=1;&#xD;&#xA;            b0>>=1;&#xD;&#xA;            while (b0) {///N cycles, maximum 7&#xD;&#xA;                a+=a;&#xD;&#xA;                if ( (b1 & 1) )&#xD;&#xA;                    res+=(test_t)((uint8_t)(a & 0xff))*256;&#xD;&#xA;                if ( (b0 & 1) )&#xD;&#xA;                    res+=a;&#xD;&#xA;                b1>>=1;&#xD;&#xA;                b0>>=1; //I try to put as last the one that will leave the carry flag in the desired state&#xD;&#xA;            }&#xD;&#xA;        &#xD;&#xA;            uint8_t a0 = a & 0xff; //Again, not a real copy but a register selection&#xD;&#xA;        &#xD;&#xA;            while (b1) {///P cycles, maximum 7 - N cycles&#xD;&#xA;                a0+=a0;&#xD;&#xA;                if ( (b1 & 1) )&#xD;&#xA;                    res+=(test_t) a0 * 256;&#xD;&#xA;                b1>>=1;&#xD;&#xA;            }&#xD;&#xA;            return res;&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        test_t umul16_base(test_t a, test_t b)&#xD;&#xA;        {&#xD;&#xA;            test_t res=0;&#xD;&#xA;        &#xD;&#xA;            while (b) {&#xD;&#xA;                if ( (b & 1) )&#xD;&#xA;                    res+=a;&#xD;&#xA;                b>>=1;&#xD;&#xA;                a+=a;&#xD;&#xA;            }&#xD;&#xA;        &#xD;&#xA;            return res;&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        test_t umul16_baseandlogic(test_t a, test_t b)&#xD;&#xA;        {&#xD;&#xA;            test_t res=0;&#xD;&#xA;        &#xD;&#xA;            while (b) {&#xD;&#xA;                //if ( (b & 1) )&#xD;&#xA;                //    res+=a;&#xD;&#xA;                res+=  ((0 - !(!(b&1))) & a);&#xD;&#xA;                b>>=1;&#xD;&#xA;                a+=a;&#xD;&#xA;            }&#xD;&#xA;        &#xD;&#xA;            return res;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    test_t umul16_baseswap(test_t a, test_t b)&#xD;&#xA;    {&#xD;&#xA;        test_t res;&#xD;&#xA;    &#xD;&#xA;        if (a<b) {&#xD;&#xA;            res=a;&#xD;&#xA;            a=b;&#xD;&#xA;            b=res;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        res=0;&#xD;&#xA;        while (b) {&#xD;&#xA;            if ( (b & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;            b>>=1;&#xD;&#xA;            a+=a;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    test_t umul16_avr(test_t a,test_t b)&#xD;&#xA;    {&#xD;&#xA;    /*&#xD;&#xA;    a0:	00 24       	eor	r0, r0&#xD;&#xA;    a2:	55 27       	eor	r21, r21&#xD;&#xA;    a4:	04 c0       	rjmp	.+8      	; 0xae <__mulhi3+0xe>&#xD;&#xA;    a6:	08 0e       	add	r0, r24&#xD;&#xA;    a8:	59 1f       	adc	r21, r25&#xD;&#xA;    aa:	88 0f       	add	r24, r24&#xD;&#xA;    ac:	99 1f       	adc	r25, r25&#xD;&#xA;    ae:	00 97       	sbiw	r24, 0x00	; 0&#xD;&#xA;    b0:	29 f0       	breq	.+10     	; 0xbc <__mulhi3+0x1c>&#xD;&#xA;    b2:	76 95       	lsr	r23&#xD;&#xA;    b4:	67 95       	ror	r22&#xD;&#xA;    b6:	b8 f3       	brcs	.-18     	; 0xa6 <__mulhi3+0x6>&#xD;&#xA;    b8:	71 05       	cpc	r23, r1         ; ???&#xD;&#xA;    ba:	b9 f7       	brne	.-18     	; 0xaa <__mulhi3+0xa>&#xD;&#xA;    bc:	80 2d       	mov	r24, r0&#xD;&#xA;    be:	95 2f       	mov	r25, r21&#xD;&#xA;    c0:	08 95       	ret&#xD;&#xA;    */&#xD;&#xA;    /* The worst code you had never seen, but it works good! &#xD;&#xA;    	I tried to copy the asm changing few things,&#xD;&#xA;    	but is obvious it's possible to write better code!!! :)&#xD;&#xA;    */&#xD;&#xA;        /* a is r24(l)r25(h) b is r22(l)r23(h) */&#xD;&#xA;        test_t r0r21=0;&#xD;&#xA;        char c;	//carry flag (casual state as in the asm)&#xD;&#xA;        goto ae;&#xD;&#xA;    a6: r0r21+=a;&#xD;&#xA;    aa: a+=a;&#xD;&#xA;    ae: if (!a) goto bc;&#xD;&#xA;        c=b&1;	//evaluates the carry (output or ror)&#xD;&#xA;        b>>=1;&#xD;&#xA;        if (c) goto a6;&#xD;&#xA;        if (!((b>>8)-c)) goto aa;&#xD;&#xA;    &#xD;&#xA;    bc: a=r0r21;&#xD;&#xA;        return a;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    test_t umul16_Antonio4(test_t a, test_t b)&#xD;&#xA;    {&#xD;&#xA;        uint8_t res1 = 0;&#xD;&#xA;    &#xD;&#xA;        uint8_t a0 = a & 0xff; //This effectively needs to copy the data&#xD;&#xA;        uint8_t b0 = b & 0xff; //This should be optimized away&#xD;&#xA;        uint8_t b1 = b >>8; //This should be optimized away&#xD;&#xA;    &#xD;&#xA;        //Here a0 and b1 could be swapped (to have b1 < a0)&#xD;&#xA;        if ( (b1 & 1) )&#xD;&#xA;            res1+=a0;&#xD;&#xA;        b1>>=1;&#xD;&#xA;        while (b1) {///Maximum 7 cycles&#xD;&#xA;            a0+=a0;&#xD;&#xA;            if ( (b1 & 1) )&#xD;&#xA;                res1+=a0;&#xD;&#xA;            b1>>=1;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        test_t res = (test_t) res1 * 256; //Should be optimized away, it's not even a copy!&#xD;&#xA;    &#xD;&#xA;        //Here swapping wouldn't make much sense&#xD;&#xA;        if ( (b0 & 1) )&#xD;&#xA;            res+=a;&#xD;&#xA;        b0>>=1;&#xD;&#xA;        while (b0) {///Maximum 7 cycles&#xD;&#xA;            a+=a;&#xD;&#xA;            if ( (b0 & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;            b0>>=1;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    test_t umul16_vect(test_t a, test_t b)&#xD;&#xA;    {&#xD;&#xA;        test_t c[2];&#xD;&#xA;    &#xD;&#xA;        c[0]=0;c[1]=a;a=0;&#xD;&#xA;        while (b) {&#xD;&#xA;            a+=c[(b & 1)];&#xD;&#xA;            b>>=1;&#xD;&#xA;            c[1]+=c[1];&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return a;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    test_t umul16_vectswap(test_t a, test_t b)&#xD;&#xA;    {&#xD;&#xA;        test_t c[2];&#xD;&#xA;    &#xD;&#xA;        if (a<b) {&#xD;&#xA;            c[1]=b;&#xD;&#xA;            b=a;&#xD;&#xA;            a=c[1];&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        c[0]=0;c[1]=a;a=0;&#xD;&#xA;        while (b) {&#xD;&#xA;            a+=c[(b & 1)];&#xD;&#xA;            b>>=1;&#xD;&#xA;            c[1]+=c[1];&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return a;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    test_t udiv_(test_t n,test_t d, test_t *r)&#xD;&#xA;    {&#xD;&#xA;        test_t q = 0,i,r_;&#xD;&#xA;    &#xD;&#xA;        r_=0;&#xD;&#xA;        if (d == 0) return (test_t)-1U; //error&#xD;&#xA;    &#xD;&#xA;        i= ( (test_t)(1) << ((sizeof(n)<<3)-1) );&#xD;&#xA;        for (;i!=0;i>>=1) {&#xD;&#xA;            r_ <<= 1;&#xD;&#xA;    &#xD;&#xA;            if (n&i)&#xD;&#xA;                r_ |= 1;&#xD;&#xA;    &#xD;&#xA;            if (r_ >= d) {&#xD;&#xA;                r_ -= d;&#xD;&#xA;                q |= i;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        if (r!=NULL)&#xD;&#xA;            *r=r_;&#xD;&#xA;    &#xD;&#xA;        return q;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;Here the include file (there's something strange for my purposes!!!):&#xD;&#xA;&#xD;&#xA;    #ifndef __UMUL_H&#xD;&#xA;    #define __UMUL_H&#xD;&#xA;    &#xD;&#xA;    #ifdef __AVR_ATtiny85__&#xD;&#xA;    /* You may think this is strange!!! But I need it! */&#xD;&#xA;    typedef signed int int8_t __attribute__((__mode__(__QI__)));&#xD;&#xA;    typedef unsigned int uint8_t __attribute__((__mode__(__QI__)));&#xD;&#xA;    typedef signed int int16_t __attribute__ ((__mode__ (__HI__)));&#xD;&#xA;    typedef unsigned int uint16_t __attribute__ ((__mode__ (__HI__)));&#xD;&#xA;    typedef signed int int32_t __attribute__ ((__mode__ (__SI__)));&#xD;&#xA;    typedef unsigned int uint32_t __attribute__ ((__mode__ (__SI__)));&#xD;&#xA;    typedef signed int int64_t __attribute__((__mode__(__DI__)));&#xD;&#xA;    typedef unsigned int uint64_t __attribute__((__mode__(__DI__)));&#xD;&#xA;    &#xD;&#xA;    #define NULL 0&#xD;&#xA;    #else&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    #include <stdint.h>&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    typedef uint16_t test_t;&#xD;&#xA;    &#xD;&#xA;    #ifdef __cplusplus&#xD;&#xA;    extern ""C"" {&#xD;&#xA;    #endif&#xD;&#xA;    test_t umul16_unrolled(test_t a, test_t b);&#xD;&#xA;    test_t umul16_unrolledandlogic(test_t a, test_t b);&#xD;&#xA;    test_t umul16_Antonio5(test_t a, test_t b);&#xD;&#xA;    test_t umul16_base(test_t a, test_t b);&#xD;&#xA;    test_t umul16_baseswap(test_t a, test_t b);&#xD;&#xA;    test_t umul16_avr(test_t a,test_t b);&#xD;&#xA;    test_t umul16_Antonio4(test_t a, test_t b);&#xD;&#xA;    uint64_t umul(uint64_t a, uint64_t b);&#xD;&#xA;    test_t umul16_vect(test_t a, test_t b);&#xD;&#xA;    test_t umul16_vectswap(test_t a, test_t b);&#xD;&#xA;    test_t umul16_baseandlogic(test_t a, test_t b);&#xD;&#xA;    test_t udiv_(test_t n,test_t d, test_t *r);&#xD;&#xA;    &#xD;&#xA;    #ifdef __cplusplus&#xD;&#xA;    } // extern ""C""&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added some benchmarks
89036641;29812009;4769313;5;b0930867-c44b-4e74-81ad-105a2ec07890;2015-04-26 01:51:20.0;"I'm searching for an algorithm to multiply two integer numbers that is better than the one below. Do you have a good idea about that? (The MCU - AT Tiny 84/85 or similar - where this code runs has no mul/div operator)&#xD;&#xA;&#xD;&#xA;    uint16_t umul16_(uint16_t a, uint16_t b)&#xD;&#xA;    {&#xD;&#xA;        uint16_t res=0;&#xD;&#xA;    &#xD;&#xA;        while (b) {&#xD;&#xA;            if ( (b & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;            b>>=1;&#xD;&#xA;            a+=a;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This algorithm, when compiled for AT Tiny 85/84 using the avr-gcc compiler, is almost identical to the algorithm __mulhi3 the avr-gcc generates.&#xD;&#xA;&#xD;&#xA;avr-gcc algorithm:&#xD;&#xA;&#xD;&#xA;    00000106 <__mulhi3>:&#xD;&#xA;     106:	00 24       	eor	r0, r0&#xD;&#xA;     108:	55 27       	eor	r21, r21&#xD;&#xA;     10a:	04 c0       	rjmp	.+8      	; 0x114 <__mulhi3+0xe>&#xD;&#xA;     10c:	08 0e       	add	r0, r24&#xD;&#xA;     10e:	59 1f       	adc	r21, r25&#xD;&#xA;     110:	88 0f       	add	r24, r24&#xD;&#xA;     112:	99 1f       	adc	r25, r25&#xD;&#xA;     114:	00 97       	sbiw	r24, 0x00	; 0&#xD;&#xA;     116:	29 f0       	breq	.+10     	; 0x122 <__mulhi3+0x1c>&#xD;&#xA;     118:	76 95       	lsr	r23&#xD;&#xA;     11a:	67 95       	ror	r22&#xD;&#xA;     11c:	b8 f3       	brcs	.-18     	; 0x10c <__mulhi3+0x6>&#xD;&#xA;     11e:	71 05       	cpc	r23, r1&#xD;&#xA;     120:	b9 f7       	brne	.-18     	; 0x110 <__mulhi3+0xa>&#xD;&#xA;     122:	80 2d       	mov	r24, r0&#xD;&#xA;     124:	95 2f       	mov	r25, r21&#xD;&#xA;     126:	08 95       	ret&#xD;&#xA;&#xD;&#xA;umul16_ algorithm:&#xD;&#xA;&#xD;&#xA;    00000044 <umul16_>:&#xD;&#xA;      44:	20 e0       	ldi	r18, 0x00	; 0&#xD;&#xA;      46:	30 e0       	ldi	r19, 0x00	; 0&#xD;&#xA;      48:	61 15       	cp	r22, r1&#xD;&#xA;      4a:	71 05       	cpc	r23, r1&#xD;&#xA;      4c:	49 f0       	breq	.+18     	; 0x60 <umul16_+0x1c>&#xD;&#xA;      4e:	60 ff       	sbrs	r22, 0&#xD;&#xA;      50:	02 c0       	rjmp	.+4      	; 0x56 <umul16_+0x12>&#xD;&#xA;      52:	28 0f       	add	r18, r24&#xD;&#xA;      54:	39 1f       	adc	r19, r25&#xD;&#xA;      56:	76 95       	lsr	r23&#xD;&#xA;      58:	67 95       	ror	r22&#xD;&#xA;      5a:	88 0f       	add	r24, r24&#xD;&#xA;      5c:	99 1f       	adc	r25, r25&#xD;&#xA;      5e:	f4 cf       	rjmp	.-24     	; 0x48 <umul16_+0x4>&#xD;&#xA;      60:	c9 01       	movw	r24, r18&#xD;&#xA;      62:	08 95       	ret&#xD;&#xA;&#xD;&#xA;<hr/>&#xD;&#xA;**Edit:** The instruction set is available [here](http://www.atmel.com/Images/8006S.pdf).&#xD;&#xA;&#xD;&#xA;April 26, 2015&#xD;&#xA;&#xD;&#xA;I've written a simple benchmark for almost all the code you wrote!&#xD;&#xA;&#xD;&#xA;The results are formatted so the first field is a label-name for the routine, the second is a time in usec. (see the code that follows the results to link the functions with the labels)&#xD;&#xA;&#xD;&#xA;Here are the benchmark results on an ATmega168 16Mhz (compiled with avr-gcc -Os) :&#xD;&#xA;&#xD;&#xA;    ant4 1114568&#xD;&#xA;    ant5 1118404&#xD;&#xA;    unro 1132304&#xD;&#xA;    basw 1163808&#xD;&#xA;    base 1165632&#xD;&#xA;    basl 1222412&#xD;&#xA;    unrl 1292244&#xD;&#xA;    vesw 1363604&#xD;&#xA;    vect 1373376&#xD;&#xA;    ----------------&#xD;&#xA;    ant4 1114592&#xD;&#xA;    ant5 1118316&#xD;&#xA;    unro 1132464&#xD;&#xA;    basw 1164072&#xD;&#xA;    base 1165640&#xD;&#xA;    basl 1221980&#xD;&#xA;    unrl 1292208&#xD;&#xA;    vesw 1364288&#xD;&#xA;    vect 1373584&#xD;&#xA;    ----------------&#xD;&#xA;    [...]&#xD;&#xA;&#xD;&#xA;Here are the benchmark results on my Intel I3 2.4GHz (compiled with gcc -O2)&#xD;&#xA;&#xD;&#xA;    base 515006&#xD;&#xA;    ant4 522369&#xD;&#xA;    basw 547531&#xD;&#xA;    unrl 550278&#xD;&#xA;    vect 648548&#xD;&#xA;    basl 653037&#xD;&#xA;    vesw 654661&#xD;&#xA;    ant5 827930&#xD;&#xA;    unro 855820&#xD;&#xA;    ----------------&#xD;&#xA;    base 515838&#xD;&#xA;    ant4 550381&#xD;&#xA;    basw 551334&#xD;&#xA;    unrl 556447&#xD;&#xA;    vesw 641729&#xD;&#xA;    vect 647695&#xD;&#xA;    basl 653741&#xD;&#xA;    ant5 829905&#xD;&#xA;    unro 863286&#xD;&#xA;    [...]&#xD;&#xA;&#xD;&#xA;Here the benchmark on my Intel I3 without gcc optimization&#xD;&#xA;&#xD;&#xA;    vect 953624&#xD;&#xA;    vesw 1025501&#xD;&#xA;    unro 1138897&#xD;&#xA;    unrl 1275428&#xD;&#xA;    ant5 1419721&#xD;&#xA;    ant4 1474709&#xD;&#xA;    base 1556936&#xD;&#xA;    basw 1575208&#xD;&#xA;    basl 1720379&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;In the following is the benchmark function (the type test_t is defined in umul.h - that also follows - I used this typedef to easily test other integer types where's possible):&#xD;&#xA;&#xD;&#xA;    typedef test_t fn_t(test_t a,test_t b);&#xD;&#xA;    &#xD;&#xA;    typedef struct fntest_s {&#xD;&#xA;        fn_t * fn;&#xD;&#xA;        char * msg;&#xD;&#xA;    } fntest_t;&#xD;&#xA;    &#xD;&#xA;    void umultry()&#xD;&#xA;    {&#xD;&#xA;    #ifdef __AVR__&#xD;&#xA;    #define RUNS 10000&#xD;&#xA;    char strbuf[40];&#xD;&#xA;    #else&#xD;&#xA;    #define RUNS 10000000&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;        int i,j,k;&#xD;&#xA;        uint32_t x;&#xD;&#xA;    &#xD;&#xA;        test_t ix,iy;&#xD;&#xA;        static test_t z[16];&#xD;&#xA;    &#xD;&#xA;        fntest_t fnt[]={&#xD;&#xA;            {umul16_base,(char *)""base""},&#xD;&#xA;            {umul16_baseandlogic,(char *)""basl""},&#xD;&#xA;            {umul16_baseswap,(char *)""basw""},&#xD;&#xA;            {umul16_Antonio4,(char *)""ant4""},&#xD;&#xA;            {umul16_Antonio5,(char *)""ant5""},&#xD;&#xA;            {umul16_unrolled,(char *)""unro""},&#xD;&#xA;            {umul16_unrolledandlogic,(char *)""unrl""},&#xD;&#xA;            {umul16_vect,(char *)""vect""},&#xD;&#xA;            {umul16_vectswap,(char *)""vesw""}&#xD;&#xA;        };&#xD;&#xA;    &#xD;&#xA;        for(j=0;j<5;j++) {&#xD;&#xA;            k=sizeof(fnt)/sizeof(fntest_t)-1;&#xD;&#xA;            for(;k>=0;k--) {&#xD;&#xA;                x=micros();srand(x);&#xD;&#xA;                for(i=0;i<RUNS;i++) {&#xD;&#xA;                    ix=rand();iy=rand();&#xD;&#xA;                    z[i&0xF]=fnt[k].fn(ix,iy);&#xD;&#xA;                }&#xD;&#xA;    #ifdef __AVR__&#xD;&#xA;                sprintf(strbuf,""%s %lu\\n"",fnt[k].msg, micros()-x);&#xD;&#xA;                Serial.print(strbuf);&#xD;&#xA;    #else&#xD;&#xA;                printf(""%s %lu\\n"",fnt[k].msg, micros()-x);&#xD;&#xA;    #endif&#xD;&#xA;            }&#xD;&#xA;            for(i=0;i<16;i++) {&#xD;&#xA;                z[0]+=z[i]; /* To avoid warn unused */&#xD;&#xA;            }&#xD;&#xA;    #ifdef __AVR__&#xD;&#xA;            Serial.println(""----------------"");&#xD;&#xA;    #else&#xD;&#xA;            puts(""----------------"");&#xD;&#xA;    #endif&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On the AVR I use Serial.print because the printf and puts functions in my library fail!&#xD;&#xA;&#xD;&#xA;Here the code of the umul functions:&#xD;&#xA;&#xD;&#xA;        #include ""umul.h""&#xD;&#xA;        &#xD;&#xA;        uint16_t umul16_unrolled(uint16_t a, uint16_t b)&#xD;&#xA;        {&#xD;&#xA;        uint16_t result=0;&#xD;&#xA;        &#xD;&#xA;        #define UMUL16_STEP(a, b, shift) \\&#xD;&#xA;            if ((b) & (1U << (shift))) result += (a<<shift);&#xD;&#xA;        &#xD;&#xA;            UMUL16_STEP(a, b, 0);&#xD;&#xA;            UMUL16_STEP(a, b, 1);&#xD;&#xA;            UMUL16_STEP(a, b, 2);&#xD;&#xA;            UMUL16_STEP(a, b, 3);&#xD;&#xA;            UMUL16_STEP(a, b, 4);&#xD;&#xA;            UMUL16_STEP(a, b, 5);&#xD;&#xA;            UMUL16_STEP(a, b, 6);&#xD;&#xA;            UMUL16_STEP(a, b, 7);&#xD;&#xA;            UMUL16_STEP(a, b, 8);&#xD;&#xA;            UMUL16_STEP(a, b, 9);&#xD;&#xA;            UMUL16_STEP(a, b, 10);&#xD;&#xA;            UMUL16_STEP(a, b, 11);&#xD;&#xA;            UMUL16_STEP(a, b, 12);&#xD;&#xA;            UMUL16_STEP(a, b, 13);&#xD;&#xA;            UMUL16_STEP(a, b, 14);&#xD;&#xA;            UMUL16_STEP(a, b, 15);&#xD;&#xA;        &#xD;&#xA;            return result;&#xD;&#xA;        #undef UMUL16_STEP&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        test_t umul16_unrolledandlogic(test_t a, test_t b)&#xD;&#xA;        {&#xD;&#xA;        test_t result=0;&#xD;&#xA;        #define UMUL16_STEP(a, b, shift) \\&#xD;&#xA;        /*    if ((b) & (1U << (shift))) result += (a<<shift);*/\\&#xD;&#xA;            result+=  ((0 - !(!((b&(1U<<(shift)))))) & (a<<(shift)));&#xD;&#xA;        &#xD;&#xA;            UMUL16_STEP(a, b, 0);&#xD;&#xA;            UMUL16_STEP(a, b, 1);&#xD;&#xA;            UMUL16_STEP(a, b, 2);&#xD;&#xA;            UMUL16_STEP(a, b, 3);&#xD;&#xA;            UMUL16_STEP(a, b, 4);&#xD;&#xA;            UMUL16_STEP(a, b, 5);&#xD;&#xA;            UMUL16_STEP(a, b, 6);&#xD;&#xA;            UMUL16_STEP(a, b, 7);&#xD;&#xA;            UMUL16_STEP(a, b, 8);&#xD;&#xA;            UMUL16_STEP(a, b, 9);&#xD;&#xA;            UMUL16_STEP(a, b, 10);&#xD;&#xA;            UMUL16_STEP(a, b, 11);&#xD;&#xA;            UMUL16_STEP(a, b, 12);&#xD;&#xA;            UMUL16_STEP(a, b, 13);&#xD;&#xA;            UMUL16_STEP(a, b, 14);&#xD;&#xA;            UMUL16_STEP(a, b, 15);&#xD;&#xA;        &#xD;&#xA;            return result;&#xD;&#xA;        #undef UMUL16_STEP&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        test_t umul16_Antonio5(test_t a, test_t b)&#xD;&#xA;        {&#xD;&#xA;            test_t res = 0;&#xD;&#xA;        &#xD;&#xA;            uint8_t b0 = b & 0xff; //This should be optimized away&#xD;&#xA;            uint8_t b1 = b >>8; //This should be optimized away&#xD;&#xA;        &#xD;&#xA;            //Swapping probably doesn't make much sense anymore&#xD;&#xA;            if ( (b1 & 1) )&#xD;&#xA;                res+=(test_t)((uint8_t)(a && 0xff))*256;&#xD;&#xA;            //Hopefully the compiler understands it has simply to add the low 8bit register of a to the high 8bit register of res&#xD;&#xA;        &#xD;&#xA;            if ( (b0 & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;        &#xD;&#xA;            b1>>=1;&#xD;&#xA;            b0>>=1;&#xD;&#xA;            while (b0) {///N cycles, maximum 7&#xD;&#xA;                a+=a;&#xD;&#xA;                if ( (b1 & 1) )&#xD;&#xA;                    res+=(test_t)((uint8_t)(a & 0xff))*256;&#xD;&#xA;                if ( (b0 & 1) )&#xD;&#xA;                    res+=a;&#xD;&#xA;                b1>>=1;&#xD;&#xA;                b0>>=1; //I try to put as last the one that will leave the carry flag in the desired state&#xD;&#xA;            }&#xD;&#xA;        &#xD;&#xA;            uint8_t a0 = a & 0xff; //Again, not a real copy but a register selection&#xD;&#xA;        &#xD;&#xA;            while (b1) {///P cycles, maximum 7 - N cycles&#xD;&#xA;                a0+=a0;&#xD;&#xA;                if ( (b1 & 1) )&#xD;&#xA;                    res+=(test_t) a0 * 256;&#xD;&#xA;                b1>>=1;&#xD;&#xA;            }&#xD;&#xA;            return res;&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        test_t umul16_base(test_t a, test_t b)&#xD;&#xA;        {&#xD;&#xA;            test_t res=0;&#xD;&#xA;        &#xD;&#xA;            while (b) {&#xD;&#xA;                if ( (b & 1) )&#xD;&#xA;                    res+=a;&#xD;&#xA;                b>>=1;&#xD;&#xA;                a+=a;&#xD;&#xA;            }&#xD;&#xA;        &#xD;&#xA;            return res;&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        test_t umul16_baseandlogic(test_t a, test_t b)&#xD;&#xA;        {&#xD;&#xA;            test_t res=0;&#xD;&#xA;        &#xD;&#xA;            while (b) {&#xD;&#xA;                //if ( (b & 1) )&#xD;&#xA;                //    res+=a;&#xD;&#xA;                res+=  ((0 - !(!(b&1))) & a);&#xD;&#xA;                b>>=1;&#xD;&#xA;                a+=a;&#xD;&#xA;            }&#xD;&#xA;        &#xD;&#xA;            return res;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    test_t umul16_baseswap(test_t a, test_t b)&#xD;&#xA;    {&#xD;&#xA;        test_t res;&#xD;&#xA;    &#xD;&#xA;        if (a<b) {&#xD;&#xA;            res=a;&#xD;&#xA;            a=b;&#xD;&#xA;            b=res;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        res=0;&#xD;&#xA;        while (b) {&#xD;&#xA;            if ( (b & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;            b>>=1;&#xD;&#xA;            a+=a;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;       &#xD;&#xA;    test_t umul16_Antonio4(test_t a, test_t b)&#xD;&#xA;    {&#xD;&#xA;        uint8_t res1 = 0;&#xD;&#xA;    &#xD;&#xA;        uint8_t a0 = a & 0xff; //This effectively needs to copy the data&#xD;&#xA;        uint8_t b0 = b & 0xff; //This should be optimized away&#xD;&#xA;        uint8_t b1 = b >>8; //This should be optimized away&#xD;&#xA;    &#xD;&#xA;        //Here a0 and b1 could be swapped (to have b1 < a0)&#xD;&#xA;        if ( (b1 & 1) )&#xD;&#xA;            res1+=a0;&#xD;&#xA;        b1>>=1;&#xD;&#xA;        while (b1) {///Maximum 7 cycles&#xD;&#xA;            a0+=a0;&#xD;&#xA;            if ( (b1 & 1) )&#xD;&#xA;                res1+=a0;&#xD;&#xA;            b1>>=1;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        test_t res = (test_t) res1 * 256; //Should be optimized away, it's not even a copy!&#xD;&#xA;    &#xD;&#xA;        //Here swapping wouldn't make much sense&#xD;&#xA;        if ( (b0 & 1) )&#xD;&#xA;            res+=a;&#xD;&#xA;        b0>>=1;&#xD;&#xA;        while (b0) {///Maximum 7 cycles&#xD;&#xA;            a+=a;&#xD;&#xA;            if ( (b0 & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;            b0>>=1;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    test_t umul16_vect(test_t a, test_t b)&#xD;&#xA;    {&#xD;&#xA;        test_t c[2];&#xD;&#xA;    &#xD;&#xA;        c[0]=0;c[1]=a;a=0;&#xD;&#xA;        while (b) {&#xD;&#xA;            a+=c[(b & 1)];&#xD;&#xA;            b>>=1;&#xD;&#xA;            c[1]+=c[1];&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return a;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    test_t umul16_vectswap(test_t a, test_t b)&#xD;&#xA;    {&#xD;&#xA;        test_t c[2];&#xD;&#xA;    &#xD;&#xA;        if (a<b) {&#xD;&#xA;            c[1]=b;&#xD;&#xA;            b=a;&#xD;&#xA;            a=c[1];&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        c[0]=0;c[1]=a;a=0;&#xD;&#xA;        while (b) {&#xD;&#xA;            a+=c[(b & 1)];&#xD;&#xA;            b>>=1;&#xD;&#xA;            c[1]+=c[1];&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return a;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    test_t udiv_(test_t n,test_t d, test_t *r)&#xD;&#xA;    {&#xD;&#xA;        test_t q = 0,i,r_;&#xD;&#xA;    &#xD;&#xA;        r_=0;&#xD;&#xA;        if (d == 0) return (test_t)-1U; //error&#xD;&#xA;    &#xD;&#xA;        i= ( (test_t)(1) << ((sizeof(n)<<3)-1) );&#xD;&#xA;        for (;i!=0;i>>=1) {&#xD;&#xA;            r_ <<= 1;&#xD;&#xA;    &#xD;&#xA;            if (n&i)&#xD;&#xA;                r_ |= 1;&#xD;&#xA;    &#xD;&#xA;            if (r_ >= d) {&#xD;&#xA;                r_ -= d;&#xD;&#xA;                q |= i;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        if (r!=NULL)&#xD;&#xA;            *r=r_;&#xD;&#xA;    &#xD;&#xA;        return q;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;Here the include file (there's something strange for my purposes!!!):&#xD;&#xA;&#xD;&#xA;    #ifndef __UMUL_H&#xD;&#xA;    #define __UMUL_H&#xD;&#xA;    &#xD;&#xA;    #ifdef __AVR_ATtiny85__&#xD;&#xA;    /* You may think this is strange!!! But I need it! */&#xD;&#xA;    typedef signed int int8_t __attribute__((__mode__(__QI__)));&#xD;&#xA;    typedef unsigned int uint8_t __attribute__((__mode__(__QI__)));&#xD;&#xA;    typedef signed int int16_t __attribute__ ((__mode__ (__HI__)));&#xD;&#xA;    typedef unsigned int uint16_t __attribute__ ((__mode__ (__HI__)));&#xD;&#xA;    typedef signed int int32_t __attribute__ ((__mode__ (__SI__)));&#xD;&#xA;    typedef unsigned int uint32_t __attribute__ ((__mode__ (__SI__)));&#xD;&#xA;    typedef signed int int64_t __attribute__((__mode__(__DI__)));&#xD;&#xA;    typedef unsigned int uint64_t __attribute__((__mode__(__DI__)));&#xD;&#xA;    &#xD;&#xA;    #define NULL 0&#xD;&#xA;    #else&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    #include <stdint.h>&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    typedef uint16_t test_t;&#xD;&#xA;    &#xD;&#xA;    #ifdef __cplusplus&#xD;&#xA;    extern ""C"" {&#xD;&#xA;    #endif&#xD;&#xA;    test_t umul16_unrolled(test_t a, test_t b);&#xD;&#xA;    test_t umul16_unrolledandlogic(test_t a, test_t b);&#xD;&#xA;    test_t umul16_Antonio5(test_t a, test_t b);&#xD;&#xA;    test_t umul16_base(test_t a, test_t b);&#xD;&#xA;    test_t umul16_baseswap(test_t a, test_t b);&#xD;&#xA;    test_t umul16_Antonio4(test_t a, test_t b);&#xD;&#xA;    uint64_t umul(uint64_t a, uint64_t b);&#xD;&#xA;    test_t umul16_vect(test_t a, test_t b);&#xD;&#xA;    test_t umul16_vectswap(test_t a, test_t b);&#xD;&#xA;    test_t umul16_baseandlogic(test_t a, test_t b);&#xD;&#xA;    test_t udiv_(test_t n,test_t d, test_t *r);&#xD;&#xA;    &#xD;&#xA;    #ifdef __cplusplus&#xD;&#xA;    } // extern ""C""&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;Deleted some not working code! :( I apologize!
89037310;29812009;4769313;5;6d834cfc-2e76-4abf-8f13-37fbad92bced;2015-04-26 02:19:48.0;"I'm searching for an algorithm to multiply two integer numbers that is better than the one below. Do you have a good idea about that? (The MCU - AT Tiny 84/85 or similar - where this code runs has no mul/div operator)&#xD;&#xA;&#xD;&#xA;    uint16_t umul16_(uint16_t a, uint16_t b)&#xD;&#xA;    {&#xD;&#xA;        uint16_t res=0;&#xD;&#xA;    &#xD;&#xA;        while (b) {&#xD;&#xA;            if ( (b & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;            b>>=1;&#xD;&#xA;            a+=a;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This algorithm, when compiled for AT Tiny 85/84 using the avr-gcc compiler, is almost identical to the algorithm __mulhi3 the avr-gcc generates.&#xD;&#xA;&#xD;&#xA;avr-gcc algorithm:&#xD;&#xA;&#xD;&#xA;    00000106 <__mulhi3>:&#xD;&#xA;     106:	00 24       	eor	r0, r0&#xD;&#xA;     108:	55 27       	eor	r21, r21&#xD;&#xA;     10a:	04 c0       	rjmp	.+8      	; 0x114 <__mulhi3+0xe>&#xD;&#xA;     10c:	08 0e       	add	r0, r24&#xD;&#xA;     10e:	59 1f       	adc	r21, r25&#xD;&#xA;     110:	88 0f       	add	r24, r24&#xD;&#xA;     112:	99 1f       	adc	r25, r25&#xD;&#xA;     114:	00 97       	sbiw	r24, 0x00	; 0&#xD;&#xA;     116:	29 f0       	breq	.+10     	; 0x122 <__mulhi3+0x1c>&#xD;&#xA;     118:	76 95       	lsr	r23&#xD;&#xA;     11a:	67 95       	ror	r22&#xD;&#xA;     11c:	b8 f3       	brcs	.-18     	; 0x10c <__mulhi3+0x6>&#xD;&#xA;     11e:	71 05       	cpc	r23, r1&#xD;&#xA;     120:	b9 f7       	brne	.-18     	; 0x110 <__mulhi3+0xa>&#xD;&#xA;     122:	80 2d       	mov	r24, r0&#xD;&#xA;     124:	95 2f       	mov	r25, r21&#xD;&#xA;     126:	08 95       	ret&#xD;&#xA;&#xD;&#xA;umul16_ algorithm:&#xD;&#xA;&#xD;&#xA;    00000044 <umul16_>:&#xD;&#xA;      44:	20 e0       	ldi	r18, 0x00	; 0&#xD;&#xA;      46:	30 e0       	ldi	r19, 0x00	; 0&#xD;&#xA;      48:	61 15       	cp	r22, r1&#xD;&#xA;      4a:	71 05       	cpc	r23, r1&#xD;&#xA;      4c:	49 f0       	breq	.+18     	; 0x60 <umul16_+0x1c>&#xD;&#xA;      4e:	60 ff       	sbrs	r22, 0&#xD;&#xA;      50:	02 c0       	rjmp	.+4      	; 0x56 <umul16_+0x12>&#xD;&#xA;      52:	28 0f       	add	r18, r24&#xD;&#xA;      54:	39 1f       	adc	r19, r25&#xD;&#xA;      56:	76 95       	lsr	r23&#xD;&#xA;      58:	67 95       	ror	r22&#xD;&#xA;      5a:	88 0f       	add	r24, r24&#xD;&#xA;      5c:	99 1f       	adc	r25, r25&#xD;&#xA;      5e:	f4 cf       	rjmp	.-24     	; 0x48 <umul16_+0x4>&#xD;&#xA;      60:	c9 01       	movw	r24, r18&#xD;&#xA;      62:	08 95       	ret&#xD;&#xA;&#xD;&#xA;<hr/>&#xD;&#xA;**Edit:** The instruction set is available [here](http://www.atmel.com/Images/8006S.pdf).&#xD;&#xA;&#xD;&#xA;April 26, 2015&#xD;&#xA;&#xD;&#xA;I've written a simple benchmark for almost all the code you wrote!&#xD;&#xA;&#xD;&#xA;The results are formatted so the first field is a label-name for the routine, the second is a time in usec. (see the code that follows the results to link the functions with the labels)&#xD;&#xA;&#xD;&#xA;Here are the benchmark results on an ATmega168 16Mhz (compiled with avr-gcc -Os) :&#xD;&#xA;&#xD;&#xA;    ant4 1114568&#xD;&#xA;    ant5 1118404&#xD;&#xA;    unro 1132304&#xD;&#xA;    basw 1163808&#xD;&#xA;    base 1165632&#xD;&#xA;    basl 1222412&#xD;&#xA;    unrl 1292244&#xD;&#xA;    vesw 1363604&#xD;&#xA;    vect 1373376&#xD;&#xA;    ----------------&#xD;&#xA;    ant4 1114592&#xD;&#xA;    ant5 1118316&#xD;&#xA;    unro 1132464&#xD;&#xA;    basw 1164072&#xD;&#xA;    base 1165640&#xD;&#xA;    basl 1221980&#xD;&#xA;    unrl 1292208&#xD;&#xA;    vesw 1364288&#xD;&#xA;    vect 1373584&#xD;&#xA;    ----------------&#xD;&#xA;    [...]&#xD;&#xA;&#xD;&#xA;Here are the benchmark results on my Intel I3 2.4GHz (compiled with gcc -O2)&#xD;&#xA;&#xD;&#xA;    base 515006&#xD;&#xA;    ant4 522369&#xD;&#xA;    basw 547531&#xD;&#xA;    unrl 550278&#xD;&#xA;    vect 648548&#xD;&#xA;    basl 653037&#xD;&#xA;    vesw 654661&#xD;&#xA;    ant5 827930&#xD;&#xA;    unro 855820&#xD;&#xA;    ----------------&#xD;&#xA;    base 515838&#xD;&#xA;    ant4 550381&#xD;&#xA;    basw 551334&#xD;&#xA;    unrl 556447&#xD;&#xA;    vesw 641729&#xD;&#xA;    vect 647695&#xD;&#xA;    basl 653741&#xD;&#xA;    ant5 829905&#xD;&#xA;    unro 863286&#xD;&#xA;    [...]&#xD;&#xA;&#xD;&#xA;Here the benchmark on my Intel I3 without gcc optimization&#xD;&#xA;&#xD;&#xA;    vect 953624&#xD;&#xA;    vesw 1025501&#xD;&#xA;    unro 1138897&#xD;&#xA;    unrl 1275428&#xD;&#xA;    ant5 1419721&#xD;&#xA;    ant4 1474709&#xD;&#xA;    base 1556936&#xD;&#xA;    basw 1575208&#xD;&#xA;    basl 1720379&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;In the following is the benchmark function (the type test_t is defined in umul.h - that also follows - I used this typedef to easily test other integer types where's possible):&#xD;&#xA;&#xD;&#xA;    typedef test_t fn_t(test_t a,test_t b);&#xD;&#xA;    &#xD;&#xA;    typedef struct fntest_s {&#xD;&#xA;        fn_t * fn;&#xD;&#xA;        char * msg;&#xD;&#xA;    } fntest_t;&#xD;&#xA;    &#xD;&#xA;    #ifndef __AVR__&#xD;&#xA;    uint32_t micros()&#xD;&#xA;    {&#xD;&#xA;        struct timeval t;&#xD;&#xA;        gettimeofday(&t,NULL);&#xD;&#xA;    &#xD;&#xA;        return (t.tv_sec*1000000UL+t.tv_usec);&#xD;&#xA;    }&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;    void umultry()&#xD;&#xA;    {&#xD;&#xA;    #ifdef __AVR__&#xD;&#xA;    #define RUNS 10000&#xD;&#xA;    char strbuf[40];&#xD;&#xA;    #else&#xD;&#xA;    #define RUNS 10000000&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;        int i,j,k;&#xD;&#xA;        uint32_t x;&#xD;&#xA;    &#xD;&#xA;        test_t ix,iy;&#xD;&#xA;        static test_t z[16];&#xD;&#xA;    &#xD;&#xA;        fntest_t fnt[]={&#xD;&#xA;            {umul16_base,(char *)""base""},&#xD;&#xA;            {umul16_baseandlogic,(char *)""basl""},&#xD;&#xA;            {umul16_baseswap,(char *)""basw""},&#xD;&#xA;            {umul16_Antonio4,(char *)""ant4""},&#xD;&#xA;            {umul16_Antonio5,(char *)""ant5""},&#xD;&#xA;            {umul16_unrolled,(char *)""unro""},&#xD;&#xA;            {umul16_unrolledandlogic,(char *)""unrl""},&#xD;&#xA;            {umul16_vect,(char *)""vect""},&#xD;&#xA;            {umul16_vectswap,(char *)""vesw""}&#xD;&#xA;        };&#xD;&#xA;    &#xD;&#xA;        for(j=0;j<5;j++) {&#xD;&#xA;            k=sizeof(fnt)/sizeof(fntest_t)-1;&#xD;&#xA;            for(;k>=0;k--) {&#xD;&#xA;                x=micros();srand(x);&#xD;&#xA;                for(i=0;i<RUNS;i++) {&#xD;&#xA;                    ix=rand();iy=rand();&#xD;&#xA;                    z[i&0xF]=fnt[k].fn(ix,iy);&#xD;&#xA;                }&#xD;&#xA;    #ifdef __AVR__&#xD;&#xA;                sprintf(strbuf,""%s %lu\\n"",fnt[k].msg, micros()-x);&#xD;&#xA;                Serial.print(strbuf);&#xD;&#xA;    #else&#xD;&#xA;                printf(""%s %lu\\n"",fnt[k].msg, micros()-x);&#xD;&#xA;    #endif&#xD;&#xA;            }&#xD;&#xA;            for(i=0;i<16;i++) {&#xD;&#xA;                z[0]+=z[i]; /* To avoid warn unused */&#xD;&#xA;            }&#xD;&#xA;    #ifdef __AVR__&#xD;&#xA;            Serial.println(""----------------"");&#xD;&#xA;    #else&#xD;&#xA;            puts(""----------------"");&#xD;&#xA;    #endif&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On the AVR I use Serial.print because the printf and puts functions in my library fail!&#xD;&#xA;&#xD;&#xA;Here the code of the umul functions:&#xD;&#xA;&#xD;&#xA;        #include ""umul.h""&#xD;&#xA;        &#xD;&#xA;        uint16_t umul16_unrolled(uint16_t a, uint16_t b)&#xD;&#xA;        {&#xD;&#xA;        uint16_t result=0;&#xD;&#xA;        &#xD;&#xA;        #define UMUL16_STEP(a, b, shift) \\&#xD;&#xA;            if ((b) & (1U << (shift))) result += (a<<shift);&#xD;&#xA;        &#xD;&#xA;            UMUL16_STEP(a, b, 0);&#xD;&#xA;            UMUL16_STEP(a, b, 1);&#xD;&#xA;            UMUL16_STEP(a, b, 2);&#xD;&#xA;            UMUL16_STEP(a, b, 3);&#xD;&#xA;            UMUL16_STEP(a, b, 4);&#xD;&#xA;            UMUL16_STEP(a, b, 5);&#xD;&#xA;            UMUL16_STEP(a, b, 6);&#xD;&#xA;            UMUL16_STEP(a, b, 7);&#xD;&#xA;            UMUL16_STEP(a, b, 8);&#xD;&#xA;            UMUL16_STEP(a, b, 9);&#xD;&#xA;            UMUL16_STEP(a, b, 10);&#xD;&#xA;            UMUL16_STEP(a, b, 11);&#xD;&#xA;            UMUL16_STEP(a, b, 12);&#xD;&#xA;            UMUL16_STEP(a, b, 13);&#xD;&#xA;            UMUL16_STEP(a, b, 14);&#xD;&#xA;            UMUL16_STEP(a, b, 15);&#xD;&#xA;        &#xD;&#xA;            return result;&#xD;&#xA;        #undef UMUL16_STEP&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        test_t umul16_unrolledandlogic(test_t a, test_t b)&#xD;&#xA;        {&#xD;&#xA;        test_t result=0;&#xD;&#xA;        #define UMUL16_STEP(a, b, shift) \\&#xD;&#xA;        /*    if ((b) & (1U << (shift))) result += (a<<shift);*/\\&#xD;&#xA;            result+=  ((0 - !(!((b&(1U<<(shift)))))) & (a<<(shift)));&#xD;&#xA;        &#xD;&#xA;            UMUL16_STEP(a, b, 0);&#xD;&#xA;            UMUL16_STEP(a, b, 1);&#xD;&#xA;            UMUL16_STEP(a, b, 2);&#xD;&#xA;            UMUL16_STEP(a, b, 3);&#xD;&#xA;            UMUL16_STEP(a, b, 4);&#xD;&#xA;            UMUL16_STEP(a, b, 5);&#xD;&#xA;            UMUL16_STEP(a, b, 6);&#xD;&#xA;            UMUL16_STEP(a, b, 7);&#xD;&#xA;            UMUL16_STEP(a, b, 8);&#xD;&#xA;            UMUL16_STEP(a, b, 9);&#xD;&#xA;            UMUL16_STEP(a, b, 10);&#xD;&#xA;            UMUL16_STEP(a, b, 11);&#xD;&#xA;            UMUL16_STEP(a, b, 12);&#xD;&#xA;            UMUL16_STEP(a, b, 13);&#xD;&#xA;            UMUL16_STEP(a, b, 14);&#xD;&#xA;            UMUL16_STEP(a, b, 15);&#xD;&#xA;        &#xD;&#xA;            return result;&#xD;&#xA;        #undef UMUL16_STEP&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        test_t umul16_Antonio5(test_t a, test_t b)&#xD;&#xA;        {&#xD;&#xA;            test_t res = 0;&#xD;&#xA;        &#xD;&#xA;            uint8_t b0 = b & 0xff; //This should be optimized away&#xD;&#xA;            uint8_t b1 = b >>8; //This should be optimized away&#xD;&#xA;        &#xD;&#xA;            //Swapping probably doesn't make much sense anymore&#xD;&#xA;            if ( (b1 & 1) )&#xD;&#xA;                res+=(test_t)((uint8_t)(a && 0xff))*256;&#xD;&#xA;            //Hopefully the compiler understands it has simply to add the low 8bit register of a to the high 8bit register of res&#xD;&#xA;        &#xD;&#xA;            if ( (b0 & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;        &#xD;&#xA;            b1>>=1;&#xD;&#xA;            b0>>=1;&#xD;&#xA;            while (b0) {///N cycles, maximum 7&#xD;&#xA;                a+=a;&#xD;&#xA;                if ( (b1 & 1) )&#xD;&#xA;                    res+=(test_t)((uint8_t)(a & 0xff))*256;&#xD;&#xA;                if ( (b0 & 1) )&#xD;&#xA;                    res+=a;&#xD;&#xA;                b1>>=1;&#xD;&#xA;                b0>>=1; //I try to put as last the one that will leave the carry flag in the desired state&#xD;&#xA;            }&#xD;&#xA;        &#xD;&#xA;            uint8_t a0 = a & 0xff; //Again, not a real copy but a register selection&#xD;&#xA;        &#xD;&#xA;            while (b1) {///P cycles, maximum 7 - N cycles&#xD;&#xA;                a0+=a0;&#xD;&#xA;                if ( (b1 & 1) )&#xD;&#xA;                    res+=(test_t) a0 * 256;&#xD;&#xA;                b1>>=1;&#xD;&#xA;            }&#xD;&#xA;            return res;&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        test_t umul16_base(test_t a, test_t b)&#xD;&#xA;        {&#xD;&#xA;            test_t res=0;&#xD;&#xA;        &#xD;&#xA;            while (b) {&#xD;&#xA;                if ( (b & 1) )&#xD;&#xA;                    res+=a;&#xD;&#xA;                b>>=1;&#xD;&#xA;                a+=a;&#xD;&#xA;            }&#xD;&#xA;        &#xD;&#xA;            return res;&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        test_t umul16_baseandlogic(test_t a, test_t b)&#xD;&#xA;        {&#xD;&#xA;            test_t res=0;&#xD;&#xA;        &#xD;&#xA;            while (b) {&#xD;&#xA;                //if ( (b & 1) )&#xD;&#xA;                //    res+=a;&#xD;&#xA;                res+=  ((0 - !(!(b&1))) & a);&#xD;&#xA;                b>>=1;&#xD;&#xA;                a+=a;&#xD;&#xA;            }&#xD;&#xA;        &#xD;&#xA;            return res;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    test_t umul16_baseswap(test_t a, test_t b)&#xD;&#xA;    {&#xD;&#xA;        test_t res;&#xD;&#xA;    &#xD;&#xA;        if (a<b) {&#xD;&#xA;            res=a;&#xD;&#xA;            a=b;&#xD;&#xA;            b=res;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        res=0;&#xD;&#xA;        while (b) {&#xD;&#xA;            if ( (b & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;            b>>=1;&#xD;&#xA;            a+=a;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;       &#xD;&#xA;    test_t umul16_Antonio4(test_t a, test_t b)&#xD;&#xA;    {&#xD;&#xA;        uint8_t res1 = 0;&#xD;&#xA;    &#xD;&#xA;        uint8_t a0 = a & 0xff; //This effectively needs to copy the data&#xD;&#xA;        uint8_t b0 = b & 0xff; //This should be optimized away&#xD;&#xA;        uint8_t b1 = b >>8; //This should be optimized away&#xD;&#xA;    &#xD;&#xA;        //Here a0 and b1 could be swapped (to have b1 < a0)&#xD;&#xA;        if ( (b1 & 1) )&#xD;&#xA;            res1+=a0;&#xD;&#xA;        b1>>=1;&#xD;&#xA;        while (b1) {///Maximum 7 cycles&#xD;&#xA;            a0+=a0;&#xD;&#xA;            if ( (b1 & 1) )&#xD;&#xA;                res1+=a0;&#xD;&#xA;            b1>>=1;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        test_t res = (test_t) res1 * 256; //Should be optimized away, it's not even a copy!&#xD;&#xA;    &#xD;&#xA;        //Here swapping wouldn't make much sense&#xD;&#xA;        if ( (b0 & 1) )&#xD;&#xA;            res+=a;&#xD;&#xA;        b0>>=1;&#xD;&#xA;        while (b0) {///Maximum 7 cycles&#xD;&#xA;            a+=a;&#xD;&#xA;            if ( (b0 & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;            b0>>=1;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    test_t umul16_vect(test_t a, test_t b)&#xD;&#xA;    {&#xD;&#xA;        test_t c[2];&#xD;&#xA;    &#xD;&#xA;        c[0]=0;c[1]=a;a=0;&#xD;&#xA;        while (b) {&#xD;&#xA;            a+=c[(b & 1)];&#xD;&#xA;            b>>=1;&#xD;&#xA;            c[1]+=c[1];&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return a;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    test_t umul16_vectswap(test_t a, test_t b)&#xD;&#xA;    {&#xD;&#xA;        test_t c[2];&#xD;&#xA;    &#xD;&#xA;        if (a<b) {&#xD;&#xA;            c[1]=b;&#xD;&#xA;            b=a;&#xD;&#xA;            a=c[1];&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        c[0]=0;c[1]=a;a=0;&#xD;&#xA;        while (b) {&#xD;&#xA;            a+=c[(b & 1)];&#xD;&#xA;            b>>=1;&#xD;&#xA;            c[1]+=c[1];&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return a;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    test_t udiv_(test_t n,test_t d, test_t *r)&#xD;&#xA;    {&#xD;&#xA;        test_t q = 0,i,r_;&#xD;&#xA;    &#xD;&#xA;        r_=0;&#xD;&#xA;        if (d == 0) return (test_t)-1U; //error&#xD;&#xA;    &#xD;&#xA;        i= ( (test_t)(1) << ((sizeof(n)<<3)-1) );&#xD;&#xA;        for (;i!=0;i>>=1) {&#xD;&#xA;            r_ <<= 1;&#xD;&#xA;    &#xD;&#xA;            if (n&i)&#xD;&#xA;                r_ |= 1;&#xD;&#xA;    &#xD;&#xA;            if (r_ >= d) {&#xD;&#xA;                r_ -= d;&#xD;&#xA;                q |= i;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        if (r!=NULL)&#xD;&#xA;            *r=r_;&#xD;&#xA;    &#xD;&#xA;        return q;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;Here the include file (there's something strange for my purposes!!!):&#xD;&#xA;&#xD;&#xA;    #ifndef __UMUL_H&#xD;&#xA;    #define __UMUL_H&#xD;&#xA;    &#xD;&#xA;    #ifdef __AVR_ATtiny85__&#xD;&#xA;    /* You may think this is strange!!! But I need it! */&#xD;&#xA;    typedef signed int int8_t __attribute__((__mode__(__QI__)));&#xD;&#xA;    typedef unsigned int uint8_t __attribute__((__mode__(__QI__)));&#xD;&#xA;    typedef signed int int16_t __attribute__ ((__mode__ (__HI__)));&#xD;&#xA;    typedef unsigned int uint16_t __attribute__ ((__mode__ (__HI__)));&#xD;&#xA;    typedef signed int int32_t __attribute__ ((__mode__ (__SI__)));&#xD;&#xA;    typedef unsigned int uint32_t __attribute__ ((__mode__ (__SI__)));&#xD;&#xA;    typedef signed int int64_t __attribute__((__mode__(__DI__)));&#xD;&#xA;    typedef unsigned int uint64_t __attribute__((__mode__(__DI__)));&#xD;&#xA;    &#xD;&#xA;    #define NULL 0&#xD;&#xA;    #else&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    #include <stdint.h>&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    typedef uint16_t test_t;&#xD;&#xA;    &#xD;&#xA;    #ifdef __cplusplus&#xD;&#xA;    extern ""C"" {&#xD;&#xA;    #endif&#xD;&#xA;    test_t umul16_unrolled(test_t a, test_t b);&#xD;&#xA;    test_t umul16_unrolledandlogic(test_t a, test_t b);&#xD;&#xA;    test_t umul16_Antonio5(test_t a, test_t b);&#xD;&#xA;    test_t umul16_base(test_t a, test_t b);&#xD;&#xA;    test_t umul16_baseswap(test_t a, test_t b);&#xD;&#xA;    test_t umul16_Antonio4(test_t a, test_t b);&#xD;&#xA;    uint64_t umul(uint64_t a, uint64_t b);&#xD;&#xA;    test_t umul16_vect(test_t a, test_t b);&#xD;&#xA;    test_t umul16_vectswap(test_t a, test_t b);&#xD;&#xA;    test_t umul16_baseandlogic(test_t a, test_t b);&#xD;&#xA;    test_t udiv_(test_t n,test_t d, test_t *r);&#xD;&#xA;    &#xD;&#xA;    #ifdef __cplusplus&#xD;&#xA;    } // extern ""C""&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added 187 characters in body
89039304;29812009;4769313;5;280b4239-08cf-47bd-bcd6-7b4e65e40b03;2015-04-26 03:21:52.0;"I'm searching for an algorithm to multiply two integer numbers that is better than the one below. Do you have a good idea about that? (The MCU - AT Tiny 84/85 or similar - where this code runs has no mul/div operator)&#xD;&#xA;&#xD;&#xA;    uint16_t umul16_(uint16_t a, uint16_t b)&#xD;&#xA;    {&#xD;&#xA;        uint16_t res=0;&#xD;&#xA;    &#xD;&#xA;        while (b) {&#xD;&#xA;            if ( (b & 1) )&#xD;&#xA;                res+=a;&#xD;&#xA;            b>>=1;&#xD;&#xA;            a+=a;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return res;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This algorithm, when compiled for AT Tiny 85/84 using the avr-gcc compiler, is almost identical to the algorithm __mulhi3 the avr-gcc generates.&#xD;&#xA;&#xD;&#xA;avr-gcc algorithm:&#xD;&#xA;&#xD;&#xA;    00000106 <__mulhi3>:&#xD;&#xA;     106:	00 24       	eor	r0, r0&#xD;&#xA;     108:	55 27       	eor	r21, r21&#xD;&#xA;     10a:	04 c0       	rjmp	.+8      	; 0x114 <__mulhi3+0xe>&#xD;&#xA;     10c:	08 0e       	add	r0, r24&#xD;&#xA;     10e:	59 1f       	adc	r21, r25&#xD;&#xA;     110:	88 0f       	add	r24, r24&#xD;&#xA;     112:	99 1f       	adc	r25, r25&#xD;&#xA;     114:	00 97       	sbiw	r24, 0x00	; 0&#xD;&#xA;     116:	29 f0       	breq	.+10     	; 0x122 <__mulhi3+0x1c>&#xD;&#xA;     118:	76 95       	lsr	r23&#xD;&#xA;     11a:	67 95       	ror	r22&#xD;&#xA;     11c:	b8 f3       	brcs	.-18     	; 0x10c <__mulhi3+0x6>&#xD;&#xA;     11e:	71 05       	cpc	r23, r1&#xD;&#xA;     120:	b9 f7       	brne	.-18     	; 0x110 <__mulhi3+0xa>&#xD;&#xA;     122:	80 2d       	mov	r24, r0&#xD;&#xA;     124:	95 2f       	mov	r25, r21&#xD;&#xA;     126:	08 95       	ret&#xD;&#xA;&#xD;&#xA;umul16_ algorithm:&#xD;&#xA;&#xD;&#xA;    00000044 <umul16_>:&#xD;&#xA;      44:	20 e0       	ldi	r18, 0x00	; 0&#xD;&#xA;      46:	30 e0       	ldi	r19, 0x00	; 0&#xD;&#xA;      48:	61 15       	cp	r22, r1&#xD;&#xA;      4a:	71 05       	cpc	r23, r1&#xD;&#xA;      4c:	49 f0       	breq	.+18     	; 0x60 <umul16_+0x1c>&#xD;&#xA;      4e:	60 ff       	sbrs	r22, 0&#xD;&#xA;      50:	02 c0       	rjmp	.+4      	; 0x56 <umul16_+0x12>&#xD;&#xA;      52:	28 0f       	add	r18, r24&#xD;&#xA;      54:	39 1f       	adc	r19, r25&#xD;&#xA;      56:	76 95       	lsr	r23&#xD;&#xA;      58:	67 95       	ror	r22&#xD;&#xA;      5a:	88 0f       	add	r24, r24&#xD;&#xA;      5c:	99 1f       	adc	r25, r25&#xD;&#xA;      5e:	f4 cf       	rjmp	.-24     	; 0x48 <umul16_+0x4>&#xD;&#xA;      60:	c9 01       	movw	r24, r18&#xD;&#xA;      62:	08 95       	ret&#xD;&#xA;&#xD;&#xA;<hr/>&#xD;&#xA;**Edit:** The instruction set is available [here](http://www.atmel.com/Images/8006S.pdf).&#xD;&#xA;&#xD;&#xA;";;The benchmark is to be rewrited!
