Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
9488060;4494490;464331;2;a27311f3-23e9-4eb9-b1f7-9bbcfb1b7a3b;2010-12-20 22:13:32.0;"This question seems to be very similar to what you are trying to achieve, and it worked for the asker.&#xD;&#xA;&#xD;&#xA;http://stackoverflow.com/questions/4356798/merge-dll-into-c-assembly/4382512#4382512&#xD;&#xA;&#xD;&#xA;Are you doing something differently?";;
9488197;4494490;464331;5;aa34c223-e462-4442-b3a4-f24bed6b210e;2010-12-20 22:21:24.0;"This question seems to be very similar to what you are trying to achieve, and it worked for the asker.&#xD;&#xA;&#xD;&#xA;http://stackoverflow.com/questions/4356798/merge-dll-into-c-assembly/4382512#4382512&#xD;&#xA;&#xD;&#xA;Are you doing something differently? Specifically, if you're targetting an older version of the .NET Framework, maybe that's a hint for understanding why your application is behaving differently.";;added 159 characters in body
9488295;4494490;464331;5;87bbf63a-4c44-4334-b450-077125dd0f74;2010-12-20 22:27:42.0;"This question seems to be very similar to what you are trying to achieve, and it worked for the asker.&#xD;&#xA;&#xD;&#xA;http://stackoverflow.com/questions/4356798/merge-dll-into-c-assembly/4382512#4382512&#xD;&#xA;&#xD;&#xA;Are you doing something differently? Specifically, if you're targetting an older version of the .NET Framework, maybe that's a hint for understanding why your application is behaving differently.&#xD;&#xA;&#xD;&#xA;Another direction, use a tool such as [Fusion Log Viewer](http://msdn.microsoft.com/en-us/library/e74a18c4.aspx) to analyze what was going on when you tried to load the assembly. This may give some more hints. If you manage to get log information, posting it in the question may help someone figure it out.";;added 310 characters in body
9494444;4494490;464331;5;3acf0d2b-6aba-42b0-bbc6-5c8bae870ef6;2010-12-21 08:18:18.0;"This question seems to be very similar to what you are trying to achieve, and it worked for the asker.&#xD;&#xA;&#xD;&#xA;http://stackoverflow.com/questions/4356798/merge-dll-into-c-assembly/4382512#4382512&#xD;&#xA;&#xD;&#xA;Are you doing something differently? Specifically, if you're targetting an older version of the .NET Framework, maybe that's a hint for understanding why your application is behaving differently.&#xD;&#xA;&#xD;&#xA;Another direction, use a tool such as [Fusion Log Viewer](http://msdn.microsoft.com/en-us/library/e74a18c4.aspx) to analyze what was going on when you tried to load the assembly. This may give some more hints. If you manage to get log information, posting it in the question may help someone figure it out.&#xD;&#xA;&#xD;&#xA;**EDIT: Another explanation, following your comment.**&#xD;&#xA;&#xD;&#xA;Well, I think I know what the problem is.&#xD;&#xA;&#xD;&#xA;In your `Main` method, you are refering to the type in the other dll. But you are doing it in `static` code, i.e. you use the type explicitly in the code (as opposed to loading it dynamically by its name).&#xD;&#xA;&#xD;&#xA;Why is this a problem? The CLR tries to load your assembly *in order to JIT* `Main` itself.&#xD;&#xA;&#xD;&#xA;Your `FileNotFoundException` was thrown while `Main` was being compiled. It didn't even start running, and therefore your event handler wasn't registered.&#xD;&#xA;&#xD;&#xA;A simple way to check if I'm right is to change the code to something like this:&#xD;&#xA;&#xD;&#xA;    static public void Main(string[] args)&#xD;&#xA;    {&#xD;&#xA;        AppDomain.CurrentDomain.AssemblyResolve += MyEventHandler;&#xD;&#xA;        DeferredMain();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    static public void DeferredMain()&#xD;&#xA;    {&#xD;&#xA;        using(var thing = new Thing())&#xD;&#xA;        {&#xD;&#xA;             // now the event will be triggered, still on JIT and not on execution...&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The important difference is that `Main` has no dependency on another assembly, so there will be no problem to JIT and run it.&#xD;&#xA;&#xD;&#xA;By the time `DeferredMain` is being JIT'ed, your event handler is already in place so you can manually load the assembly.&#xD;&#xA;&#xD;&#xA;By the way, to avoid another possible similar pitfall, make sure that the class in which `Main` is defined doesn't have any field with a type from the other assembly, because in this case also, the CLR will try loading the assembly before `Main` starts, in order to compile it.";;"added 1325 characters in body; added 59 characters in body; added 157 characters in body"
9494609;4494490;464331;5;37cf8245-0a47-42e3-904d-ea7d43dd661c;2010-12-21 08:31:04.0;"This question seems to be very similar to what you are trying to achieve, and it worked for the asker.&#xD;&#xA;&#xD;&#xA;http://stackoverflow.com/questions/4356798/merge-dll-into-c-assembly/4382512#4382512&#xD;&#xA;&#xD;&#xA;Are you doing something differently? Specifically, if you're targetting an older version of the .NET Framework, maybe that's a hint for understanding why your application is behaving differently.&#xD;&#xA;&#xD;&#xA;Another direction, use a tool such as [Fusion Log Viewer](http://msdn.microsoft.com/en-us/library/e74a18c4.aspx) to analyze what was going on when you tried to load the assembly. This may give some more hints. If you manage to get log information, posting it in the question may help someone figure it out.&#xD;&#xA;&#xD;&#xA;**EDIT: Another explanation, following your comment.**&#xD;&#xA;&#xD;&#xA;Well, I think I know what the problem is.&#xD;&#xA;&#xD;&#xA;In your `Main` method, you are refering to the type in the other dll. But you are doing it in `static` code, i.e. you use the type explicitly in the code (as opposed to loading it dynamically by its name).&#xD;&#xA;&#xD;&#xA;Why is this a problem? The CLR tries to load your assembly *in order to JIT* `Main` itself.&#xD;&#xA;&#xD;&#xA;Your `FileNotFoundException` was thrown while `Main` was being compiled. It didn't even start running, and therefore your event handler wasn't registered.&#xD;&#xA;&#xD;&#xA;A simple way to check if I'm right is to change the code to something like this:&#xD;&#xA;&#xD;&#xA;    static public void Main(string[] args)&#xD;&#xA;    {&#xD;&#xA;        AppDomain.CurrentDomain.AssemblyResolve += MyEventHandler;&#xD;&#xA;        MyMain();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // The CLR will actually try to load your assembly before even starting the execution&#xD;&#xA;    // of this method. It needs the assembly in order to JIT the method because it has to know&#xD;&#xA;    // the Thing type.&#xD;&#xA;    static public void MyMain()&#xD;&#xA;    {&#xD;&#xA;        using(var thing = new Thing())&#xD;&#xA;        {&#xD;&#xA;             // ...&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The important difference is that `Main` has no dependency on another assembly, so there will be no problem to JIT and run it.&#xD;&#xA;&#xD;&#xA;By the time `MyMain` is being JIT'ed, your event handler is already in place so you can manually load the assembly.&#xD;&#xA;&#xD;&#xA;By the way, to avoid another possible similar pitfall, make sure that the class in which `Main` is defined doesn't have any field with a type from the other assembly, because in this case also, the CLR will try loading the assembly before `Main` starts, in order to compile it.";;"deleted 18 characters in body; added 110 characters in body; added 35 characters in body"
9494676;4494490;464331;5;b6f33f9d-2e72-48b1-9fd2-bf6aa22eec1a;2010-12-21 08:36:16.0;"This question seems to be very similar to what you are trying to achieve, and it worked for the asker.&#xD;&#xA;&#xD;&#xA;http://stackoverflow.com/questions/4356798/merge-dll-into-c-assembly/4382512#4382512&#xD;&#xA;&#xD;&#xA;Are you doing something differently? Specifically, if you're targetting an older version of the .NET Framework, maybe that's a hint for understanding why your application is behaving differently.&#xD;&#xA;&#xD;&#xA;Another direction, use a tool such as [Fusion Log Viewer](http://msdn.microsoft.com/en-us/library/e74a18c4.aspx) to analyze what was going on when you tried to load the assembly. This may give some more hints. If you manage to get log information, posting it in the question may help someone figure it out.&#xD;&#xA;&#xD;&#xA;**EDIT: Another explanation, following your comment.**&#xD;&#xA;&#xD;&#xA;Well, now I think I know what the problem is. &#xD;&#xA;&#xD;&#xA;In your `Main` method, you are refering to the type in the other dll. But you are doing it in `static` code, i.e. you use the type explicitly in the code (as opposed to loading it dynamically by its name).&#xD;&#xA;&#xD;&#xA;Why is this a problem? The CLR tries to load your assembly *in order to JIT* `Main` itself.&#xD;&#xA;&#xD;&#xA;Your `FileNotFoundException` was thrown while `Main` was being compiled. It didn't even start running, and therefore your event handler wasn't registered.&#xD;&#xA;&#xD;&#xA;A simple way to check if I'm right is to change the code to something like this:&#xD;&#xA;&#xD;&#xA;    static public void Main(string[] args)&#xD;&#xA;    {&#xD;&#xA;        AppDomain.CurrentDomain.AssemblyResolve += MyEventHandler;&#xD;&#xA;        MyMain();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // The CLR will actually try to load your assembly before even starting the execution&#xD;&#xA;    // of this method. It needs the assembly in order to JIT the method because it has to &#xD;&#xA;    // know the Thing type.&#xD;&#xA;    static public void MyMain()&#xD;&#xA;    {&#xD;&#xA;        using(var thing = new Thing())&#xD;&#xA;        {&#xD;&#xA;             // ...&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The important difference is that `Main` has no dependency on another assembly, so there will be no problem to JIT and run it.&#xD;&#xA;&#xD;&#xA;By the time `MyMain` is being JIT'ed, your event handler is already in place so you can manually load the assembly.&#xD;&#xA;&#xD;&#xA;By the way, to avoid another possible similar pitfall, make sure that the class in which `Main` is defined doesn't have any field with a type from the other assembly, because in this case also, the CLR will try loading the assembly before `Main` starts, in order to compile it.";;"added 1 characters in body; added 98 characters in body; deleted 93 characters in body"
9494769;4494490;464331;5;64d1f738-4975-4936-9e88-003add2231e7;2010-12-21 08:42:17.0;"This question seems to be very similar to what you are trying to achieve, and it worked for the asker.&#xD;&#xA;&#xD;&#xA;http://stackoverflow.com/questions/4356798/merge-dll-into-c-assembly/4382512#4382512&#xD;&#xA;&#xD;&#xA;Are you doing something differently? Specifically, if you're targetting an older version of the .NET Framework, maybe that's a hint for understanding why your application is behaving differently.&#xD;&#xA;&#xD;&#xA;Another direction, use a tool such as [Fusion Log Viewer](http://msdn.microsoft.com/en-us/library/e74a18c4.aspx) to analyze what was going on when you tried to load the assembly. This may give some more hints. If you manage to get log information, posting it in the question may help someone figure it out.&#xD;&#xA;&#xD;&#xA;**EDIT: Another explanation, following your comment.**&#xD;&#xA;&#xD;&#xA;Well, now I think I know what the problem is. &#xD;&#xA;&#xD;&#xA;In your `Main` method, you are refering to the type in the other dll. But you are doing it in `static` code, i.e. you use the type explicitly in the code (as opposed to loading it dynamically by its name).&#xD;&#xA;&#xD;&#xA;Why is this a problem? The CLR tries to load your assembly *in order to JIT* `Main` itself.&#xD;&#xA;&#xD;&#xA;Your `FileNotFoundException` was thrown while `Main` was being compiled. `Main` didn't even start running, and therefore your event handler wasn't registered.&#xD;&#xA;&#xD;&#xA;A simple way to check if I'm right is to change the code to something like this:&#xD;&#xA;&#xD;&#xA;    static public void Main(string[] args)&#xD;&#xA;    {&#xD;&#xA;        AppDomain.CurrentDomain.AssemblyResolve += MyEventHandler;&#xD;&#xA;        MyMain();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // The CLR will actually try to load your assembly before even starting the execution&#xD;&#xA;    // of this method. It needs the assembly in order to JIT the method because it has to &#xD;&#xA;    // know the Thing type.&#xD;&#xA;    static public void MyMain()&#xD;&#xA;    {&#xD;&#xA;        using(var thing = new Thing())&#xD;&#xA;        {&#xD;&#xA;             // ...&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The important difference is that `Main` has no dependency on another assembly, so there will be no problem to JIT and run it.&#xD;&#xA;&#xD;&#xA;By the time `MyMain` is being JIT'ed, your event handler is already in place so you can manually load the assembly.&#xD;&#xA;&#xD;&#xA;By the way, to avoid another possible similar pitfall, make sure that the class in which `Main` is defined doesn't have any field with a type from the other assembly, because in this case also, the CLR will try loading the assembly before `Main` starts, in order to compile it.";;added 4 characters in body
9523132;4494490;464331;5;6c601fa2-618e-4846-9ec7-7260ae673ed9;2010-12-22 14:55:53.0;"This question seems to be very similar to what you are trying to achieve, and it worked for the asker.&#xD;&#xA;&#xD;&#xA;http://stackoverflow.com/questions/4356798/merge-dll-into-c-assembly/4382512#4382512&#xD;&#xA;&#xD;&#xA;Are you doing something differently? Specifically, if you're targetting an older version of the .NET Framework, maybe that's a hint for understanding why your application is behaving differently.&#xD;&#xA;&#xD;&#xA;Another direction, use a tool such as [Fusion Log Viewer](http://msdn.microsoft.com/en-us/library/e74a18c4.aspx) to analyze what was going on when you tried to load the assembly. This may give some more hints. If you manage to get log information, posting it in the question may help someone figure it out.&#xD;&#xA;&#xD;&#xA;**EDIT: Another explanation, following your comment.**&#xD;&#xA;&#xD;&#xA;Well, now I think I know what the problem is. &#xD;&#xA;&#xD;&#xA;In your `Main` method, you are refering to the type in the other dll. But you are doing it in *static* code, i.e. you use the type explicitly in the code (as opposed to loading it dynamically by its name).&#xD;&#xA;&#xD;&#xA;Why is this a problem? The CLR tries to load your assembly *in order to JIT* `Main` itself.&#xD;&#xA;&#xD;&#xA;Your `FileNotFoundException` was thrown while `Main` was being compiled. `Main` didn't even start running, and therefore your event handler wasn't registered.&#xD;&#xA;&#xD;&#xA;A simple way to check if I'm right is to change the code to something like this:&#xD;&#xA;&#xD;&#xA;    static public void Main(string[] args)&#xD;&#xA;    {&#xD;&#xA;        AppDomain.CurrentDomain.AssemblyResolve += MyEventHandler;&#xD;&#xA;        MyMain();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // The CLR will actually try to load your assembly before even starting the execution&#xD;&#xA;    // of this method. It needs the assembly in order to JIT the method because it has to &#xD;&#xA;    // know the Thing type.&#xD;&#xA;    static public void MyMain()&#xD;&#xA;    {&#xD;&#xA;        using(var thing = new Thing())&#xD;&#xA;        {&#xD;&#xA;             // ...&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The important difference is that `Main` has no dependency on another assembly, so there will be no problem to JIT and run it.&#xD;&#xA;&#xD;&#xA;By the time `MyMain` is being JIT'ed, your event handler is already in place so you can manually load the assembly.&#xD;&#xA;&#xD;&#xA;By the way, to avoid another possible similar pitfall, make sure that the class in which `Main` is defined doesn't have any field with a type from the other assembly, because in this case also, the CLR will try loading the assembly before `Main` starts, in order to compile it.";;edited body
147546862;4494490;-1;5;1bbfdcc5-ef0b-4f4b-8c20-2642f6c63c05;2017-05-23 12:28:22.0;"This question seems to be very similar to what you are trying to achieve, and it worked for the asker.&#xD;&#xA;&#xD;&#xA;https://stackoverflow.com/questions/4356798/merge-dll-into-c-assembly/4382512#4382512&#xD;&#xA;&#xD;&#xA;Are you doing something differently? Specifically, if you're targetting an older version of the .NET Framework, maybe that's a hint for understanding why your application is behaving differently.&#xD;&#xA;&#xD;&#xA;Another direction, use a tool such as [Fusion Log Viewer](http://msdn.microsoft.com/en-us/library/e74a18c4.aspx) to analyze what was going on when you tried to load the assembly. This may give some more hints. If you manage to get log information, posting it in the question may help someone figure it out.&#xD;&#xA;&#xD;&#xA;**EDIT: Another explanation, following your comment.**&#xD;&#xA;&#xD;&#xA;Well, now I think I know what the problem is. &#xD;&#xA;&#xD;&#xA;In your `Main` method, you are refering to the type in the other dll. But you are doing it in *static* code, i.e. you use the type explicitly in the code (as opposed to loading it dynamically by its name).&#xD;&#xA;&#xD;&#xA;Why is this a problem? The CLR tries to load your assembly *in order to JIT* `Main` itself.&#xD;&#xA;&#xD;&#xA;Your `FileNotFoundException` was thrown while `Main` was being compiled. `Main` didn't even start running, and therefore your event handler wasn't registered.&#xD;&#xA;&#xD;&#xA;A simple way to check if I'm right is to change the code to something like this:&#xD;&#xA;&#xD;&#xA;    static public void Main(string[] args)&#xD;&#xA;    {&#xD;&#xA;        AppDomain.CurrentDomain.AssemblyResolve += MyEventHandler;&#xD;&#xA;        MyMain();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // The CLR will actually try to load your assembly before even starting the execution&#xD;&#xA;    // of this method. It needs the assembly in order to JIT the method because it has to &#xD;&#xA;    // know the Thing type.&#xD;&#xA;    static public void MyMain()&#xD;&#xA;    {&#xD;&#xA;        using(var thing = new Thing())&#xD;&#xA;        {&#xD;&#xA;             // ...&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The important difference is that `Main` has no dependency on another assembly, so there will be no problem to JIT and run it.&#xD;&#xA;&#xD;&#xA;By the time `MyMain` is being JIT'ed, your event handler is already in place so you can manually load the assembly.&#xD;&#xA;&#xD;&#xA;By the way, to avoid another possible similar pitfall, make sure that the class in which `Main` is defined doesn't have any field with a type from the other assembly, because in this case also, the CLR will try loading the assembly before `Main` starts, in order to compile it.";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
