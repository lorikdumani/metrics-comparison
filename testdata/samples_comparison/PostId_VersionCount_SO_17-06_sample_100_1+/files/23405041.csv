Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
64137670;23405041;2855480;2;f11abdab-98ee-409a-9915-3e5b5b702f6b;2014-05-01 09:20:34.0;"After consideration, here's a solution I've come up with after finding the following article...&#xD;&#xA;&#xD;&#xA;<http://jendaperl.blogspot.co.uk/2010/10/attributeproviderattribute-rendered.html>&#xD;&#xA;&#xD;&#xA;Create a new attribute as below...&#xD;&#xA;&#xD;&#xA;    using System.ComponentModel;&#xD;&#xA;&#xD;&#xA;    namespace MyApp.ViewModels&#xD;&#xA;    {&#xD;&#xA;        public class AttributesFromAttribute : AttributeProviderAttribute&#xD;&#xA;        {&#xD;&#xA;            public AttributesFromAttribute(Type type, string property)&#xD;&#xA;                : base(type.AssemblyQualifiedName, property)&#xD;&#xA;            {&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public T GetInheritedAttributeOfType<T>() where T : System.Attribute&#xD;&#xA;            {&#xD;&#xA;                Dictionary<string,object> attrs = Type.GetType(this.TypeName).GetProperty(this.PropertyName).GetCustomAttributes(true).ToDictionary(a => a.GetType().Name, a => a);&#xD;&#xA;                return attrs.Values.OfType<T>().FirstOrDefault();&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;now you can just add the following to the relevant property in the view model class...&#xD;&#xA;&#xD;&#xA;    [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""UserName"")]&#xD;&#xA;&#xD;&#xA;e.g...&#xD;&#xA;&#xD;&#xA;    public class RegisterViewModel&#xD;&#xA;    {&#xD;&#xA;        public UserAccount UserAccount { get; set; }&#xD;&#xA;        public RegisterViewModel()&#xD;&#xA;        {&#xD;&#xA;            UserAccount = new UserAccount();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""UserName"")]&#xD;&#xA;        string UserName { get; set; }&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""Password"")]&#xD;&#xA;        string Password { get; set; }&#xD;&#xA;&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""Password"")]&#xD;&#xA;        [Display(Name = ""Confirm Password"", Prompt = ""Confirm Password""), Compare(""Password"", ErrorMessage = ""Your confirmation doesn't match."")]&#xD;&#xA;        public string PasswordConfirmation { get; set; }&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This then gives copying of attributes that can be overridden (as with PasswordConfirmation above) allowing for multiple data models in the same viewmodel and if you need to access the inherited attributes from code, you can do so using the GetInheritedAttributeOfType method. For example...&#xD;&#xA;&#xD;&#xA;    public static class AttrHelper&#xD;&#xA;    {&#xD;&#xA;       public static T GetAttributeOfType<T>(this ViewDataDictionary viewData) where T : System.Attribute&#xD;&#xA;        {&#xD;&#xA;            var metadata = viewData.ModelMetadata;&#xD;&#xA;            var prop = metadata.ContainerType.GetProperty(metadata.PropertyName);&#xD;&#xA;            var attrs = prop.GetCustomAttributes(false);&#xD;&#xA;&#xD;&#xA;            // Try and get the attribute directly from the property.&#xD;&#xA;            T ret = attrs.OfType<T>().FirstOrDefault();&#xD;&#xA;&#xD;&#xA;            // If there isn't one, look at inherited attribute info if there is any.&#xD;&#xA;            if(ret == default(T))&#xD;&#xA;            {&#xD;&#xA;                AttributesFromAttribute inheritedAttributes = attrs.OfType<AttributesFromAttribute>().FirstOrDefault();&#xD;&#xA;                if (inheritedAttributes != null)&#xD;&#xA;                {&#xD;&#xA;                    ret = inheritedAttributes.GetInheritedAttributeOfType<T>();&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            // return what we've found.&#xD;&#xA;            return ret;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This can be called from an Editor Template for example...&#xD;&#xA;&#xD;&#xA;    var dataTypeAttr = AttrHelper.GetAttributeOfType<DataTypeAttribute>(ViewData);&#xD;&#xA;&#xD;&#xA;which will first look at the viewmodel's property attributes directly but if nothing's found it will look at the inherited attributes with it's call to GetInheritedAttributeOfType.&#xD;&#xA;&#xD;&#xA;I'm not sure there's a definitive right answer, but this works best for me because I feel that current practice of repeating DataAnnotations in viewmodels as well as the datamodels isn't great for maintainability or reuse and encapsulating the datamodels in the viewmodels without Properties works, but validation is lacking upfront on the encapsulated objects requiring additional validation routines.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;
64141685;23405041;2855480;5;8aa7965f-de8b-462c-b777-998deb1d164f;2014-05-01 10:26:39.0;"After consideration, here's a solution I've come up with after finding the following article...&#xD;&#xA;&#xD;&#xA;<http://jendaperl.blogspot.co.uk/2010/10/attributeproviderattribute-rendered.html>&#xD;&#xA;&#xD;&#xA;Create a new attribute as below...&#xD;&#xA;&#xD;&#xA;    using System.ComponentModel;&#xD;&#xA;&#xD;&#xA;    namespace MyApp.ViewModels&#xD;&#xA;    {&#xD;&#xA;        public class AttributesFromAttribute : AttributeProviderAttribute&#xD;&#xA;        {&#xD;&#xA;            public AttributesFromAttribute(Type type, string property)&#xD;&#xA;                : base(type.AssemblyQualifiedName, property)&#xD;&#xA;            {&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public T GetInheritedAttributeOfType<T>() where T : System.Attribute&#xD;&#xA;            {&#xD;&#xA;                Dictionary<string,object> attrs = Type.GetType(this.TypeName).GetProperty(this.PropertyName).GetCustomAttributes(true).ToDictionary(a => a.GetType().Name, a => a);&#xD;&#xA;                return attrs.Values.OfType<T>().FirstOrDefault();&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;now you can just add the following to the relevant property in the view model class...&#xD;&#xA;&#xD;&#xA;    [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""UserName"")]&#xD;&#xA;&#xD;&#xA;e.g...&#xD;&#xA;&#xD;&#xA;    public class RegisterViewModel&#xD;&#xA;    {&#xD;&#xA;        public UserAccount UserAccount { get; set; }&#xD;&#xA;        public RegisterViewModel()&#xD;&#xA;        {&#xD;&#xA;            UserAccount = new UserAccount();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""UserName"")]&#xD;&#xA;        string UserName { get; set; }&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""Password"")]&#xD;&#xA;        string Password { get; set; }&#xD;&#xA;&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""Password"")]&#xD;&#xA;        [Display(Name = ""Confirm Password"", Prompt = ""Confirm Password""), Compare(""Password"", ErrorMessage = ""Your confirmation doesn't match."")]&#xD;&#xA;        public string PasswordConfirmation { get; set; }&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This then gives copying of attributes that can be overridden (as with PasswordConfirmation above) allowing for multiple data models in the same viewmodel and if you need to access the inherited attributes from code, you can do so using the GetInheritedAttributeOfType method. For example...&#xD;&#xA;&#xD;&#xA;    public static class AttrHelper&#xD;&#xA;    {&#xD;&#xA;       public static T GetAttributeOfType<T>(this ViewDataDictionary viewData) where T : System.Attribute&#xD;&#xA;        {&#xD;&#xA;            var metadata = viewData.ModelMetadata;&#xD;&#xA;            var prop = metadata.ContainerType.GetProperty(metadata.PropertyName);&#xD;&#xA;            var attrs = prop.GetCustomAttributes(false);&#xD;&#xA;&#xD;&#xA;            // Try and get the attribute directly from the property.&#xD;&#xA;            T ret = attrs.OfType<T>().FirstOrDefault();&#xD;&#xA;&#xD;&#xA;            // If there isn't one, look at inherited attribute info if there is any.&#xD;&#xA;            if(ret == default(T))&#xD;&#xA;            {&#xD;&#xA;                AttributesFromAttribute inheritedAttributes = attrs.OfType<AttributesFromAttribute>().FirstOrDefault();&#xD;&#xA;                if (inheritedAttributes != null)&#xD;&#xA;                {&#xD;&#xA;                    ret = inheritedAttributes.GetInheritedAttributeOfType<T>();&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            // return what we've found.&#xD;&#xA;            return ret;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This can be called from an Editor Template for example...&#xD;&#xA;&#xD;&#xA;    var dataTypeAttr = AttrHelper.GetAttributeOfType<DataTypeAttribute>(ViewData);&#xD;&#xA;&#xD;&#xA;which will first look at the viewmodel's property attributes directly but if nothing's found it will look at the inherited attributes with it's call to GetInheritedAttributeOfType.&#xD;&#xA;&#xD;&#xA;I'm not sure there's a definitive right answer, but this works best for me because I feel that current practice of repeating DataAnnotations in viewmodels as well as the datamodels isn't great for maintainability or reuse and encapsulating the datamodels in the viewmodels without Properties works, but validation is lacking upfront as ModelState.IsValid reports true based on the current object, it doesn't check encapsulated objects.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;clarification of where encapsulation of datamodels falls down
64219498;23405041;2855480;5;d7ffed05-e347-49f6-a8d0-e3d7ce151505;2014-05-02 10:40:00.0;"Here's the solution I've come up with after consideration of the other possible solutions possed. It's based on finding the following article, my reasons for this over others are stated at the bottom of this post...&#xD;&#xA;&#xD;&#xA;<http://jendaperl.blogspot.co.uk/2010/10/attributeproviderattribute-rendered.html>&#xD;&#xA;&#xD;&#xA;Create a new attribute as below...&#xD;&#xA;&#xD;&#xA;    using System.ComponentModel;&#xD;&#xA;&#xD;&#xA;    namespace MyApp.ViewModels&#xD;&#xA;    {&#xD;&#xA;        public class AttributesFromAttribute : AttributeProviderAttribute&#xD;&#xA;        {&#xD;&#xA;            public AttributesFromAttribute(Type type, string property)&#xD;&#xA;                : base(type.AssemblyQualifiedName, property)&#xD;&#xA;            {&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public T GetInheritedAttributeOfType<T>() where T : System.Attribute&#xD;&#xA;            {&#xD;&#xA;                Dictionary<string,object> attrs = Type.GetType(this.TypeName).GetProperty(this.PropertyName).GetCustomAttributes(true).ToDictionary(a => a.GetType().Name, a => a);&#xD;&#xA;                return attrs.Values.OfType<T>().FirstOrDefault();&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;now you can just add the following to the relevant property in the view model class...&#xD;&#xA;&#xD;&#xA;    [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""UserName"")]&#xD;&#xA;&#xD;&#xA;e.g...&#xD;&#xA;&#xD;&#xA;    public class RegisterViewModel&#xD;&#xA;    {&#xD;&#xA;        public UserAccount UserAccount { get; set; }&#xD;&#xA;        public RegisterViewModel()&#xD;&#xA;        {&#xD;&#xA;            UserAccount = new UserAccount();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""UserName"")]&#xD;&#xA;        string UserName { get; set; }&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""Password"")]&#xD;&#xA;        string Password { get; set; }&#xD;&#xA;&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""Password"")]&#xD;&#xA;        [Display(Name = ""Confirm Password"", Prompt = ""Confirm Password""), Compare(""Password"", ErrorMessage = ""Your confirmation doesn't match."")]&#xD;&#xA;        public string PasswordConfirmation { get; set; }&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This then gives copying of attributes that can be overridden (as with PasswordConfirmation above) allowing for multiple data models in the same viewmodel and if you need to access the inherited attributes from code, you can do so using the GetInheritedAttributeOfType method. For example...&#xD;&#xA;&#xD;&#xA;    public static class AttrHelper&#xD;&#xA;    {&#xD;&#xA;       public static T GetAttributeOfType<T>(this ViewDataDictionary viewData) where T : System.Attribute&#xD;&#xA;        {&#xD;&#xA;            var metadata = viewData.ModelMetadata;&#xD;&#xA;            var prop = metadata.ContainerType.GetProperty(metadata.PropertyName);&#xD;&#xA;            var attrs = prop.GetCustomAttributes(false);&#xD;&#xA;&#xD;&#xA;            // Try and get the attribute directly from the property.&#xD;&#xA;            T ret = attrs.OfType<T>().FirstOrDefault();&#xD;&#xA;&#xD;&#xA;            // If there isn't one, look at inherited attribute info if there is any.&#xD;&#xA;            if(ret == default(T))&#xD;&#xA;            {&#xD;&#xA;                AttributesFromAttribute inheritedAttributes = attrs.OfType<AttributesFromAttribute>().FirstOrDefault();&#xD;&#xA;                if (inheritedAttributes != null)&#xD;&#xA;                {&#xD;&#xA;                    ret = inheritedAttributes.GetInheritedAttributeOfType<T>();&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            // return what we've found.&#xD;&#xA;            return ret;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This can be called from an Editor Template for example...&#xD;&#xA;&#xD;&#xA;    var dataTypeAttr = AttrHelper.GetAttributeOfType<DataTypeAttribute>(ViewData);&#xD;&#xA;&#xD;&#xA;which will first look at the viewmodel's property attributes directly but if nothing's found it will look at the inherited attributes with it's call to GetInheritedAttributeOfType.&#xD;&#xA;&#xD;&#xA;I'm not sure there's a definitive right answer, but this works best for me because I feel that current practice of repeating DataAnnotations in viewmodels as well as the datamodels isn't great for maintainability or reuse and encapsulating the datamodels in the viewmodels without Properties works, but validation is lacking upfront as ModelState.IsValid reports true based on the current object, it doesn't check encapsulated objects.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;Changed wording now that I've decided it's the correct solution for me.
64220555;23405041;2855480;5;6b7da0e3-2cea-47b4-b6df-9efb36a8122c;2014-05-02 10:54:33.0;"Here's the solution I've come up with after consideration of the other possible solutions posed. It's based on finding the following article...&#xD;&#xA;&#xD;&#xA;<http://jendaperl.blogspot.co.uk/2010/10/attributeproviderattribute-rendered.html>&#xD;&#xA;&#xD;&#xA;My reasons for this over others are stated at the bottom of this post.&#xD;&#xA;&#xD;&#xA;Having an existing Data Model class of...&#xD;&#xA;&#xD;&#xA;    public class UserAccount&#xD;&#xA;    {&#xD;&#xA;         [Display(Name = ""Username"", Prompt = ""Login As""), Required()]&#xD;&#xA;         string UserName { get; set; }&#xD;&#xA;         [Display(Name = ""Password"", Prompt = ""Password""), Required(), DataType(DataType.Password), StringLength(255, MinimumLength = 7, ErrorMessage = ""The password must be at least 7 characters"")]&#xD;&#xA;         string Password { get; set; }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Create a new attribute as below...&#xD;&#xA;&#xD;&#xA;    using System.ComponentModel;&#xD;&#xA;&#xD;&#xA;    namespace MyApp.ViewModels&#xD;&#xA;    {&#xD;&#xA;        public class AttributesFromAttribute : AttributeProviderAttribute&#xD;&#xA;        {&#xD;&#xA;            public AttributesFromAttribute(Type type, string property)&#xD;&#xA;                : base(type.AssemblyQualifiedName, property)&#xD;&#xA;            {&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public T GetInheritedAttributeOfType<T>() where T : System.Attribute&#xD;&#xA;            {&#xD;&#xA;                Dictionary<string,object> attrs = Type.GetType(this.TypeName).GetProperty(this.PropertyName).GetCustomAttributes(true).ToDictionary(a => a.GetType().Name, a => a);&#xD;&#xA;                return attrs.Values.OfType<T>().FirstOrDefault();&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;now you can just add the following to the relevant property in the view model class...&#xD;&#xA;&#xD;&#xA;    [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""UserName"")]&#xD;&#xA;&#xD;&#xA;e.g...&#xD;&#xA;&#xD;&#xA;    public class RegisterViewModel&#xD;&#xA;    {&#xD;&#xA;        public UserAccount UserAccount { get; set; }&#xD;&#xA;        public RegisterViewModel()&#xD;&#xA;        {&#xD;&#xA;            UserAccount = new UserAccount();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""UserName"")]&#xD;&#xA;        string UserName { get; set; }&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""Password"")]&#xD;&#xA;        string Password { get; set; }&#xD;&#xA;&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""Password"")]&#xD;&#xA;        [Display(Name = ""Confirm Password"", Prompt = ""Confirm Password""), Compare(""Password"", ErrorMessage = ""Your confirmation doesn't match."")]&#xD;&#xA;        public string PasswordConfirmation { get; set; }&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This then gives copying of attributes that can be overridden (as with PasswordConfirmation above) allowing for multiple data models in the same viewmodel and if you need to access the inherited attributes from code, you can do so using the GetInheritedAttributeOfType method. For example...&#xD;&#xA;&#xD;&#xA;    public static class AttrHelper&#xD;&#xA;    {&#xD;&#xA;       public static T GetAttributeOfType<T>(this ViewDataDictionary viewData) where T : System.Attribute&#xD;&#xA;        {&#xD;&#xA;            var metadata = viewData.ModelMetadata;&#xD;&#xA;            var prop = metadata.ContainerType.GetProperty(metadata.PropertyName);&#xD;&#xA;            var attrs = prop.GetCustomAttributes(false);&#xD;&#xA;&#xD;&#xA;            // Try and get the attribute directly from the property.&#xD;&#xA;            T ret = attrs.OfType<T>().FirstOrDefault();&#xD;&#xA;&#xD;&#xA;            // If there isn't one, look at inherited attribute info if there is any.&#xD;&#xA;            if(ret == default(T))&#xD;&#xA;            {&#xD;&#xA;                AttributesFromAttribute inheritedAttributes = attrs.OfType<AttributesFromAttribute>().FirstOrDefault();&#xD;&#xA;                if (inheritedAttributes != null)&#xD;&#xA;                {&#xD;&#xA;                    ret = inheritedAttributes.GetInheritedAttributeOfType<T>();&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            // return what we've found.&#xD;&#xA;            return ret;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This can be called from an Editor Template for example...&#xD;&#xA;&#xD;&#xA;    var dataTypeAttr = AttrHelper.GetAttributeOfType<DataTypeAttribute>(ViewData);&#xD;&#xA;&#xD;&#xA;which will first look at the viewmodel's property attributes directly but if nothing's found it will look at the inherited attributes with it's call to GetInheritedAttributeOfType.&#xD;&#xA;&#xD;&#xA;The other options are fine, but this works best for me because I feel that current practice of repeating DataAnnotations in viewmodels as well as the datamodels isn't great for maintainability or reuse and encapsulating the datamodels in the viewmodels without Properties works, but validation is lacking upfront as ModelState.IsValid reports true based on the current object, it doesn't check the properties of the encapsulated objects.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;Changed wording now that I've decided it's the correct solution for me.
64223045;23405041;2855480;5;6b4f13d0-a184-4b2d-8d54-d361e9b2b605;2014-05-02 11:27:10.0;"Here's the solution I've come up with after consideration of the other possible solutions posed. It's based on finding the following article...&#xD;&#xA;&#xD;&#xA;<http://jendaperl.blogspot.co.uk/2010/10/attributeproviderattribute-rendered.html>&#xD;&#xA;&#xD;&#xA;My reasons for this over others are stated at the bottom of this post.&#xD;&#xA;&#xD;&#xA;Having an existing Data Model class of...&#xD;&#xA;&#xD;&#xA;    public class UserAccount&#xD;&#xA;    {&#xD;&#xA;         [Display(Name = ""Username"", Prompt = ""Login As""), Required()]&#xD;&#xA;         string UserName { get; set; }&#xD;&#xA;         [Display(Name = ""Password"", Prompt = ""Password""), Required(), DataType(DataType.Password), StringLength(255, MinimumLength = 7, ErrorMessage = ""The password must be at least 7 characters"")]&#xD;&#xA;         string Password { get; set; }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Create a new attribute as below...&#xD;&#xA;&#xD;&#xA;    using System.ComponentModel;&#xD;&#xA;&#xD;&#xA;    namespace MyApp.ViewModels&#xD;&#xA;    {&#xD;&#xA;        public class AttributesFromAttribute : AttributeProviderAttribute&#xD;&#xA;        {&#xD;&#xA;            public AttributesFromAttribute(Type type, string property)&#xD;&#xA;                : base(type.AssemblyQualifiedName, property)&#xD;&#xA;            {&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public T GetInheritedAttributeOfType<T>() where T : System.Attribute&#xD;&#xA;            {&#xD;&#xA;                Dictionary<string,object> attrs = Type.GetType(this.TypeName).GetProperty(this.PropertyName).GetCustomAttributes(true).ToDictionary(a => a.GetType().Name, a => a);&#xD;&#xA;                return attrs.Values.OfType<T>().FirstOrDefault();&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;now you can just add the following to the relevant property in the view model class...&#xD;&#xA;&#xD;&#xA;    [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""UserName"")]&#xD;&#xA;&#xD;&#xA;e.g...&#xD;&#xA;&#xD;&#xA;    public class RegisterViewModel&#xD;&#xA;    {&#xD;&#xA;        public UserAccount UserAccount { get; set; }&#xD;&#xA;        public RegisterViewModel()&#xD;&#xA;        {&#xD;&#xA;            UserAccount = new UserAccount();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""UserName"")]&#xD;&#xA;        string UserName { get; set; }&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""Password"")]&#xD;&#xA;        string Password { get; set; }&#xD;&#xA;&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""Password"")]&#xD;&#xA;        [Display(Name = ""Confirm Password"", Prompt = ""Confirm Password""), Compare(""Password"", ErrorMessage = ""Your confirmation doesn't match."")]&#xD;&#xA;        public string PasswordConfirmation { get; set; }&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This then gives copying of attributes that can be overridden (as with PasswordConfirmation above) allowing for multiple data models in the same viewmodel and if you need to access the inherited attributes from code, you can do so using the GetInheritedAttributeOfType method. For example...&#xD;&#xA;&#xD;&#xA;    public static class AttrHelper&#xD;&#xA;    {&#xD;&#xA;       public static T GetAttributeOfType<T>(this ViewDataDictionary viewData) where T : System.Attribute&#xD;&#xA;        {&#xD;&#xA;            var metadata = viewData.ModelMetadata;&#xD;&#xA;            var prop = metadata.ContainerType.GetProperty(metadata.PropertyName);&#xD;&#xA;            var attrs = prop.GetCustomAttributes(false);&#xD;&#xA;&#xD;&#xA;            // Try and get the attribute directly from the property.&#xD;&#xA;            T ret = attrs.OfType<T>().FirstOrDefault();&#xD;&#xA;&#xD;&#xA;            // If there isn't one, look at inherited attribute info if there is any.&#xD;&#xA;            if(ret == default(T))&#xD;&#xA;            {&#xD;&#xA;                AttributesFromAttribute inheritedAttributes = attrs.OfType<AttributesFromAttribute>().FirstOrDefault();&#xD;&#xA;                if (inheritedAttributes != null)&#xD;&#xA;                {&#xD;&#xA;                    ret = inheritedAttributes.GetInheritedAttributeOfType<T>();&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            // return what we've found.&#xD;&#xA;            return ret;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This can be called from an Editor Template for example...&#xD;&#xA;&#xD;&#xA;    var dataTypeAttr = AttrHelper.GetAttributeOfType<DataTypeAttribute>(ViewData);&#xD;&#xA;&#xD;&#xA;which will first look at the viewmodel's property attributes directly but if nothing's found it will look at the inherited attributes with it's call to GetInheritedAttributeOfType.&#xD;&#xA;&#xD;&#xA;This works best for me because I feel that current practice of repeating DataAnnotations in viewmodels as well as the datamodels isn't great for maintainability or reuse, and encapsulating the datamodels in the viewmodels without Properties is lacking in validation as ModelState.IsValid reports true based on the current object, it doesn't check the properties of the encapsulated objects.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;deleted 47 characters in body
64753212;23405041;2855480;5;79b4ee2b-ab4f-442a-80f1-c4b82646797a;2014-05-09 12:26:59.0;"Here's a solution I've come up with after considering the other possible solutions posed. It's based on finding the following article...&#xD;&#xA;&#xD;&#xA;<http://jendaperl.blogspot.co.uk/2010/10/attributeproviderattribute-rendered.html>&#xD;&#xA;&#xD;&#xA;My reasons for this over others are stated at the bottom of this post.&#xD;&#xA;&#xD;&#xA;Having an existing Data Model class of...&#xD;&#xA;&#xD;&#xA;    public class UserAccount&#xD;&#xA;    {&#xD;&#xA;         [Display(Name = ""Username"", Prompt = ""Login As""), Required()]&#xD;&#xA;         string UserName { get; set; }&#xD;&#xA;         [Display(Name = ""Password"", Prompt = ""Password""), Required(), DataType(DataType.Password), StringLength(255, MinimumLength = 7, ErrorMessage = ""The password must be at least 7 characters"")]&#xD;&#xA;         string Password { get; set; }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Create a new attribute as below...&#xD;&#xA;&#xD;&#xA;    using System.ComponentModel;&#xD;&#xA;&#xD;&#xA;    namespace MyApp.ViewModels&#xD;&#xA;    {&#xD;&#xA;        public class AttributesFromAttribute : AttributeProviderAttribute&#xD;&#xA;        {&#xD;&#xA;            public AttributesFromAttribute(Type type, string property)&#xD;&#xA;                : base(type.AssemblyQualifiedName, property)&#xD;&#xA;            {&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public T GetInheritedAttributeOfType<T>() where T : System.Attribute&#xD;&#xA;            {&#xD;&#xA;                Dictionary<string,object> attrs = Type.GetType(this.TypeName).GetProperty(this.PropertyName).GetCustomAttributes(true).ToDictionary(a => a.GetType().Name, a => a);&#xD;&#xA;                return attrs.Values.OfType<T>().FirstOrDefault();&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;now you can just add the following to the relevant property in the view model class...&#xD;&#xA;&#xD;&#xA;    [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""UserName"")]&#xD;&#xA;&#xD;&#xA;e.g...&#xD;&#xA;&#xD;&#xA;    public class RegisterViewModel&#xD;&#xA;    {&#xD;&#xA;        public UserAccount UserAccount { get; set; }&#xD;&#xA;        public RegisterViewModel()&#xD;&#xA;        {&#xD;&#xA;            UserAccount = new UserAccount();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""UserName"")]&#xD;&#xA;        string UserName { get; set; }&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""Password"")]&#xD;&#xA;        string Password { get; set; }&#xD;&#xA;&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""Password"")]&#xD;&#xA;        [Display(Name = ""Confirm Password"", Prompt = ""Confirm Password""), Compare(""Password"", ErrorMessage = ""Your confirmation doesn't match."")]&#xD;&#xA;        public string PasswordConfirmation { get; set; }&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This then gives copying of attributes that can be overridden (as with PasswordConfirmation above) allowing for multiple data models in the same viewmodel and if you need to access the inherited attributes from code, you can do so using the GetInheritedAttributeOfType method. For example...&#xD;&#xA;&#xD;&#xA;    public static class AttrHelper&#xD;&#xA;    {&#xD;&#xA;       public static T GetAttributeOfType<T>(this ViewDataDictionary viewData) where T : System.Attribute&#xD;&#xA;        {&#xD;&#xA;            var metadata = viewData.ModelMetadata;&#xD;&#xA;            var prop = metadata.ContainerType.GetProperty(metadata.PropertyName);&#xD;&#xA;            var attrs = prop.GetCustomAttributes(false);&#xD;&#xA;&#xD;&#xA;            // Try and get the attribute directly from the property.&#xD;&#xA;            T ret = attrs.OfType<T>().FirstOrDefault();&#xD;&#xA;&#xD;&#xA;            // If there isn't one, look at inherited attribute info if there is any.&#xD;&#xA;            if(ret == default(T))&#xD;&#xA;            {&#xD;&#xA;                AttributesFromAttribute inheritedAttributes = attrs.OfType<AttributesFromAttribute>().FirstOrDefault();&#xD;&#xA;                if (inheritedAttributes != null)&#xD;&#xA;                {&#xD;&#xA;                    ret = inheritedAttributes.GetInheritedAttributeOfType<T>();&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            // return what we've found.&#xD;&#xA;            return ret;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This can be called from an Editor Template for example...&#xD;&#xA;&#xD;&#xA;    var dataTypeAttr = AttrHelper.GetAttributeOfType<DataTypeAttribute>(ViewData);&#xD;&#xA;&#xD;&#xA;which will first look at the viewmodel's property attributes directly but if nothing's found it will look at the inherited attributes with it's call to GetInheritedAttributeOfType.&#xD;&#xA;&#xD;&#xA;This works best for me because...&#xD;&#xA;&#xD;&#xA;1. I feel that current practice of repeating DataAnnotations in viewmodels as well as the datamodels isn't great for maintainability or reuse.&#xD;&#xA;&#xD;&#xA;2. Using MetadataType is also inflexible, it's all or nothing and you can't include multiple MetadataType attributes on a single ViewModel.&#xD;&#xA;&#xD;&#xA;3. Encapsulating the datamodels in the viewmodels without Properties is lacking as it also doesn't have the flexability, you have to include the entire encapsulated object and you can't Bind to the sub properties i.e. the encapsulated objects individual properties.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;added 194 characters in body
64765925;23405041;2855480;5;748d484b-1f5e-4193-8e98-68a83651bd3e;2014-05-09 15:07:30.0;"Here's a solution I've come up with after considering the other possible solutions posed. It's based on finding the following article...&#xD;&#xA;&#xD;&#xA;<http://jendaperl.blogspot.co.uk/2010/10/attributeproviderattribute-rendered.html>&#xD;&#xA;&#xD;&#xA;My reasons for this over others are stated at the bottom of this post.&#xD;&#xA;&#xD;&#xA;Having an existing Data Model class of...&#xD;&#xA;&#xD;&#xA;    public class UserAccount&#xD;&#xA;    {&#xD;&#xA;         [Display(Name = ""Username"", Prompt = ""Login As""), Required()]&#xD;&#xA;         string UserName { get; set; }&#xD;&#xA;         [Display(Name = ""Password"", Prompt = ""Password""), Required(), DataType(DataType.Password), StringLength(255, MinimumLength = 7, ErrorMessage = ""The password must be at least 7 characters"")]&#xD;&#xA;         string Password { get; set; }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Create a new attribute as below...&#xD;&#xA;&#xD;&#xA;    using System.ComponentModel;&#xD;&#xA;&#xD;&#xA;    namespace MyApp.ViewModels&#xD;&#xA;    {&#xD;&#xA;        public class AttributesFromAttribute : AttributeProviderAttribute&#xD;&#xA;        {&#xD;&#xA;            public AttributesFromAttribute(Type type, string property)&#xD;&#xA;                : base(type.AssemblyQualifiedName, property)&#xD;&#xA;            {&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public T GetInheritedAttributeOfType<T>() where T : System.Attribute&#xD;&#xA;            {&#xD;&#xA;                Dictionary<string,object> attrs = Type.GetType(this.TypeName).GetProperty(this.PropertyName).GetCustomAttributes(true).ToDictionary(a => a.GetType().Name, a => a);&#xD;&#xA;                return attrs.Values.OfType<T>().FirstOrDefault();&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;now you can just add the following to the relevant property in the view model class...&#xD;&#xA;&#xD;&#xA;    [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""UserName"")]&#xD;&#xA;&#xD;&#xA;e.g...&#xD;&#xA;&#xD;&#xA;    public class RegisterViewModel&#xD;&#xA;    {&#xD;&#xA;        public UserAccount UserAccount { get; set; }&#xD;&#xA;        public RegisterViewModel()&#xD;&#xA;        {&#xD;&#xA;            UserAccount = new UserAccount();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""UserName"")]&#xD;&#xA;        string UserName { get; set; }&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""Password"")]&#xD;&#xA;        string Password { get; set; }&#xD;&#xA;&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""Password"")]&#xD;&#xA;        [Display(Name = ""Confirm Password"", Prompt = ""Confirm Password""), Compare(""Password"", ErrorMessage = ""Your confirmation doesn't match."")]&#xD;&#xA;        public string PasswordConfirmation { get; set; }&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This then gives copying of attributes that can be overridden (as with PasswordConfirmation above) allowing for multiple data models in the same viewmodel and if you need to access the inherited attributes from code, you can do so using the GetInheritedAttributeOfType method. For example...&#xD;&#xA;&#xD;&#xA;    public static class AttrHelper&#xD;&#xA;    {&#xD;&#xA;       public static T GetAttributeOfType<T>(this ViewDataDictionary viewData) where T : System.Attribute&#xD;&#xA;        {&#xD;&#xA;            var metadata = viewData.ModelMetadata;&#xD;&#xA;            var prop = metadata.ContainerType.GetProperty(metadata.PropertyName);&#xD;&#xA;            var attrs = prop.GetCustomAttributes(false);&#xD;&#xA;&#xD;&#xA;            // Try and get the attribute directly from the property.&#xD;&#xA;            T ret = attrs.OfType<T>().FirstOrDefault();&#xD;&#xA;&#xD;&#xA;            // If there isn't one, look at inherited attribute info if there is any.&#xD;&#xA;            if(ret == default(T))&#xD;&#xA;            {&#xD;&#xA;                AttributesFromAttribute inheritedAttributes = attrs.OfType<AttributesFromAttribute>().FirstOrDefault();&#xD;&#xA;                if (inheritedAttributes != null)&#xD;&#xA;                {&#xD;&#xA;                    ret = inheritedAttributes.GetInheritedAttributeOfType<T>();&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            // return what we've found.&#xD;&#xA;            return ret;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This can be called from an Editor Template for example...&#xD;&#xA;&#xD;&#xA;    var dataTypeAttr = AttrHelper.GetAttributeOfType<DataTypeAttribute>(ViewData);&#xD;&#xA;&#xD;&#xA;which will first look at the viewmodel's property attributes directly but if nothing's found it will look at the inherited attributes with it's call to GetInheritedAttributeOfType.&#xD;&#xA;&#xD;&#xA;This works best for me because...&#xD;&#xA;&#xD;&#xA;1. I feel that current practice of repeating DataAnnotations in viewmodels as well as the datamodels isn't great for maintainability or reuse.&#xD;&#xA;&#xD;&#xA;2. Using MetadataType is also inflexible, it's all or nothing and you can't include multiple MetadataType attributes on a single ViewModel.&#xD;&#xA;&#xD;&#xA;3. Encapsulating the datamodels in the viewmodels without Properties is lacking as it also doesn't have the flexability. You have to include the entire encapsulated object so cannot populate the DataModel over multiple views.&#xD;&#xA;&#xD;&#xA;";;added 23 characters in body
64766477;23405041;2855480;5;325617bd-6118-4144-97ad-cdc33873b7c2;2014-05-09 15:14:24.0;"Here's a solution I've come up with after considering the other possible solutions posed. It's based on finding the following article...&#xD;&#xA;&#xD;&#xA;<http://jendaperl.blogspot.co.uk/2010/10/attributeproviderattribute-rendered.html>&#xD;&#xA;&#xD;&#xA;My reasons for this over others are stated at the bottom of this post.&#xD;&#xA;&#xD;&#xA;Having an existing Data Model class of...&#xD;&#xA;&#xD;&#xA;    public class UserAccount&#xD;&#xA;    {&#xD;&#xA;         [Display(Name = ""Username"", Prompt = ""Login As""), Required()]&#xD;&#xA;         string UserName { get; set; }&#xD;&#xA;         [Display(Name = ""Password"", Prompt = ""Password""), Required(), DataType(DataType.Password), StringLength(255, MinimumLength = 7, ErrorMessage = ""The password must be at least 7 characters"")]&#xD;&#xA;         string Password { get; set; }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;wouldn't it be great if we could just copy the property attributes into a view that use it, maybe override them if we need to so that the views that use this class don't need to be revisted on a simple attribute change. Here's my solutions. Create a new attribute as below...&#xD;&#xA;&#xD;&#xA;    using System.ComponentModel;&#xD;&#xA;&#xD;&#xA;    namespace MyApp.ViewModels&#xD;&#xA;    {&#xD;&#xA;        public class AttributesFromAttribute : AttributeProviderAttribute&#xD;&#xA;        {&#xD;&#xA;            public AttributesFromAttribute(Type type, string property)&#xD;&#xA;                : base(type.AssemblyQualifiedName, property)&#xD;&#xA;            {&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public T GetInheritedAttributeOfType<T>() where T : System.Attribute&#xD;&#xA;            {&#xD;&#xA;                Dictionary<string,object> attrs = Type.GetType(this.TypeName).GetProperty(this.PropertyName).GetCustomAttributes(true).ToDictionary(a => a.GetType().Name, a => a);&#xD;&#xA;                return attrs.Values.OfType<T>().FirstOrDefault();&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;now you can just add the following to the relevant property in the view model class...&#xD;&#xA;&#xD;&#xA;    [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""UserName"")]&#xD;&#xA;&#xD;&#xA;e.g...&#xD;&#xA;&#xD;&#xA;    public class RegisterViewModel&#xD;&#xA;    {&#xD;&#xA;        public UserAccount UserAccount { get; set; }&#xD;&#xA;        public RegisterViewModel()&#xD;&#xA;        {&#xD;&#xA;            UserAccount = new UserAccount();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""UserName"")]&#xD;&#xA;        string UserName { get; set; }&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""Password"")]&#xD;&#xA;        string Password { get; set; }&#xD;&#xA;&#xD;&#xA;        [AttributesFrom(typeof(MyApp.DataModel.UserAccount), ""Password"")]&#xD;&#xA;        [Display(Name = ""Confirm Password"", Prompt = ""Confirm Password""), Compare(""Password"", ErrorMessage = ""Your confirmation doesn't match."")]&#xD;&#xA;        public string PasswordConfirmation { get; set; }&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This then gives copying of attributes that can be overridden (as with PasswordConfirmation above) allowing for multiple data models in the same viewmodel and if you need to access the inherited attributes from code, you can do so using the GetInheritedAttributeOfType method. For example...&#xD;&#xA;&#xD;&#xA;    public static class AttrHelper&#xD;&#xA;    {&#xD;&#xA;       public static T GetAttributeOfType<T>(this ViewDataDictionary viewData) where T : System.Attribute&#xD;&#xA;        {&#xD;&#xA;            var metadata = viewData.ModelMetadata;&#xD;&#xA;            var prop = metadata.ContainerType.GetProperty(metadata.PropertyName);&#xD;&#xA;            var attrs = prop.GetCustomAttributes(false);&#xD;&#xA;&#xD;&#xA;            // Try and get the attribute directly from the property.&#xD;&#xA;            T ret = attrs.OfType<T>().FirstOrDefault();&#xD;&#xA;&#xD;&#xA;            // If there isn't one, look at inherited attribute info if there is any.&#xD;&#xA;            if(ret == default(T))&#xD;&#xA;            {&#xD;&#xA;                AttributesFromAttribute inheritedAttributes = attrs.OfType<AttributesFromAttribute>().FirstOrDefault();&#xD;&#xA;                if (inheritedAttributes != null)&#xD;&#xA;                {&#xD;&#xA;                    ret = inheritedAttributes.GetInheritedAttributeOfType<T>();&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            // return what we've found.&#xD;&#xA;            return ret;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This can be called from an Editor Template for example...&#xD;&#xA;&#xD;&#xA;    var dataTypeAttr = AttrHelper.GetAttributeOfType<DataTypeAttribute>(ViewData);&#xD;&#xA;&#xD;&#xA;which will first look at the viewmodel's property attributes directly but if nothing's found it will look at the inherited attributes with it's call to GetInheritedAttributeOfType.&#xD;&#xA;&#xD;&#xA;This works best for me because...&#xD;&#xA;&#xD;&#xA;1. I feel that current practice of repeating DataAnnotations in viewmodels as well as the datamodels isn't great for maintainability or reuse.&#xD;&#xA;&#xD;&#xA;2. Using MetadataType is also inflexible, it's all or nothing and you can't include multiple MetadataType attributes on a single ViewModel.&#xD;&#xA;&#xD;&#xA;3. Encapsulating the datamodels in the viewmodels without Properties is lacking as it also doesn't have the flexability. You have to include the entire encapsulated object so cannot populate the DataModel over multiple views.&#xD;&#xA;&#xD;&#xA;";;added 23 characters in body
