Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
8816669;4186542;32829;2;75f22cb4-3e5e-4a6c-94c6-1c85f688205c;2010-11-15 16:31:27.0;I am implementing my first syncing code.  In my case I will have 2 types of iOS clients per user that will sync records to a server using a `lastSyncTimestamp`, a 64 bit integer representing the Unix epoch in milliseconds of the last sync.  Records can be created on the server or the clients at any time and the records are exchanged as JSON over HTTP. However, I am not worried about conflicts as much as there are few updates and always from the same user.  I am wondering if there are common things that I need to be aware of that can go wrong with this approach such as syncing during daylight savings time, syncs conflicting with another, or other gotchas with a timestamp based approach.  I know that git and other version control system eschew syncing with timestamps for a content based negotiation syncing approach.  I could imagine such an approach for my apps too, where using the `uuid` or `hash` of the objects, both peers announce which objects they own, and then exchange them until both peers have the same sets.  If anybody knows the advantages and disadvantages of content-based syncing versus timestamp-based syncing that would be helpful as well.;;
8816831;4186542;32829;5;e8449f10-119e-43f6-a6f8-4c9e2820de30;2010-11-15 16:37:18.0;I am implementing my first syncing code.  In my case I will have 2 types of iOS clients per user that will sync records to a server using a `lastSyncTimestamp`, a 64 bit integer representing the Unix epoch in milliseconds of the last sync.  Records can be created on the server or the clients at any time and the records are exchanged as JSON over HTTP. I am not worried about conflicts as there are few updates and always from the same user.  However, I am wondering if there are common things that I need to be aware of that can go wrong with a timestamp based approach such as syncing during daylight savings time, syncs conflicting with another, or other gotchas.  I know that git and some other version control system eschew syncing with timestamps for a content based negotiation syncing approach.  I could imagine such an approach for my apps too, where using the `uuid` or `hash` of the objects, both peers announce which objects they own, and then exchange them until both peers have the same sets.  If anybody knows any advantages and disadvantages of content-based syncing versus timestamp-based syncing in the world of regular old JSON objects (I realize it's much different than version control) that would be helpful as well.;;"added 99 characters in body; deleted 8 characters in body; deleted 10 characters in body; deleted 9 characters in body"
8817484;4186542;32829;5;c12cab35-2095-404e-9973-e6288d2fba79;2010-11-15 17:02:10.0;I am implementing my first syncing code.  In my case I will have 2 types of iOS clients per user that will sync records to a server using a `lastSyncTimestamp`, a 64 bit integer representing the Unix epoch in milliseconds of the last sync.  Records can be created on the server or the clients at any time and the records are exchanged as JSON over HTTP. I am not worried about conflicts as there are few updates and always from the same user.  However, I am wondering if there are common things that I need to be aware of that can go wrong with a timestamp based approach such as syncing during daylight savings time, syncs conflicting with another, or other gotchas.  I know that git and some other version control system eschew syncing with timestamps for a content based negotiation syncing approach.  I could imagine such an approach for my apps too, where using the `uuid` or `hash` of the objects, both peers announce which objects they own, and then exchange them until both peers have the same sets.  If anybody knows any advantages and disadvantages of content-based syncing versus timestamp-based syncing in general that would be helpful as well.;;"edited tags; deleted 83 characters in body"
8818751;4186542;32829;5;8f776e77-2e54-407a-a735-a7ce27e82663;2010-11-15 18:15:14.0;I am implementing my first syncing code.  In my case I will have 2 types of iOS clients per user that will sync records to a server using a `lastSyncTimestamp`, a 64 bit integer representing the Unix epoch in milliseconds of the last sync.  Records can be created on the server or the clients at any time and the records are exchanged as JSON over HTTP. I am not worried about conflicts as there are few updates and always from the same user.  However, I am wondering if there are common things that I need to be aware of that can go wrong with a timestamp based approach such as syncing during daylight savings time, syncs conflicting with another, or other gotchas.  I know that git and some other version control system eschew syncing with timestamps for a content based negotiation syncing approach.  I could imagine such an approach for my apps too, where using the `uuid` or `hash` of the objects, both peers announce which objects they own, and then exchange them until both peers have the same sets.  If anybody knows any advantages or disadvantages of content-based syncing versus timestamp-based syncing in general that would be helpful as well.;;deleted 1 characters in body
8823805;4186542;32829;5;18094da9-26ae-4d0b-87ab-9c5837274b1e;2010-11-15 23:27:01.0;"I am implementing my first syncing code.  In my case I will have 2 types of iOS clients per user that will sync records to a server using a `lastSyncTimestamp`, a 64 bit integer representing the Unix epoch in milliseconds of the last sync.  Records can be created on the server or the clients at any time and the records are exchanged as JSON over HTTP. I am not worried about conflicts as there are few updates and always from the same user.  However, I am wondering if there are common things that I need to be aware of that can go wrong with a timestamp based approach such as syncing during daylight savings time, syncs conflicting with another, or other gotchas.  I know that git and some other version control system eschew syncing with timestamps for a content based negotiation syncing approach.  I could imagine such an approach for my apps too, where using the `uuid` or `hash` of the objects, both peers announce which objects they own, and then exchange them until both peers have the same sets.  If anybody knows any advantages or disadvantages of content-based syncing versus timestamp-based syncing in general that would be helpful as well.&#xD;&#xA;&#xD;&#xA;Edit - Some of the pitfalls from this post and that I came up with in my research.  Feel free to challenge and correct.&#xD;&#xA;&#xD;&#xA; 1. Time is a relative concept to the observer and different machine's clock can be out of sync.  There are a couple ways to solve this.  Generate timestamp on a single machine, which doesn't scale well and represents a single point of failure.  Or use logical clocks such as vector clocks.  For the average developer building their own system, vector clocks might be too complex to implement.&#xD;&#xA; 2.  Timestamp based syncing works for client to master syncing but doesn't work as well for peer to peer syncing or where syncing can occur with 2 masters.";;"added 636 characters in body; added 38 characters in body; added 4 characters in body"
8824047;4186542;32829;5;700a75f2-3a77-44f1-b122-50d76df5de84;2010-11-15 23:46:18.0;"I am implementing my first syncing code.  In my case I will have 2 types of iOS clients per user that will sync records to a server using a `lastSyncTimestamp`, a 64 bit integer representing the Unix epoch in milliseconds of the last sync.  Records can be created on the server or the clients at any time and the records are exchanged as JSON over HTTP. I am not worried about conflicts as there are few updates and always from the same user.  However, I am wondering if there are common things that I need to be aware of that can go wrong with a timestamp based approach such as syncing during daylight savings time, syncs conflicting with another, or other gotchas.  I know that git and some other version control system eschew syncing with timestamps for a content based negotiation syncing approach.  I could imagine such an approach for my apps too, where using the `uuid` or `hash` of the objects, both peers announce which objects they own, and then exchange them until both peers have the same sets.  If anybody knows any advantages or disadvantages of content-based syncing versus timestamp-based syncing in general that would be helpful as well.&#xD;&#xA;&#xD;&#xA;**Edit** - Here are some of the advantages/disadvantages that I have come up with for timestamp and content based syncing.  Please challenge/correct. &#xD;&#xA;&#xD;&#xA;**Note** - I am defining content-based syncing as simple negotiation of 2 sets of objects such as how 2 kids would exchange cards if you gave them each parts of a jumbled up pile of 2 identical sets of baseball cards and told them that as they look through them to announce and hand over any duplicates they found to the other until they both have identical sets.  &#xD;&#xA; &#xD;&#xA;&#xD;&#xA; - Johnny - ""I got this card and this card""&#xD;&#xA; - Davey - ""I got this bunch of cards.  Give me those 2 cards.""&#xD;&#xA; - Johnny - ""Here are your 2 cards. Gimme that bunch of cards""&#xD;&#xA; - Davey - ""Here are your bunch of cards""&#xD;&#xA; - ....&#xD;&#xA; - Both - ""We are done""&#xD;&#xA;&#xD;&#xA;**Advantages of timestamp-based syncing** &#xD;&#xA;&#xD;&#xA; - Easy to implement&#xD;&#xA; - Single property used for syncing.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Disadvantages of timestamp-based syncing**&#xD;&#xA;&#xD;&#xA; - Time is a relative concept to the observer and different machine's clock can be out of sync.  There are a couple ways to solve this.  Generate timestamp on a single machine, which doesn't scale well and represents a single point of failure.  Or use logical clocks such as vector clocks.  For the average developer building their own system, vector clocks might be too complex to implement.&#xD;&#xA; - Timestamp based syncing works for client to master syncing but doesn't work as well for peer to peer syncing or where syncing can occur with 2 masters.&#xD;&#xA; - Single point of failure, whatever generates the timestamp.&#xD;&#xA; - Time is not really related to the content of what is being synced. &#xD;&#xA;&#xD;&#xA;**Advantages of content-based syncing**&#xD;&#xA;&#xD;&#xA; - No per peer timestamp needs to be maintained.  2 peers can start a sync session and start syncing based on the content.&#xD;&#xA; - Well defined endpoint to sync - when both parties have identical sets.&#xD;&#xA; - Allows a peer to peer architecture, where any peer can act as client or server, providing they can host an HTTP server.&#xD;&#xA; - Sync works with the content of the sets, not with an abstract concept time.&#xD;&#xA; - Since sync is built around content, sync can be used to do content verification if desired. E.g. a SHA-1 hash can be computed on the content and used as the uuid.  It can be compared to what is sent during syncing.  Even further, SHA-1 hashes can be chained to maintain a consistent history of content each peer.&#xD;&#xA;&#xD;&#xA;**Disadvantages of content-based syncing**&#xD;&#xA; &#xD;&#xA; - Extra properties on your objects may be needed to implement.&#xD;&#xA; - More logic on both sides compared to timestamp based syncing.&#xD;&#xA; -Slightly more chatty protocol (this could be tuned by syncing content in clusters).";;"added 1916 characters in body; added 4 characters in body; added 1 characters in body; added 57 characters in body"
8824115;4186542;32829;5;39277358-904b-4a7a-8758-bbf98db45f46;2010-11-15 23:52:24.0;"I am implementing my first syncing code.  In my case I will have 2 types of iOS clients per user that will sync records to a server using a `lastSyncTimestamp`, a 64 bit integer representing the Unix epoch in milliseconds of the last sync.  Records can be created on the server or the clients at any time and the records are exchanged as JSON over HTTP. I am not worried about conflicts as there are few updates and always from the same user.  However, I am wondering if there are common things that I need to be aware of that can go wrong with a timestamp based approach such as syncing during daylight savings time, syncs conflicting with another, or other gotchas.  I know that git and some other version control system eschew syncing with timestamps for a content based negotiation syncing approach.  I could imagine such an approach for my apps too, where using the `uuid` or `hash` of the objects, both peers announce which objects they own, and then exchange them until both peers have the same sets.  If anybody knows any advantages or disadvantages of content-based syncing versus timestamp-based syncing in general that would be helpful as well.&#xD;&#xA;&#xD;&#xA;**Edit** - Here are some of the advantages/disadvantages that I have come up with for timestamp and content based syncing.  Please challenge/correct. &#xD;&#xA;&#xD;&#xA;**Note** - I am defining content-based syncing as simple negotiation of 2 sets of objects such as how 2 kids would exchange cards if you gave them each parts of a jumbled up pile of 2 identical sets of baseball cards and told them that as they look through them to announce and hand over any duplicates they found to the other until they both have identical sets.  &#xD;&#xA; &#xD;&#xA;&#xD;&#xA; - Johnny - ""I got this card.""&#xD;&#xA; - Davey - ""I got this bunch of cards.  Give me that card.""&#xD;&#xA; - Johnny - ""Here is your card. Gimme that bunch of cards.""&#xD;&#xA; - Davey - ""Here are your bunch of cards.""&#xD;&#xA; - ....&#xD;&#xA; - Both - ""We are done""&#xD;&#xA;&#xD;&#xA;**Advantages of timestamp-based syncing** &#xD;&#xA;&#xD;&#xA; - Easy to implement&#xD;&#xA; - Single property used for syncing.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Disadvantages of timestamp-based syncing**&#xD;&#xA;&#xD;&#xA; - Time is a relative concept to the observer and different machine's clock can be out of sync.  There are a couple ways to solve this.  Generate timestamp on a single machine, which doesn't scale well and represents a single point of failure.  Or use logical clocks such as vector clocks.  For the average developer building their own system, vector clocks might be too complex to implement.&#xD;&#xA; - Timestamp based syncing works for client to master syncing but doesn't work as well for peer to peer syncing or where syncing can occur with 2 masters.&#xD;&#xA; - Single point of failure, whatever generates the timestamp.&#xD;&#xA; - Time is not really related to the content of what is being synced. &#xD;&#xA;&#xD;&#xA;**Advantages of content-based syncing**&#xD;&#xA;&#xD;&#xA; - No per peer timestamp needs to be maintained.  2 peers can start a sync session and start syncing based on the content.&#xD;&#xA; - Well defined endpoint to sync - when both parties have identical sets.&#xD;&#xA; - Allows a peer to peer architecture, where any peer can act as client or server, providing they can host an HTTP server.&#xD;&#xA; - Sync works with the content of the sets, not with an abstract concept time.&#xD;&#xA; - Since sync is built around content, sync can be used to do content verification if desired. E.g. a SHA-1 hash can be computed on the content and used as the uuid.  It can be compared to what is sent during syncing.  Even further, SHA-1 hashes can be chained to maintain a consistent history of content each peer.&#xD;&#xA;&#xD;&#xA;**Disadvantages of content-based syncing**&#xD;&#xA; &#xD;&#xA; - Extra properties on your objects may be needed to implement.&#xD;&#xA; - More logic on both sides compared to timestamp based syncing.&#xD;&#xA; -Slightly more chatty protocol (this could be tuned by syncing content in clusters).";;deleted 19 characters in body
8824203;4186542;32829;5;d8d48fb0-ca2a-4369-b17c-303e66028b09;2010-11-16 00:02:34.0;"I am implementing my first syncing code.  In my case I will have 2 types of iOS clients per user that will sync records to a server using a `lastSyncTimestamp`, a 64 bit integer representing the Unix epoch in milliseconds of the last sync.  Records can be created on the server or the clients at any time and the records are exchanged as JSON over HTTP. I am not worried about conflicts as there are few updates and always from the same user.  However, I am wondering if there are common things that I need to be aware of that can go wrong with a timestamp based approach such as syncing during daylight savings time, syncs conflicting with another, or other gotchas.  I know that git and some other version control system eschew syncing with timestamps for a content based negotiation syncing approach.  I could imagine such an approach for my apps too, where using the `uuid` or `hash` of the objects, both peers announce which objects they own, and then exchange them until both peers have the same sets.  If anybody knows any advantages or disadvantages of content-based syncing versus timestamp-based syncing in general that would be helpful as well.&#xD;&#xA;&#xD;&#xA;**Edit** - Here are some of the advantages/disadvantages that I have come up with for timestamp and content based syncing.  Please challenge/correct. &#xD;&#xA;&#xD;&#xA;**Note** - I am defining content-based syncing as simple negotiation of 2 sets of objects such as how 2 kids would exchange cards if you gave them each parts of a jumbled up pile of 2 identical sets of baseball cards and told them that as they look through them to announce and hand over any duplicates they found to the other until they both have identical sets.  &#xD;&#xA; &#xD;&#xA;&#xD;&#xA; - Johnny - ""I got this card.""&#xD;&#xA; - Davey - ""I got this bunch of cards.  Give me that card.""&#xD;&#xA; - Johnny - ""Here is your card. Gimme that bunch of cards.""&#xD;&#xA; - Davey - ""Here are your bunch of cards.""&#xD;&#xA; - ....&#xD;&#xA; - Both - ""We are done""&#xD;&#xA;&#xD;&#xA;**Advantages of timestamp-based syncing** &#xD;&#xA;&#xD;&#xA; - Easy to implement&#xD;&#xA; - Single property used for syncing.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Disadvantages of timestamp-based syncing**&#xD;&#xA;&#xD;&#xA; - Time is a relative concept to the observer and different machine's clock can be out of sync.  There are a couple ways to solve this.  Generate timestamp on a single machine, which doesn't scale well and represents a single point of failure.  Or use logical clocks such as vector clocks.  For the average developer building their own system, vector clocks might be too complex to implement.&#xD;&#xA; - Timestamp based syncing works for client to master syncing but doesn't work as well for peer to peer syncing or where syncing can occur with 2 masters.&#xD;&#xA; - Single point of failure, whatever generates the timestamp.&#xD;&#xA; - Time is not really related to the content of what is being synced. &#xD;&#xA;&#xD;&#xA;**Advantages of content-based syncing**&#xD;&#xA;&#xD;&#xA; - No per peer timestamp needs to be maintained.  2 peers can start a sync session and start syncing based on the content.&#xD;&#xA; - Well defined endpoint to sync - when both parties have identical sets.&#xD;&#xA; - Allows a peer to peer architecture, where any peer can act as client or server, providing they can host an HTTP server.&#xD;&#xA; - Sync works with the content of the sets, not with an abstract concept time.&#xD;&#xA; - Since sync is built around content, sync can be used to do content verification if desired. E.g. a SHA-1 hash can be computed on the content and used as the uuid.  It can be compared to what is sent during syncing.  Even further, SHA-1 hashes can be chained to maintain a consistent history of content each peer.&#xD;&#xA;&#xD;&#xA;**Disadvantages of content-based syncing**&#xD;&#xA; &#xD;&#xA; - Extra properties on your objects may be needed to implement.&#xD;&#xA; - More logic on both sides compared to timestamp based syncing.&#xD;&#xA; - Slightly more chatty protocol (this could be tuned by syncing content in clusters).";;added 1 characters in body
8824373;4186542;32829;5;069cd4c2-3149-41a0-80e2-877e701c192a;2010-11-16 00:18:48.0;"I am implementing my first syncing code.  In my case I will have 2 types of iOS clients per user that will sync records to a server using a `lastSyncTimestamp`, a 64 bit integer representing the Unix epoch in milliseconds of the last sync.  Records can be created on the server or the clients at any time and the records are exchanged as JSON over HTTP. I am not worried about conflicts as there are few updates and always from the same user.  However, I am wondering if there are common things that I need to be aware of that can go wrong with a timestamp based approach such as syncing during daylight savings time, syncs conflicting with another, or other gotchas.  I know that git and some other version control system eschew syncing with timestamps for a content based negotiation syncing approach.  I could imagine such an approach for my apps too, where using the `uuid` or `hash` of the objects, both peers announce which objects they own, and then exchange them until both peers have the same sets.  If anybody knows any advantages or disadvantages of content-based syncing versus timestamp-based syncing in general that would be helpful as well.&#xD;&#xA;&#xD;&#xA;**Edit** - Here are some of the advantages/disadvantages that I have come up with for timestamp and content based syncing.  Please challenge/correct. &#xD;&#xA;&#xD;&#xA;**Note** - I am defining content-based syncing as simple negotiation of 2 sets of objects such as how 2 kids would exchange cards if you gave them each parts of a jumbled up pile of 2 identical sets of baseball cards and told them that as they look through them to announce and hand over any duplicates they found to the other until they both have identical sets.  &#xD;&#xA; &#xD;&#xA;&#xD;&#xA; - Johnny - ""I got this card.""&#xD;&#xA; - Davey - ""I got this bunch of cards.  Give me that card.""&#xD;&#xA; - Johnny - ""Here is your card. Gimme that bunch of cards.""&#xD;&#xA; - Davey - ""Here are your bunch of cards.""&#xD;&#xA; - ....&#xD;&#xA; - Both - ""We are done""&#xD;&#xA;&#xD;&#xA;**Advantages of timestamp-based syncing** &#xD;&#xA;&#xD;&#xA; - Easy to implement&#xD;&#xA; - Single property used for syncing.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Disadvantages of timestamp-based syncing**&#xD;&#xA;&#xD;&#xA; - Time is a relative concept to the observer and different machine's clocks can be out of sync.  There are a couple ways to solve this.  Generate timestamp on a single machine, which doesn't scale well and represents a single point of failure.  Or use logical clocks such as vector clocks.  For the average developer building their own system, vector clocks might be too complex to implement.&#xD;&#xA; - Timestamp based syncing works for client to master syncing but doesn't work as well for peer to peer syncing or where syncing can occur with 2 masters.&#xD;&#xA; - Single point of failure, whatever generates the timestamp.&#xD;&#xA; - Time is not really related to the content of what is being synced. &#xD;&#xA;&#xD;&#xA;**Advantages of content-based syncing**&#xD;&#xA;&#xD;&#xA; - No per peer timestamp needs to be maintained.  2 peers can start a sync session and start syncing based on the content.&#xD;&#xA; - Well defined endpoint to sync - when both parties have identical sets.&#xD;&#xA; - Allows a peer to peer architecture, where any peer can act as client or server, providing they can host an HTTP server.&#xD;&#xA; - Sync works with the content of the sets, not with an abstract concept time.&#xD;&#xA; - Since sync is built around content, sync can be used to do content verification if desired. E.g. a SHA-1 hash can be computed on the content and used as the uuid.  It can be compared to what is sent during syncing.  Even further, SHA-1 hashes can be chained to maintain a consistent history of content each peer.&#xD;&#xA;&#xD;&#xA;**Disadvantages of content-based syncing**&#xD;&#xA; &#xD;&#xA; - Extra properties on your objects may be needed to implement.&#xD;&#xA; - More logic on both sides compared to timestamp based syncing.&#xD;&#xA; - Slightly more chatty protocol (this could be tuned by syncing content in clusters).";;added 1 characters in body
8829535;4186542;30461;5;58e6c739-5658-4c9a-95f2-1c65687fe96e;2010-11-16 08:50:53.0;"I am implementing my first syncing code.  In my case I will have 2 types of iOS clients per user that will sync records to a server using a `lastSyncTimestamp`, a 64 bit integer representing the Unix epoch in milliseconds of the last sync.  Records can be created on the server or the clients at any time and the records are exchanged as JSON over HTTP.&#xD;&#xA;&#xD;&#xA;I am not worried about conflicts as there are few updates and always from the same user.  However, I am wondering if there are common things that I need to be aware of that can go wrong with a timestamp based approach such as syncing during daylight savings time, syncs conflicting with another, or other gotchas.&#xD;&#xA;&#xD;&#xA;I know that git and some other version control system eschew syncing with timestamps for a content based negotiation syncing approach.  I could imagine such an approach for my apps too, where using the `uuid` or `hash` of the objects, both peers announce which objects they own, and then exchange them until both peers have the same sets.&#xD;&#xA;&#xD;&#xA;If anybody knows any advantages or disadvantages of content-based syncing versus timestamp-based syncing in general that would be helpful as well.&#xD;&#xA;&#xD;&#xA;**Edit** - Here are some of the advantages/disadvantages that I have come up with for timestamp and content based syncing.  Please challenge/correct. &#xD;&#xA;&#xD;&#xA;**Note** - I am defining content-based syncing as simple negotiation of 2 sets of objects such as how 2 kids would exchange cards if you gave them each parts of a jumbled up pile of 2 identical sets of baseball cards and told them that as they look through them to announce and hand over any duplicates they found to the other until they both have identical sets.  &#xD;&#xA; &#xD;&#xA;&#xD;&#xA; - Johnny - ""I got this card.""&#xD;&#xA; - Davey - ""I got this bunch of cards.  Give me that card.""&#xD;&#xA; - Johnny - ""Here is your card. Gimme that bunch of cards.""&#xD;&#xA; - Davey - ""Here are your bunch of cards.""&#xD;&#xA; - ....&#xD;&#xA; - Both - ""We are done""&#xD;&#xA;&#xD;&#xA;**Advantages of timestamp-based syncing** &#xD;&#xA;&#xD;&#xA; - Easy to implement&#xD;&#xA; - Single property used for syncing.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Disadvantages of timestamp-based syncing**&#xD;&#xA;&#xD;&#xA; - Time is a relative concept to the observer and different machine's clocks can be out of sync.  There are a couple ways to solve this.  Generate timestamp on a single machine, which doesn't scale well and represents a single point of failure.  Or use logical clocks such as vector clocks.  For the average developer building their own system, vector clocks might be too complex to implement.&#xD;&#xA; - Timestamp based syncing works for client to master syncing but doesn't work as well for peer to peer syncing or where syncing can occur with 2 masters.&#xD;&#xA; - Single point of failure, whatever generates the timestamp.&#xD;&#xA; - Time is not really related to the content of what is being synced. &#xD;&#xA;&#xD;&#xA;**Advantages of content-based syncing**&#xD;&#xA;&#xD;&#xA; - No per peer timestamp needs to be maintained.  2 peers can start a sync session and start syncing based on the content.&#xD;&#xA; - Well defined endpoint to sync - when both parties have identical sets.&#xD;&#xA; - Allows a peer to peer architecture, where any peer can act as client or server, providing they can host an HTTP server.&#xD;&#xA; - Sync works with the content of the sets, not with an abstract concept time.&#xD;&#xA; - Since sync is built around content, sync can be used to do content verification if desired. E.g. a SHA-1 hash can be computed on the content and used as the uuid.  It can be compared to what is sent during syncing.  Even further, SHA-1 hashes can be chained to maintain a consistent history of content each peer.&#xD;&#xA;&#xD;&#xA;**Disadvantages of content-based syncing**&#xD;&#xA; &#xD;&#xA; - Extra properties on your objects may be needed to implement.&#xD;&#xA; - More logic on both sides compared to timestamp based syncing.&#xD;&#xA; - Slightly more chatty protocol (this could be tuned by syncing content in clusters).";;Dynamited the initial wall of text into paragraphs.
8836773;4186542;32829;5;82110c96-1aa9-48ff-8fb3-56222d178fac;2010-11-16 15:33:46.0;"I am implementing my first syncing code.  In my case I will have 2 types of iOS clients per user that will sync records to a server using a `lastSyncTimestamp`, a 64 bit integer representing the Unix epoch in milliseconds of the last sync.  Records can be created on the server or the clients at any time and the records are exchanged as JSON over HTTP.&#xD;&#xA;&#xD;&#xA;I am not worried about conflicts as there are few updates and always from the same user.  However, I am wondering if there are common things that I need to be aware of that can go wrong with a timestamp based approach such as syncing during daylight savings time, syncs conflicting with another, or other gotchas.&#xD;&#xA;&#xD;&#xA;I know that git and some other version control system eschew syncing with timestamps for a content based negotiation syncing approach.  I could imagine such an approach for my apps too, where using the `uuid` or `hash` of the objects, both peers announce which objects they own, and then exchange them until both peers have the same sets.&#xD;&#xA;&#xD;&#xA;If anybody knows any advantages or disadvantages of content-based syncing versus timestamp-based syncing in general that would be helpful as well.&#xD;&#xA;&#xD;&#xA;**Edit** - Here are some of the advantages/disadvantages that I have come up with for timestamp and content based syncing.  Please challenge/correct. &#xD;&#xA;&#xD;&#xA;**Note** - I am defining content-based syncing as simple negotiation of 2 sets of objects such as how 2 kids would exchange cards if you gave them each parts of a jumbled up pile of 2 identical sets of baseball cards and told them that as they look through them to announce and hand over any duplicates they found to the other until they both have identical sets.  &#xD;&#xA; &#xD;&#xA;&#xD;&#xA; - Johnny - ""I got this card.""&#xD;&#xA; - Davey - ""I got this bunch of cards.  Give me that card.""&#xD;&#xA; - Johnny - ""Here is your card. Gimme that bunch of cards.""&#xD;&#xA; - Davey - ""Here are your bunch of cards.""&#xD;&#xA; - ....&#xD;&#xA; - Both - ""We are done""&#xD;&#xA;&#xD;&#xA;**Advantages of timestamp-based syncing** &#xD;&#xA;&#xD;&#xA; - Easy to implement&#xD;&#xA; - Single property used for syncing.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Disadvantages of timestamp-based syncing**&#xD;&#xA;&#xD;&#xA; - Time is a relative concept to the observer and different machine's clocks can be out of sync.  There are a couple ways to solve this.  Generate timestamp on a single machine, which doesn't scale well and represents a single point of failure.  Or use logical clocks such as vector clocks.  For the average developer building their own system, vector clocks might be too complex to implement.&#xD;&#xA; - Timestamp based syncing works for client to master syncing but doesn't work as well for peer to peer syncing or where syncing can occur with 2 masters.&#xD;&#xA; - Single point of failure, whatever generates the timestamp.&#xD;&#xA; - Time is not really related to the content of what is being synced. &#xD;&#xA;&#xD;&#xA;**Advantages of content-based syncing**&#xD;&#xA;&#xD;&#xA; - No per peer timestamp needs to be maintained.  2 peers can start a sync session and start syncing based on the content.&#xD;&#xA; - Well defined endpoint to sync - when both parties have identical sets.&#xD;&#xA; - Allows a peer to peer architecture, where any peer can act as client or server, providing they can host an HTTP server.&#xD;&#xA; - Sync works with the content of the sets, not with an abstract concept time.&#xD;&#xA; - Since sync is built around content, sync can be used to do content verification if desired. E.g. a SHA-1 hash can be computed on the content and used as the uuid.  It can be compared to what is sent during syncing.  &#xD;&#xA; - Even further, SHA-1 hashes can be based on previous hashes to maintain a consistent history of content.&#xD;&#xA;&#xD;&#xA;**Disadvantages of content-based syncing**&#xD;&#xA; &#xD;&#xA; - Extra properties on your objects may be needed to implement.&#xD;&#xA; - More logic on both sides compared to timestamp based syncing.&#xD;&#xA; - Slightly more chatty protocol (this could be tuned by syncing content in clusters).";;added 12 characters in body
