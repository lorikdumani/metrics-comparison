Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
32016705;13450233;1374437;2;6c10c029-4c9a-4bd6-8a93-68eea5c323c5;2012-11-19 08:44:51.0;"First, variables that are determined to be `private` in a given region are automatically `firstprivate` in explicit tasks, so you don't need to declare them explicitly as `firstprivate`. Second, your code contains `++end;` and `--end;` which modify the value of `end`, affecting other tasks if `end` is `shared`. `firstprivate` is the correct data sharing class here - each task simply retains the values of `begin`, `end` and `middle` that they used to have at the time the task was created.&#xD;&#xA;&#xD;&#xA;Your `ParallelQuickSort` should be as simple as this:&#xD;&#xA;&#xD;&#xA;<!-- language-all: lang-cpp -->&#xD;&#xA;&#xD;&#xA;    void ParallelQuickSort(int *begin, int *end)&#xD;&#xA;    {&#xD;&#xA;        if (begin+1 < end) &#xD;&#xA;        {&#xD;&#xA;            --end;&#xD;&#xA;            int *middle = partition(begin, end, bind2nd(less<int>(), *end));&#xD;&#xA;            swap(*end, *middle);&#xD;&#xA;            #pragma omp task&#xD;&#xA;                ParallelQuickSort(begin, middle);&#xD;&#xA;            #pragma omp task&#xD;&#xA;                ParallelQuickSort(++middle, ++end); &#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Note that although this code works, it is way slower than the single-threaded version: 88.2 seconds with 2 threads on a large Xeon X7350 (Tigerton) box versus 50.1 seconds with a single thread. The reason is that tasks creation continues up to the very simple task of swapping two array elements. The overhead of using tasks is huge and you should put a sane upper threshold below which tasking should be disabled, let's say when the subarray size has reached 1024 elements. The exact number depends on the OpenMP run-time implementation, your CPU type and memory speed, so the value of 1024 is more or less randomly chosen. Still the optimal value should not create two tasks that process elements that would fall in the same cache line, so the number of elements should be a multiple of 16 (64 bytes per cache line / 4 bytes per integer):&#xD;&#xA;&#xD;&#xA;    void ParallelQuickSort(int *begin, int *end)&#xD;&#xA;    {&#xD;&#xA;        if (begin+1 < end) &#xD;&#xA;        {&#xD;&#xA;            --end;&#xD;&#xA;            int *middle = partition(begin, end, bind2nd(less<int>(), *end));&#xD;&#xA;            swap(*end, *middle);&#xD;&#xA;            #pragma omp task if((end - begin) >= 1024)&#xD;&#xA;                ParallelQuickSort(begin, middle);&#xD;&#xA;            #pragma omp task if((end - begin) >= 1024)&#xD;&#xA;                ParallelQuickSort(++middle, ++end); &#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;With this modification the code runs for 34.2 seconds with two threads on the same box.";;
32026571;13450233;1374437;5;c88622c1-8f5c-4a7f-8d5c-03dd80d4c5c9;2012-11-19 12:26:33.0;"First, variables that are determined to be `private` in a given region are automatically `firstprivate` in explicit tasks, so you don't need to declare them explicitly as `firstprivate`. Second, your code contains `++end;` and `--end;` which modify the value of `end`, affecting other tasks if `end` is `shared`. `firstprivate` is the correct data sharing class here - each task simply retains the values of `begin`, `end` and `middle` that they used to have at the time the task was created.&#xD;&#xA;&#xD;&#xA;Your `ParallelQuickSort` should be as simple as this:&#xD;&#xA;&#xD;&#xA;<!-- language-all: lang-cpp -->&#xD;&#xA;&#xD;&#xA;    void ParallelQuickSort(int *begin, int *end)&#xD;&#xA;    {&#xD;&#xA;        if (begin+1 < end) &#xD;&#xA;        {&#xD;&#xA;            --end;&#xD;&#xA;            int *middle = partition(begin, end, bind2nd(less<int>(), *end));&#xD;&#xA;            swap(*end, *middle);&#xD;&#xA;            #pragma omp task&#xD;&#xA;                ParallelQuickSort(begin, middle);&#xD;&#xA;            #pragma omp task&#xD;&#xA;                ParallelQuickSort(++middle, ++end); &#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Note that although this code works, it is way slower than the single-threaded version: 88.2 seconds with 2 threads on a large Xeon X7350 (Tigerton) box versus 50.1 seconds with a single thread. The reason is that tasks creation continues up to the very simple task of swapping two array elements. The overhead of using tasks is huge and you should put a sane upper threshold below which tasking should be disabled, let's say when the subarray size has reached 1024 elements. The exact number depends on the OpenMP run-time implementation, your CPU type and memory speed, so the value of 1024 is more or less randomly chosen. Still the optimal value should not create two tasks that process elements that would fall in the same cache line, so the number of elements should be a multiple of 16 (64 bytes per cache line / 4 bytes per integer):&#xD;&#xA;&#xD;&#xA;    void ParallelQuickSort(int *begin, int *end)&#xD;&#xA;    {&#xD;&#xA;        if (begin+1 < end) &#xD;&#xA;        {&#xD;&#xA;            --end;&#xD;&#xA;            int *middle = partition(begin, end, bind2nd(less<int>(), *end));&#xD;&#xA;            swap(*end, *middle);&#xD;&#xA;            #pragma omp task if((end - begin) > 1024)&#xD;&#xA;                ParallelQuickSort(begin, middle);&#xD;&#xA;            #pragma omp task if((end - begin) > 1024)&#xD;&#xA;                ParallelQuickSort(++middle, ++end); &#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;With this modification the code runs for 34.2 seconds with two threads on the same box.";;Fixed off-by-1 error
