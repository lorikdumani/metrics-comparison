Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
75581122;26383526;3992047;2;4774b521-d809-40b4-ad75-c7785b8c6f36;2014-10-15 13:13:26.0;"Finally some how I found the solution to identify the changes happening inside the method but it gives simultaneously . I store it in a hash map as specified in the http://stackoverflow.com/questions/13761220/how-to-capture-changes-inside-methods-in-an-eclipse-plugin answer and by using IResourceChangeEvent.POST_CHANGE we can get the collection of changes happened up to the user saves the file. &#xD;&#xA;&#xD;&#xA;    public void elementChanged(ElementChangedEvent event) {&#xD;&#xA;		 IJavaElementDelta delta= event.getDelta();&#xD;&#xA;	        if (delta != null) {	           &#xD;&#xA;	            delta.getCompilationUnitAST().accept(new ASTVisitor() {&#xD;&#xA;&#xD;&#xA;	             @Override&#xD;&#xA;	             public boolean visit(MethodDeclaration node) {&#xD;&#xA;	            	 String name = ( (TypeDeclaration) node.getParent()).getName()&#xD;&#xA;	                     .getFullyQualifiedName() + ""."" + node.getName().getFullyQualifiedName();&#xD;&#xA;	               &#xD;&#xA;	            	 boolean changedmethodvalue = false;&#xD;&#xA;	                       &#xD;&#xA;	                 if (subtrees.containsKey(name)){&#xD;&#xA;	                    &#xD;&#xA;	                	changedmethodvalue = !node.subtreeMatch(new ASTMatcher(),subtrees.get(Name));&#xD;&#xA;	                        &#xD;&#xA;	                     if(changedmethodvalue){&#xD;&#xA;	                    	 &#xD;&#xA;	                      System.out.println(""method  changed""+Name+"":""+changedmethodvalue);&#xD;&#xA;	                      &#xD;&#xA;	                      /**&#xD;&#xA;	                       * Store the changed method inside the hash map for future reflection.&#xD;&#xA;	                       */&#xD;&#xA;	                     &#xD;&#xA;	                      changed.put(Name, (IMethod) node.resolveBinding().getJavaElement());&#xD;&#xA;	                      &#xD;&#xA;	                      /**&#xD;&#xA;	                       * setting up the hash map value each time changes happened.&#xD;&#xA;	                       * &#xD;&#xA;	                       */&#xD;&#xA;	                      ModificationStore.setChanged(changed);&#xD;&#xA;	                      &#xD;&#xA;	                   &#xD;&#xA;	                        	   &#xD;&#xA;	                      }&#xD;&#xA;	                 }&#xD;&#xA;	                 else{&#xD;&#xA;	                	 &#xD;&#xA;	                	 // No earlier entry found, definitely changed&#xD;&#xA;	                     methodHasChanged = true;&#xD;&#xA;	                     System.out.println(""A new method is added"");&#xD;&#xA;	                     &#xD;&#xA;	                 }&#xD;&#xA;&#xD;&#xA;                 }&#xD;&#xA;                          /**&#xD;&#xA;	                     * updating the subtree structure &#xD;&#xA;	                     */&#xD;&#xA;	                       subtrees.put(mName, node);&#xD;&#xA;	                    &#xD;&#xA;	                       return true;&#xD;&#xA;	                   }&#xD;&#xA;	               });&#xD;&#xA;	           &#xD;&#xA;	       }&#xD;&#xA;	   }&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;When the user invokes save option we can get the collection of method name and its location from the hash map &#xD;&#xA;&#xD;&#xA;     public class InvokeSynchronizer  implements IResourceDeltaVisitor{&#xD;&#xA;	&#xD;&#xA;	private static HashMap<String, IMethod> methodtoinvoke = new HashMap<String, IMethod>();&#xD;&#xA;	&#xD;&#xA;	public boolean visit(IResourceDelta delta) {&#xD;&#xA;    	&#xD;&#xA;	       IResource res = delta.getResource();&#xD;&#xA;	        switch (delta.getKind()) {&#xD;&#xA;	       &#xD;&#xA;	          case IResourceDelta.ADDED:&#xD;&#xA;	        	  System.out.println(""ADDED: "");&#xD;&#xA;	          break;&#xD;&#xA;            case IResourceDelta.CHANGED:&#xD;&#xA;              /**&#xD;&#xA;	               * methodtoinvoke is a hash map values got from the modification store class.&#xD;&#xA;	               */&#xD;&#xA;	              methodtoinvoke=ModificationStore.getChanged();&#xD;&#xA;&#xD;&#xA;                   Iterator it = methodtoinvoke.entrySet().iterator();&#xD;&#xA;	              while (it.hasNext()) {&#xD;&#xA;	                 &#xD;&#xA;					Map.Entry pairs = (Map.Entry)it.next();&#xD;&#xA;	                //  System.out.println(pairs.getKey() + "" = "" + pairs.getValue());&#xD;&#xA;	                  IMethod methods=(IMethod) pairs.getValue();&#xD;&#xA;	                  &#xD;&#xA;	                  //IResource resource=(IResource) methods;&#xD;&#xA;	                  &#xD;&#xA;	                  System.out.println(""I resource value""+res);&#xD;&#xA;	                  &#xD;&#xA;	                  System.out.println(""\\nlocation of the method:""+methods.getParent().getResource().toString());&#xD;&#xA;	                  System.out.println(""\\n\\nmethod name ::""+methods.getElementName());&#xD;&#xA;	                  &#xD;&#xA;	                  it.remove(); // avoids a ConcurrentModificationException&#xD;&#xA;	              }}&#xD;&#xA;	       return true; &#xD;&#xA;	    }&#xD;&#xA;	 &#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;";;
146084543;26383526;-1;5;9563ab0a-31b2-4df0-aaf7-dbc20a3a43b1;2017-05-23 10:25:59.0;"Finally some how I found the solution to identify the changes happening inside the method but it gives simultaneously . I store it in a hash map as specified in the https://stackoverflow.com/questions/13761220/how-to-capture-changes-inside-methods-in-an-eclipse-plugin answer and by using IResourceChangeEvent.POST_CHANGE we can get the collection of changes happened up to the user saves the file. &#xD;&#xA;&#xD;&#xA;    public void elementChanged(ElementChangedEvent event) {&#xD;&#xA;		 IJavaElementDelta delta= event.getDelta();&#xD;&#xA;	        if (delta != null) {	           &#xD;&#xA;	            delta.getCompilationUnitAST().accept(new ASTVisitor() {&#xD;&#xA;&#xD;&#xA;	             @Override&#xD;&#xA;	             public boolean visit(MethodDeclaration node) {&#xD;&#xA;	            	 String name = ( (TypeDeclaration) node.getParent()).getName()&#xD;&#xA;	                     .getFullyQualifiedName() + ""."" + node.getName().getFullyQualifiedName();&#xD;&#xA;	               &#xD;&#xA;	            	 boolean changedmethodvalue = false;&#xD;&#xA;	                       &#xD;&#xA;	                 if (subtrees.containsKey(name)){&#xD;&#xA;	                    &#xD;&#xA;	                	changedmethodvalue = !node.subtreeMatch(new ASTMatcher(),subtrees.get(Name));&#xD;&#xA;	                        &#xD;&#xA;	                     if(changedmethodvalue){&#xD;&#xA;	                    	 &#xD;&#xA;	                      System.out.println(""method  changed""+Name+"":""+changedmethodvalue);&#xD;&#xA;	                      &#xD;&#xA;	                      /**&#xD;&#xA;	                       * Store the changed method inside the hash map for future reflection.&#xD;&#xA;	                       */&#xD;&#xA;	                     &#xD;&#xA;	                      changed.put(Name, (IMethod) node.resolveBinding().getJavaElement());&#xD;&#xA;	                      &#xD;&#xA;	                      /**&#xD;&#xA;	                       * setting up the hash map value each time changes happened.&#xD;&#xA;	                       * &#xD;&#xA;	                       */&#xD;&#xA;	                      ModificationStore.setChanged(changed);&#xD;&#xA;	                      &#xD;&#xA;	                   &#xD;&#xA;	                        	   &#xD;&#xA;	                      }&#xD;&#xA;	                 }&#xD;&#xA;	                 else{&#xD;&#xA;	                	 &#xD;&#xA;	                	 // No earlier entry found, definitely changed&#xD;&#xA;	                     methodHasChanged = true;&#xD;&#xA;	                     System.out.println(""A new method is added"");&#xD;&#xA;	                     &#xD;&#xA;	                 }&#xD;&#xA;&#xD;&#xA;                 }&#xD;&#xA;                          /**&#xD;&#xA;	                     * updating the subtree structure &#xD;&#xA;	                     */&#xD;&#xA;	                       subtrees.put(mName, node);&#xD;&#xA;	                    &#xD;&#xA;	                       return true;&#xD;&#xA;	                   }&#xD;&#xA;	               });&#xD;&#xA;	           &#xD;&#xA;	       }&#xD;&#xA;	   }&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;When the user invokes save option we can get the collection of method name and its location from the hash map &#xD;&#xA;&#xD;&#xA;     public class InvokeSynchronizer  implements IResourceDeltaVisitor{&#xD;&#xA;	&#xD;&#xA;	private static HashMap<String, IMethod> methodtoinvoke = new HashMap<String, IMethod>();&#xD;&#xA;	&#xD;&#xA;	public boolean visit(IResourceDelta delta) {&#xD;&#xA;    	&#xD;&#xA;	       IResource res = delta.getResource();&#xD;&#xA;	        switch (delta.getKind()) {&#xD;&#xA;	       &#xD;&#xA;	          case IResourceDelta.ADDED:&#xD;&#xA;	        	  System.out.println(""ADDED: "");&#xD;&#xA;	          break;&#xD;&#xA;            case IResourceDelta.CHANGED:&#xD;&#xA;              /**&#xD;&#xA;	               * methodtoinvoke is a hash map values got from the modification store class.&#xD;&#xA;	               */&#xD;&#xA;	              methodtoinvoke=ModificationStore.getChanged();&#xD;&#xA;&#xD;&#xA;                   Iterator it = methodtoinvoke.entrySet().iterator();&#xD;&#xA;	              while (it.hasNext()) {&#xD;&#xA;	                 &#xD;&#xA;					Map.Entry pairs = (Map.Entry)it.next();&#xD;&#xA;	                //  System.out.println(pairs.getKey() + "" = "" + pairs.getValue());&#xD;&#xA;	                  IMethod methods=(IMethod) pairs.getValue();&#xD;&#xA;	                  &#xD;&#xA;	                  //IResource resource=(IResource) methods;&#xD;&#xA;	                  &#xD;&#xA;	                  System.out.println(""I resource value""+res);&#xD;&#xA;	                  &#xD;&#xA;	                  System.out.println(""\\nlocation of the method:""+methods.getParent().getResource().toString());&#xD;&#xA;	                  System.out.println(""\\n\\nmethod name ::""+methods.getElementName());&#xD;&#xA;	                  &#xD;&#xA;	                  it.remove(); // avoids a ConcurrentModificationException&#xD;&#xA;	              }}&#xD;&#xA;	       return true; &#xD;&#xA;	    }&#xD;&#xA;	 &#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
