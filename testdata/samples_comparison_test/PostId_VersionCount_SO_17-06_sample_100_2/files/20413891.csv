Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
53019802;20413891;363751;2;764eaef9-645a-4254-80ed-fd611bbf65f0;2013-12-06 00:47:32.0;"The creators of .NET have decided that a property should be a special kind of entity in its own right, rather than merely allowing an alternate form of invocation for suitably-named methods with a ""property"" attribute.  This is at times annoying; the one potentially-useful aspect is that it ensures that prevents the possibility of code overriding a property getter without realizing that the property *also* has a setter, or overriding a property setter without realizing that the getter does something other than returning the expected backing field.&#xD;&#xA;&#xD;&#xA;This, if one wished to have a covariant set of list interfaces, one would need to define:&#xD;&#xA;&#xD;&#xA;    interface IReadableList<out T> { T this[int index] {get;}; }&#xD;&#xA;    interface IWritableList<in T> {T this[int index] {set; }&#xD;&#xA;    interface IMutableList<T> : IReadableList<T>,IWritableList<T> &#xD;&#xA;      {new T this[int index] {get; set; }&#xD;&#xA;&#xD;&#xA;It would in turn be necessary for code to define implementations for all three properties.  Implicit interface implementation in C# may ease the burden of having to define three properties, since a class which defines `T this[int index] {get {...}; set {...};}` will cause the compiler to implement the read-only method using the specified getter, the write-only method using the specified setter, and the read-write method using both, but from the perspective of the Framework, there are in fact three separate properties, and the get/set of the read/write property is independent of the get/set properties associated with the read-only or write-only properties.&#xD;&#xA;&#xD;&#xA;Personally, I think it's annoying that neither vb.net nor C# is willing to use the fact that a property is being read as a clue that write-only properties shouldn't be considered in overload resolution, and likewise the fact that it's being written should exclude read-only properties, but I didn't design those languages nor the Framework.";;
53089867;20413891;927012;5;0179da2b-7d77-4c3d-8091-7f7026e3b7ce;2013-12-06 21:07:47.0;"The creators of .NET have decided that a property should be a special kind of entity in its own right, rather than merely allowing an alternate form of invocation for suitably-named methods with a ""property"" attribute.  This is at times annoying; the one potentially-useful aspect is that it ensures that prevents the possibility of code overriding a property getter without realizing that the property *also* has a setter, or overriding a property setter without realizing that the getter does something other than returning the expected backing field.&#xD;&#xA;&#xD;&#xA;This, if one wished to have a covariant set of list interfaces, one would need to define:&#xD;&#xA;&#xD;&#xA;	interface IReadableList<out T> {&#xD;&#xA;		T this[int index] {&#xD;&#xA;			get;&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	interface IWritableList<in T> {&#xD;&#xA;		T this[int index] {&#xD;&#xA;			set;&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	interface IMutableList<T>: IReadableList<T>, IWritableList<T> {&#xD;&#xA;		new T this[int index] {&#xD;&#xA;			get;&#xD;&#xA;			set;&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;It would in turn be necessary for code to define implementations for all three properties.  Implicit interface implementation in C# may ease the burden of having to define three properties, since a class which defines `T this[int index] {get {...}; set {...};}` will cause the compiler to implement the read-only method using the specified getter, the write-only method using the specified setter, and the read-write method using both, but from the perspective of the Framework, there are in fact three separate properties, and the get/set of the read/write property is independent of the get/set properties associated with the read-only or write-only properties.&#xD;&#xA;&#xD;&#xA;Personally, I think it's annoying that neither vb.net nor C# is willing to use the fact that a property is being read as a clue that write-only properties shouldn't be considered in overload resolution, and likewise the fact that it's being written should exclude read-only properties, but I didn't design those languages nor the Framework.";;"format code; correct syntax"
53090683;20413891;363751;5;1ab96e99-9280-4efa-ac3a-0856798650a6;2013-12-06 21:24:14.0;"The creators of .NET have decided that a property should be a special kind of entity in its own right, rather than merely allowing an alternate form of invocation for suitably-named methods with a ""property"" attribute.  This is at times annoying; the one potentially-useful aspect is that it ensures that prevents the possibility of code overriding a property getter without realizing that the property *also* has a setter, or overriding a property setter without realizing that the getter does something other than returning the expected backing field.&#xD;&#xA;&#xD;&#xA;This, if one wished to have a covariant set of list interfaces, one would need to define:&#xD;&#xA;&#xD;&#xA;	interface IReadableList<out T> {&#xD;&#xA;		T this[int index] { get; }&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	interface IWritableList<in T> {&#xD;&#xA;		T this[int index] { set; }&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	interface IMutableList<T>: IReadableList<T>, IWritableList<T> {&#xD;&#xA;		new T this[int index] { get; set; }&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;It would in turn be necessary for code to define implementations for all three properties.  Implicit interface implementation in C# may ease the burden of having to define three properties, since a class which defines `T this[int index] {get {...}; set {...};}` will cause the compiler to implement the read-only method using the specified getter, the write-only method using the specified setter, and the read-write method using both, but from the perspective of the Framework, there are in fact three separate properties, and the get/set of the read/write property is independent of the get/set properties associated with the read-only or write-only properties.&#xD;&#xA;&#xD;&#xA;Personally, I think it's annoying that neither vb.net nor C# is willing to use the fact that a property is being read as a clue that write-only properties shouldn't be considered in overload resolution, and likewise the fact that it's being written should exclude read-only properties, but I didn't design those languages nor the Framework.";;deleted 25 characters in body
