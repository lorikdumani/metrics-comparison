Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
81156415;27834291;783743;2;bc65d2f0-0bec-4e76-9ba5-1621f3993251;2015-01-08 06:35:51.0;"Inheritance in JavaScript is a little difficult to understand at first because:&#xD;&#xA;&#xD;&#xA;1. JavaScript is a prototypal object-oriented programming language (i.e. objects directly inherit from other objects). This means that there's no distinction between classes and objects. Objects which are used as classes are called prototypes.&#xD;&#xA;2. Unfortunately, the traditional way to create an instance of a prototype is by using `new` (which makes people think that the instance inherits from the constructor function, and not the prototype). This is called the [constructor pattern](http://aaditmshah.github.io/why-prototypal-inheritance-matters/#toc_6), and it's the main reason of confusion in JavaScript.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;For this reason `Object.create` was introduced. It allowed objects to directly inherit from other objects. However, `Object.create` is slow as compared to using `new`. I had the same problem that you did and I was looking for an  alternative; and I did come up with one.&#xD;&#xA;&#xD;&#xA;# The Traditional Way of OOP in JavaScript #&#xD;&#xA;&#xD;&#xA;Consider the following code:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function Person(firstname, lastname, gender) {&#xD;&#xA;        this.firstname = firstname;&#xD;&#xA;        this.lastname  = lastname;&#xD;&#xA;        this.gender    = gender;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Person.prototype.getFullname = function () {&#xD;&#xA;        return this.firstname + "" "" + this.lastname;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    Man.prototype             = new Person;&#xD;&#xA;    Man.prototype.constructor = Man;&#xD;&#xA;&#xD;&#xA;    function Man(firstname, lastname) {&#xD;&#xA;        Person.call(this, firstname, lastname, ""M"");&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    var bobMarley = new Man(""Bob"", ""Marley"");&#xD;&#xA;&#xD;&#xA;    alert(bobMarley.getFullname());&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;This way of writing code suffers from several problems:&#xD;&#xA;&#xD;&#xA;1. There is no encapsulation. The constructor function and the prototype methods are defined all over the place. It look incoherent. Like shaghetti. It doesn't look like one logical unit.&#xD;&#xA;2. We make `Man.prototype` inherit from `Person.prototype` by setting it to `new Person`. However, in doing so we're initializing the `firstname`, `lastname` and `gender` properties on `Man.prototype` which is wrong.&#xD;&#xA;&#xD;&#xA;# The New Way of OOP in JavaScript #&#xD;&#xA;&#xD;&#xA;With the introduction of `Object.create` we can now write code like this:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function Person(firstname, lastname, gender) {&#xD;&#xA;        this.firstname = firstname;&#xD;&#xA;        this.lastname  = lastname;&#xD;&#xA;        this.gender    = gender;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Person.prototype.getFullname = function () {&#xD;&#xA;        return this.firstname + "" "" + this.lastname;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    Man.prototype             = Object.create(Person.prototype);&#xD;&#xA;    Man.prototype.constructor = Man;&#xD;&#xA;&#xD;&#xA;    function Man(firstname, lastname) {&#xD;&#xA;        Person.call(this, firstname, lastname, ""M"");&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    var bobMarley = new Man(""Bob"", ""Marley"");&#xD;&#xA;&#xD;&#xA;    alert(bobMarley.getFullname());&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;The only change is that instead of `Man.prototype = new Person` we write `Man.prototype = Object.create(Person.prototype)`. This solves the second problem of the traditional method. However, the code still looks like spaghetti.&#xD;&#xA;&#xD;&#xA;However, `Object.create` is quite powerful. You could also use it to write object-oriented code without creating constructor functions at all. Some people call this the [initializer pattern](http://blog.javascriptroom.com/2013/01/21/the-initializer-pattern/):&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    var person = {&#xD;&#xA;        init: function (firstname, lastname, gender) {&#xD;&#xA;            this.firstname = firstname;&#xD;&#xA;            this.lastname  = lastname;&#xD;&#xA;            this.gender    = gender;&#xD;&#xA;        },&#xD;&#xA;        getFullname: function () {&#xD;&#xA;            return this.firstname + "" "" + this.lastname;&#xD;&#xA;        }&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    var man = Object.create(person, {&#xD;&#xA;        init: {&#xD;&#xA;            value: function (firstname, lastname) {&#xD;&#xA;                person.init.call(this, firstname, lastname, ""M"");&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    });&#xD;&#xA;&#xD;&#xA;    var bobMarley = Object.create(man);&#xD;&#xA;    bobMarley.init(""Bob"", ""Marley"");&#xD;&#xA;    alert(bobMarley.getFullname());&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;This solves all the problems of the traditional method. However, it also introduces some new problems of its own:&#xD;&#xA;&#xD;&#xA;1. The way of creating instances of prototypes is not consistent with the way of creating object literals.&#xD;&#xA;2. You have to create an instance using `Object.create` and then initialize the new object using `init`. This is much slower than simply using `new`.&#xD;&#xA;&#xD;&#xA;# My Way of OOP is JavaScript #&#xD;&#xA;&#xD;&#xA;To solve this problem, I wrote my own functions for OOP in JavaScript:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    var Person = defclass({&#xD;&#xA;        constructor: function (firstname, lastname, gender) {&#xD;&#xA;            this.firstname = firstname;&#xD;&#xA;            this.lastname  = lastname;&#xD;&#xA;            this.gender    = gender;&#xD;&#xA;        },&#xD;&#xA;        getFullname: function () {&#xD;&#xA;            return this.firstname + "" "" + this.lastname;&#xD;&#xA;        }&#xD;&#xA;    });&#xD;&#xA;&#xD;&#xA;    var Man = extend(Person, {&#xD;&#xA;        constructor: function (firstname, lastname) {&#xD;&#xA;            Person.call(this, firstname, lastname, ""M"");&#xD;&#xA;        }&#xD;&#xA;    });&#xD;&#xA;&#xD;&#xA;    var bobMarley = new Man(""Bob"", ""Marley"");&#xD;&#xA;&#xD;&#xA;    alert(bobMarley.getFullname());&#xD;&#xA;&#xD;&#xA;    function defclass(prototype) {&#xD;&#xA;        var constructor = prototype.constructor;&#xD;&#xA;        constructor.prototype = prototype;&#xD;&#xA;        return constructor;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    function extend(constructor, properties) {&#xD;&#xA;        var prototype = Object.create(constructor.prototype);&#xD;&#xA;        var keys      = Object.keys(properties);&#xD;&#xA;        var length    = keys.length;&#xD;&#xA;        var index     = 0;&#xD;&#xA;&#xD;&#xA;        while (index < length) {&#xD;&#xA;            var key = keys[index++];&#xD;&#xA;            prototype[key] = properties[key];&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        return defclass(prototype);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;I defined two functions `defclass` and `extend` for OOP in JavaScript. The `defclass` function creates a &ldquo;class&rdquo; from a prototype. This is possible because [prototypes and classes are isomorphic](http://stackoverflow.com/a/19640910/783743).&#xD;&#xA;&#xD;&#xA;The extend function is for inheritance. It creates an instance of the `prototype` of a `constructor` and copies some properties onto it before returning the &ldquo;class&rdquo; of the new prototype.&#xD;&#xA;&#xD;&#xA;This is the way I currently create prototype chains in JavaScript. It has the following advantages over other methods:&#xD;&#xA;&#xD;&#xA;1. Every &ldquo;class&rdquo; is encapsulated. There are no prototype methods dangling all over the place. It doesn't look like spaghetti.&#xD;&#xA;2. The `extend` function uses `Object.create` for inheritance. Hence no extra properties are added to the new prototype. It's a blank prototype.&#xD;&#xA;3. You don't have to worry about resetting the `constructor` property on the `prototype`. It is automatically done for you.&#xD;&#xA;4. The `defclass` and the `extend` functions are consistent unlike object literals and the `Object.create` functions in the initializer pattern.&#xD;&#xA;5. We create instances using `new` instead of `Object.create` and `init`. Hence the resulting code is much faster.&#xD;&#xA;&#xD;&#xA;Hope that helps.";;
81159263;27834291;783743;5;7a0c1703-364e-43e0-861e-4316b95de043;2015-01-08 07:32:35.0;"Inheritance in JavaScript is a little difficult to understand at first because:&#xD;&#xA;&#xD;&#xA;1. JavaScript is a prototypal object-oriented programming language (i.e. objects directly inherit from other objects). This means that there's no distinction between classes and objects. Objects which are used as classes are called prototypes.&#xD;&#xA;2. Unfortunately, the traditional way to create an instance of a prototype is by using `new` (which makes people think that the instance inherits from the constructor function, and not the prototype). This is called the [constructor pattern](http://aaditmshah.github.io/why-prototypal-inheritance-matters/#toc_6), and it's the main reason of confusion in JavaScript.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;For this reason `Object.create` was introduced. It allowed objects to directly inherit from other objects. However, `Object.create` is slow as compared to using `new`. I had the same problem that you did and I was looking for an  alternative; and I did come up with one.&#xD;&#xA;&#xD;&#xA;# The Traditional Way of OOP in JavaScript #&#xD;&#xA;&#xD;&#xA;Consider the following code:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function Person(firstname, lastname, gender) {&#xD;&#xA;        this.firstname = firstname;&#xD;&#xA;        this.lastname  = lastname;&#xD;&#xA;        this.gender    = gender;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Person.prototype.getFullname = function () {&#xD;&#xA;        return this.firstname + "" "" + this.lastname;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    Man.prototype             = new Person;&#xD;&#xA;    Man.prototype.constructor = Man;&#xD;&#xA;&#xD;&#xA;    function Man(firstname, lastname) {&#xD;&#xA;        Person.call(this, firstname, lastname, ""M"");&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    var bobMarley = new Man(""Bob"", ""Marley"");&#xD;&#xA;&#xD;&#xA;    alert(bobMarley.getFullname());&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;This way of writing code suffers from several problems:&#xD;&#xA;&#xD;&#xA;1. There is no encapsulation. The constructor function and the prototype methods are defined all over the place. It look incoherent. Like shaghetti. It doesn't look like one logical unit.&#xD;&#xA;2. We make `Man.prototype` inherit from `Person.prototype` by setting it to `new Person`. However, in doing so we're initializing the `firstname`, `lastname` and `gender` properties on `Man.prototype` which is wrong.&#xD;&#xA;&#xD;&#xA;# The New Way of OOP in JavaScript #&#xD;&#xA;&#xD;&#xA;With the introduction of `Object.create` we can now write code like this:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function Person(firstname, lastname, gender) {&#xD;&#xA;        this.firstname = firstname;&#xD;&#xA;        this.lastname  = lastname;&#xD;&#xA;        this.gender    = gender;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Person.prototype.getFullname = function () {&#xD;&#xA;        return this.firstname + "" "" + this.lastname;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    Man.prototype             = Object.create(Person.prototype);&#xD;&#xA;    Man.prototype.constructor = Man;&#xD;&#xA;&#xD;&#xA;    function Man(firstname, lastname) {&#xD;&#xA;        Person.call(this, firstname, lastname, ""M"");&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    var bobMarley = new Man(""Bob"", ""Marley"");&#xD;&#xA;&#xD;&#xA;    alert(bobMarley.getFullname());&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;The only change is that instead of `Man.prototype = new Person` we write `Man.prototype = Object.create(Person.prototype)`. This solves the second problem of the traditional method. However, the code still looks like spaghetti.&#xD;&#xA;&#xD;&#xA;However, `Object.create` is quite powerful. You could also use it to write object-oriented code without creating constructor functions at all. Some people call this the [initializer pattern](http://blog.javascriptroom.com/2013/01/21/the-initializer-pattern/):&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    var person = {&#xD;&#xA;        init: function (firstname, lastname, gender) {&#xD;&#xA;            this.firstname = firstname;&#xD;&#xA;            this.lastname  = lastname;&#xD;&#xA;            this.gender    = gender;&#xD;&#xA;        },&#xD;&#xA;        getFullname: function () {&#xD;&#xA;            return this.firstname + "" "" + this.lastname;&#xD;&#xA;        }&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    var man = Object.create(person, {&#xD;&#xA;        init: {&#xD;&#xA;            value: function (firstname, lastname) {&#xD;&#xA;                person.init.call(this, firstname, lastname, ""M"");&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    });&#xD;&#xA;&#xD;&#xA;    var bobMarley = Object.create(man);&#xD;&#xA;    bobMarley.init(""Bob"", ""Marley"");&#xD;&#xA;    alert(bobMarley.getFullname());&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;This solves all the problems of the traditional method. However, it also introduces some new problems of its own:&#xD;&#xA;&#xD;&#xA;1. The way of creating instances of prototypes is not consistent with the way of creating object literals.&#xD;&#xA;2. You have to create an instance using `Object.create` and then initialize the new object using `init`. This is much slower than simply using `new`.&#xD;&#xA;&#xD;&#xA;# My Way of OOP is JavaScript #&#xD;&#xA;&#xD;&#xA;To solve this problem, I wrote my own functions for OOP in JavaScript:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    var Person = defclass({&#xD;&#xA;        constructor: function (firstname, lastname, gender) {&#xD;&#xA;            this.firstname = firstname;&#xD;&#xA;            this.lastname  = lastname;&#xD;&#xA;            this.gender    = gender;&#xD;&#xA;        },&#xD;&#xA;        getFullname: function () {&#xD;&#xA;            return this.firstname + "" "" + this.lastname;&#xD;&#xA;        }&#xD;&#xA;    });&#xD;&#xA;&#xD;&#xA;    var Man = extend(Person, {&#xD;&#xA;        constructor: function (firstname, lastname) {&#xD;&#xA;            Person.call(this, firstname, lastname, ""M"");&#xD;&#xA;        }&#xD;&#xA;    });&#xD;&#xA;&#xD;&#xA;    var bobMarley = new Man(""Bob"", ""Marley"");&#xD;&#xA;&#xD;&#xA;    alert(bobMarley.getFullname());&#xD;&#xA;&#xD;&#xA;    function defclass(prototype) {&#xD;&#xA;        var constructor = prototype.constructor;&#xD;&#xA;        constructor.prototype = prototype;&#xD;&#xA;        return constructor;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    function extend(constructor, properties) {&#xD;&#xA;        var prototype = Object.create(constructor.prototype);&#xD;&#xA;        var keys      = Object.keys(properties);&#xD;&#xA;        var length    = keys.length;&#xD;&#xA;        var index     = 0;&#xD;&#xA;&#xD;&#xA;        while (index < length) {&#xD;&#xA;            var key = keys[index++];&#xD;&#xA;            prototype[key] = properties[key];&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        return defclass(prototype);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;I defined two functions `defclass` and `extend` for OOP in JavaScript. The `defclass` function creates a &ldquo;class&rdquo; from a prototype. This is possible because [prototypes and classes are isomorphic](http://stackoverflow.com/a/19640910/783743).&#xD;&#xA;&#xD;&#xA;The extend function is for inheritance. It creates an instance of the `prototype` of a `constructor` and copies some properties onto it before returning the &ldquo;class&rdquo; of the new prototype.&#xD;&#xA;&#xD;&#xA;This is the way I currently create prototype chains in JavaScript. It has the following advantages over other methods:&#xD;&#xA;&#xD;&#xA;1. Every &ldquo;class&rdquo; is encapsulated. There are no prototype methods dangling all over the place. It doesn't look like spaghetti.&#xD;&#xA;2. The `extend` function uses `Object.create` for inheritance. Hence no extra properties are added to the new prototype. It's a blank prototype.&#xD;&#xA;3. You don't have to worry about resetting the `constructor` property on the `prototype`. It is automatically done for you.&#xD;&#xA;4. The `defclass` and the `extend` functions are consistent unlike object literals and the `Object.create` functions in the initializer pattern.&#xD;&#xA;5. We create instances using `new` instead of `Object.create` and `init`. Hence the resulting code is much faster.&#xD;&#xA;&#xD;&#xA;I could be wrong now, but I don't think so. Hope that helps.";;added 44 characters in body
147549415;27834291;-1;5;cf7e505c-5326-4ec6-b454-55df253a0ffd;2017-05-23 12:28:28.0;"Inheritance in JavaScript is a little difficult to understand at first because:&#xD;&#xA;&#xD;&#xA;1. JavaScript is a prototypal object-oriented programming language (i.e. objects directly inherit from other objects). This means that there's no distinction between classes and objects. Objects which are used as classes are called prototypes.&#xD;&#xA;2. Unfortunately, the traditional way to create an instance of a prototype is by using `new` (which makes people think that the instance inherits from the constructor function, and not the prototype). This is called the [constructor pattern](http://aaditmshah.github.io/why-prototypal-inheritance-matters/#toc_6), and it's the main reason of confusion in JavaScript.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;For this reason `Object.create` was introduced. It allowed objects to directly inherit from other objects. However, `Object.create` is slow as compared to using `new`. I had the same problem that you did and I was looking for an  alternative; and I did come up with one.&#xD;&#xA;&#xD;&#xA;# The Traditional Way of OOP in JavaScript #&#xD;&#xA;&#xD;&#xA;Consider the following code:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function Person(firstname, lastname, gender) {&#xD;&#xA;        this.firstname = firstname;&#xD;&#xA;        this.lastname  = lastname;&#xD;&#xA;        this.gender    = gender;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Person.prototype.getFullname = function () {&#xD;&#xA;        return this.firstname + "" "" + this.lastname;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    Man.prototype             = new Person;&#xD;&#xA;    Man.prototype.constructor = Man;&#xD;&#xA;&#xD;&#xA;    function Man(firstname, lastname) {&#xD;&#xA;        Person.call(this, firstname, lastname, ""M"");&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    var bobMarley = new Man(""Bob"", ""Marley"");&#xD;&#xA;&#xD;&#xA;    alert(bobMarley.getFullname());&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;This way of writing code suffers from several problems:&#xD;&#xA;&#xD;&#xA;1. There is no encapsulation. The constructor function and the prototype methods are defined all over the place. It look incoherent. Like shaghetti. It doesn't look like one logical unit.&#xD;&#xA;2. We make `Man.prototype` inherit from `Person.prototype` by setting it to `new Person`. However, in doing so we're initializing the `firstname`, `lastname` and `gender` properties on `Man.prototype` which is wrong.&#xD;&#xA;&#xD;&#xA;# The New Way of OOP in JavaScript #&#xD;&#xA;&#xD;&#xA;With the introduction of `Object.create` we can now write code like this:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function Person(firstname, lastname, gender) {&#xD;&#xA;        this.firstname = firstname;&#xD;&#xA;        this.lastname  = lastname;&#xD;&#xA;        this.gender    = gender;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Person.prototype.getFullname = function () {&#xD;&#xA;        return this.firstname + "" "" + this.lastname;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    Man.prototype             = Object.create(Person.prototype);&#xD;&#xA;    Man.prototype.constructor = Man;&#xD;&#xA;&#xD;&#xA;    function Man(firstname, lastname) {&#xD;&#xA;        Person.call(this, firstname, lastname, ""M"");&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    var bobMarley = new Man(""Bob"", ""Marley"");&#xD;&#xA;&#xD;&#xA;    alert(bobMarley.getFullname());&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;The only change is that instead of `Man.prototype = new Person` we write `Man.prototype = Object.create(Person.prototype)`. This solves the second problem of the traditional method. However, the code still looks like spaghetti.&#xD;&#xA;&#xD;&#xA;However, `Object.create` is quite powerful. You could also use it to write object-oriented code without creating constructor functions at all. Some people call this the [initializer pattern](http://blog.javascriptroom.com/2013/01/21/the-initializer-pattern/):&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    var person = {&#xD;&#xA;        init: function (firstname, lastname, gender) {&#xD;&#xA;            this.firstname = firstname;&#xD;&#xA;            this.lastname  = lastname;&#xD;&#xA;            this.gender    = gender;&#xD;&#xA;        },&#xD;&#xA;        getFullname: function () {&#xD;&#xA;            return this.firstname + "" "" + this.lastname;&#xD;&#xA;        }&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    var man = Object.create(person, {&#xD;&#xA;        init: {&#xD;&#xA;            value: function (firstname, lastname) {&#xD;&#xA;                person.init.call(this, firstname, lastname, ""M"");&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    });&#xD;&#xA;&#xD;&#xA;    var bobMarley = Object.create(man);&#xD;&#xA;    bobMarley.init(""Bob"", ""Marley"");&#xD;&#xA;    alert(bobMarley.getFullname());&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;This solves all the problems of the traditional method. However, it also introduces some new problems of its own:&#xD;&#xA;&#xD;&#xA;1. The way of creating instances of prototypes is not consistent with the way of creating object literals.&#xD;&#xA;2. You have to create an instance using `Object.create` and then initialize the new object using `init`. This is much slower than simply using `new`.&#xD;&#xA;&#xD;&#xA;# My Way of OOP is JavaScript #&#xD;&#xA;&#xD;&#xA;To solve this problem, I wrote my own functions for OOP in JavaScript:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    var Person = defclass({&#xD;&#xA;        constructor: function (firstname, lastname, gender) {&#xD;&#xA;            this.firstname = firstname;&#xD;&#xA;            this.lastname  = lastname;&#xD;&#xA;            this.gender    = gender;&#xD;&#xA;        },&#xD;&#xA;        getFullname: function () {&#xD;&#xA;            return this.firstname + "" "" + this.lastname;&#xD;&#xA;        }&#xD;&#xA;    });&#xD;&#xA;&#xD;&#xA;    var Man = extend(Person, {&#xD;&#xA;        constructor: function (firstname, lastname) {&#xD;&#xA;            Person.call(this, firstname, lastname, ""M"");&#xD;&#xA;        }&#xD;&#xA;    });&#xD;&#xA;&#xD;&#xA;    var bobMarley = new Man(""Bob"", ""Marley"");&#xD;&#xA;&#xD;&#xA;    alert(bobMarley.getFullname());&#xD;&#xA;&#xD;&#xA;    function defclass(prototype) {&#xD;&#xA;        var constructor = prototype.constructor;&#xD;&#xA;        constructor.prototype = prototype;&#xD;&#xA;        return constructor;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    function extend(constructor, properties) {&#xD;&#xA;        var prototype = Object.create(constructor.prototype);&#xD;&#xA;        var keys      = Object.keys(properties);&#xD;&#xA;        var length    = keys.length;&#xD;&#xA;        var index     = 0;&#xD;&#xA;&#xD;&#xA;        while (index < length) {&#xD;&#xA;            var key = keys[index++];&#xD;&#xA;            prototype[key] = properties[key];&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        return defclass(prototype);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;I defined two functions `defclass` and `extend` for OOP in JavaScript. The `defclass` function creates a &ldquo;class&rdquo; from a prototype. This is possible because [prototypes and classes are isomorphic](https://stackoverflow.com/a/19640910/783743).&#xD;&#xA;&#xD;&#xA;The extend function is for inheritance. It creates an instance of the `prototype` of a `constructor` and copies some properties onto it before returning the &ldquo;class&rdquo; of the new prototype.&#xD;&#xA;&#xD;&#xA;This is the way I currently create prototype chains in JavaScript. It has the following advantages over other methods:&#xD;&#xA;&#xD;&#xA;1. Every &ldquo;class&rdquo; is encapsulated. There are no prototype methods dangling all over the place. It doesn't look like spaghetti.&#xD;&#xA;2. The `extend` function uses `Object.create` for inheritance. Hence no extra properties are added to the new prototype. It's a blank prototype.&#xD;&#xA;3. You don't have to worry about resetting the `constructor` property on the `prototype`. It is automatically done for you.&#xD;&#xA;4. The `defclass` and the `extend` functions are consistent unlike object literals and the `Object.create` functions in the initializer pattern.&#xD;&#xA;5. We create instances using `new` instead of `Object.create` and `init`. Hence the resulting code is much faster.&#xD;&#xA;&#xD;&#xA;I could be wrong now, but I don't think so. Hope that helps.";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
