Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
55824310;21174174;85371;2;1f96b8fc-0afc-4060-9d2a-49976f370221;2014-01-16 22:22:59.0;"The **[docs](http://www.boost.org/doc/libs/1_55_0/libs/multiprecision/doc/html/boost_multiprecision/intro.html)** say&#xD;&#xA;&#xD;&#xA;> Conversions are also allowed: &#xD;&#xA;>&#xD;&#xA;>     d = a; // OK, widening conversion.&#xD;&#xA;>     d = a * b;  // OK, can convert from an expression template too.&#xD;&#xA;> &#xD;&#xA;> However conversions that are inherently lossy are either declared explicit or else forbidden altogether: &#xD;&#xA;>&#xD;&#xA;>     d = 3.14;  // Error implicit conversion from float not allowed.&#xD;&#xA;>     d = static_cast<mp::int512_t>(3.14);  // OK explicit construction is allowed&#xD;&#xA;&#xD;&#xA;----&#xD;&#xA;&#xD;&#xA;So, what you're seeing is a lossy conversion. Demonstrating that the conversion would be disallowed if you hadn't specified it _explicitly_:&#xD;&#xA;&#xD;&#xA;    cpp_rational a(""4561231231235/123123123123"");&#xD;&#xA;    int i   = a;        // error: cannot convert `cpp_rational` to `int` in initialization&#xD;&#xA;    float f = a;        // error: cannot convert `cpp_rational` to `float` in initialization&#xD;&#xA;    long double ld = a; // error: cannot convert `cpp_rational` to `long double` in initialization&#xD;&#xA;    long long   ll = a; // error: cannot convert `cpp_rational` to `long long int` in initialization&#xD;&#xA;&#xD;&#xA;So, what you're doing with all the explicit casts, is telling the compiler to ""Shut up; I know what I'm doing"". Hence why you didn't get the warning.&#xD;&#xA;&#xD;&#xA;Now, how to fix things: keep the division in the multi-precision domain:&#xD;&#xA;&#xD;&#xA;    cpp_int v = numerator(a)/denominator(a);&#xD;&#xA;&#xD;&#xA;You're sample fixed: **[Live On Coliru](http://coliru.stacked-crooked.com/a/1f4cc815f6ca0df1)**&#xD;&#xA;&#xD;&#xA;    #include <boost/multiprecision/cpp_int.hpp>&#xD;&#xA;    #include <iostream>&#xD;&#xA;&#xD;&#xA;    using namespace boost::multiprecision;&#xD;&#xA;&#xD;&#xA;    int main() {&#xD;&#xA;        cpp_rational a(""4561231231235/123123123123"");&#xD;&#xA;        cpp_int v = numerator(a)/denominator(a);&#xD;&#xA;        std::cout << ""convert: "" << v.convert_to<int>() << ""\\n"";&#xD;&#xA;&#xD;&#xA;        a = cpp_rational(""456/123"");&#xD;&#xA;        v = numerator(a)/denominator(a);&#xD;&#xA;        std::cout << ""convert: "" << v.convert_to<int>() << ""\\n"";&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;
55824812;21174174;85371;5;1a66ddae-c49d-4ad5-9c3d-10d544944f80;2014-01-16 22:32:11.0;"The **[docs](http://www.boost.org/doc/libs/1_55_0/libs/multiprecision/doc/html/boost_multiprecision/intro.html)** say&#xD;&#xA;&#xD;&#xA;> Conversions are also allowed: &#xD;&#xA;>&#xD;&#xA;>     d = a; // OK, widening conversion.&#xD;&#xA;>     d = a * b;  // OK, can convert from an expression template too.&#xD;&#xA;> &#xD;&#xA;> However conversions that are inherently lossy are either declared explicit or else forbidden altogether: &#xD;&#xA;>&#xD;&#xA;>     d = 3.14;  // Error implicit conversion from float not allowed.&#xD;&#xA;>     d = static_cast<mp::int512_t>(3.14);  // OK explicit construction is allowed&#xD;&#xA;&#xD;&#xA;----&#xD;&#xA;&#xD;&#xA;So, what you're seeing is a lossy conversion. Demonstrating that the conversion would be disallowed if you hadn't specified it _explicitly_:&#xD;&#xA;&#xD;&#xA;    cpp_rational a(""4561231231235/123123123123"");&#xD;&#xA;    int i   = a;        // error: cannot convert `cpp_rational` to `int` in initialization&#xD;&#xA;    float f = a;        // error: cannot convert `cpp_rational` to `float` in initialization&#xD;&#xA;    long double ld = a; // error: cannot convert `cpp_rational` to `long double` in initialization&#xD;&#xA;    long long   ll = a; // error: cannot convert `cpp_rational` to `long long int` in initialization&#xD;&#xA;&#xD;&#xA;So, what you're doing with all the explicit casts, is telling the compiler to ""Shut up; I know what I'm doing"". Hence why you didn't get the warning.&#xD;&#xA;&#xD;&#xA;Now, how to fix things: keep the division in the multi-precision domain:&#xD;&#xA;&#xD;&#xA;    cpp_int v = numerator(a)/denominator(a);&#xD;&#xA;&#xD;&#xA;Your sample fixed: **[Live On Coliru](http://coliru.stacked-crooked.com/a/1f4cc815f6ca0df1)**&#xD;&#xA;&#xD;&#xA;    #include <boost/multiprecision/cpp_int.hpp>&#xD;&#xA;    #include <iostream>&#xD;&#xA;&#xD;&#xA;    using namespace boost::multiprecision;&#xD;&#xA;&#xD;&#xA;    int main() {&#xD;&#xA;        cpp_rational a(""4561231231235/123123123123"");&#xD;&#xA;        cpp_int v = numerator(a)/denominator(a);&#xD;&#xA;        std::cout << ""convert: "" << v.convert_to<int>() << ""\\n"";&#xD;&#xA;&#xD;&#xA;        a = cpp_rational(""456/123"");&#xD;&#xA;        v = numerator(a)/denominator(a);&#xD;&#xA;        std::cout << ""convert: "" << v.convert_to<int>() << ""\\n"";&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";;deleted 2 characters in body
