Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
142639288;43295645;5459839;2;9da31507-0204-4da8-ab98-7e17807b6844;2017-04-08 15:00:36.0;"You could do it like this:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false console: true babel: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function purgeNodes(root, whitelist) {&#xD;&#xA;        const hash = new Set(whitelist); // for faster look-up&#xD;&#xA;        const blacklist = [...root.querySelectorAll(""*"")].reverse().filter( node =>&#xD;&#xA;            !node.children.length && !hash.has(node) && node.parentNode.removeChild(node)&#xD;&#xA;        );&#xD;&#xA;        return blacklist;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    purge.onclick = _ => purgeNodes(document.body, document.querySelectorAll('.white'));&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<!-- language: lang-css -->&#xD;&#xA;&#xD;&#xA;    div { margin-left: 10px; padding-left: 10px; border: 1px solid; background-color: white }&#xD;&#xA;    .white { background-color: pink }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<!-- language: lang-html -->&#xD;&#xA;&#xD;&#xA;    <button id=""purge"">Purge</button>&#xD;&#xA;    <div id=""a"">a&#xD;&#xA;        <div id=""b"" class=""white"">b&#xD;&#xA;            <div id=""c"">c</div>&#xD;&#xA;            <div id=""d"">d</div>&#xD;&#xA;            <div id=""e"">e</div>&#xD;&#xA;        </div>&#xD;&#xA;        <div id=""f"">f&#xD;&#xA;            <div id=""g"">g</div>&#xD;&#xA;            <div id=""h"">h&#xD;&#xA;                <div id=""i"">i&#xD;&#xA;                    <div id=""j"">j</div>&#xD;&#xA;                    <div id=""k"" class=""white"">k</div>&#xD;&#xA;                    <div id=""l"">l</div>&#xD;&#xA;                </div>&#xD;&#xA;            </div>&#xD;&#xA;            <div id=""m"">m</div>&#xD;&#xA;        </div>&#xD;&#xA;        <div id=""n"">n&#xD;&#xA;            <div id=""o"">o</div>&#xD;&#xA;            <div id=""p"">p</div>&#xD;&#xA;        </div>&#xD;&#xA;    </div>&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;The `reverse()` call is crucial to this algorithm. It relies on the fact that `querySelectorAll('*')` will return the nodes in document order. So if you iterate over them in reverse order, you will start with a leaf. If that node is deleted, the parent node might become a leaf. If that parent never becomes a leaf, it means it has a descendant that is on the white list. So the node tree gets trimmed from the bottom up.";;
142639470;43295645;5459839;5;47c04d77-bc67-40d1-b148-7b01dee3beb5;2017-04-08 15:05:49.0;"You could do it like this:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false console: true babel: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function purgeNodes(root, whitelist) {&#xD;&#xA;        const hash = new Set(whitelist); // for faster look-up&#xD;&#xA;        const blacklist = [...root.querySelectorAll(""*"")].reverse().filter( node =>&#xD;&#xA;            !node.children.length && !hash.has(node) && node.parentNode.removeChild(node)&#xD;&#xA;        );&#xD;&#xA;        return blacklist;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    purge.onclick = _ => purgeNodes(document.body, document.querySelectorAll('.white'));&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<!-- language: lang-css -->&#xD;&#xA;&#xD;&#xA;    div { margin-left: 10px; padding-left: 10px; border: 1px solid; background-color: white }&#xD;&#xA;    .white { background-color: pink }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<!-- language: lang-html -->&#xD;&#xA;&#xD;&#xA;    <button id=""purge"">Purge</button>&#xD;&#xA;    <div id=""a"">a&#xD;&#xA;        <div id=""b"" class=""white"">b&#xD;&#xA;            <div id=""c"">c</div>&#xD;&#xA;            <div id=""d"">d</div>&#xD;&#xA;            <div id=""e"">e</div>&#xD;&#xA;        </div>&#xD;&#xA;        <div id=""f"">f&#xD;&#xA;            <div id=""g"">g</div>&#xD;&#xA;            <div id=""h"">h&#xD;&#xA;                <div id=""i"">i&#xD;&#xA;                    <div id=""j"">j</div>&#xD;&#xA;                    <div id=""k"" class=""white"">k</div>&#xD;&#xA;                    <div id=""l"">l</div>&#xD;&#xA;                </div>&#xD;&#xA;            </div>&#xD;&#xA;            <div id=""m"">m</div>&#xD;&#xA;        </div>&#xD;&#xA;        <div id=""n"">n&#xD;&#xA;            <div id=""o"">o</div>&#xD;&#xA;            <div id=""p"">p</div>&#xD;&#xA;        </div>&#xD;&#xA;    </div>&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;The `reverse()` call is crucial to this algorithm. It relies on the fact that `querySelectorAll('*')` will return the nodes in document order. So if you iterate over them in reverse order, you will start with a leaf. If that node is deleted, the parent node might become a leaf. If that parent never becomes a leaf, it means it has a descendant that is on the white list. So the node tree gets trimmed from the bottom up.&#xD;&#xA;&#xD;&#xA;This algorithm only regards elements as children, not text nodes and other stuff (comments, ...). So the latter will survive if their container element survives.";;added 165 characters in body
142641135;43295645;5459839;5;3842b2a0-ff10-43b8-a1f7-3f36967df0cd;2017-04-08 15:48:17.0;"You could do it like this:&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: false console: true babel: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function purgeNodes(root, whitelist) {&#xD;&#xA;        const hash = new Set(whitelist); // for faster look-up&#xD;&#xA;        const blacklist = [...root.querySelectorAll(""*"")].reverse().filter( node =>&#xD;&#xA;            !node.children.length && !hash.has(node) && node.parentNode.removeChild(node)&#xD;&#xA;        );&#xD;&#xA;        return blacklist;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    purge.onclick = _ => purgeNodes(document.body, document.querySelectorAll('.white'));&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<!-- language: lang-css -->&#xD;&#xA;&#xD;&#xA;    div { margin-left: 10px; padding-left: 10px; border: 1px solid; background-color: white }&#xD;&#xA;    .white { background-color: pink }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<!-- language: lang-html -->&#xD;&#xA;&#xD;&#xA;    <button id=""purge"">Purge</button>&#xD;&#xA;    <div id=""a"">a&#xD;&#xA;        <div id=""b"" class=""white"">b&#xD;&#xA;            <div id=""c"">c</div>&#xD;&#xA;            <div id=""d"">d</div>&#xD;&#xA;            <div id=""e"">e</div>&#xD;&#xA;        </div>&#xD;&#xA;        <div id=""f"">f&#xD;&#xA;            <div id=""g"">g</div>&#xD;&#xA;            <div id=""h"">h&#xD;&#xA;                <div id=""i"">i&#xD;&#xA;                    <div id=""j"">j</div>&#xD;&#xA;                    <div id=""k"" class=""white"">k</div>&#xD;&#xA;                    <div id=""l"">l</div>&#xD;&#xA;                </div>&#xD;&#xA;            </div>&#xD;&#xA;            <div id=""m"">m</div>&#xD;&#xA;        </div>&#xD;&#xA;        <div id=""n"">n&#xD;&#xA;            <div id=""o"">o</div>&#xD;&#xA;            <div id=""p"">p</div>&#xD;&#xA;        </div>&#xD;&#xA;    </div>&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;The `reverse()` call is crucial to this algorithm. It relies on the fact that `querySelectorAll('*')` will return the nodes [in document order<sup>&nbsp;w3.org</sup>](https://www.w3.org/TR/selectors-api/#findelements) (emphasis mine):&#xD;&#xA;&#xD;&#xA;> The `querySelectorAll()` methods on the `Document`, `DocumentFragment`, and `Element` interfaces must return a `NodeList` containing all of the matching `Element` nodes within the subtrees of the context node, ***in document order***.&#xD;&#xA;&#xD;&#xA;See also on [`MDN`](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll):&#xD;&#xA;&#xD;&#xA;> ...depth-first pre-order traversal...&#xD;&#xA;&#xD;&#xA;So if you iterate over them in reverse order, you will start with a leaf. If that node is deleted, the parent node might become a leaf. If that parent never becomes a leaf, it means it has a descendant that is on the white list. So the node tree gets trimmed from the bottom up.&#xD;&#xA;&#xD;&#xA;This algorithm only regards elements as children, not text nodes and other stuff (comments, ...). So the latter will survive if their container element survives.";;Documented the fact that traversal is depth-first pre-order.
142699898;43295645;5459839;5;51d93f44-a650-49ea-bdbf-404332bf0ad5;2017-04-09 20:11:56.0;"As became clear in comments and an update to the question, there are two interpretations. One where nodes that have no whitelisted children are removed, and another where those nodes are only removed if they don't have a whitelisted ancestor.&#xD;&#xA;&#xD;&#xA;I provide a separate solution for each of these cases.&#xD;&#xA;&#xD;&#xA;###1. Nodes are removed when they have no whitelisted descendants&#xD;&#xA;&#xD;&#xA;    function purgeNodes(root, whitelist) {&#xD;&#xA;        const hash = new Set(whitelist); // for faster look-up&#xD;&#xA;        const blacklist = [...root.querySelectorAll(""*"")].reverse().filter( node =>&#xD;&#xA;            !node.children.length && !hash.has(node) && node.parentNode.removeChild(node)&#xD;&#xA;        );&#xD;&#xA;        return blacklist;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: true console: true babel: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function purgeNodes(root, whitelist) {&#xD;&#xA;        const hash = new Set(whitelist); // for faster look-up&#xD;&#xA;        const blacklist = [...root.querySelectorAll(""*"")].reverse().filter( node =>&#xD;&#xA;            !node.children.length && !hash.has(node) && node.parentNode.removeChild(node)&#xD;&#xA;        );&#xD;&#xA;        return blacklist;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    purge.onclick = _ => purgeNodes(document.body, document.querySelectorAll('.white'));&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<!-- language: lang-css -->&#xD;&#xA;&#xD;&#xA;    div { margin-left: 10px; padding-left: 10px; border: 1px solid; background-color: white }&#xD;&#xA;    .white { background-color: pink }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<!-- language: lang-html -->&#xD;&#xA;&#xD;&#xA;    <button id=""purge"">Purge</button>&#xD;&#xA;    <div id=""a"">a&#xD;&#xA;        <div id=""b"" class=""white"">b&#xD;&#xA;            <div id=""c"">c</div>&#xD;&#xA;            <div id=""d"">d</div>&#xD;&#xA;            <div id=""e"">e</div>&#xD;&#xA;        </div>&#xD;&#xA;        <div id=""f"">f&#xD;&#xA;            <div id=""g"">g</div>&#xD;&#xA;            <div id=""h"">h&#xD;&#xA;                <div id=""i"">i&#xD;&#xA;                    <div id=""j"">j</div>&#xD;&#xA;                    <div id=""k"" class=""white"">k</div>&#xD;&#xA;                    <div id=""l"">l</div>&#xD;&#xA;                </div>&#xD;&#xA;            </div>&#xD;&#xA;            <div id=""m"">m</div>&#xD;&#xA;        </div>&#xD;&#xA;        <div id=""n"">n&#xD;&#xA;            <div id=""o"">o</div>&#xD;&#xA;            <div id=""p"">p</div>&#xD;&#xA;        </div>&#xD;&#xA;    </div>&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;The `reverse()` call is crucial to this algorithm. It relies on the fact that `querySelectorAll('*')` will return the nodes [in document order<sup>&nbsp;w3.org</sup>](https://www.w3.org/TR/selectors-api/#findelements) (emphasis mine):&#xD;&#xA;&#xD;&#xA;> The `querySelectorAll()` methods on the `Document`, `DocumentFragment`, and `Element` interfaces must return a `NodeList` containing all of the matching `Element` nodes within the subtrees of the context node, ***in document order***.&#xD;&#xA;&#xD;&#xA;See also on [`MDN`](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll):&#xD;&#xA;&#xD;&#xA;> ...depth-first pre-order traversal...&#xD;&#xA;&#xD;&#xA;So if you iterate over them in reverse order, you will start with a leaf. If that node is deleted, the parent node might become a leaf. If that parent never becomes a leaf, it means it has a descendant that is on the white list. So the node tree gets trimmed from the bottom up.&#xD;&#xA;&#xD;&#xA;This algorithm only regards elements as children, not text nodes and other stuff (comments, ...). So the latter will survive if their container element survives.&#xD;&#xA;&#xD;&#xA;###2. Nodes are removed when they don't have descendants nor ancestors that are whitelisted&#xD;&#xA;&#xD;&#xA;In this case a recursive, top-down algorithm is more suitable:&#xD;&#xA;&#xD;&#xA;    function purgeNodes(root, whitelist) {&#xD;&#xA;        const hash = new Set(whitelist); // for faster look-up&#xD;&#xA;        const recurse = node => hash.has(node) || [...node.children].filter(recurse)[0] &#xD;&#xA;                                               || !node.parentNode.removeChild(node);&#xD;&#xA;        recurse(root);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;<!-- begin snippet: js hide: true console: true babel: false -->&#xD;&#xA;&#xD;&#xA;<!-- language: lang-js -->&#xD;&#xA;&#xD;&#xA;    function purgeNodes(root, whitelist) {&#xD;&#xA;        const hash = new Set(whitelist); // for faster look-up&#xD;&#xA;        const recurse = node => hash.has(node) || [...node.children].filter(recurse)[0] &#xD;&#xA;                                               || !node.parentNode.removeChild(node);&#xD;&#xA;        recurse(root);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    purge.onclick = _ => purgeNodes(document.body, document.querySelectorAll('.white'));&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<!-- language: lang-css -->&#xD;&#xA;&#xD;&#xA;    div { margin-left: 10px; padding-left: 10px; border: 1px solid; background-color: white }&#xD;&#xA;    .white { background-color: pink }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<!-- language: lang-html -->&#xD;&#xA;&#xD;&#xA;    <button id=""purge"">Purge</button>&#xD;&#xA;    <div id=""a"">a&#xD;&#xA;        <div id=""b"" class=""white"">b&#xD;&#xA;            <div id=""c"">c</div>&#xD;&#xA;            <div id=""d"">d</div>&#xD;&#xA;            <div id=""e"">e</div>&#xD;&#xA;        </div>&#xD;&#xA;        <div id=""f"">f&#xD;&#xA;            <div id=""g"">g</div>&#xD;&#xA;            <div id=""h"">h&#xD;&#xA;                <div id=""i"">i&#xD;&#xA;                    <div id=""j"">j</div>&#xD;&#xA;                    <div id=""k"" class=""white"">k</div>&#xD;&#xA;                    <div id=""l"">l</div>&#xD;&#xA;                </div>&#xD;&#xA;            </div>&#xD;&#xA;            <div id=""m"">m</div>&#xD;&#xA;        </div>&#xD;&#xA;        <div id=""n"">n&#xD;&#xA;            <div id=""o"">o</div>&#xD;&#xA;            <div id=""p"">p</div>&#xD;&#xA;        </div>&#xD;&#xA;    </div>&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<!-- end snippet -->&#xD;&#xA;&#xD;&#xA;Note the different output: the nodes *c, d* and *e* are not removed, because *b* is whitelisted.&#xD;&#xA;&#xD;&#xA;This function does not return the removed nodes, just a value indicating whether the root still has children after the purge: a falsy/truthy value (not necessarily boolean).&#xD;&#xA;&#xD;&#xA;Note that `!node.parentNode.removeChild(node)` is always `false`, because `removeChild` will return the removed element, and the negation (`!`) of that is always `false`. This is to ensure the function returns `false` when it removes the node passed as argument.&#xD;&#xA;&#xD;&#xA;`[...node.children].filter(recurse)[0]` will perform the recursion on each of the children, and only keep an array where that call is truthy, i.e. the children that should not be removed. By referencing `[0]` we check if there is at least one such node. I could also have used `.length` or `.length>0`, but `[0]` is shorter and also has a truthy value when it exists, as then it is an object.";;"Added solution for alternative intpretation "
