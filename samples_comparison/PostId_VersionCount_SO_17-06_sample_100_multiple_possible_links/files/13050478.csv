Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
30918064;13050478;20394;2;44bb2a0e-358b-45ab-891f-d4f5b9087cc0;2012-10-24 13:38:30.0;"There are two things at play here : activation records, and objects on the heap.&#xD;&#xA;&#xD;&#xA;You start off with an activation frame for global variables:&#xD;&#xA;&#xD;&#xA;    globArray : undefined&#xD;&#xA;&#xD;&#xA;and the heap contains literals that appear in your code&#xD;&#xA;&#xD;&#xA;    ptr0      : ""craig""&#xD;&#xA;    ptr1      : ""silva""&#xD;&#xA;&#xD;&#xA;where `ptr0`, `ptr1`, etc. are just addresses or labels that refer to a particular location in memory.&#xD;&#xA;&#xD;&#xA;When you call `test()`, the interpreter pushes a new activation frame which contains boxes for local variables.&#xD;&#xA;&#xD;&#xA;    globArray : undefined&#xD;&#xA;    ---------------------&#xD;&#xA;    names     : undefined&#xD;&#xA;&#xD;&#xA;Then the interpreter evaluates `[""craig"", ""silva""]` which creates an object on the heap.&#xD;&#xA;&#xD;&#xA;    ptr0      : ""craig""&#xD;&#xA;    ptr1      : ""silva""&#xD;&#xA;    ptr2      : [ &ptr0, &ptr1 ]&#xD;&#xA;&#xD;&#xA;so `ptr2` now is a location in memory containing an array that points to two values.&#xD;&#xA;&#xD;&#xA;This memory location is now stored in the `names` location in the activation record, so your call stack looks like&#xD;&#xA;&#xD;&#xA;    globArray : undefined&#xD;&#xA;    ---------------------&#xD;&#xA;    names     : &ptr2&#xD;&#xA;&#xD;&#xA;The assignment `names = ...` does not change the heap, just the activation record.&#xD;&#xA;&#xD;&#xA;Next `globArray = names` copies the contents of one activation record entry to another.&#xD;&#xA;&#xD;&#xA;    globArray : &ptr2&#xD;&#xA;    ---------------------&#xD;&#xA;    names     : &ptr2&#xD;&#xA;&#xD;&#xA;Then the call to `test` ends so that activation record is discarded, leaving&#xD;&#xA;&#xD;&#xA;    globArray : &ptr2&#xD;&#xA;&#xD;&#xA;where the global `globArray` points to the object created during the call to `test`.&#xD;&#xA;The end of the function just changes the active activation records, not the heap, so the heap still looks like&#xD;&#xA;&#xD;&#xA;    ptr0      : ""craig""&#xD;&#xA;    ptr1      : ""silva""&#xD;&#xA;    ptr2      : [ &ptr0, &ptr1 ]&#xD;&#xA;&#xD;&#xA;so `ptr2` is still the same array.&#xD;&#xA;&#xD;&#xA;`names` (the entry in the activation record) is gone, but the object it pointed to is not since it is still pointed to by the `globArray` entry in an active activation record.";;
30918346;13050478;20394;5;84eabbd0-01a4-4dd2-87a2-7e3bc7777c39;2012-10-24 13:43:31.0;"There are two things at play here : activation records, and objects on the heap.&#xD;&#xA;&#xD;&#xA;You start off with an activation frame for global variables:&#xD;&#xA;&#xD;&#xA;    globArray : undefined&#xD;&#xA;&#xD;&#xA;and the heap contains literals that appear in your code&#xD;&#xA;&#xD;&#xA;    ptr0      : ""craig""&#xD;&#xA;    ptr1      : ""silva""&#xD;&#xA;&#xD;&#xA;where `ptr0`, `ptr1`, etc. are just addresses or labels that refer to a particular location in memory.&#xD;&#xA;&#xD;&#xA;When you call `test()`, the interpreter pushes a new activation frame which contains boxes for local variables.&#xD;&#xA;&#xD;&#xA;    globArray : undefined&#xD;&#xA;    ---------------------&#xD;&#xA;    names     : undefined&#xD;&#xA;&#xD;&#xA;Then the interpreter evaluates `[""craig"", ""silva""]` which creates an object on the heap.&#xD;&#xA;&#xD;&#xA;    ptr0      : ""craig""&#xD;&#xA;    ptr1      : ""silva""&#xD;&#xA;    ptr2      : [ &ptr0, &ptr1 ]&#xD;&#xA;&#xD;&#xA;so `ptr2` now is a location in memory containing an array that points to two values.&#xD;&#xA;&#xD;&#xA;This memory location is now stored in the `names` location in the activation record, so your call stack looks like&#xD;&#xA;&#xD;&#xA;    globArray : undefined&#xD;&#xA;    ---------------------&#xD;&#xA;    names     : &ptr2&#xD;&#xA;&#xD;&#xA;The assignment `names = ...` does not change the heap, just the activation record.&#xD;&#xA;&#xD;&#xA;Next `globArray = names` copies the contents of one activation record entry to another.&#xD;&#xA;&#xD;&#xA;    globArray : &ptr2&#xD;&#xA;    ---------------------&#xD;&#xA;    names     : &ptr2&#xD;&#xA;&#xD;&#xA;Then the call to `test` ends so that activation record is discarded, leaving&#xD;&#xA;&#xD;&#xA;    globArray : &ptr2&#xD;&#xA;&#xD;&#xA;where the global `globArray` points to the object created during the call to `test`.&#xD;&#xA;The end of the function just changes the active activation records, not the heap, so the heap still looks like&#xD;&#xA;&#xD;&#xA;    ptr0      : ""craig""&#xD;&#xA;    ptr1      : ""silva""&#xD;&#xA;    ptr2      : [ &ptr0, &ptr1 ]&#xD;&#xA;&#xD;&#xA;so `ptr2` is still the same array.&#xD;&#xA;&#xD;&#xA;> so ""names"" is gone, right?&#xD;&#xA;&#xD;&#xA;`names` (the entry in the activation record) is gone, but the object it pointed to is not since it is still pointed to by the `globArray` entry in an active activation record.&#xD;&#xA;&#xD;&#xA;> Then later I call test2, but it DOES show the elements! So it must have COPIED the whole object&#xD;&#xA;&#xD;&#xA;No, it just copied a reference to the location in the heap occupied by that object.  No new object was created since the heap was not changed, and the heap is where all objects are created.&#xD;&#xA;&#xD;&#xA;http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap might be of interest.";;added 218 characters in body
146311591;13050478;-1;5;728c9b81-7e82-4304-ae4b-5abdef50701c;2017-05-23 10:34:54.0;"There are two things at play here : activation records, and objects on the heap.&#xD;&#xA;&#xD;&#xA;You start off with an activation frame for global variables:&#xD;&#xA;&#xD;&#xA;    globArray : undefined&#xD;&#xA;&#xD;&#xA;and the heap contains literals that appear in your code&#xD;&#xA;&#xD;&#xA;    ptr0      : ""craig""&#xD;&#xA;    ptr1      : ""silva""&#xD;&#xA;&#xD;&#xA;where `ptr0`, `ptr1`, etc. are just addresses or labels that refer to a particular location in memory.&#xD;&#xA;&#xD;&#xA;When you call `test()`, the interpreter pushes a new activation frame which contains boxes for local variables.&#xD;&#xA;&#xD;&#xA;    globArray : undefined&#xD;&#xA;    ---------------------&#xD;&#xA;    names     : undefined&#xD;&#xA;&#xD;&#xA;Then the interpreter evaluates `[""craig"", ""silva""]` which creates an object on the heap.&#xD;&#xA;&#xD;&#xA;    ptr0      : ""craig""&#xD;&#xA;    ptr1      : ""silva""&#xD;&#xA;    ptr2      : [ &ptr0, &ptr1 ]&#xD;&#xA;&#xD;&#xA;so `ptr2` now is a location in memory containing an array that points to two values.&#xD;&#xA;&#xD;&#xA;This memory location is now stored in the `names` location in the activation record, so your call stack looks like&#xD;&#xA;&#xD;&#xA;    globArray : undefined&#xD;&#xA;    ---------------------&#xD;&#xA;    names     : &ptr2&#xD;&#xA;&#xD;&#xA;The assignment `names = ...` does not change the heap, just the activation record.&#xD;&#xA;&#xD;&#xA;Next `globArray = names` copies the contents of one activation record entry to another.&#xD;&#xA;&#xD;&#xA;    globArray : &ptr2&#xD;&#xA;    ---------------------&#xD;&#xA;    names     : &ptr2&#xD;&#xA;&#xD;&#xA;Then the call to `test` ends so that activation record is discarded, leaving&#xD;&#xA;&#xD;&#xA;    globArray : &ptr2&#xD;&#xA;&#xD;&#xA;where the global `globArray` points to the object created during the call to `test`.&#xD;&#xA;The end of the function just changes the active activation records, not the heap, so the heap still looks like&#xD;&#xA;&#xD;&#xA;    ptr0      : ""craig""&#xD;&#xA;    ptr1      : ""silva""&#xD;&#xA;    ptr2      : [ &ptr0, &ptr1 ]&#xD;&#xA;&#xD;&#xA;so `ptr2` is still the same array.&#xD;&#xA;&#xD;&#xA;> so ""names"" is gone, right?&#xD;&#xA;&#xD;&#xA;`names` (the entry in the activation record) is gone, but the object it pointed to is not since it is still pointed to by the `globArray` entry in an active activation record.&#xD;&#xA;&#xD;&#xA;> Then later I call test2, but it DOES show the elements! So it must have COPIED the whole object&#xD;&#xA;&#xD;&#xA;No, it just copied a reference to the location in the heap occupied by that object.  No new object was created since the heap was not changed, and the heap is where all objects are created.&#xD;&#xA;&#xD;&#xA;https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap might be of interest.";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
