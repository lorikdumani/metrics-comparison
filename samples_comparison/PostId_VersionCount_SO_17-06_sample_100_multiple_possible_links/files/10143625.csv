Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
23251162;10143625;1310991;2;015db5f3-2f6a-4886-947d-115897de37fb;2012-04-13 15:19:24.0;"General undo will be complicated, but if you are only interested in saving the state of MATLAB variables, this might be one possible solution:&#xD;&#xA;&#xD;&#xA;save_state.m:&#xD;&#xA;&#xD;&#xA;    SavedStateFolder = '/home/user/matlab_saved_states_folder/';&#xD;&#xA;    save([ SavedStateFolder, 'saved_state_', sprintf('%06d', (size(dir(SavedStateFolder), 1) - 1)) ]); &#xD;&#xA;    fprintf('state saved in saved_state_%s.mat\\n', sprintf('%06d', (size(dir(SavedStateFolder), 1) - 2)));&#xD;&#xA;&#xD;&#xA;undo_index.m:&#xD;&#xA;&#xD;&#xA;    function undo_index()&#xD;&#xA;    SavedStateFolder = '/home/user/matlab_saved_states_folder/';&#xD;&#xA;    FilesStruct = dir(SavedStateFolder);&#xD;&#xA;    LastSavedStateIndex = size(FilesStruct, 1) - 2;&#xD;&#xA;    if (LastSavedStateIndex < 1)&#xD;&#xA;        fprintf('No saved states available.\\n');&#xD;&#xA;    else	&#xD;&#xA;        fprintf('Index of last saved state is %06d\\n', LastSavedStateIndex);&#xD;&#xA;    end&#xD;&#xA;    return&#xD;&#xA;&#xD;&#xA;undo.m:&#xD;&#xA;&#xD;&#xA;    SavedStateFolder = '/home/user/matlab_saved_states_folder/';&#xD;&#xA;    load([ SavedStateFolder, 'saved_state_', sprintf('%06d', input('Enter saved state index ')) ]); &#xD;&#xA;&#xD;&#xA;Then you can use `save_state` to save the state of MATLAB variables or you can even prefix all your commands with `save_state;` if you want to keep track of all changes. When you want to return to a previous state of variables, you can run `undo_index` to find out the index of last saved state and then you can run `undo` and input the index given by `undo_index`, or alternatively any smaller positive integer to return to an earlier state of variables. The first saved state file will be named `saved_state_000001.mat`, then `saved_state_000002.mat` and so on... Note that `save_state` saves everything to disk, so using SSD or RAM disk might be a good idea if you want to try this in a loop with a lot of data. Note also that the previous content of variable called `SavedStateFolder` is lost when you run `save_state` or `undo`. To avoid this, you can replace all instances of `SavedStateFolder` in `save.state.m` and `undo.m` with hard-coded folder names, for example:&#xD;&#xA;&#xD;&#xA;save_state.m:&#xD;&#xA;&#xD;&#xA;    save([ '/home/user/matlab_saved_states_folder/', 'saved_state_', sprintf('%06d', (size(dir('/home/user/matlab_saved_states_folder/'), 1) - 1)) ]); &#xD;&#xA;    fprintf('state saved in saved_state_%s.mat\\n', sprintf('%06d', (size(dir('/home/user/matlab_saved_states_folder/'), 1) - 2)));&#xD;&#xA;&#xD;&#xA;undo.m:&#xD;&#xA;&#xD;&#xA;    load([ '/home/user/matlab_saved_states_folder/', 'saved_state_', sprintf('%06d', input('Enter saved state index ')) ]);&#xD;&#xA;&#xD;&#xA;Note also that `save_state`, `undo_index` and `undo` assume that in `SavedStateFolder` there are no other files except `.`, `..` and `saved_state_*.mat` files. Also the number of `saved_state_*.mat` files and the running index to be saved is found out this way, so if you delete some previous `saved_state_*.mat` files without eg. creating equal number of empty files to replace them, the counts don't match and `save_state` might save the state on top of on an already existing saved state file.&#xD;&#xA;";;
23252298;10143625;1310991;5;4d5ab0a2-d830-44f2-9bef-a8f8ad61a908;2012-04-13 15:48:08.0;"General undo will be complicated, but if you are only interested in saving the state of MATLAB variables and returning to a saved state, this might be one possible solution:&#xD;&#xA;&#xD;&#xA;save_state.m:&#xD;&#xA;&#xD;&#xA;    SavedStateFolder = '/home/user/matlab_saved_states_folder/';&#xD;&#xA;    save([ SavedStateFolder, 'saved_state_', sprintf('%06d', (size(dir(SavedStateFolder), 1) - 1)) ]); &#xD;&#xA;    fprintf('state saved in saved_state_%s.mat\\n', sprintf('%06d', (size(dir(SavedStateFolder), 1) - 2)));&#xD;&#xA;&#xD;&#xA;undo_index.m:&#xD;&#xA;&#xD;&#xA;    function undo_index()&#xD;&#xA;    SavedStateFolder = '/home/user/matlab_saved_states_folder/';&#xD;&#xA;    FilesStruct = dir(SavedStateFolder);&#xD;&#xA;    LastSavedStateIndex = size(FilesStruct, 1) - 2;&#xD;&#xA;    if (LastSavedStateIndex < 1)&#xD;&#xA;        fprintf('No saved states available.\\n');&#xD;&#xA;    else	&#xD;&#xA;        fprintf('Index of last saved state is %06d\\n', LastSavedStateIndex);&#xD;&#xA;    end&#xD;&#xA;    return&#xD;&#xA;&#xD;&#xA;undo.m:&#xD;&#xA;&#xD;&#xA;    SavedStateFolder = '/home/user/matlab_saved_states_folder/';&#xD;&#xA;    load([ SavedStateFolder, 'saved_state_', sprintf('%06d', input('Enter saved state index ')) ]); &#xD;&#xA;&#xD;&#xA;Then you can use `save_state` to save the state of MATLAB variables or you can even prefix all your commands with `save_state;` if you want to keep track of all changes. When you want to return to a previous state of variables, you can run `undo_index` to find out the index of last saved state and then you can run `undo` and input the index given by `undo_index`, or alternatively any smaller positive integer to return to an earlier state of variables. The first saved state file will be named `saved_state_000001.mat`, then `saved_state_000002.mat` and so on... Note that `save_state` saves everything to disk, so using SSD or RAM disk might be a good idea if you want to try this in a loop with a lot of data. Note also that the previous content of variable called `SavedStateFolder` is lost when you run `save_state` or `undo`. To avoid this, you can replace all instances of `SavedStateFolder` in `save.state.m` and `undo.m` with hard-coded folder names, for example:&#xD;&#xA;&#xD;&#xA;save_state.m:&#xD;&#xA;&#xD;&#xA;    save([ '/home/user/matlab_saved_states_folder/', 'saved_state_', sprintf('%06d', (size(dir('/home/user/matlab_saved_states_folder/'), 1) - 1)) ]); &#xD;&#xA;    fprintf('state saved in saved_state_%s.mat\\n', sprintf('%06d', (size(dir('/home/user/matlab_saved_states_folder/'), 1) - 2)));&#xD;&#xA;&#xD;&#xA;undo.m:&#xD;&#xA;&#xD;&#xA;    load([ '/home/user/matlab_saved_states_folder/', 'saved_state_', sprintf('%06d', input('Enter saved state index ')) ]);&#xD;&#xA;&#xD;&#xA;Note also that `save_state`, `undo_index` and `undo` assume that in `SavedStateFolder` there are no other files except `.`, `..` and `saved_state_*.mat` files. Also the number of `saved_state_*.mat` files and the running index to be saved is found out this way, so if you delete some previous `saved_state_*.mat` files without eg. creating equal number of empty files to replace them, the counts don't match and `save_state` might save the state on top of on an already existing saved state file.&#xD;&#xA;";;edit: clarified one sentence
23262072;10143625;1310991;5;ab73b386-af4c-446b-b27e-2d08796fae0e;2012-04-13 20:43:38.0;"General undo will be complicated, but if you are only interested in saving the state of MATLAB variables and returning to a saved state, this might be one possible solution:&#xD;&#xA;&#xD;&#xA;save_state.m:&#xD;&#xA;&#xD;&#xA;    SavedStateFolder = '/home/user/matlab_saved_states_folder/';&#xD;&#xA;    save([ SavedStateFolder, 'saved_state_', sprintf('%06d', (size(dir(SavedStateFolder), 1) - 1)) ]); &#xD;&#xA;    fprintf('state saved in saved_state_%s.mat\\n', sprintf('%06d', (size(dir(SavedStateFolder), 1) - 2)));&#xD;&#xA;&#xD;&#xA;undo_index.m:&#xD;&#xA;&#xD;&#xA;    function undo_index()&#xD;&#xA;    SavedStateFolder = '/home/user/matlab_saved_states_folder/';&#xD;&#xA;    FilesStruct = dir(SavedStateFolder);&#xD;&#xA;    LastSavedStateIndex = size(FilesStruct, 1) - 2;&#xD;&#xA;    if (LastSavedStateIndex < 1)&#xD;&#xA;        fprintf('No saved states available.\\n');&#xD;&#xA;    else	&#xD;&#xA;        fprintf('Index of last saved state is %06d\\n', LastSavedStateIndex);&#xD;&#xA;    end&#xD;&#xA;    return&#xD;&#xA;&#xD;&#xA;undo.m:&#xD;&#xA;&#xD;&#xA;    SavedStateFolder = '/home/user/matlab_saved_states_folder/';&#xD;&#xA;    load([ SavedStateFolder, 'saved_state_', sprintf('%06d', input('Enter saved state index ')) ]); &#xD;&#xA;&#xD;&#xA;Then you can use `save_state` to save the state of MATLAB variables or you can even prefix all your commands with `save_state;` if you want to keep track of all changes. When you want to return to a previous state of variables, you can run `undo_index` to find out the index of last saved state and then you can run `undo` and input the index given by `undo_index`, or alternatively any smaller positive integer to return to an earlier state of variables. The first saved state file will be named `saved_state_000001.mat`, then `saved_state_000002.mat` and so on... Note that `save_state` saves everything to disk, so using SSD or RAM disk might be a good idea if you want to try this in a loop with a lot of data. Note also that the previous content of variable called `SavedStateFolder` is lost when you run `save_state` or `undo`. To avoid this, you can replace all instances of `SavedStateFolder` in `save.state.m` and `undo.m` with hard-coded folder names, for example:&#xD;&#xA;&#xD;&#xA;save_state.m:&#xD;&#xA;&#xD;&#xA;    save([ '/home/user/matlab_saved_states_folder/', 'saved_state_', sprintf('%06d', (size(dir('/home/user/matlab_saved_states_folder/'), 1) - 1)) ]); &#xD;&#xA;    fprintf('state saved in saved_state_%s.mat\\n', sprintf('%06d', (size(dir('/home/user/matlab_saved_states_folder/'), 1) - 2)));&#xD;&#xA;&#xD;&#xA;undo.m:&#xD;&#xA;&#xD;&#xA;    load([ '/home/user/matlab_saved_states_folder/', 'saved_state_', sprintf('%06d', input('Enter saved state index ')) ]);&#xD;&#xA;&#xD;&#xA;Note also that `save_state`, `undo_index` and `undo` assume that in `SavedStateFolder` there are no other files except `.`, `..` and `saved_state_*.mat` files. Also the number of `saved_state_*.mat` files and the running index to be saved is found out this way, so if you delete some previous `saved_state_*.mat` files without eg. creating equal number of empty files to replace them, the counts don't match and `save_state` might save the state on top of an already existing saved state file.&#xD;&#xA;";;typo corrected
