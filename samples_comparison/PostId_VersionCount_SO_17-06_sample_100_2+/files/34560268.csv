Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
107527684;34560268;4031604;2;e6a4cb63-748c-4999-9c39-8fab442e88f0;2016-01-01 21:32:21.0;"You would not need a VLA to pass an VLA array as parameter. In fact you must know that arrays and functions can't be either passed or returned to/from a function (unless you use a structure hack but in our case this wouldn't work).&#xD;&#xA;&#xD;&#xA;However you could pass a pointer to your arrays using VM types. Something like this:&#xD;&#xA;&#xD;&#xA;    void printArry(int a1, int b1, int a2, int b2, int (*parry)[a1][b1]){&#xD;&#xA;    /* accessing array 'array' by '*parry' */&#xD;&#xA;    }";;
107527761;34560268;4031604;5;f6b13f45-75b6-4483-a925-9b8e8a7be5f9;2016-01-01 21:35:56.0;"You would not need a VLA to pass an VLA array as parameter. In fact you must know that arrays and functions can't be either passed or returned to/from a function (unless you use a structure hack but in our case this wouldn't work).&#xD;&#xA;&#xD;&#xA;However you could pass a pointer to your array using VM types. Something like this:&#xD;&#xA;&#xD;&#xA;    void printArry(int a1, int b1, int a2, int b2, int (*parry)[a1][b1]){&#xD;&#xA;    /* accessing array 'array' by '*parry' */&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You must declare the pointer to the VLA array parameter after declaring the parameters defining the array dimensions for obvious reasons ('a1' and 'b1' must be defined at the time of use).&#xD;&#xA;&#xD;&#xA;The code using this function will look like this:&#xD;&#xA;&#xD;&#xA;    int main(int argc, char** argv){&#xD;&#xA;    &#xD;&#xA;    int a1=5;&#xD;&#xA;    int b1=6;&#xD;&#xA;    int a2=7;&#xD;&#xA;    int a2=8;&#xD;&#xA;    &#xD;&#xA;    int arry1[a1][b1];&#xD;&#xA;    int arry2[a2][b2];&#xD;&#xA;    &#xD;&#xA;    /* set values in arrays */&#xD;&#xA;    &#xD;&#xA;    printArry(a1, b1, &arry1);&#xD;&#xA;    printArry(a2, b2, &arry2);&#xD;&#xA;    &#xD;&#xA;    }";;added 192 characters in body
107527977;34560268;4031604;5;2c0ba53e-58a6-4012-b156-9b59db59e933;2016-01-01 21:42:14.0;"You would not need a VLA to pass an VLA array as parameter. In fact you must know that arrays and functions can't be either passed or returned to/from a function (unless you use a structure hack but in our case this wouldn't work).&#xD;&#xA;&#xD;&#xA;However you could pass a pointer to your array using VM types. Something like this:&#xD;&#xA;&#xD;&#xA;    void printArry(int a1, int b1, int (*parry)[a1][b1]){&#xD;&#xA;    /* accessing array 'array' by '*parry' */&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You must declare the pointer to the VLA array parameter after declaring the parameters defining the array dimensions for obvious reasons ('a1' and 'b1' must be defined at the time of use).&#xD;&#xA;&#xD;&#xA;The code using this function will look like this:&#xD;&#xA;&#xD;&#xA;    int main(int argc, char** argv){&#xD;&#xA;    &#xD;&#xA;    int a1=5;&#xD;&#xA;    int b1=6;&#xD;&#xA;    int a2=7;&#xD;&#xA;    int a2=8;&#xD;&#xA;    &#xD;&#xA;    int arry1[a1][b1];&#xD;&#xA;    int arry2[a2][b2];&#xD;&#xA;    &#xD;&#xA;    /* set values in arrays */&#xD;&#xA;    &#xD;&#xA;    printArry(a1, b1, &arry1);&#xD;&#xA;    printArry(a2, b2, &arry2);&#xD;&#xA;    &#xD;&#xA;    }";;deleted 16 characters in body
107528184;34560268;4031604;5;f1453f45-6443-4946-8f70-7069bc55f424;2016-01-01 21:49:18.0;"You would not need a VLA to pass an VLA array as parameter. In fact you must know that arrays and functions can't be either passed or returned to/from a function (unless you use a structure hack but in our case this wouldn't work).&#xD;&#xA;&#xD;&#xA;However you could pass a pointer to your array using VM types. Something like this:&#xD;&#xA;&#xD;&#xA;    void printArry(int a1, int b1, int (*parry)[a1][b1]){&#xD;&#xA;    /* accessing array 'array' by '*parry' */&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You must declare the pointer to the VLA array parameter after declaring the parameters defining the array dimensions for obvious reasons ('a1' and 'b1' must be defined at the time of use).&#xD;&#xA;&#xD;&#xA;The code using this function will look like this:&#xD;&#xA;&#xD;&#xA;    int main(int argc, char** argv){&#xD;&#xA;    &#xD;&#xA;    int a1=5;&#xD;&#xA;    int b1=6;&#xD;&#xA;    int a2=7;&#xD;&#xA;    int a2=8;&#xD;&#xA;    &#xD;&#xA;    int arry1[a1][b1];&#xD;&#xA;    int arry2[a2][b2];&#xD;&#xA;    &#xD;&#xA;    /* set values in arrays */&#xD;&#xA;    &#xD;&#xA;    printArry(a1, b1, &arry1);&#xD;&#xA;    printArry(a2, b2, &arry2);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;We can't use the structure hack firstly because structures can have VLA members and secondly because even if they had we couldn't be able to specify their length when an argument is passed (the member type must be known at the time of declaration and we can't declare structures inside a function declaration).";;added 314 characters in body
107528423;34560268;4031604;5;94dfe89e-8b27-416f-9f91-136a49f91797;2016-01-01 21:58:24.0;"You would not need a VLA to pass an VLA as parameter. In fact you must know that arrays and functions can't be either passed or returned to/from a function (unless you use a structure hack but in our case this wouldn't work).&#xD;&#xA;&#xD;&#xA;However you could pass a pointer to your array using VM types. Something like this:&#xD;&#xA;&#xD;&#xA;    void printArry(int a1, int b1, int (*parry)[a1][b1]){&#xD;&#xA;    /* accessing array 'array' by '*parry' */&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You must declare the pointer to the VLA array parameter after declaring the parameters defining the array dimensions for obvious reasons ('a1' and 'b1' must be defined at the time of use).&#xD;&#xA;&#xD;&#xA;The code using this function will look like this:&#xD;&#xA;&#xD;&#xA;    int main(int argc, char** argv){&#xD;&#xA;    &#xD;&#xA;    int a1=5;&#xD;&#xA;    int b1=6;&#xD;&#xA;    int a2=7;&#xD;&#xA;    int a2=8;&#xD;&#xA;    &#xD;&#xA;    int arry1[a1][b1];&#xD;&#xA;    int arry2[a2][b2];&#xD;&#xA;    &#xD;&#xA;    /* set values in arrays */&#xD;&#xA;    &#xD;&#xA;    printArry(a1, b1, &arry1);&#xD;&#xA;    printArry(a2, b2, &arry2);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;We can't use the structure hack firstly because structures can have VLA members and secondly because even if they had we couldn't be able to specify their length when an argument is passed (the member type must be known at the time of declaration and we can't declare structures inside a function declaration).&#xD;&#xA;&#xD;&#xA;I guess this is all you can do in the case. If you want to use C98 simply don't use VLAs.";;added 87 characters in body
107528687;34560268;4031604;5;3504c1b9-cfb7-43cd-b16e-4563340cb14e;2016-01-01 22:07:22.0;"You would not need a VLA to pass an VLA as parameter. In fact you must know that arrays and functions can't be either passed or returned to/from a function (unless you use a structure hack but in our case this wouldn't work).&#xD;&#xA;&#xD;&#xA;However you could pass a pointer to your array using VM types. Something like this:&#xD;&#xA;&#xD;&#xA;    void printArry(int a1, int b1, int (*parry)[a1][b1]){&#xD;&#xA;    /* accessing array 'array' by '*parry' */&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You must declare the pointer to the VLA array parameter after declaring the parameters defining the array dimensions for obvious reasons ('a1' and 'b1' must be defined at the time of use).&#xD;&#xA;&#xD;&#xA;The code using this function will look like this:&#xD;&#xA;&#xD;&#xA;    int main(int argc, char** argv){&#xD;&#xA;    &#xD;&#xA;    int a1=5;&#xD;&#xA;    int b1=6;&#xD;&#xA;    int a2=7;&#xD;&#xA;    int a2=8;&#xD;&#xA;    &#xD;&#xA;    int arry1[a1][b1];&#xD;&#xA;    int arry2[a2][b2];&#xD;&#xA;    &#xD;&#xA;    /* set values in arrays */&#xD;&#xA;    &#xD;&#xA;    printArry(a1, b1, &arry1);&#xD;&#xA;    printArry(a2, b2, &arry2);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;We can't use the structure hack firstly because structures can have VLA members and secondly because even if they had we couldn't be able to specify their length when an argument is passed (the member type must be known at the time of declaration and we can't declare structures inside a function declaration).&#xD;&#xA;&#xD;&#xA;I guess this is all you can do in the case. If you want to use C98 simply don't use VLAs.&#xD;&#xA;&#xD;&#xA;Also maybe this function will work for normal arrays (it's worth a try at least) but you would need to provide their dimensions each time you call it and also it would be slower then passing them properly (by using their real static types). However I can't guarantee for this - it may be as well UB.&#xD;&#xA;&#xD;&#xA;On the other hand you could also access your array the bad old way using a simple pointer to it's first element:&#xD;&#xA;&#xD;&#xA;    void printArry(int a1, int b1, int *parryFirstElement){&#xD;&#xA;        for(int i = 0; i < a1; ++i)&#xD;&#xA;            for(int y = 0; y < b1; ++y)&#xD;&#xA;                parryFirstElement[i * b1 + y]; //your array [i][y] element&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;*I may be wrong though. I'm sleepy right now. If I'm wrong - well then that's bad.*";;added 87 characters in body
107528862;34560268;4031604;5;02d5789f-04a0-492b-8a89-b5c822aa6a87;2016-01-01 22:12:41.0;"You would not need a VLA to pass an VLA as parameter. In fact you must know that arrays and functions can't be either passed or returned to/from a function (unless you use a structure hack but in our case this wouldn't work).&#xD;&#xA;&#xD;&#xA;However you could pass a pointer to your array using VM types. Something like this:&#xD;&#xA;&#xD;&#xA;    void printArry(size_t a1, size_t b1, int (*parry)[a1][b1]){&#xD;&#xA;    /* accessing array 'array' by '*parry' */&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You must declare the pointer to the VLA array parameter after declaring the parameters defining the array dimensions for obvious reasons ('a1' and 'b1' must be defined at the time of use).&#xD;&#xA;&#xD;&#xA;The code using this function will look like this:&#xD;&#xA;&#xD;&#xA;    int main(int argc, char** argv){&#xD;&#xA;    &#xD;&#xA;    size_t a1=5;&#xD;&#xA;    size_t b1=6;&#xD;&#xA;    size_t a2=7;&#xD;&#xA;    size_t a2=8;&#xD;&#xA;    &#xD;&#xA;    int arry1[a1][b1];&#xD;&#xA;    int arry2[a2][b2];&#xD;&#xA;    &#xD;&#xA;    /* set values in arrays */&#xD;&#xA;    &#xD;&#xA;    printArry(a1, b1, &arry1);&#xD;&#xA;    printArry(a2, b2, &arry2);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;We can't use the structure hack firstly because structures can have VLA members and secondly because even if they had we couldn't be able to specify their length when an argument is passed (the member type must be known at the time of declaration and we can't declare structures inside a function declaration).&#xD;&#xA;&#xD;&#xA;I guess this is all you can do in the case. If you want to use C98 simply don't use VLAs.&#xD;&#xA;&#xD;&#xA;Also maybe this function will work for normal arrays (it's worth a try at least) but you would need to provide their dimensions each time you call it and also it would be slower then passing them properly (by using their real static types). However I can't guarantee for this - it may be as well UB.&#xD;&#xA;&#xD;&#xA;On the other hand you could also access your array the bad old way using a simple pointer to it's first element:&#xD;&#xA;&#xD;&#xA;    void printArry(size_t a1, size_t b1, int *parryFirstElement){&#xD;&#xA;        for(size_t i = 0; i < a1; ++i)&#xD;&#xA;            for(size_t y = 0; y < b1; ++y)&#xD;&#xA;                parryFirstElement[i * b1 + y]; //your array [i][y] element&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Calling this function could be done the same way as before (as IIRC pointer in 'C' doesn't need to be casted).&#xD;&#xA;&#xD;&#xA;I replaced 'int' in the times where is better to use 'size_t'. Although if you're targeting some old standard you could reverse them back to 'int'.&#xD;&#xA;&#xD;&#xA;*I may be wrong though. I'm sleepy right now. If I'm wrong - well then that's bad.*";;added 87 characters in body
107529148;34560268;4031604;5;926982b6-e1c2-4c1b-a46c-cd2ef10d2bf5;2016-01-01 22:20:46.0;"You would not need a VLA to pass an VLA as parameter. In fact you must know that arrays and functions can't be either passed or returned to/from a function (unless you use a structure hack but in our case this wouldn't work).&#xD;&#xA;&#xD;&#xA;However you could pass a pointer to your array using VM types. Something like this:&#xD;&#xA;&#xD;&#xA;    void printArry(size_t a1, size_t b1, int (*parry)[a1][b1]){&#xD;&#xA;    /* accessing array 'array' by '*parry' */&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You must declare the pointer to the VLA array parameter after declaring the parameters defining the array dimensions for obvious reasons ('a1' and 'b1' must be defined at the time of use).&#xD;&#xA;&#xD;&#xA;The code using this function will look like this:&#xD;&#xA;&#xD;&#xA;    int main(int argc, char** argv){&#xD;&#xA;    &#xD;&#xA;    size_t a1=5;&#xD;&#xA;    size_t b1=6;&#xD;&#xA;    size_t a2=7;&#xD;&#xA;    size_t a2=8;&#xD;&#xA;    &#xD;&#xA;    int arry1[a1][b1];&#xD;&#xA;    int arry2[a2][b2];&#xD;&#xA;    &#xD;&#xA;    /* set values in arrays */&#xD;&#xA;    &#xD;&#xA;    printArry(a1, b1, &arry1);&#xD;&#xA;    printArry(a2, b2, &arry2);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;We can't use the structure hack firstly because structures can have VLA members and secondly because even if they had we couldn't be able to specify their length when an argument is passed (the member type must be known at the time of declaration and we can't declare structures inside a function declaration).&#xD;&#xA;&#xD;&#xA;I guess this is all you can do in the case. If you want to use C98 simply don't use VLAs.&#xD;&#xA;&#xD;&#xA;**Confirmed - even ordinary arrays must work with my this version of 'printArry'(supposing that their dimensions sizes are properly passed to the function).** At least this is what the C11 standard says about it in it's examples.&#xD;&#xA;&#xD;&#xA;**All pointers to arrays with equal dimensions sizes can be assigned one another (no-matter if they are VM or not).**&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On the other hand you could also access your array the bad old way using a simple pointer to it's first element:&#xD;&#xA;&#xD;&#xA;    void printArry(size_t a1, size_t b1, int *parryFirstElement){&#xD;&#xA;        for(size_t i = 0; i < a1; ++i)&#xD;&#xA;            for(size_t y = 0; y < b1; ++y)&#xD;&#xA;                parryFirstElement[i * b1 + y]; //your array [i][y] element&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Calling this function could be done the same way as before (as IIRC pointer in 'C' doesn't need to be casted).&#xD;&#xA;&#xD;&#xA;I replaced 'int' in the times where is better to use 'size_t'. Although if you're targeting some old standard you could reverse them back to 'int'.&#xD;&#xA;&#xD;&#xA;*I may be wrong though. I'm sleepy right now. If I'm wrong - well then that's bad.*";;added 156 characters in body
107529389;34560268;4031604;5;bee30d38-093f-4d72-892d-6a2ff3bb7ca1;2016-01-01 22:28:56.0;"You would not need a VLA to pass an VLA as parameter. In fact you must know that arrays and functions can't be either passed or returned to/from a function (unless you use a structure hack but in our case this wouldn't work).&#xD;&#xA;&#xD;&#xA;However you could pass a pointer to your array using VM types. Something like this:&#xD;&#xA;&#xD;&#xA;    void printArry(size_t a1, size_t b1, int (*parry)[a1][b1]){&#xD;&#xA;    /* accessing array 'array' by '*parry' */&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You must declare the pointer to the VLA array parameter after declaring the parameters defining the array dimensions for obvious reasons ('a1' and 'b1' must be defined at the time of use).&#xD;&#xA;&#xD;&#xA;The code using this function will look like this:&#xD;&#xA;&#xD;&#xA;    int main(int argc, char** argv){&#xD;&#xA;    &#xD;&#xA;    size_t a1=5;&#xD;&#xA;    size_t b1=6;&#xD;&#xA;    size_t a2=7;&#xD;&#xA;    size_t a2=8;&#xD;&#xA;    &#xD;&#xA;    int arry1[a1][b1];&#xD;&#xA;    int arry2[a2][b2];&#xD;&#xA;    &#xD;&#xA;    /* set values in arrays */&#xD;&#xA;    &#xD;&#xA;    printArry(a1, b1, &arry1);&#xD;&#xA;    printArry(a2, b2, &arry2);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;We can't use the structure hack firstly because structures can have VLA members and secondly because even if they had we couldn't be able to specify their length when an argument is passed (the member type must be known at the time of declaration and we can't declare structures inside a function declaration).&#xD;&#xA;&#xD;&#xA;I guess this is all you can do in the case. If you want to use C98 simply don't use VLAs.&#xD;&#xA;&#xD;&#xA;**Confirmed - even ordinary (non VM) arrays must work with this version of 'printArry'(supposing that their dimensions sizes are properly passed to the function).** At least this is what the C11 standard says about it in it's examples.&#xD;&#xA;&#xD;&#xA;**All pointers to arrays with equal dimensions sizes can be assigned one another (no-matter if they are VM or not) without invoking UB.**&#xD;&#xA;&#xD;&#xA;Here are the examples on the latest C11 standard from which this comes from:&#xD;&#xA;&#xD;&#xA;> EXAMPLE 3  The following declarations demonstrate the compatibility&#xD;&#xA;> rules for variably modified types.&#xD;&#xA;> &#xD;&#xA;>     extern int n;&#xD;&#xA;>&#xD;&#xA;>     extern int m;&#xD;&#xA;>&#xD;&#xA;>     void fcompat(void)&#xD;&#xA;>     {&#xD;&#xA;>         int a[n][6][m];&#xD;&#xA;&#xD;&#xA;>         int (*p)[4][n+1];&#xD;&#xA;&#xD;&#xA;>         int c[n][n][6][m];&#xD;&#xA;&#xD;&#xA;>         int (*r)[n][n][n+1];&#xD;&#xA;>&#xD;&#xA;>         p = a;   // invalid: not compatible because 4 != 6&#xD;&#xA;>     &#xD;&#xA;>         r = c;   // compatible, but defined behavior only if&#xD;&#xA;>                  // n == 6 and m == n+1&#xD;&#xA;>            &#xD;&#xA;>     }&#xD;&#xA;&#xD;&#xA;At $6.7.6.2.&#xD;&#xA;&#xD;&#xA;On the other hand you could also access your array the bad old way using a simple pointer to it's first element:&#xD;&#xA;&#xD;&#xA;    void printArry(size_t a1, size_t b1, int *parryFirstElement){&#xD;&#xA;        for(size_t i = 0; i < a1; ++i)&#xD;&#xA;            for(size_t y = 0; y < b1; ++y)&#xD;&#xA;                parryFirstElement[i * b1 + y]; //your array [i][y] element&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Calling this function could be done the same way as before (as IIRC pointer in 'C' doesn't need to be casted).&#xD;&#xA;&#xD;&#xA;I replaced 'int' in the times where is better to use 'size_t'. Although if you're targeting some old standard you could reverse them back to 'int'.&#xD;&#xA;&#xD;&#xA;*I may be wrong though. I'm sleepy right now. If I'm wrong - well then that's bad.*";;added 588 characters in body
107529649;34560268;4031604;5;8ca5b9a1-64f5-4763-9bc4-d65b63ca2b8a;2016-01-01 22:37:27.0;"You would not need a VLA to pass an VLA as parameter. In fact you must know that arrays and functions can't be either passed or returned to/from a function (unless you use a structure hack but in our case this wouldn't work).&#xD;&#xA;&#xD;&#xA;However you could pass a pointer to your array using VM types. Something like this:&#xD;&#xA;&#xD;&#xA;    void printArry(size_t a1, size_t b1, int (*parry)[a1][b1]){&#xD;&#xA;    /* accessing array 'array' by '*parry' */&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You must declare the pointer to the VLA array parameter after declaring the parameters defining the array dimensions for obvious reasons ('a1' and 'b1' must be defined at the time of use).&#xD;&#xA;&#xD;&#xA;The code using this function will look like this:&#xD;&#xA;&#xD;&#xA;    int main(int argc, char** argv){&#xD;&#xA;    &#xD;&#xA;    size_t a1=5;&#xD;&#xA;    size_t b1=6;&#xD;&#xA;    size_t a2=7;&#xD;&#xA;    size_t a2=8;&#xD;&#xA;    &#xD;&#xA;    int arry1[a1][b1];&#xD;&#xA;    int arry2[a2][b2];&#xD;&#xA;    &#xD;&#xA;    /* set values in arrays */&#xD;&#xA;    &#xD;&#xA;    printArry(a1, b1, &arry1);&#xD;&#xA;    printArry(a2, b2, &arry2);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;We can't use the structure hack firstly because structures can have VLA members and secondly because even if they had we couldn't be able to specify their length when an argument is passed (the member type must be known at the time of declaration and we can't declare structures inside a function declaration).&#xD;&#xA;&#xD;&#xA;I guess this is all you can do in the case. If you want to use C98 simply don't use VLAs.&#xD;&#xA;&#xD;&#xA;**Confirmed - even ordinary (non VM) arrays must work with this version of 'printArry'(supposing that their dimensions sizes are properly passed to the function).** At least this is what the C11 standard says about it in it's examples.&#xD;&#xA;&#xD;&#xA;**All pointers to arrays with equal dimensions sizes can be assigned one another (no-matter if they are VM or not) without invoking UB.**&#xD;&#xA;&#xD;&#xA;Here are the examples on the latest C11 standard from which this comes from:&#xD;&#xA;&#xD;&#xA;> EXAMPLE 3  The following declarations demonstrate the compatibility&#xD;&#xA;> rules for variably modified types.&#xD;&#xA;> &#xD;&#xA;>     extern int n;&#xD;&#xA;>&#xD;&#xA;>     extern int m;&#xD;&#xA;>&#xD;&#xA;>     void fcompat(void)&#xD;&#xA;>     {&#xD;&#xA;>         int a[n][6][m];&#xD;&#xA;&#xD;&#xA;>         int (*p)[4][n+1];&#xD;&#xA;&#xD;&#xA;>         int c[n][n][6][m];&#xD;&#xA;&#xD;&#xA;>         int (*r)[n][n][n+1];&#xD;&#xA;>&#xD;&#xA;>         p = a;   // invalid: not compatible because 4 != 6&#xD;&#xA;>     &#xD;&#xA;>         r = c;   // compatible, but defined behavior only if&#xD;&#xA;>                  // n == 6 and m == n+1&#xD;&#xA;>            &#xD;&#xA;>     }&#xD;&#xA;&#xD;&#xA;At $6.7.6.2.&#xD;&#xA;&#xD;&#xA;Which means you can call this function for example like this:&#xD;&#xA;&#xD;&#xA;    int main(int, char**)&#xD;&#xA;    {&#xD;&#xA;        int arry[10][23];&#xD;&#xA;&#xD;&#xA;        printArry(sizeof(arry) / sizeof(arry[0]), &#xD;&#xA;                sizeof(arry[0]) / sizeof(arry[0][0]), &arry);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On the other hand you could also access your array the bad old way using a simple pointer to it's first element:&#xD;&#xA;&#xD;&#xA;    void printArry(size_t a1, size_t b1, int *parryFirstElement){&#xD;&#xA;        for(size_t i = 0; i < a1; ++i)&#xD;&#xA;            for(size_t y = 0; y < b1; ++y)&#xD;&#xA;                parryFirstElement[i * b1 + y]; //your array [i][y] element&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Calling this function could be done the same way as before (as IIRC pointer in 'C' doesn't need to be casted).&#xD;&#xA;&#xD;&#xA;I replaced 'int' in the times where is better to use 'size_t'. Although if you're targeting some old standard you could reverse them back to 'int'.&#xD;&#xA;&#xD;&#xA;*I may be wrong though. I'm sleepy right now. If I'm wrong - well then that's bad.*";;added 224 characters in body
107530266;34560268;4031604;5;a590bb1e-ad67-4a34-8f2b-04df0edaf8a3;2016-01-01 22:58:45.0;"You would not need a VLA to pass an VLA as parameter. In fact you must know that arrays and functions can't be either passed or returned to/from a function (unless you use a structure hack but in our case this wouldn't work).&#xD;&#xA;&#xD;&#xA;However you could pass a pointer to your array using VM types. Something like this:&#xD;&#xA;&#xD;&#xA;    void printArry(size_t a1, size_t b1, int (*parry)[a1][b1]){&#xD;&#xA;    /* accessing array 'array' by '*parry' */&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You must declare the pointer to the VLA array parameter after declaring the parameters defining the array dimensions for obvious reasons ('a1' and 'b1' must be defined at the time of use).&#xD;&#xA;&#xD;&#xA;The code using this function will look like this:&#xD;&#xA;&#xD;&#xA;    int main(int argc, char** argv){&#xD;&#xA;    &#xD;&#xA;    size_t a1=5;&#xD;&#xA;    size_t b1=6;&#xD;&#xA;    size_t a2=7;&#xD;&#xA;    size_t a2=8;&#xD;&#xA;    &#xD;&#xA;    int arry1[a1][b1];&#xD;&#xA;    int arry2[a2][b2];&#xD;&#xA;    &#xD;&#xA;    /* set values in arrays */&#xD;&#xA;    &#xD;&#xA;    printArry(a1, b1, &arry1);&#xD;&#xA;    printArry(a2, b2, &arry2);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;We can't use the structure hack firstly because structures can have VLA members and secondly because even if they had we couldn't be able to specify their length when an argument is passed (the member type must be known at the time of declaration and we can't declare structures inside a function declaration).&#xD;&#xA;&#xD;&#xA;**Confirmed - even ordinary (non VM) arrays must work with this version of 'printArry'(supposing that their dimensions sizes are properly passed to the function).** At least this is what the C11 standard says about it in it's examples.&#xD;&#xA;&#xD;&#xA;**All pointers to arrays with equal dimensions sizes can be assigned one another (no-matter if they are VM or not) without invoking UB.**&#xD;&#xA;&#xD;&#xA;Here are the examples on the latest C11 standard from which this comes from:&#xD;&#xA;&#xD;&#xA;> EXAMPLE 3  The following declarations demonstrate the compatibility&#xD;&#xA;> rules for variably modified types.&#xD;&#xA;> &#xD;&#xA;>     extern int n;&#xD;&#xA;>&#xD;&#xA;>     extern int m;&#xD;&#xA;>&#xD;&#xA;>     void fcompat(void)&#xD;&#xA;>     {&#xD;&#xA;>         int a[n][6][m];&#xD;&#xA;&#xD;&#xA;>         int (*p)[4][n+1];&#xD;&#xA;&#xD;&#xA;>         int c[n][n][6][m];&#xD;&#xA;&#xD;&#xA;>         int (*r)[n][n][n+1];&#xD;&#xA;>&#xD;&#xA;>         p = a;   // invalid: not compatible because 4 != 6&#xD;&#xA;>     &#xD;&#xA;>         r = c;   // compatible, but defined behavior only if&#xD;&#xA;>                  // n == 6 and m == n+1&#xD;&#xA;>            &#xD;&#xA;>     }&#xD;&#xA;&#xD;&#xA;At $6.7.6.2.&#xD;&#xA;&#xD;&#xA;Which means you can call this function for example like this:&#xD;&#xA;&#xD;&#xA;    int main(int, char**)&#xD;&#xA;    {&#xD;&#xA;        int arry[10][23];&#xD;&#xA;&#xD;&#xA;        printArry(sizeof(arry) / sizeof(arry[0]), &#xD;&#xA;                sizeof(arry[0]) / sizeof(arry[0][0]), &arry);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On the other hand you could also access your array the bad old way using a simple pointer to it's first element:&#xD;&#xA;&#xD;&#xA;    void printArry(size_t a1, size_t b1, int *parryFirstElement){&#xD;&#xA;        for(size_t i = 0; i < a1; ++i)&#xD;&#xA;            for(size_t y = 0; y < b1; ++y)&#xD;&#xA;                parryFirstElement[i * b1 + y]; //your array [i][y] element&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Calling this function could be done the same way as before (as IIRC pointer in 'C' doesn't need to be casted).&#xD;&#xA;&#xD;&#xA;I replaced 'int' in the times where is better to use 'size_t'. Although if you're targeting some old standard you could reverse them back to 'int'.&#xD;&#xA;&#xD;&#xA;*I may be wrong though. I'm sleepy right now. If I'm wrong - well then that's bad.*";;deleted 93 characters in body
107530763;34560268;4031604;5;17c2863e-b88c-4d1f-b3dc-f437c3253bd4;2016-01-01 23:18:35.0;"You would not need a VLA to pass an VLA as parameter. In fact you must know that arrays and functions can't be neither passed nor returned to/from a function (unless you use a structure hack but in our case this wouldn't work).&#xD;&#xA;&#xD;&#xA;However you could pass a pointer to your array using VM types. Something like this:&#xD;&#xA;&#xD;&#xA;    void printArry(size_t a1, size_t b1, int (*parry)[a1][b1]){&#xD;&#xA;    /* accessing array 'array' by '*parry' */&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You must declare the pointer to the VLA array parameter after declaring the parameters defining the array dimensions for obvious reasons ('a1' and 'b1' must be defined at the time of use).&#xD;&#xA;&#xD;&#xA;The code using this function will look like this:&#xD;&#xA;&#xD;&#xA;    int main(int argc, char** argv){&#xD;&#xA;    &#xD;&#xA;    size_t a1=5;&#xD;&#xA;    size_t b1=6;&#xD;&#xA;    size_t a2=7;&#xD;&#xA;    size_t a2=8;&#xD;&#xA;    &#xD;&#xA;    int arry1[a1][b1];&#xD;&#xA;    int arry2[a2][b2];&#xD;&#xA;    &#xD;&#xA;    /* set values in arrays */&#xD;&#xA;    &#xD;&#xA;    printArry(a1, b1, &arry1);&#xD;&#xA;    printArry(a2, b2, &arry2);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;We can't use the structure hack firstly because structures can't have VLA members and secondly because even if they could we wouldn't be able to specify their length when an argument is passed (the member type must be known at the time of declaration and we can't declare structures inside a function declaration).&#xD;&#xA;&#xD;&#xA;**Confirmed - even ordinary (non VM) arrays must work with this version of 'printArry'(supposing that their dimensions sizes are properly passed to the function).** At least this is what the C11 standard says about it in it's examples.&#xD;&#xA;&#xD;&#xA;**All pointers to arrays with equal dimensions sizes can be assigned one another (no-matter if they are VM or not) without invoking UB.**&#xD;&#xA;&#xD;&#xA;Here are the examples on the latest C11 standard from which this comes from:&#xD;&#xA;&#xD;&#xA;> EXAMPLE 3  The following declarations demonstrate the compatibility&#xD;&#xA;> rules for variably modified types.&#xD;&#xA;> &#xD;&#xA;>     extern int n;&#xD;&#xA;>&#xD;&#xA;>     extern int m;&#xD;&#xA;>&#xD;&#xA;>     void fcompat(void)&#xD;&#xA;>     {&#xD;&#xA;>         int a[n][6][m];&#xD;&#xA;&#xD;&#xA;>         int (*p)[4][n+1];&#xD;&#xA;&#xD;&#xA;>         int c[n][n][6][m];&#xD;&#xA;&#xD;&#xA;>         int (*r)[n][n][n+1];&#xD;&#xA;>&#xD;&#xA;>         p = a;   // invalid: not compatible because 4 != 6&#xD;&#xA;>     &#xD;&#xA;>         r = c;   // compatible, but defined behavior only if&#xD;&#xA;>                  // n == 6 and m == n+1&#xD;&#xA;>            &#xD;&#xA;>     }&#xD;&#xA;&#xD;&#xA;At $6.7.6.2.&#xD;&#xA;&#xD;&#xA;Which means you can call this function for example like this:&#xD;&#xA;&#xD;&#xA;    int main(int, char**)&#xD;&#xA;    {&#xD;&#xA;        int arry[10][23];&#xD;&#xA;&#xD;&#xA;        printArry(sizeof(arry) / sizeof(arry[0]), &#xD;&#xA;                sizeof(arry[0]) / sizeof(arry[0][0]), &arry);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On the other hand you could also access your array the bad old way using a simple pointer to it's first element:&#xD;&#xA;&#xD;&#xA;    void printArry(size_t a1, size_t b1, int *parryFirstElement){&#xD;&#xA;        for(size_t i = 0; i < a1; ++i)&#xD;&#xA;            for(size_t y = 0; y < b1; ++y)&#xD;&#xA;                parryFirstElement[i * b1 + y]; //your array [i][y] element&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Calling this function could be done the same way as before (as IIRC pointer in 'C' doesn't need to be casted).&#xD;&#xA;&#xD;&#xA;I replaced 'int' in the times where is better to use 'size_t'. Although if you're targeting some old standard you could reverse them back to 'int'.&#xD;&#xA;&#xD;&#xA;*I may be wrong though. I'm sleepy right now. If I'm wrong - well then that's bad.*";;added 2 characters in body
107557151;34560268;15168;5;499ff400-65fa-4c45-8b5c-27b127491393;2016-01-02 12:44:32.0;"You would not need a VLA to pass an VLA as parameter. In fact you must know that arrays and functions can be neither passed to nor returned from a function (unless you use a structure hack, but in our case this wouldn't work).&#xD;&#xA;&#xD;&#xA;However you could pass a pointer to your array using VM types. Something like this:&#xD;&#xA;&#xD;&#xA;    void printArry(size_t a1, size_t b1, int (*parry)[a1][b1]){&#xD;&#xA;    /* accessing array 'array' by '*parry' */&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You must declare the pointer to the VLA array parameter after declaring the parameters defining the array dimensions for obvious reasons ('a1' and 'b1' must be defined at the time of use).&#xD;&#xA;&#xD;&#xA;The code using this function will look like this:&#xD;&#xA;&#xD;&#xA;    int main(int argc, char** argv){&#xD;&#xA;    &#xD;&#xA;    size_t a1=5;&#xD;&#xA;    size_t b1=6;&#xD;&#xA;    size_t a2=7;&#xD;&#xA;    size_t b2=8;&#xD;&#xA;    &#xD;&#xA;    int arry1[a1][b1];&#xD;&#xA;    int arry2[a2][b2];&#xD;&#xA;    &#xD;&#xA;    /* set values in arrays */&#xD;&#xA;    &#xD;&#xA;    printArry(a1, b1, &arry1);&#xD;&#xA;    printArry(a2, b2, &arry2);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;We can't use the structure hack firstly because structures can't have VLA members and secondly because even if they could we wouldn't be able to specify their length when an argument is passed (the member type must be known at the time of declaration and we can't declare structures inside a function declaration).&#xD;&#xA;&#xD;&#xA;**Confirmed - even ordinary (non VM) arrays must work with this version of 'printArry'(supposing that their dimensions sizes are properly passed to the function).** At least this is what the C11 standard says about it in it's examples.&#xD;&#xA;&#xD;&#xA;**All pointers to arrays with equal dimensions sizes can be assigned one another (no-matter if they are VM or not) without invoking UB.**&#xD;&#xA;&#xD;&#xA;Here are the examples on the latest C11 standard from which this comes from:&#xD;&#xA;&#xD;&#xA;> EXAMPLE 3  The following declarations demonstrate the compatibility&#xD;&#xA;> rules for variably modified types.&#xD;&#xA;> &#xD;&#xA;>     extern int n;&#xD;&#xA;>&#xD;&#xA;>     extern int m;&#xD;&#xA;>&#xD;&#xA;>     void fcompat(void)&#xD;&#xA;>     {&#xD;&#xA;>         int a[n][6][m];&#xD;&#xA;&#xD;&#xA;>         int (*p)[4][n+1];&#xD;&#xA;&#xD;&#xA;>         int c[n][n][6][m];&#xD;&#xA;&#xD;&#xA;>         int (*r)[n][n][n+1];&#xD;&#xA;>&#xD;&#xA;>         p = a;   // invalid: not compatible because 4 != 6&#xD;&#xA;>     &#xD;&#xA;>         r = c;   // compatible, but defined behavior only if&#xD;&#xA;>                  // n == 6 and m == n+1&#xD;&#xA;>            &#xD;&#xA;>     }&#xD;&#xA;&#xD;&#xA;At $6.7.6.2.&#xD;&#xA;&#xD;&#xA;Which means you can call this function for example like this:&#xD;&#xA;&#xD;&#xA;    int main(int argc, char **argv)&#xD;&#xA;    {&#xD;&#xA;        int arry[10][23];&#xD;&#xA;&#xD;&#xA;        printArry(sizeof(arry) / sizeof(arry[0]), &#xD;&#xA;                sizeof(arry[0]) / sizeof(arry[0][0]), &arry);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;On the other hand you could also access your array the bad old way using a simple pointer to it's first element:&#xD;&#xA;&#xD;&#xA;    void printArry(size_t a1, size_t b1, int *parryFirstElement){&#xD;&#xA;        for(size_t i = 0; i < a1; ++i)&#xD;&#xA;            for(size_t y = 0; y < b1; ++y)&#xD;&#xA;                parryFirstElement[i * b1 + y]; //your array [i][y] element&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Calling this function could be done the same way as before (as IIRC pointer in 'C' doesn't need to be casted).&#xD;&#xA;&#xD;&#xA;I replaced 'int' in the times where is better to use 'size_t'. Although if you're targeting some old standard you could reverse them back to 'int'.&#xD;&#xA;&#xD;&#xA;*I may be wrong though. I'm sleepy right now. If I'm wrong - well then that's bad.*";;"repeated a2 changed to b2 (bug in original code from question), etc; deleted 1 character in body"
