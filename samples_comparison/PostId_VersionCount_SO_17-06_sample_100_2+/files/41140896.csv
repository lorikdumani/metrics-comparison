Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
133825427;41140896;6523232;2;7d8ee6f3-47d6-4a60-943c-a1066bb19dcc;2016-12-14 10:58:19.0;"I'm using OpenGL for display YUV420P frames on screen in Android.&#xD;&#xA;With some resolution, my frame looks good, but with big resolution (on the same screen), it still looks like my original frame (with colors and all), but with some green lines hatching it (depending to the orientation, 4 lines, 30 lines?). Is it a alignment problem? A texture binding problem? Here is my code:&#xD;&#xA;&#xD;&#xA;    private final short[] INDICES_DATA = {0, 1, 2, 0, 2, 3};&#xD;&#xA;&#xD;&#xA;    private final float[] VERTICES_DATA = new float[] {&#xD;&#xA;        -1f, 1f, 0f,&#xD;&#xA;        0f, 0f,&#xD;&#xA;        -1f, -1f, 0f,&#xD;&#xA;        0f, 1f,&#xD;&#xA;        1f, -1f, 0f,&#xD;&#xA;        1f, 1f,&#xD;&#xA;        1f, 1f, 0f,&#xD;&#xA;        1f, 0f&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    private final String szVertexShaderCode =&#xD;&#xA;            ""attribute vec4 aPosition;\\n"" +&#xD;&#xA;            ""attribute vec2 aTexCoord;\\n"" +&#xD;&#xA;            ""varying vec2 vTexCoord;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""void main() {\\n"" +&#xD;&#xA;            ""   gl_Position = aPosition;\\n"" +&#xD;&#xA;            ""   vTexCoord = aTexCoord;\\n"" +&#xD;&#xA;            ""}\\n"";&#xD;&#xA;&#xD;&#xA;    private final String szYUV420PFragmentShaderCode =&#xD;&#xA;            ""#ifdef GL_FRAGMENT_PRECISION_HIGH\\n"" +&#xD;&#xA;            ""   precision highp float;\\n"" +&#xD;&#xA;            ""#else\\n"" +&#xD;&#xA;            ""   precision mediump float;\\n"" +&#xD;&#xA;            ""#endif\\n"" +&#xD;&#xA;&#xD;&#xA;            ""varying vec2 vTexCoord;\\n"" +&#xD;&#xA;            ""uniform sampler2D yTexture;\\n"" +&#xD;&#xA;            ""uniform sampler2D uTexture;\\n"" +&#xD;&#xA;            ""uniform sampler2D vTexture;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""void main() {\\n"" +&#xD;&#xA;            ""   float r, g, b, y, u, v;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   y = texture2D(yTexture, vTexCoord).r;\\n"" +&#xD;&#xA;            ""   u = texture2D(uTexture, vTexCoord).r - 0.5;\\n"" +&#xD;&#xA;            ""   v = texture2D(vTexture, vTexCoord).r - 0.5;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   r = y + (1.13983 * v);\\n"" +&#xD;&#xA;            ""   g = y - (0.39465 * u) - (0.58060 * v);\\n"" +&#xD;&#xA;            ""   b = y + (2.03211 * u);\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   gl_FragColor = vec4(r, g, b, 1.0);\\n"" +&#xD;&#xA;            ""}\\n"";&#xD;&#xA;&#xD;&#xA;**Function on surface created:**&#xD;&#xA;&#xD;&#xA;        //initShadersAndProgram();&#xD;&#xA;&#xD;&#xA;        iPositionLoc = GLES20.glGetAttribLocation(iProgram, ""aPosition"");&#xD;&#xA;        iTexCoordLoc = GLES20.glGetAttribLocation(iProgram, ""aTexCoord"");&#xD;&#xA;&#xD;&#xA;        // Is this line useful?&#xD;&#xA;        GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT, 1);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iYTexture = GLES20.glGetUniformLocation(iProgram, ""yTexture"");&#xD;&#xA;        int[] yTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, yTextureNames, 0);&#xD;&#xA;        int iYTextureName = yTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE1);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iYTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iUTexture = GLES20.glGetUniformLocation(iProgram, ""uTexture"");&#xD;&#xA;        int[] uTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, uTextureNames, 0);&#xD;&#xA;        int iUTextureName = uTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE2);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iUTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iVTexture = GLES20.glGetUniformLocation(iProgram, ""vTexture"");&#xD;&#xA;        int[] vTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, vTextureNames, 0);&#xD;&#xA;        int iVTextureName = vTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE3);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iVTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;&#xD;&#xA;**Function on draw frame:**&#xD;&#xA;&#xD;&#xA;    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);&#xD;&#xA;&#xD;&#xA;    GLES20.glUseProgram(iProgram);&#xD;&#xA;&#xD;&#xA;    verticesBuffer.position(0);&#xD;&#xA;    GLES20.glVertexAttribPointer(iPositionLoc, 3, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer);&#xD;&#xA;&#xD;&#xA;    verticesBuffer.position(3);&#xD;&#xA;    GLES20.glVertexAttribPointer(iTexCoordLoc, 2, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer);&#xD;&#xA;&#xD;&#xA;    GLES20.glEnableVertexAttribArray(iPositionLoc);&#xD;&#xA;    GLES20.glEnableVertexAttribArray(iTexCoordLoc);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE1);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iYTexture, 1);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth(),&#xD;&#xA;            pixmap.getHeight(),&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer Y */);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE2);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iUTexture, 2);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth() / 2,&#xD;&#xA;            pixmap.getHeight() / 2,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer U */);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE3);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iVTexture, 3);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth() / 2,&#xD;&#xA;            pixmap.getHeight() / 2,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer V */);&#xD;&#xA;&#xD;&#xA;    GLES20.glDrawElements(GLES20.GL_TRIANGLES, 6, GLES20.GL_UNSIGNED_SHORT, indicesBuffer);&#xD;&#xA;&#xD;&#xA;What do I miss?&#xD;&#xA;&#xD;&#xA;EDIT: Frames are provided from two different decoders and all works find with an other render process.";;
133826508;41140896;6523232;5;73eb7b53-e2ed-4b7f-818a-342642dbf382;2016-12-14 11:11:13.0;"I'm using OpenGL for display YUV420P frames on screen in Android.&#xD;&#xA;With some resolution, my frame looks good, but with big resolution (on the same screen), it still looks like my original frame (with colors and all), but with some green lines hatching it (depending to the orientation, 4 lines, 30 lines?).&#xD;&#xA;&#xD;&#xA;Here is an example:&#xD;&#xA;&#xD;&#xA;[![enter image description here][1]][1]&#xD;&#xA;&#xD;&#xA;Is it a alignment problem? A texture binding problem? Here is my code:&#xD;&#xA;&#xD;&#xA;    private final short[] INDICES_DATA = {0, 1, 2, 0, 2, 3};&#xD;&#xA;&#xD;&#xA;    private final float[] VERTICES_DATA = new float[] {&#xD;&#xA;        -1f, 1f, 0f,&#xD;&#xA;        0f, 0f,&#xD;&#xA;        -1f, -1f, 0f,&#xD;&#xA;        0f, 1f,&#xD;&#xA;        1f, -1f, 0f,&#xD;&#xA;        1f, 1f,&#xD;&#xA;        1f, 1f, 0f,&#xD;&#xA;        1f, 0f&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    private final String szVertexShaderCode =&#xD;&#xA;            ""attribute vec4 aPosition;\\n"" +&#xD;&#xA;            ""attribute vec2 aTexCoord;\\n"" +&#xD;&#xA;            ""varying vec2 vTexCoord;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""void main() {\\n"" +&#xD;&#xA;            ""   gl_Position = aPosition;\\n"" +&#xD;&#xA;            ""   vTexCoord = aTexCoord;\\n"" +&#xD;&#xA;            ""}\\n"";&#xD;&#xA;&#xD;&#xA;    private final String szYUV420PFragmentShaderCode =&#xD;&#xA;            ""#ifdef GL_FRAGMENT_PRECISION_HIGH\\n"" +&#xD;&#xA;            ""   precision highp float;\\n"" +&#xD;&#xA;            ""#else\\n"" +&#xD;&#xA;            ""   precision mediump float;\\n"" +&#xD;&#xA;            ""#endif\\n"" +&#xD;&#xA;&#xD;&#xA;            ""varying vec2 vTexCoord;\\n"" +&#xD;&#xA;            ""uniform sampler2D yTexture;\\n"" +&#xD;&#xA;            ""uniform sampler2D uTexture;\\n"" +&#xD;&#xA;            ""uniform sampler2D vTexture;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""void main() {\\n"" +&#xD;&#xA;            ""   float r, g, b, y, u, v;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   y = texture2D(yTexture, vTexCoord).r;\\n"" +&#xD;&#xA;            ""   u = texture2D(uTexture, vTexCoord).r - 0.5;\\n"" +&#xD;&#xA;            ""   v = texture2D(vTexture, vTexCoord).r - 0.5;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   r = y + (1.13983 * v);\\n"" +&#xD;&#xA;            ""   g = y - (0.39465 * u) - (0.58060 * v);\\n"" +&#xD;&#xA;            ""   b = y + (2.03211 * u);\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   gl_FragColor = vec4(r, g, b, 1.0);\\n"" +&#xD;&#xA;            ""}\\n"";&#xD;&#xA;&#xD;&#xA;**Function on surface created:**&#xD;&#xA;&#xD;&#xA;        //initShadersAndProgram();&#xD;&#xA;&#xD;&#xA;        iPositionLoc = GLES20.glGetAttribLocation(iProgram, ""aPosition"");&#xD;&#xA;        iTexCoordLoc = GLES20.glGetAttribLocation(iProgram, ""aTexCoord"");&#xD;&#xA;&#xD;&#xA;        // Is this line useful?&#xD;&#xA;        GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT, 1);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iYTexture = GLES20.glGetUniformLocation(iProgram, ""yTexture"");&#xD;&#xA;        int[] yTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, yTextureNames, 0);&#xD;&#xA;        int iYTextureName = yTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE1);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iYTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iUTexture = GLES20.glGetUniformLocation(iProgram, ""uTexture"");&#xD;&#xA;        int[] uTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, uTextureNames, 0);&#xD;&#xA;        int iUTextureName = uTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE2);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iUTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iVTexture = GLES20.glGetUniformLocation(iProgram, ""vTexture"");&#xD;&#xA;        int[] vTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, vTextureNames, 0);&#xD;&#xA;        int iVTextureName = vTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE3);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iVTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;&#xD;&#xA;**Function on draw frame:**&#xD;&#xA;&#xD;&#xA;    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);&#xD;&#xA;&#xD;&#xA;    GLES20.glUseProgram(iProgram);&#xD;&#xA;&#xD;&#xA;    verticesBuffer.position(0);&#xD;&#xA;    GLES20.glVertexAttribPointer(iPositionLoc, 3, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer);&#xD;&#xA;&#xD;&#xA;    verticesBuffer.position(3);&#xD;&#xA;    GLES20.glVertexAttribPointer(iTexCoordLoc, 2, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer);&#xD;&#xA;&#xD;&#xA;    GLES20.glEnableVertexAttribArray(iPositionLoc);&#xD;&#xA;    GLES20.glEnableVertexAttribArray(iTexCoordLoc);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE1);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iYTexture, 1);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth(),&#xD;&#xA;            pixmap.getHeight(),&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer Y */);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE2);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iUTexture, 2);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth() / 2,&#xD;&#xA;            pixmap.getHeight() / 2,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer U */);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE3);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iVTexture, 3);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth() / 2,&#xD;&#xA;            pixmap.getHeight() / 2,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer V */);&#xD;&#xA;&#xD;&#xA;    GLES20.glDrawElements(GLES20.GL_TRIANGLES, 6, GLES20.GL_UNSIGNED_SHORT, indicesBuffer);&#xD;&#xA;&#xD;&#xA;What do I miss?&#xD;&#xA;&#xD;&#xA;EDIT: Frames are provided from two different decoders and all works find with an other render process.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://i.stack.imgur.com/nZn6M.jpg";;Add screen capture to be more explicit
133827175;41140896;6523232;5;34133acf-c310-45b2-b952-5fc922b81d5a;2016-12-14 11:21:11.0;"I'm using OpenGL for display YUV420P frames on screen in Android.&#xD;&#xA;With some resolution, my frame looks good, but with big resolution (on the same screen), it still looks like my original frame (with colors and all), but with some green lines hatching it (depending to the orientation, 4 lines, 30 lines?).&#xD;&#xA;&#xD;&#xA;Here is an example (an 1080x607 frame):&#xD;&#xA;&#xD;&#xA;[![enter image description here][1]][1]&#xD;&#xA;&#xD;&#xA;Is it a alignment problem? A texture binding problem? Here is my code:&#xD;&#xA;&#xD;&#xA;    private final short[] INDICES_DATA = {0, 1, 2, 0, 2, 3};&#xD;&#xA;&#xD;&#xA;    private final float[] VERTICES_DATA = new float[] {&#xD;&#xA;        -1f, 1f, 0f,&#xD;&#xA;        0f, 0f,&#xD;&#xA;        -1f, -1f, 0f,&#xD;&#xA;        0f, 1f,&#xD;&#xA;        1f, -1f, 0f,&#xD;&#xA;        1f, 1f,&#xD;&#xA;        1f, 1f, 0f,&#xD;&#xA;        1f, 0f&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    private final String szVertexShaderCode =&#xD;&#xA;            ""attribute vec4 aPosition;\\n"" +&#xD;&#xA;            ""attribute vec2 aTexCoord;\\n"" +&#xD;&#xA;            ""varying vec2 vTexCoord;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""void main() {\\n"" +&#xD;&#xA;            ""   gl_Position = aPosition;\\n"" +&#xD;&#xA;            ""   vTexCoord = aTexCoord;\\n"" +&#xD;&#xA;            ""}\\n"";&#xD;&#xA;&#xD;&#xA;    private final String szYUV420PFragmentShaderCode =&#xD;&#xA;            ""#ifdef GL_FRAGMENT_PRECISION_HIGH\\n"" +&#xD;&#xA;            ""   precision highp float;\\n"" +&#xD;&#xA;            ""#else\\n"" +&#xD;&#xA;            ""   precision mediump float;\\n"" +&#xD;&#xA;            ""#endif\\n"" +&#xD;&#xA;&#xD;&#xA;            ""varying vec2 vTexCoord;\\n"" +&#xD;&#xA;            ""uniform sampler2D yTexture;\\n"" +&#xD;&#xA;            ""uniform sampler2D uTexture;\\n"" +&#xD;&#xA;            ""uniform sampler2D vTexture;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""void main() {\\n"" +&#xD;&#xA;            ""   float r, g, b, y, u, v;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   y = texture2D(yTexture, vTexCoord).r;\\n"" +&#xD;&#xA;            ""   u = texture2D(uTexture, vTexCoord).r - 0.5;\\n"" +&#xD;&#xA;            ""   v = texture2D(vTexture, vTexCoord).r - 0.5;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   r = y + (1.13983 * v);\\n"" +&#xD;&#xA;            ""   g = y - (0.39465 * u) - (0.58060 * v);\\n"" +&#xD;&#xA;            ""   b = y + (2.03211 * u);\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   gl_FragColor = vec4(r, g, b, 1.0);\\n"" +&#xD;&#xA;            ""}\\n"";&#xD;&#xA;&#xD;&#xA;**Function on surface created:**&#xD;&#xA;&#xD;&#xA;        //initShadersAndProgram();&#xD;&#xA;&#xD;&#xA;        iPositionLoc = GLES20.glGetAttribLocation(iProgram, ""aPosition"");&#xD;&#xA;        iTexCoordLoc = GLES20.glGetAttribLocation(iProgram, ""aTexCoord"");&#xD;&#xA;&#xD;&#xA;        // Is this line useful?&#xD;&#xA;        GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT, 1);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iYTexture = GLES20.glGetUniformLocation(iProgram, ""yTexture"");&#xD;&#xA;        int[] yTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, yTextureNames, 0);&#xD;&#xA;        int iYTextureName = yTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE1);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iYTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iUTexture = GLES20.glGetUniformLocation(iProgram, ""uTexture"");&#xD;&#xA;        int[] uTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, uTextureNames, 0);&#xD;&#xA;        int iUTextureName = uTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE2);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iUTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iVTexture = GLES20.glGetUniformLocation(iProgram, ""vTexture"");&#xD;&#xA;        int[] vTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, vTextureNames, 0);&#xD;&#xA;        int iVTextureName = vTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE3);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iVTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;&#xD;&#xA;**Function on draw frame:**&#xD;&#xA;&#xD;&#xA;    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);&#xD;&#xA;&#xD;&#xA;    GLES20.glUseProgram(iProgram);&#xD;&#xA;&#xD;&#xA;    verticesBuffer.position(0);&#xD;&#xA;    GLES20.glVertexAttribPointer(iPositionLoc, 3, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer);&#xD;&#xA;&#xD;&#xA;    verticesBuffer.position(3);&#xD;&#xA;    GLES20.glVertexAttribPointer(iTexCoordLoc, 2, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer);&#xD;&#xA;&#xD;&#xA;    GLES20.glEnableVertexAttribArray(iPositionLoc);&#xD;&#xA;    GLES20.glEnableVertexAttribArray(iTexCoordLoc);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE1);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iYTexture, 1);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth(),&#xD;&#xA;            pixmap.getHeight(),&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer Y */);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE2);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iUTexture, 2);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth() / 2,&#xD;&#xA;            pixmap.getHeight() / 2,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer U */);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE3);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iVTexture, 3);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth() / 2,&#xD;&#xA;            pixmap.getHeight() / 2,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer V */);&#xD;&#xA;&#xD;&#xA;    GLES20.glDrawElements(GLES20.GL_TRIANGLES, 6, GLES20.GL_UNSIGNED_SHORT, indicesBuffer);&#xD;&#xA;&#xD;&#xA;What do I miss?&#xD;&#xA;&#xD;&#xA;EDIT: Frames are provided from two different decoders and all works find with an other render process.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://i.stack.imgur.com/nZn6M.jpg";;added 20 characters in body
133839030;41140896;6523232;5;6608789e-4941-43f2-96f2-dce3c0b9a0b4;2016-12-14 13:46:40.0;"I'm using OpenGL for display YUV420P frames on screen in Android.&#xD;&#xA;With some resolution, my frame looks good, but with big resolution (on the same screen), it still looks like my original frame (with colors and all), but with some green lines hatching it (depending to the orientation, 4 lines, 30 lines?).&#xD;&#xA;&#xD;&#xA;Here is an example (an 1080x607 frame):&#xD;&#xA;&#xD;&#xA;[![enter image description here][1]][1]&#xD;&#xA;&#xD;&#xA;Is it a alignment problem? A texture binding problem? Here is my code:&#xD;&#xA;&#xD;&#xA;    private final short[] INDICES_DATA = {0, 1, 2, 0, 2, 3};&#xD;&#xA;&#xD;&#xA;    private final float[] VERTICES_DATA = new float[] {&#xD;&#xA;        -1f, 1f, 0f,&#xD;&#xA;        0f, 0f,&#xD;&#xA;        -1f, -1f, 0f,&#xD;&#xA;        0f, 1f,&#xD;&#xA;        1f, -1f, 0f,&#xD;&#xA;        1f, 1f,&#xD;&#xA;        1f, 1f, 0f,&#xD;&#xA;        1f, 0f&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    private final String szVertexShaderCode =&#xD;&#xA;            ""attribute vec4 aPosition;\\n"" +&#xD;&#xA;            ""attribute vec2 aTexCoord;\\n"" +&#xD;&#xA;            ""varying vec2 vTexCoord;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""void main() {\\n"" +&#xD;&#xA;            ""   gl_Position = aPosition;\\n"" +&#xD;&#xA;            ""   vTexCoord = aTexCoord;\\n"" +&#xD;&#xA;            ""}\\n"";&#xD;&#xA;&#xD;&#xA;    private final String szYUV420PFragmentShaderCode =&#xD;&#xA;            ""#ifdef GL_FRAGMENT_PRECISION_HIGH\\n"" +&#xD;&#xA;            ""   precision highp float;\\n"" +&#xD;&#xA;            ""#else\\n"" +&#xD;&#xA;            ""   precision mediump float;\\n"" +&#xD;&#xA;            ""#endif\\n"" +&#xD;&#xA;&#xD;&#xA;            ""varying vec2 vTexCoord;\\n"" +&#xD;&#xA;            ""uniform sampler2D yTexture;\\n"" +&#xD;&#xA;            ""uniform sampler2D uTexture;\\n"" +&#xD;&#xA;            ""uniform sampler2D vTexture;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""void main() {\\n"" +&#xD;&#xA;            ""   float r, g, b, y, u, v;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   y = texture2D(yTexture, vTexCoord).r;\\n"" +&#xD;&#xA;            ""   u = texture2D(uTexture, vTexCoord).r - 0.5;\\n"" +&#xD;&#xA;            ""   v = texture2D(vTexture, vTexCoord).r - 0.5;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   r = y + (1.13983 * v);\\n"" +&#xD;&#xA;            ""   g = y - (0.39465 * u) - (0.58060 * v);\\n"" +&#xD;&#xA;            ""   b = y + (2.03211 * u);\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   gl_FragColor = vec4(r, g, b, 1.0);\\n"" +&#xD;&#xA;            ""}\\n"";&#xD;&#xA;&#xD;&#xA;**Function on surface created:**&#xD;&#xA;&#xD;&#xA;        //initShadersAndProgram();&#xD;&#xA;&#xD;&#xA;        iPositionLoc = GLES20.glGetAttribLocation(iProgram, ""aPosition"");&#xD;&#xA;        iTexCoordLoc = GLES20.glGetAttribLocation(iProgram, ""aTexCoord"");&#xD;&#xA;&#xD;&#xA;        // Is this line useful?&#xD;&#xA;        GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT, 1);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iYTexture = GLES20.glGetUniformLocation(iProgram, ""yTexture"");&#xD;&#xA;        int[] yTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, yTextureNames, 0);&#xD;&#xA;        int iYTextureName = yTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE1);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iYTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iUTexture = GLES20.glGetUniformLocation(iProgram, ""uTexture"");&#xD;&#xA;        int[] uTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, uTextureNames, 0);&#xD;&#xA;        int iUTextureName = uTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE2);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iUTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iVTexture = GLES20.glGetUniformLocation(iProgram, ""vTexture"");&#xD;&#xA;        int[] vTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, vTextureNames, 0);&#xD;&#xA;        int iVTextureName = vTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE3);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iVTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;&#xD;&#xA;**Function on draw frame:**&#xD;&#xA;&#xD;&#xA;    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);&#xD;&#xA;&#xD;&#xA;    GLES20.glUseProgram(iProgram);&#xD;&#xA;&#xD;&#xA;    verticesBuffer.position(0);&#xD;&#xA;    GLES20.glVertexAttribPointer(iPositionLoc, 3, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer);&#xD;&#xA;&#xD;&#xA;    verticesBuffer.position(3);&#xD;&#xA;    GLES20.glVertexAttribPointer(iTexCoordLoc, 2, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer);&#xD;&#xA;&#xD;&#xA;    GLES20.glEnableVertexAttribArray(iPositionLoc);&#xD;&#xA;    GLES20.glEnableVertexAttribArray(iTexCoordLoc);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE1);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iYTexture, 1);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth(),&#xD;&#xA;            pixmap.getHeight(),&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer Y */);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE2);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iUTexture, 2);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth() / 2,&#xD;&#xA;            pixmap.getHeight() / 2,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer U */);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE3);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iVTexture, 3);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth() / 2,&#xD;&#xA;            pixmap.getHeight() / 2,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer V */);&#xD;&#xA;&#xD;&#xA;    GLES20.glDrawElements(GLES20.GL_TRIANGLES, 6, GLES20.GL_UNSIGNED_SHORT, indicesBuffer);&#xD;&#xA;&#xD;&#xA;What do I miss?&#xD;&#xA;&#xD;&#xA;EDIT: Frames are provided from two different decoders and all works find with an other render process.&#xD;&#xA;&#xD;&#xA;EDIT2: I displayed only the Y plane and the result is a grey frame (as expected) but there is no hatch lines!! So problem comes from U/V planes?&#xD;&#xA;&#xD;&#xA;  [1]: https://i.stack.imgur.com/nZn6M.jpg";;added 146 characters in body
133847482;41140896;6523232;5;0adc2da6-4f99-4cc1-b9ed-be94101675ab;2016-12-14 15:29:07.0;"I'm using OpenGL for display YUV420P frames on screen in Android.&#xD;&#xA;With some resolution, my frame looks good, but with big resolution (on the same screen), it still looks like my original frame (with colors and all), but with some green lines hatching it (depending to the orientation, 4 lines, 30 lines?).&#xD;&#xA;&#xD;&#xA;Here is an example (an 1080x607 frame):&#xD;&#xA;&#xD;&#xA;[![enter image description here][1]][1]&#xD;&#xA;&#xD;&#xA;Is it a alignment problem? A texture binding problem? Here is my code:&#xD;&#xA;&#xD;&#xA;    private final short[] INDICES_DATA = {0, 1, 2, 0, 2, 3};&#xD;&#xA;&#xD;&#xA;    private final float[] VERTICES_DATA = new float[] {&#xD;&#xA;        -1f, 1f, 0f,&#xD;&#xA;        0f, 0f,&#xD;&#xA;        -1f, -1f, 0f,&#xD;&#xA;        0f, 1f,&#xD;&#xA;        1f, -1f, 0f,&#xD;&#xA;        1f, 1f,&#xD;&#xA;        1f, 1f, 0f,&#xD;&#xA;        1f, 0f&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    private final String szVertexShaderCode =&#xD;&#xA;            ""attribute vec4 aPosition;\\n"" +&#xD;&#xA;            ""attribute vec2 aTexCoord;\\n"" +&#xD;&#xA;            ""varying vec2 vTexCoord;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""void main() {\\n"" +&#xD;&#xA;            ""   gl_Position = aPosition;\\n"" +&#xD;&#xA;            ""   vTexCoord = aTexCoord;\\n"" +&#xD;&#xA;            ""}\\n"";&#xD;&#xA;&#xD;&#xA;    private final String szYUV420PFragmentShaderCode =&#xD;&#xA;            ""#ifdef GL_FRAGMENT_PRECISION_HIGH\\n"" +&#xD;&#xA;            ""   precision highp float;\\n"" +&#xD;&#xA;            ""#else\\n"" +&#xD;&#xA;            ""   precision mediump float;\\n"" +&#xD;&#xA;            ""#endif\\n"" +&#xD;&#xA;&#xD;&#xA;            ""varying vec2 vTexCoord;\\n"" +&#xD;&#xA;            ""uniform sampler2D yTexture;\\n"" +&#xD;&#xA;            ""uniform sampler2D uTexture;\\n"" +&#xD;&#xA;            ""uniform sampler2D vTexture;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""void main() {\\n"" +&#xD;&#xA;            ""   float r, g, b, y, u, v;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   y = texture2D(yTexture, vTexCoord).r;\\n"" +&#xD;&#xA;            ""   u = texture2D(uTexture, vTexCoord).r - 0.5;\\n"" +&#xD;&#xA;            ""   v = texture2D(vTexture, vTexCoord).r - 0.5;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   r = y + (1.13983 * v);\\n"" +&#xD;&#xA;            ""   g = y - (0.39465 * u) - (0.58060 * v);\\n"" +&#xD;&#xA;            ""   b = y + (2.03211 * u);\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   gl_FragColor = vec4(r, g, b, 1.0);\\n"" +&#xD;&#xA;            ""}\\n"";&#xD;&#xA;&#xD;&#xA;**Function on surface created:**&#xD;&#xA;&#xD;&#xA;        //initShadersAndProgram();&#xD;&#xA;&#xD;&#xA;        iPositionLoc = GLES20.glGetAttribLocation(iProgram, ""aPosition"");&#xD;&#xA;        iTexCoordLoc = GLES20.glGetAttribLocation(iProgram, ""aTexCoord"");&#xD;&#xA;&#xD;&#xA;        // Is this line useful?&#xD;&#xA;        GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT, 1);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iYTexture = GLES20.glGetUniformLocation(iProgram, ""yTexture"");&#xD;&#xA;        int[] yTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, yTextureNames, 0);&#xD;&#xA;        int iYTextureName = yTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE1);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iYTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iUTexture = GLES20.glGetUniformLocation(iProgram, ""uTexture"");&#xD;&#xA;        int[] uTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, uTextureNames, 0);&#xD;&#xA;        int iUTextureName = uTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE2);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iUTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iVTexture = GLES20.glGetUniformLocation(iProgram, ""vTexture"");&#xD;&#xA;        int[] vTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, vTextureNames, 0);&#xD;&#xA;        int iVTextureName = vTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE3);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iVTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;&#xD;&#xA;**Function on draw frame:**&#xD;&#xA;&#xD;&#xA;    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);&#xD;&#xA;&#xD;&#xA;    GLES20.glUseProgram(iProgram);&#xD;&#xA;&#xD;&#xA;    verticesBuffer.position(0);&#xD;&#xA;    GLES20.glVertexAttribPointer(iPositionLoc, 3, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer);&#xD;&#xA;&#xD;&#xA;    verticesBuffer.position(3);&#xD;&#xA;    GLES20.glVertexAttribPointer(iTexCoordLoc, 2, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer);&#xD;&#xA;&#xD;&#xA;    GLES20.glEnableVertexAttribArray(iPositionLoc);&#xD;&#xA;    GLES20.glEnableVertexAttribArray(iTexCoordLoc);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE1);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iYTexture, 1);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth(),&#xD;&#xA;            pixmap.getHeight(),&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer Y */);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE2);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iUTexture, 2);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth() / 2,&#xD;&#xA;            pixmap.getHeight() / 2,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer U */);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE3);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iVTexture, 3);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth() / 2,&#xD;&#xA;            pixmap.getHeight() / 2,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer V */);&#xD;&#xA;&#xD;&#xA;    GLES20.glDrawElements(GLES20.GL_TRIANGLES, 6, GLES20.GL_UNSIGNED_SHORT, indicesBuffer);&#xD;&#xA;&#xD;&#xA;What do I miss?&#xD;&#xA;&#xD;&#xA;**EDIT:** Frames are provided from two different decoders and all works find with an other render process.&#xD;&#xA;&#xD;&#xA;**EDIT2:** I displayed only the Y plane and the result is a grey frame (as expected) but there is no hatch lines!! &#xD;&#xA;&#xD;&#xA;[![enter image description here][2]][2]&#xD;&#xA;&#xD;&#xA;I just replaced these lines in my fragment shader to display it:&#xD;&#xA;&#xD;&#xA;    "" r = texture2D(yTexture, vTexCoord).r;\\n"" +&#xD;&#xA;    "" g = texture2D(yTexture, vTexCoord).g;\\n"" +&#xD;&#xA;    "" b = texture2D(yTexture, vTexCoord).b;\\n"" +&#xD;&#xA;&#xD;&#xA;So problem comes from U/V planes?&#xD;&#xA;&#xD;&#xA;  [1]: https://i.stack.imgur.com/nZn6M.jpg&#xD;&#xA;  [2]: https://i.stack.imgur.com/GyUiI.png";;added 319 characters in body
133848071;41140896;6523232;5;429100ee-ea75-4019-ae47-6ed4110f1618;2016-12-14 15:36:26.0;"I'm using OpenGL for display YUV420P frames on screen in Android.&#xD;&#xA;With some resolution, my frame looks good, but with big resolution (on the same screen), it still looks like my original frame (with colors and all), but with some green lines hatching it (depending to the orientation, 4 lines, 30 lines?).&#xD;&#xA;&#xD;&#xA;Here is an example (an 1080x607 frame):&#xD;&#xA;&#xD;&#xA;[![enter image description here][1]][1]&#xD;&#xA;&#xD;&#xA;Is it a alignment problem? A texture binding problem? Here is my code:&#xD;&#xA;&#xD;&#xA;    private final short[] INDICES_DATA = {0, 1, 2, 0, 2, 3};&#xD;&#xA;&#xD;&#xA;    private final float[] VERTICES_DATA = new float[] {&#xD;&#xA;        -1f, 1f, 0f,&#xD;&#xA;        0f, 0f,&#xD;&#xA;        -1f, -1f, 0f,&#xD;&#xA;        0f, 1f,&#xD;&#xA;        1f, -1f, 0f,&#xD;&#xA;        1f, 1f,&#xD;&#xA;        1f, 1f, 0f,&#xD;&#xA;        1f, 0f&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    private final String szVertexShaderCode =&#xD;&#xA;            ""attribute vec4 aPosition;\\n"" +&#xD;&#xA;            ""attribute vec2 aTexCoord;\\n"" +&#xD;&#xA;            ""varying vec2 vTexCoord;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""void main() {\\n"" +&#xD;&#xA;            ""   gl_Position = aPosition;\\n"" +&#xD;&#xA;            ""   vTexCoord = aTexCoord;\\n"" +&#xD;&#xA;            ""}\\n"";&#xD;&#xA;&#xD;&#xA;    private final String szYUV420PFragmentShaderCode =&#xD;&#xA;            ""#ifdef GL_FRAGMENT_PRECISION_HIGH\\n"" +&#xD;&#xA;            ""   precision highp float;\\n"" +&#xD;&#xA;            ""#else\\n"" +&#xD;&#xA;            ""   precision mediump float;\\n"" +&#xD;&#xA;            ""#endif\\n"" +&#xD;&#xA;&#xD;&#xA;            ""varying vec2 vTexCoord;\\n"" +&#xD;&#xA;            ""uniform sampler2D yTexture;\\n"" +&#xD;&#xA;            ""uniform sampler2D uTexture;\\n"" +&#xD;&#xA;            ""uniform sampler2D vTexture;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""void main() {\\n"" +&#xD;&#xA;            ""   float r, g, b, y, u, v;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   y = texture2D(yTexture, vTexCoord).r;\\n"" +&#xD;&#xA;            ""   u = texture2D(uTexture, vTexCoord).r - 0.5;\\n"" +&#xD;&#xA;            ""   v = texture2D(vTexture, vTexCoord).r - 0.5;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   r = y + (1.13983 * v);\\n"" +&#xD;&#xA;            ""   g = y - (0.39465 * u) - (0.58060 * v);\\n"" +&#xD;&#xA;            ""   b = y + (2.03211 * u);\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   gl_FragColor = vec4(r, g, b, 1.0);\\n"" +&#xD;&#xA;            ""}\\n"";&#xD;&#xA;&#xD;&#xA;**Function on surface created:**&#xD;&#xA;&#xD;&#xA;        //initShadersAndProgram();&#xD;&#xA;&#xD;&#xA;        iPositionLoc = GLES20.glGetAttribLocation(iProgram, ""aPosition"");&#xD;&#xA;        iTexCoordLoc = GLES20.glGetAttribLocation(iProgram, ""aTexCoord"");&#xD;&#xA;&#xD;&#xA;        // Is this line useful?&#xD;&#xA;        GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT, 1);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iYTexture = GLES20.glGetUniformLocation(iProgram, ""yTexture"");&#xD;&#xA;        int[] yTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, yTextureNames, 0);&#xD;&#xA;        int iYTextureName = yTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE1);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iYTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iUTexture = GLES20.glGetUniformLocation(iProgram, ""uTexture"");&#xD;&#xA;        int[] uTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, uTextureNames, 0);&#xD;&#xA;        int iUTextureName = uTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE2);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iUTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iVTexture = GLES20.glGetUniformLocation(iProgram, ""vTexture"");&#xD;&#xA;        int[] vTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, vTextureNames, 0);&#xD;&#xA;        int iVTextureName = vTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE3);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iVTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;&#xD;&#xA;**Function on draw frame:**&#xD;&#xA;&#xD;&#xA;    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);&#xD;&#xA;&#xD;&#xA;    GLES20.glUseProgram(iProgram);&#xD;&#xA;&#xD;&#xA;    verticesBuffer.position(0);&#xD;&#xA;    GLES20.glVertexAttribPointer(iPositionLoc, 3, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer);&#xD;&#xA;&#xD;&#xA;    verticesBuffer.position(3);&#xD;&#xA;    GLES20.glVertexAttribPointer(iTexCoordLoc, 2, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer);&#xD;&#xA;&#xD;&#xA;    GLES20.glEnableVertexAttribArray(iPositionLoc);&#xD;&#xA;    GLES20.glEnableVertexAttribArray(iTexCoordLoc);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE1);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iYTexture, 1);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth(),&#xD;&#xA;            pixmap.getHeight(),&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer Y */);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE2);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iUTexture, 2);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth() / 2,&#xD;&#xA;            pixmap.getHeight() / 2,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer U */);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE3);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iVTexture, 3);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth() / 2,&#xD;&#xA;            pixmap.getHeight() / 2,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer V */);&#xD;&#xA;&#xD;&#xA;    GLES20.glDrawElements(GLES20.GL_TRIANGLES, 6, GLES20.GL_UNSIGNED_SHORT, indicesBuffer);&#xD;&#xA;&#xD;&#xA;What do I miss?&#xD;&#xA;&#xD;&#xA;**EDIT:** Frames are provided from two different decoders and all works find with an other render process.&#xD;&#xA;&#xD;&#xA;**EDIT2:** I displayed only the Y plane and the result is a grey frame (as expected) but there is no hatch lines!! &#xD;&#xA;&#xD;&#xA;[![enter image description here][2]][2]&#xD;&#xA;&#xD;&#xA;I just replaced these lines in my fragment shader to display it:&#xD;&#xA;&#xD;&#xA;    "" r = texture2D(yTexture, vTexCoord).r;\\n"" +&#xD;&#xA;    "" g = texture2D(yTexture, vTexCoord).g;\\n"" +&#xD;&#xA;    "" b = texture2D(yTexture, vTexCoord).b;\\n"" +&#xD;&#xA;&#xD;&#xA;So problem comes from U/V planes? How can I modify my code to display only U/V planes?&#xD;&#xA;&#xD;&#xA;  [1]: https://i.stack.imgur.com/nZn6M.jpg&#xD;&#xA;  [2]: https://i.stack.imgur.com/GyUiI.png";;added 53 characters in body
133849130;41140896;6523232;5;04a5e3db-46bd-4a26-95e1-f73fc902f70c;2016-12-14 15:48:50.0;"I'm using OpenGL for display YUV420P frames on screen in Android.&#xD;&#xA;With some resolution, my frame looks good, but with big resolution (on the same screen), it still looks like my original frame (with colors and all), but with some green lines hatching it (depending to the orientation, 4 lines, 30 lines?).&#xD;&#xA;&#xD;&#xA;Here is an example (an 1080x607 frame):&#xD;&#xA;&#xD;&#xA;[![enter image description here][1]][1]&#xD;&#xA;&#xD;&#xA;Is it a alignment problem? A texture binding problem? Here is my code:&#xD;&#xA;&#xD;&#xA;    private final short[] INDICES_DATA = {0, 1, 2, 0, 2, 3};&#xD;&#xA;&#xD;&#xA;    private final float[] VERTICES_DATA = new float[] {&#xD;&#xA;        -1f, 1f, 0f,&#xD;&#xA;        0f, 0f,&#xD;&#xA;        -1f, -1f, 0f,&#xD;&#xA;        0f, 1f,&#xD;&#xA;        1f, -1f, 0f,&#xD;&#xA;        1f, 1f,&#xD;&#xA;        1f, 1f, 0f,&#xD;&#xA;        1f, 0f&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    private final String szVertexShaderCode =&#xD;&#xA;            ""attribute vec4 aPosition;\\n"" +&#xD;&#xA;            ""attribute vec2 aTexCoord;\\n"" +&#xD;&#xA;            ""varying vec2 vTexCoord;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""void main() {\\n"" +&#xD;&#xA;            ""   gl_Position = aPosition;\\n"" +&#xD;&#xA;            ""   vTexCoord = aTexCoord;\\n"" +&#xD;&#xA;            ""}\\n"";&#xD;&#xA;&#xD;&#xA;    private final String szYUV420PFragmentShaderCode =&#xD;&#xA;            ""#ifdef GL_FRAGMENT_PRECISION_HIGH\\n"" +&#xD;&#xA;            ""   precision highp float;\\n"" +&#xD;&#xA;            ""#else\\n"" +&#xD;&#xA;            ""   precision mediump float;\\n"" +&#xD;&#xA;            ""#endif\\n"" +&#xD;&#xA;&#xD;&#xA;            ""varying vec2 vTexCoord;\\n"" +&#xD;&#xA;            ""uniform sampler2D yTexture;\\n"" +&#xD;&#xA;            ""uniform sampler2D uTexture;\\n"" +&#xD;&#xA;            ""uniform sampler2D vTexture;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""void main() {\\n"" +&#xD;&#xA;            ""   float r, g, b, y, u, v;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   y = texture2D(yTexture, vTexCoord).r;\\n"" +&#xD;&#xA;            ""   u = texture2D(uTexture, vTexCoord).r - 0.5;\\n"" +&#xD;&#xA;            ""   v = texture2D(vTexture, vTexCoord).r - 0.5;\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   r = y + (1.13983 * v);\\n"" +&#xD;&#xA;            ""   g = y - (0.39465 * u) - (0.58060 * v);\\n"" +&#xD;&#xA;            ""   b = y + (2.03211 * u);\\n"" +&#xD;&#xA;&#xD;&#xA;            ""   gl_FragColor = vec4(r, g, b, 1.0);\\n"" +&#xD;&#xA;            ""}\\n"";&#xD;&#xA;&#xD;&#xA;**Function on surface created:**&#xD;&#xA;&#xD;&#xA;        //initShadersAndProgram();&#xD;&#xA;&#xD;&#xA;        iPositionLoc = GLES20.glGetAttribLocation(iProgram, ""aPosition"");&#xD;&#xA;        iTexCoordLoc = GLES20.glGetAttribLocation(iProgram, ""aTexCoord"");&#xD;&#xA;&#xD;&#xA;        // Is this line useful?&#xD;&#xA;        GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT, 1);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iYTexture = GLES20.glGetUniformLocation(iProgram, ""yTexture"");&#xD;&#xA;        int[] yTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, yTextureNames, 0);&#xD;&#xA;        int iYTextureName = yTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE1);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iYTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iUTexture = GLES20.glGetUniformLocation(iProgram, ""uTexture"");&#xD;&#xA;        int[] uTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, uTextureNames, 0);&#xD;&#xA;        int iUTextureName = uTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE2);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iUTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glEnable(GLES20.GL_TEXTURE_2D);&#xD;&#xA;        iVTexture = GLES20.glGetUniformLocation(iProgram, ""vTexture"");&#xD;&#xA;        int[] vTextureNames = new int[1];&#xD;&#xA;        GLES20.glGenTextures(1, vTextureNames, 0);&#xD;&#xA;        int iVTextureName = vTextureNames[0];&#xD;&#xA;        GLES20.glActiveTexture(GLES20.GL_TEXTURE3);&#xD;&#xA;        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, iVTextureName);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);&#xD;&#xA;&#xD;&#xA;        GLES20.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);&#xD;&#xA;&#xD;&#xA;**Function on draw frame:**&#xD;&#xA;&#xD;&#xA;    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);&#xD;&#xA;&#xD;&#xA;    GLES20.glUseProgram(iProgram);&#xD;&#xA;&#xD;&#xA;    verticesBuffer.position(0);&#xD;&#xA;    GLES20.glVertexAttribPointer(iPositionLoc, 3, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer);&#xD;&#xA;&#xD;&#xA;    verticesBuffer.position(3);&#xD;&#xA;    GLES20.glVertexAttribPointer(iTexCoordLoc, 2, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer);&#xD;&#xA;&#xD;&#xA;    GLES20.glEnableVertexAttribArray(iPositionLoc);&#xD;&#xA;    GLES20.glEnableVertexAttribArray(iTexCoordLoc);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE1);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iYTexture, 1);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth(),&#xD;&#xA;            pixmap.getHeight(),&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer Y */);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE2);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iUTexture, 2);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth() / 2,&#xD;&#xA;            pixmap.getHeight() / 2,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer U */);&#xD;&#xA;&#xD;&#xA;    GLES20.glActiveTexture(GLES20.GL_TEXTURE3);&#xD;&#xA;&#xD;&#xA;    GLES20.glUniform1i(iVTexture, 3);&#xD;&#xA;    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            pixmap.getWidth() / 2,&#xD;&#xA;            pixmap.getHeight() / 2,&#xD;&#xA;            0,&#xD;&#xA;            GLES20.GL_LUMINANCE,&#xD;&#xA;            GLES20.GL_UNSIGNED_BYTE,&#xD;&#xA;            /* buffer V */);&#xD;&#xA;&#xD;&#xA;    GLES20.glDrawElements(GLES20.GL_TRIANGLES, 6, GLES20.GL_UNSIGNED_SHORT, indicesBuffer);&#xD;&#xA;&#xD;&#xA;What do I miss?&#xD;&#xA;&#xD;&#xA;**EDIT:** Frames are provided from two different decoders and all works find with an other render process.&#xD;&#xA;&#xD;&#xA;**EDIT2:** I displayed only the Y plane and the result is a grey frame (as expected) but there is no hatch lines!! &#xD;&#xA;&#xD;&#xA;[![enter image description here][2]][2]&#xD;&#xA;&#xD;&#xA;I just replaced these lines in my fragment shader to display it:&#xD;&#xA;&#xD;&#xA;    "" r = texture2D(yTexture, vTexCoord).r;\\n"" +&#xD;&#xA;    "" g = texture2D(yTexture, vTexCoord).g;\\n"" +&#xD;&#xA;    "" b = texture2D(yTexture, vTexCoord).b;\\n"" +&#xD;&#xA;&#xD;&#xA;So problem comes from U/V planes?&#xD;&#xA;&#xD;&#xA;  [1]: https://i.stack.imgur.com/nZn6M.jpg&#xD;&#xA;  [2]: https://i.stack.imgur.com/GyUiI.png";;deleted 53 characters in body
