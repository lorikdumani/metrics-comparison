Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
103369127;33523115;2761509;2;14e67156-9970-4e82-a19d-8830ef1a3259;2015-11-04 13:25:48.0;"My problem is that component's change listener is triggered BEFORE `shouldComponentUpdate` method. That mean `this.state === nextState`  always is true inside `shouldComponentUpdate` method.&#xD;&#xA;&#xD;&#xA;***`PureRenderMixin.js`***&#xD;&#xA;&#xD;&#xA;    const deepEqual = require('deep-equal');&#xD;&#xA;    &#xD;&#xA;    module.exports = function pureRenderMixin(Component) {&#xD;&#xA;        Component.prototype.shouldComponentUpdate = function(nextProps, nextState) {&#xD;&#xA;            return !deepEqual(this.props, nextProps) || !deepEqual(this.state, nextState);&#xD;&#xA;        };&#xD;&#xA;        return Component;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;***`MyComponent.js`***&#xD;&#xA;&#xD;&#xA;    class MyComponent extends React.Component {&#xD;&#xA;    &#xD;&#xA;        constructor(props) { &#xD;&#xA;            super(props);&#xD;&#xA;            this._onChange = this._onChange.bind(this);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        componentWillMount() {&#xD;&#xA;            MyStore.addChangeListener(this._onChange);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        //==========================&#xD;&#xA;        // PROBLEM: it's called before shouldComponentUpdate&#xD;&#xA;        //==========================&#xD;&#xA;        _onChange() {            &#xD;&#xA;            this.setState({stateObj: MyStore.getState()});&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    module.exports = PureRenderMixin(MyComponent);";;
103369642;33523115;2761509;5;3041fbe4-9562-4989-82c6-4b6259801254;2015-11-04 13:32:45.0;"`shouldComponentUpdate` method is called by `this.setState` inside `MyComponent`. The problem is that inside `shouldComponentUpdate` the state is already updated, means the next will always return true `deepEqual(this.state, nextState) === true`.&#xD;&#xA;&#xD;&#xA;***`PureRenderMixin.js`***&#xD;&#xA;&#xD;&#xA;    const deepEqual = require('deep-equal');&#xD;&#xA;    &#xD;&#xA;    module.exports = function pureRenderMixin(Component) {&#xD;&#xA;        Component.prototype.shouldComponentUpdate = function(nextProps, nextState) {&#xD;&#xA;            return !deepEqual(this.props, nextProps) || !deepEqual(this.state, nextState);&#xD;&#xA;        };&#xD;&#xA;        return Component;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;***`MyComponent.js`***&#xD;&#xA;&#xD;&#xA;    class MyComponent extends React.Component {&#xD;&#xA;    &#xD;&#xA;        constructor(props) { &#xD;&#xA;            super(props);&#xD;&#xA;            this._onChange = this._onChange.bind(this);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        componentWillMount() {&#xD;&#xA;            MyStore.addChangeListener(this._onChange);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        //==========================&#xD;&#xA;        // PROBLEM: it's called before shouldComponentUpdate&#xD;&#xA;        //==========================&#xD;&#xA;        _onChange() {            &#xD;&#xA;            this.setState({stateObj: MyStore.getState()});&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    module.exports = PureRenderMixin(MyComponent);";;"added 56 characters in body; edited title"
103370103;33523115;2761509;5;116326b0-eaf9-47aa-aa13-8bc0b8aa14e1;2015-11-04 13:38:52.0;"`shouldComponentUpdate` method is called by `this.setState` inside `MyComponent`. The problem is that inside `shouldComponentUpdate` the state is already updated, means the next will always return true `deepEqual(this.state, nextState) === true`.&#xD;&#xA;&#xD;&#xA;***`PureRenderMixin.js`***&#xD;&#xA;&#xD;&#xA;    const deepEqual = require('deep-equal');&#xD;&#xA;    &#xD;&#xA;    module.exports = function pureRenderMixin(Component) {&#xD;&#xA;        Component.prototype.shouldComponentUpdate = function(nextProps, nextState) {&#xD;&#xA;            return !deepEqual(this.props, nextProps) || !deepEqual(this.state, nextState);&#xD;&#xA;        };&#xD;&#xA;        return Component;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;***`MyComponent.js`***&#xD;&#xA;&#xD;&#xA;    class MyComponent extends React.Component {&#xD;&#xA;    &#xD;&#xA;        constructor(props) { &#xD;&#xA;            super(props);&#xD;&#xA;            this._onChange = this._onChange.bind(this);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        componentWillMount() {&#xD;&#xA;            MyStore.addChangeListener(this._onChange);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        //==========================&#xD;&#xA;        // PROBLEM: it's called before shouldComponentUpdate&#xD;&#xA;        //==========================&#xD;&#xA;        _onChange() {            &#xD;&#xA;            this.setState({array: MyStore.getState()});&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    module.exports = PureRenderMixin(MyComponent);&#xD;&#xA;&#xD;&#xA;UPDATE&#xD;&#xA;--------------------&#xD;&#xA;&#xD;&#xA;Looks like that happens because `MyComponent`'s state is an array, but my changes look like `array[index].flag = false/true`. That means `MyStore` & `MyComponent` has the same reference, and `_onChange` method isn't necessary there.&#xD;&#xA;&#xD;&#xA;*But, how to be with `PureRenderMixin`?*";;deleted 3 characters in body
103372163;33523115;2761509;5;e64705f4-2bd5-4b22-ad77-4f0a81f46395;2015-11-04 14:05:10.0;"**Problem:** `shouldComponentUpdate` retrieves previous state with `this.state`, that doesn't work if you keep reference to array at `MyComponent`, and update array entity at `MyStore`.&#xD;&#xA;&#xD;&#xA;***`PureRenderMixin.js`***&#xD;&#xA;&#xD;&#xA;    const deepEqual = require('deep-equal');&#xD;&#xA;    &#xD;&#xA;    module.exports = function pureRenderMixin(Component) {&#xD;&#xA;        Component.prototype.shouldComponentUpdate = function(nextProps, nextState) {&#xD;&#xA;            return !deepEqual(this.props, nextProps) || !deepEqual(this.state, nextState);&#xD;&#xA;        };&#xD;&#xA;        return Component;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;***`MyComponent.js`***&#xD;&#xA;&#xD;&#xA;    class MyComponent extends React.Component {&#xD;&#xA;    &#xD;&#xA;        constructor(props) { &#xD;&#xA;            super(props);&#xD;&#xA;            this._onChange = this._onChange.bind(this);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        componentWillMount() {&#xD;&#xA;            MyStore.addChangeListener(this._onChange);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        //==========================&#xD;&#xA;        // PROBLEM: it's called before shouldComponentUpdate&#xD;&#xA;        //==========================&#xD;&#xA;        _onChange() {            &#xD;&#xA;            this.setState({array: MyStore.getState()});&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    module.exports = PureRenderMixin(MyComponent);&#xD;&#xA;&#xD;&#xA;UPDATE&#xD;&#xA;--------------------&#xD;&#xA;&#xD;&#xA;Looks like that happens because `MyComponent`'s state is an array, but my changes look like `array[index].flag = false/true`. That means `MyStore` & `MyComponent` has the same reference, and `_onChange` method isn't necessary there.&#xD;&#xA;&#xD;&#xA;*But, how to be with `PureRenderMixin`?*";;edited tags
103372402;33523115;2761509;5;69e4b4d8-dce8-432b-aa6e-b02e2e767ec0;2015-11-04 14:08:01.0;"**Problem:** `shouldComponentUpdate` retrieves previous state with `this.state`, that doesn't work if you keep reference to array at `MyComponent`, and update array entity at `MyStore`.&#xD;&#xA;&#xD;&#xA;***`PureRenderMixin.js`***&#xD;&#xA;&#xD;&#xA;    const deepEqual = require('deep-equal');&#xD;&#xA;    &#xD;&#xA;    module.exports = function pureRenderMixin(Component) {&#xD;&#xA;        Component.prototype.shouldComponentUpdate = function(nextProps, nextState) {&#xD;&#xA;            return !deepEqual(this.props, nextProps) || !deepEqual(this.state, nextState);&#xD;&#xA;        };&#xD;&#xA;        return Component;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;***`MyComponent.js`***&#xD;&#xA;&#xD;&#xA;    class MyComponent extends React.Component {&#xD;&#xA;    &#xD;&#xA;        constructor(props) { &#xD;&#xA;            super(props);&#xD;&#xA;            this._onChange = this._onChange.bind(this);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        componentWillMount() {&#xD;&#xA;            MyStore.addChangeListener(this._onChange);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        _onChange() {            &#xD;&#xA;            this.setState({array: MyStore.getState()});&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    module.exports = PureRenderMixin(MyComponent);&#xD;&#xA;&#xD;&#xA;***`MyStore.js`***&#xD;&#xA;&#xD;&#xA;    ......&#xD;&#xA;    getState() { return _array; }&#xD;&#xA; &#xD;&#xA;    switch(action.type) {&#xD;&#xA;       case ActionTypes.UPDATE_USER_FLAG:&#xD;&#xA;           //!!!!!!!!!!!!!!&#xD;&#xA;           //PROBLEM: since MyComponent keep _array reference, there is no way to retrieve previous state inside shouldComponentUpdate&#xD;&#xA;           _array[action.index].flag = action.flag;&#xD;&#xA;           MyStore.emitChange();&#xD;&#xA;           break;&#xD;&#xA;    }&#xD;&#xA;";;edited tags
103373094;33523115;2761509;5;6ad07f41-fded-4659-8c85-7decbd816315;2015-11-04 14:16:22.0;"**Problem:** `shouldComponentUpdate` retrieves previous state with `this.state`, that doesn't work if you keep reference to array at `UserList`, and update array entity at `UserStore`.&#xD;&#xA;&#xD;&#xA;***`PureRenderMixin.js`***&#xD;&#xA;&#xD;&#xA;    const deepEqual = require('deep-equal');&#xD;&#xA;    &#xD;&#xA;    module.exports = function pureRenderMixin(Component) {&#xD;&#xA;        Component.prototype.shouldComponentUpdate = function(nextProps, nextState) {&#xD;&#xA;            return !deepEqual(this.props, nextProps) || !deepEqual(this.state, nextState);&#xD;&#xA;        };&#xD;&#xA;        return Component;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;***`UserList.react.js`***&#xD;&#xA;&#xD;&#xA;    class UserList extends React.Component {&#xD;&#xA;    &#xD;&#xA;        constructor(props) { &#xD;&#xA;            super(props);&#xD;&#xA;            this._onChange = this._onChange.bind(this);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        componentWillMount() {&#xD;&#xA;            UsersStore.addChangeListener(this._onChange);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        _onChange() {            &#xD;&#xA;            this.setState({userList: UsersStore.getState()});&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    module.exports = PureRenderMixin(UserList);&#xD;&#xA;&#xD;&#xA;***`UsersStore.js`***&#xD;&#xA;&#xD;&#xA;    ......&#xD;&#xA;    getState() { return _userList; }&#xD;&#xA; &#xD;&#xA;    switch(action.type) {&#xD;&#xA;       case ActionTypes.UPDATE_USER_FLAG:&#xD;&#xA;           //!!!!!!!!!!!!!!&#xD;&#xA;           //PROBLEM: since UserList.react keep userList reference, there is no way to retrieve previous state inside shouldComponentUpdate&#xD;&#xA;           _userList[action.index].flag = action.flag;&#xD;&#xA;           UsersStore.emitChange();&#xD;&#xA;           break;&#xD;&#xA;    }&#xD;&#xA;";;added 22 characters in body
103374268;33523115;2761509;5;134398a8-31c9-4379-a45c-16355b930b2e;2015-11-04 14:30:14.0;"**Problem:** `shouldComponentUpdate` retrieves previous state with `this.state`, that doesn't work if you keep reference to array at `UserList`, and update array entity at `UserStore`.&#xD;&#xA;&#xD;&#xA;***`PureRenderMixin.js`***&#xD;&#xA;&#xD;&#xA;    const deepEqual = require('deep-equal');&#xD;&#xA;    &#xD;&#xA;    module.exports = function pureRenderMixin(Component) {&#xD;&#xA;        Component.prototype.shouldComponentUpdate = function(nextProps, nextState) {&#xD;&#xA;            return !deepEqual(this.props, nextProps) || !deepEqual(this.state, nextState);&#xD;&#xA;        };&#xD;&#xA;        return Component;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;***`UserList.react.js`***&#xD;&#xA;&#xD;&#xA;    class UserList extends React.Component {&#xD;&#xA;    &#xD;&#xA;        constructor(props) { &#xD;&#xA;            super(props);&#xD;&#xA;            this._onChange = this._onChange.bind(this);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        componentWillMount() {&#xD;&#xA;            UsersStore.addChangeListener(this._onChange);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        _onChange() {            &#xD;&#xA;            this.setState({userList: UsersStore.getState()});&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    module.exports = PureRenderMixin(UserList);&#xD;&#xA;&#xD;&#xA;***`UsersStore.js`***&#xD;&#xA;&#xD;&#xA;    ......&#xD;&#xA;    getState() { return _userList; }&#xD;&#xA; &#xD;&#xA;    switch(action.type) {&#xD;&#xA;       case ActionTypes.UPDATE_USER_FLAG:&#xD;&#xA;           //!!!!!!!!!!!!!!&#xD;&#xA;           //PROBLEM: since UserList.react keep userList reference, there is no way to retrieve previous state inside shouldComponentUpdate&#xD;&#xA;           _userList[action.index].flag = action.flag;&#xD;&#xA;           UsersStore.emitChange();&#xD;&#xA;           break;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;@taggon solution&#xD;&#xA;---------------&#xD;&#xA;thanks to taggon, now I know how to make `shouldComponentUpdate` keep the reference to previous state:&#xD;&#xA;&#xD;&#xA;***`UsersStore.js`***&#xD;&#xA;&#xD;&#xA;    ......&#xD;&#xA;    getState() { return _userList; }&#xD;&#xA; &#xD;&#xA;    switch(action.type) {&#xD;&#xA;       case ActionTypes.UPDATE_USER_FLAG:&#xD;&#xA;           //SOLUTION: copy an array, so there will be two versions of _userList[action.index]&#xD;&#xA;           _userList =  _.map(_userList, _.clone);&#xD;&#xA; &#xD;&#xA;           _userList[action.index].flag = action.flag;&#xD;&#xA;           UsersStore.emitChange();&#xD;&#xA;           break;&#xD;&#xA;    }";;added 559 characters in body
