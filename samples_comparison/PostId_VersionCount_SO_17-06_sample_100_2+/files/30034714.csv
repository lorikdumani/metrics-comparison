Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
89670252;30034714;4862811;2;5fd682f5-1eb9-4238-9014-1aa4a227d24a;2015-05-04 16:09:53.0;"I'm trying to get panning behavior on a scrolledWindow in gtk3/gtk2hs similar to a map display like google maps (i was told it's called panning, but the tag description defines it as rotation)&#xD;&#xA;&#xD;&#xA;(Cursor in scrolledWindow, M1 down) => object in scrolledwindow ""follows"" mouse cursor&#xD;&#xA;&#xD;&#xA;The general idea is to record the cursor position on buttonPressEvent and, on motionNotifyEvent, use the offset to the current position to update the Adjustment of the viewport.&#xD;&#xA;&#xD;&#xA;Instead of following smoothly, i get flickering behavior that causes the image to jump back and forth and not follow at the correct ""speed"" (proportional offset). &#xD;&#xA;The code below includes my attempts at debugging. The prints show that the onMotionNotify part is executed with ""incorrect"" cursor positions.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    initViewportPanning :: (WidgetClass target, ViewportClass target) =>&#xD;&#xA;        target -> IO (ConnectId target)&#xD;&#xA;    initViewportPanning target = do&#xD;&#xA;        widgetAddEvents target [Button1MotionMask]&#xD;&#xA;        initialCursorPosition <-newIORef (0, 0)&#xD;&#xA;        initialAdjustment <-newIORef (0, 0)&#xD;&#xA;        on target buttonPressEvent $ do&#xD;&#xA;            newPos <- eventCoordinates&#xD;&#xA;            liftIO $ do &#xD;&#xA;                writeIORef initialCursorPosition newPos&#xD;&#xA;                hAdj <- viewportGetHAdjustment target&#xD;&#xA;                hVal <- adjustmentGetValue hAdj&#xD;&#xA;                vAdj <- viewportGetVAdjustment target&#xD;&#xA;                vVal <- adjustmentGetValue vAdj&#xD;&#xA;                writeIORef initialAdjustment (hVal, vVal)&#xD;&#xA;            liftIO $ putStrLn ""pressed""&#xD;&#xA;            return True&#xD;&#xA;        on target motionNotifyEvent $ do&#xD;&#xA;            (newH, newV) <- eventCoordinates&#xD;&#xA;            liftIO $ do&#xD;&#xA;                putStrLn (""motion at "" ++ show newH ++ "" , ""++ show newV)&#xD;&#xA;                hAdj <- viewportGetHAdjustment target&#xD;&#xA;                vAdj <- viewportGetVAdjustment target&#xD;&#xA;                (initAdjH, initAdjV) <- readIORef initialAdjustment&#xD;&#xA;                (initCH, initCV) <- readIORef initialCursorPosition&#xD;&#xA;&#xD;&#xA;                adjustmentSetValue hAdj (initAdjH - (newH - initCH) )&#xD;&#xA;                adjustmentSetValue vAdj (initAdjV - (newV - initCV) )&#xD;&#xA;                &#xD;&#xA;                adjustmentValueChanged hAdj&#xD;&#xA;                adjustmentValueChanged vAdj&#xD;&#xA;                return False&#xD;&#xA;&#xD;&#xA;where target is the viewport in a scrolledwindow and itself contains an overlay with an image:&#xD;&#xA;&#xD;&#xA; - scrolledWindow&#xD;&#xA; - viewport&#xD;&#xA; - overlay&#xD;&#xA; - image&#xD;&#xA;&#xD;&#xA;Typical output upon pressing and slowly dragging in one direction looks like this:&#xD;&#xA;&#xD;&#xA;    pressed&#xD;&#xA;    motion at 629.247802734375 , 581.4336242675781&#xD;&#xA;    motion at 629.247802734375 , 582.4336242675781    #&#xD;&#xA;    motion at 629.247802734375 , 580.4336242675781    # &#xD;&#xA;    motion at 628.247802734375 , 582.4336242675781    #&#xD;&#xA;    motion at 629.247802734375 , 579.4336242675781      &#xD;&#xA;    motion at 627.247802734375 , 582.4336242675781&#xD;&#xA;    motion at 629.247802734375 , 578.4336242675781      &#xD;&#xA;&#xD;&#xA;The marked lines are an example of what i refer to as ""jumps""&#xD;&#xA;It seems as if the event was handled twice, but that still does not explain why the widget movement is significantly slower than mouse movement.";;
89672882;30034714;4862811;5;69be3220-889c-4624-bdff-0c8e3deb7066;2015-05-04 16:47:47.0;"I'm trying to get panning behavior on a scrolledWindow in gtk3/gtk2hs similar to a map display like google maps (i was told it's called panning, but the tag description defines it as rotation)&#xD;&#xA;&#xD;&#xA;(Cursor in scrolledWindow, M1 down) => object in scrolledwindow ""follows"" mouse cursor&#xD;&#xA;&#xD;&#xA;The general idea is to record the cursor position on buttonPressEvent and, on motionNotifyEvent, use the offset to the current position to update the Adjustment of the viewport.&#xD;&#xA;&#xD;&#xA;Instead of following smoothly, i get flickering behavior that causes the image to jump back and forth and not follow at the correct ""speed"" (proportional offset). &#xD;&#xA;The code below includes my attempts at debugging. The prints show that the onMotionNotify part is executed with ""incorrect"" cursor positions.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    initViewportPanning :: (WidgetClass target, ViewportClass target) =>&#xD;&#xA;        target -> IO (ConnectId target)&#xD;&#xA;    initViewportPanning target = do&#xD;&#xA;        widgetAddEvents target [Button1MotionMask]&#xD;&#xA;        initialCursorPosition <-newIORef (0, 0)&#xD;&#xA;        initialAdjustment <-newIORef (0, 0)&#xD;&#xA;        on target buttonPressEvent $ do&#xD;&#xA;            newPos <- eventCoordinates&#xD;&#xA;            liftIO $ do &#xD;&#xA;                writeIORef initialCursorPosition newPos&#xD;&#xA;                hAdj <- viewportGetHAdjustment target&#xD;&#xA;                hVal <- adjustmentGetValue hAdj&#xD;&#xA;                vAdj <- viewportGetVAdjustment target&#xD;&#xA;                vVal <- adjustmentGetValue vAdj&#xD;&#xA;                writeIORef initialAdjustment (hVal, vVal)&#xD;&#xA;            liftIO $ putStrLn ""pressed""&#xD;&#xA;            return True&#xD;&#xA;        on target motionNotifyEvent $ do&#xD;&#xA;            (newH, newV) <- eventCoordinates&#xD;&#xA;            liftIO $ do&#xD;&#xA;                putStrLn (""motion at "" ++ show newH ++ "" , ""++ show newV)&#xD;&#xA;                hAdj <- viewportGetHAdjustment target&#xD;&#xA;                vAdj <- viewportGetVAdjustment target&#xD;&#xA;                (initAdjH, initAdjV) <- readIORef initialAdjustment&#xD;&#xA;                (initCH, initCV) <- readIORef initialCursorPosition&#xD;&#xA;&#xD;&#xA;                adjustmentSetValue hAdj (initAdjH - (newH - initCH) )&#xD;&#xA;                adjustmentSetValue vAdj (initAdjV - (newV - initCV) )&#xD;&#xA;                &#xD;&#xA;                adjustmentValueChanged hAdj&#xD;&#xA;                adjustmentValueChanged vAdj&#xD;&#xA;                return False&#xD;&#xA;&#xD;&#xA;where target is the viewport in a scrolledwindow and itself contains an overlay with an image:&#xD;&#xA;&#xD;&#xA; - scrolledWindow&#xD;&#xA; - viewport&#xD;&#xA; - overlay&#xD;&#xA; - image&#xD;&#xA;&#xD;&#xA;Typical output upon pressing and slowly dragging in one direction looks like this:&#xD;&#xA;&#xD;&#xA;    pressed&#xD;&#xA;    motion at 629.247802734375 , 581.4336242675781&#xD;&#xA;    motion at 629.247802734375 , 582.4336242675781    &#xD;&#xA;    motion at 629.247802734375 , 580.4336242675781    # &#xD;&#xA;    motion at 628.247802734375 , 582.4336242675781    #&#xD;&#xA;    motion at 629.247802734375 , 579.4336242675781    # &#xD;&#xA;    motion at 627.247802734375 , 582.4336242675781&#xD;&#xA;    motion at 629.247802734375 , 578.4336242675781      &#xD;&#xA;&#xD;&#xA;The marked lines are an example of what i refer to as ""jumps""&#xD;&#xA;It seems as if the event was handled twice, but that still does not explain why the widget movement is significantly slower than mouse movement.";;deleted 1 character in body
89687033;30034714;4862811;5;d54ac666-4435-465f-9aab-d434b9e20ad5;2015-05-04 20:15:21.0;"I'm trying to get panning behavior on a scrolledWindow in gtk3/gtk2hs similar to a map display like google maps (i was told it's called panning, but the tag description defines it as rotation)&#xD;&#xA;&#xD;&#xA;(Cursor in scrolledWindow, M1 down) => object in scrolledwindow ""follows"" mouse cursor&#xD;&#xA;&#xD;&#xA;The general idea is to record the cursor position on buttonPressEvent and, on motionNotifyEvent, use the offset to the current position to update the Adjustment of the viewport.&#xD;&#xA;&#xD;&#xA;Instead of following smoothly, i get flickering behavior that causes the image to jump back and forth and not follow at the correct ""speed"" (proportional offset). &#xD;&#xA;The code below includes my attempts at debugging. The prints show that the onMotionNotify part is executed with ""incorrect"" cursor positions.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    initViewportPanning :: (WidgetClass target, ViewportClass target) =>&#xD;&#xA;        target -> IO (ConnectId target)&#xD;&#xA;    initViewportPanning target = do&#xD;&#xA;        widgetAddEvents target [Button1MotionMask]&#xD;&#xA;        initialCursorPosition <-newIORef (0, 0)&#xD;&#xA;        initialAdjustment <-newIORef (0, 0)&#xD;&#xA;        on target buttonPressEvent $ do&#xD;&#xA;            newPos <- eventCoordinates&#xD;&#xA;            liftIO $ do &#xD;&#xA;                writeIORef initialCursorPosition newPos&#xD;&#xA;                hAdj <- viewportGetHAdjustment target&#xD;&#xA;                hVal <- adjustmentGetValue hAdj&#xD;&#xA;                vAdj <- viewportGetVAdjustment target&#xD;&#xA;                vVal <- adjustmentGetValue vAdj&#xD;&#xA;                writeIORef initialAdjustment (hVal, vVal)&#xD;&#xA;            liftIO $ putStrLn ""pressed""&#xD;&#xA;            return True&#xD;&#xA;        on target motionNotifyEvent $ do&#xD;&#xA;            (newH, newV) <- eventCoordinates&#xD;&#xA;            liftIO $ do&#xD;&#xA;                putStrLn (""motion at "" ++ show newH ++ "" , ""++ show newV)&#xD;&#xA;                hAdj <- viewportGetHAdjustment target&#xD;&#xA;                vAdj <- viewportGetVAdjustment target&#xD;&#xA;                (initAdjH, initAdjV) <- readIORef initialAdjustment&#xD;&#xA;                (initCH, initCV) <- readIORef initialCursorPosition&#xD;&#xA;&#xD;&#xA;                adjustmentSetValue hAdj (initAdjH - (newH - initCH) )&#xD;&#xA;                adjustmentSetValue vAdj (initAdjV - (newV - initCV) )&#xD;&#xA;                &#xD;&#xA;                adjustmentValueChanged hAdj&#xD;&#xA;                adjustmentValueChanged vAdj&#xD;&#xA;                return False&#xD;&#xA;&#xD;&#xA;where target is the viewport in a scrolledwindow and itself contains an overlay with an image:&#xD;&#xA;&#xD;&#xA; - scrolledWindow&#xD;&#xA; - viewport&#xD;&#xA; - overlay&#xD;&#xA; - image&#xD;&#xA;&#xD;&#xA;Typical output upon pressing and slowly dragging in one direction looks like this:&#xD;&#xA;&#xD;&#xA;    pressed&#xD;&#xA;    motion at 629.247802734375 , 581.4336242675781&#xD;&#xA;    motion at 629.247802734375 , 582.4336242675781    &#xD;&#xA;    motion at 629.247802734375 , 580.4336242675781    # &#xD;&#xA;    motion at 628.247802734375 , 582.4336242675781    #&#xD;&#xA;    motion at 629.247802734375 , 579.4336242675781    # &#xD;&#xA;    motion at 627.247802734375 , 582.4336242675781&#xD;&#xA;    motion at 629.247802734375 , 578.4336242675781      &#xD;&#xA;&#xD;&#xA;The marked lines are an example of what i refer to as ""jumps""&#xD;&#xA;It seems as if the event was handled twice, but that still does not explain why the widget movement is significantly slower than mouse movement.&#xD;&#xA;&#xD;&#xA;edit: i don't know how to paste this here without getting errors...&#xD;&#xA;http://pastebin.com/QKbPuNKe &#xD;&#xA;these 3 files + a large image called ""redCat.jpg"" should work in a cabal sandbox using:&#xD;&#xA;&#xD;&#xA;cabal sandbox init&#xD;&#xA;cabal install --dependencies-only&#xD;&#xA;cabal run";;added 259 characters in body
89687534;30034714;4862811;5;9a990ff8-7ff3-458d-ad96-e37e9dcf1615;2015-05-04 20:23:51.0;"I'm trying to get panning behavior on a scrolledWindow in gtk3/gtk2hs similar to a map display like google maps (i was told it's called panning, but the tag description defines it as rotation)&#xD;&#xA;&#xD;&#xA;(Cursor in scrolledWindow, M1 down) => object in scrolledwindow ""follows"" mouse cursor&#xD;&#xA;&#xD;&#xA;The general idea is to record the cursor position on buttonPressEvent and, on motionNotifyEvent, use the offset to the current position to update the Adjustment of the viewport.&#xD;&#xA;&#xD;&#xA;Instead of following smoothly, i get flickering behavior that causes the image to jump back and forth and not follow at the correct ""speed"" (proportional offset). &#xD;&#xA;The code below includes my attempts at debugging. The prints show that the onMotionNotify part is executed with ""incorrect"" cursor positions.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    initViewportPanning :: (WidgetClass target, ViewportClass target) =>&#xD;&#xA;        target -> IO (ConnectId target)&#xD;&#xA;    initViewportPanning target = do&#xD;&#xA;        widgetAddEvents target [Button1MotionMask]&#xD;&#xA;        initialCursorPosition <-newIORef (0, 0)&#xD;&#xA;        initialAdjustment <-newIORef (0, 0)&#xD;&#xA;        on target buttonPressEvent $ do&#xD;&#xA;            newPos <- eventCoordinates&#xD;&#xA;            liftIO $ do &#xD;&#xA;                writeIORef initialCursorPosition newPos&#xD;&#xA;                hAdj <- viewportGetHAdjustment target&#xD;&#xA;                hVal <- adjustmentGetValue hAdj&#xD;&#xA;                vAdj <- viewportGetVAdjustment target&#xD;&#xA;                vVal <- adjustmentGetValue vAdj&#xD;&#xA;                writeIORef initialAdjustment (hVal, vVal)&#xD;&#xA;            liftIO $ putStrLn ""pressed""&#xD;&#xA;            return True&#xD;&#xA;        on target motionNotifyEvent $ do&#xD;&#xA;            (newH, newV) <- eventCoordinates&#xD;&#xA;            liftIO $ do&#xD;&#xA;                putStrLn (""motion at "" ++ show newH ++ "" , ""++ show newV)&#xD;&#xA;                hAdj <- viewportGetHAdjustment target&#xD;&#xA;                vAdj <- viewportGetVAdjustment target&#xD;&#xA;                (initAdjH, initAdjV) <- readIORef initialAdjustment&#xD;&#xA;                (initCH, initCV) <- readIORef initialCursorPosition&#xD;&#xA;&#xD;&#xA;                adjustmentSetValue hAdj (initAdjH - (newH - initCH) )&#xD;&#xA;                adjustmentSetValue vAdj (initAdjV - (newV - initCV) )&#xD;&#xA;                &#xD;&#xA;                adjustmentValueChanged hAdj&#xD;&#xA;                adjustmentValueChanged vAdj&#xD;&#xA;                return False&#xD;&#xA;&#xD;&#xA;where target is the viewport in a scrolledwindow and itself contains an overlay with an image:&#xD;&#xA;&#xD;&#xA; - scrolledWindow&#xD;&#xA; - viewport&#xD;&#xA; - overlay&#xD;&#xA; - image&#xD;&#xA;&#xD;&#xA;Typical output upon pressing and slowly dragging in one direction looks like this:&#xD;&#xA;&#xD;&#xA;    pressed&#xD;&#xA;    motion at 629.247802734375 , 581.4336242675781&#xD;&#xA;    motion at 629.247802734375 , 582.4336242675781    &#xD;&#xA;    motion at 629.247802734375 , 580.4336242675781    # &#xD;&#xA;    motion at 628.247802734375 , 582.4336242675781    #&#xD;&#xA;    motion at 629.247802734375 , 579.4336242675781    # &#xD;&#xA;    motion at 627.247802734375 , 582.4336242675781&#xD;&#xA;    motion at 629.247802734375 , 578.4336242675781      &#xD;&#xA;&#xD;&#xA;The marked lines are an example of what i refer to as ""jumps""&#xD;&#xA;It seems as if the event was handled twice, but that still does not explain why the widget movement is significantly slower than mouse movement.&#xD;&#xA;&#xD;&#xA;**Edit**: i don't know how to paste this here without getting horrible formatting/errors...&#xD;&#xA;&#xD;&#xA;XML:&#xD;&#xA;&#xD;&#xA;http://pastebin.com/pmCS1HDr&#xD;&#xA;&#xD;&#xA;Code/cabal&#xD;&#xA;&#xD;&#xA;http://pastebin.com/QKbPuNKe &#xD;&#xA;these 3 files + a large image called ""redCat.jpg"" should work in a cabal sandbox using:&#xD;&#xA;&#xD;&#xA;cabal sandbox init&#xD;&#xA;&#xD;&#xA;cabal install --dependencies-only&#xD;&#xA;&#xD;&#xA;cabal run&#xD;&#xA;";;added 56 characters in body
89699038;30034714;4862811;5;cb4d4d18-5a3f-4a53-9a00-b3bb88aa9a1b;2015-05-05 00:18:48.0;"I'm trying to get panning behavior on a scrolledWindow in gtk3/gtk2hs similar to a map display like google maps (i was told it's called panning, but the tag description defines it as rotation)&#xD;&#xA;&#xD;&#xA;(Cursor in scrolledWindow, M1 down) => object in scrolledwindow ""follows"" mouse cursor&#xD;&#xA;&#xD;&#xA;The general idea is to record the cursor position on buttonPressEvent and, on motionNotifyEvent, use the offset to the current position to update the Adjustment of the viewport.&#xD;&#xA;&#xD;&#xA;Instead of following smoothly, i get flickering behavior that causes the image to jump back and forth and not follow at the correct ""speed"" (proportional offset). &#xD;&#xA;The code below includes my attempts at debugging. The prints show that the onMotionNotify part is executed with ""incorrect"" cursor positions.&#xD;&#xA;&#xD;&#xA;    module WidgetBehavior where&#xD;&#xA; &#xD;&#xA;    import Control.Monad&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk.Buttons.Button&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk.General.Enums&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk.Gdk.EventM&#xD;&#xA;    import Network.CGI(liftIO, MonadIO)&#xD;&#xA;    import Control.Monad.State.Class&#xD;&#xA;    import Control.Monad.Trans.Reader&#xD;&#xA;    import Data.IORef&#xD;&#xA;    import Control.Applicative&#xD;&#xA;    import Control.Monad.Trans.Class&#xD;&#xA;    initViewportPanning :: (WidgetClass target, ViewportClass target) =>&#xD;&#xA;        target -> IO (ConnectId target)&#xD;&#xA;    initViewportPanning target = do&#xD;&#xA;        widgetAddEvents target [Button1MotionMask]&#xD;&#xA;        initialCursorPosition <-newIORef (0, 0)&#xD;&#xA;        initialAdjustment <-newIORef (0, 0)&#xD;&#xA;        on target buttonPressEvent $ do&#xD;&#xA;            newPos <- eventCoordinates&#xD;&#xA;            liftIO $ do &#xD;&#xA;                writeIORef initialCursorPosition newPos&#xD;&#xA;                hAdj <- viewportGetHAdjustment target&#xD;&#xA;                hVal <- adjustmentGetValue hAdj&#xD;&#xA;                vAdj <- viewportGetVAdjustment target&#xD;&#xA;                vVal <- adjustmentGetValue vAdj&#xD;&#xA;                writeIORef initialAdjustment (hVal, vVal)&#xD;&#xA;            liftIO $ putStrLn ""pressed""&#xD;&#xA;            return True&#xD;&#xA;        on target motionNotifyEvent $ do&#xD;&#xA;            (newH, newV) <- eventCoordinates&#xD;&#xA;            liftIO $ do&#xD;&#xA;                putStrLn (""motion at "" ++ show newH ++ "" , ""++ show newV)&#xD;&#xA;                hAdj <- viewportGetHAdjustment target&#xD;&#xA;                vAdj <- viewportGetVAdjustment target&#xD;&#xA;                (initAdjH, initAdjV) <- readIORef initialAdjustment&#xD;&#xA;                (initCH, initCV) <- readIORef initialCursorPosition&#xD;&#xA;&#xD;&#xA;                adjustmentSetValue hAdj (initAdjH - (newH - initCH) )&#xD;&#xA;                adjustmentSetValue vAdj (initAdjV - (newV - initCV) )&#xD;&#xA;                &#xD;&#xA;                adjustmentValueChanged hAdj&#xD;&#xA;                adjustmentValueChanged vAdj&#xD;&#xA;                return False&#xD;&#xA;&#xD;&#xA;where target is the viewport in a scrolledwindow and itself contains an overlay with an image:&#xD;&#xA;&#xD;&#xA; - scrolledWindow&#xD;&#xA; - viewport&#xD;&#xA; - overlay&#xD;&#xA; - image&#xD;&#xA;&#xD;&#xA;Typical output upon pressing and slowly dragging in one direction looks like this:&#xD;&#xA;&#xD;&#xA;    pressed&#xD;&#xA;    motion at 629.247802734375 , 581.4336242675781&#xD;&#xA;    motion at 629.247802734375 , 582.4336242675781    &#xD;&#xA;    motion at 629.247802734375 , 580.4336242675781    # &#xD;&#xA;    motion at 628.247802734375 , 582.4336242675781    #&#xD;&#xA;    motion at 629.247802734375 , 579.4336242675781    # &#xD;&#xA;    motion at 627.247802734375 , 582.4336242675781&#xD;&#xA;    motion at 629.247802734375 , 578.4336242675781      &#xD;&#xA;&#xD;&#xA;The marked lines are an example of what i refer to as ""jumps""&#xD;&#xA;It seems as if the event was handled twice, but that still does not explain why the widget movement is significantly slower than mouse movement.&#xD;&#xA;&#xD;&#xA;**Edit**: Don't know how to post XML&#xD;&#xA;&#xD;&#xA;XML: ""main.ui""&#xD;&#xA;&#xD;&#xA;http://pastebin.com/pmCS1HDr&#xD;&#xA;&#xD;&#xA;Code/cabal&#xD;&#xA;&#xD;&#xA;    -- Initial panningMinimal.cabal generated by cabal init.  For further&#xD;&#xA;    -- documentation, see http://haskell.org/cabal/users-guide/&#xD;&#xA; &#xD;&#xA;    name:                panningMinimal&#xD;&#xA;    version:             0.1.0.0&#xD;&#xA;    -- synopsis:            &#xD;&#xA;    -- description:        &#xD;&#xA;    -- license:            &#xD;&#xA;    license-file:        LICENSE&#xD;&#xA;    author:              .&#xD;&#xA;    maintainer:          .&#xD;&#xA;    -- copyright:          &#xD;&#xA;    -- category:            &#xD;&#xA;    build-type:          Simple&#xD;&#xA;    -- extra-source-files:  &#xD;&#xA;    cabal-version:       >=1.10&#xD;&#xA; &#xD;&#xA;    executable panningMinimal&#xD;&#xA;      main-is:             Main.hs&#xD;&#xA;      -- other-modules:      &#xD;&#xA;      other-extensions:    PackageImports, MultiParamTypeClasses, GeneralizedNewtypeDeriving, FlexibleInstances&#xD;&#xA;      build-depends:       base >=4.6 && <4.7, gtk3, cgi >= 3001.2.2.0, cairo      >= 0.13.0.2, transformers >= 0.4.2.0, mtl >= 2.2.1&#xD;&#xA;      -- hs-source-dirs:      &#xD;&#xA;      default-language:    Haskell2010&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Main.hs&#xD;&#xA; &#xD;&#xA;    {-# LANGUAGE PackageImports #-}&#xD;&#xA;    module Main where&#xD;&#xA; &#xD;&#xA;    import Control.Monad&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk.Buttons.Button&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk.General.Enums&#xD;&#xA;    import Network.CGI(liftIO)&#xD;&#xA;    import WidgetBehavior&#xD;&#xA; &#xD;&#xA;    main = do&#xD;&#xA;        initGUI&#xD;&#xA; &#xD;&#xA;        builder <- builderNew&#xD;&#xA;        builderAddFromFile builder ""main.ui""&#xD;&#xA; &#xD;&#xA;        window <- builderGetObject builder castToWindow ""mainWindow""&#xD;&#xA; &#xD;&#xA;        overlay <- builderGetObject builder castToOverlay ""overlay""&#xD;&#xA;        viewport <- builderGetObject builder castToViewport ""viewport""&#xD;&#xA;        scrolledWindow <- builderGetObject builder castToScrolledWindow ""scrolledWindow""&#xD;&#xA; &#xD;&#xA;        initViewportPanning viewport&#xD;&#xA;        image <- imageNewFromFile ""redCat.jpg""&#xD;&#xA; &#xD;&#xA;        containerAdd overlay image&#xD;&#xA;        set overlay [widgetOpacity := 0.9]&#xD;&#xA; &#xD;&#xA;        window `on` deleteEvent $ liftIO mainQuit >> return False&#xD;&#xA; &#xD;&#xA;        -- Display the window&#xD;&#xA;        widgetShowAll window&#xD;&#xA;        mainGUI&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;http://pastebin.com/QKbPuNKe &#xD;&#xA;these 3 files + a large image called ""redCat.jpg"" should work in a cabal sandbox using:&#xD;&#xA;&#xD;&#xA;cabal sandbox init&#xD;&#xA;&#xD;&#xA;cabal install --dependencies-only&#xD;&#xA;&#xD;&#xA;cabal run";;added code to get a demo to the actual post
89707363;30034714;4862811;5;e6e7c154-1b81-4525-a6bd-c810140ef451;2015-05-05 04:26:47.0;"I'm trying to get panning behavior on a scrolledWindow in gtk3/gtk2hs similar to a map display like google maps (i was told it's called panning, but the tag description defines it as rotation)&#xD;&#xA;&#xD;&#xA;(Cursor in scrolledWindow, M1 down) => object in scrolledwindow ""follows"" mouse cursor&#xD;&#xA;&#xD;&#xA;The general idea is to record the cursor position on buttonPressEvent and, on motionNotifyEvent, use the offset to the current position to update the Adjustment of the viewport.&#xD;&#xA;&#xD;&#xA;Instead of following smoothly, i get flickering behavior that causes the image to jump back and forth and not follow at the correct ""speed"" (proportional offset). &#xD;&#xA;The code below includes my attempts at debugging. The prints show that the onMotionNotify part is executed with ""incorrect"" cursor positions.&#xD;&#xA;&#xD;&#xA;    module WidgetBehavior where&#xD;&#xA; &#xD;&#xA;    import Control.Monad&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk.Buttons.Button&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk.General.Enums&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk.Gdk.EventM&#xD;&#xA;    import Network.CGI(liftIO, MonadIO)&#xD;&#xA;    import Control.Monad.State.Class&#xD;&#xA;    import Control.Monad.Trans.Reader&#xD;&#xA;    import Data.IORef&#xD;&#xA;    import Control.Applicative&#xD;&#xA;    import Control.Monad.Trans.Class&#xD;&#xA;    initViewportPanning :: (WidgetClass target, ViewportClass target) =>&#xD;&#xA;        target -> IO (ConnectId target)&#xD;&#xA;    initViewportPanning target = do&#xD;&#xA;        widgetAddEvents target [Button1MotionMask]&#xD;&#xA;        initialCursorPosition <-newIORef (0, 0)&#xD;&#xA;        initialAdjustment <-newIORef (0, 0)&#xD;&#xA;        on target buttonPressEvent $ do&#xD;&#xA;            newPos <- eventCoordinates&#xD;&#xA;            liftIO $ do &#xD;&#xA;                writeIORef initialCursorPosition newPos&#xD;&#xA;                hAdj <- viewportGetHAdjustment target&#xD;&#xA;                hVal <- adjustmentGetValue hAdj&#xD;&#xA;                vAdj <- viewportGetVAdjustment target&#xD;&#xA;                vVal <- adjustmentGetValue vAdj&#xD;&#xA;                writeIORef initialAdjustment (hVal, vVal)&#xD;&#xA;            liftIO $ putStrLn ""pressed""&#xD;&#xA;            return True&#xD;&#xA;        on target motionNotifyEvent $ do&#xD;&#xA;            (newH, newV) <- eventCoordinates&#xD;&#xA;            liftIO $ do&#xD;&#xA;                putStrLn (""motion at "" ++ show newH ++ "" , ""++ show newV)&#xD;&#xA;                hAdj <- viewportGetHAdjustment target&#xD;&#xA;                vAdj <- viewportGetVAdjustment target&#xD;&#xA;                (initAdjH, initAdjV) <- readIORef initialAdjustment&#xD;&#xA;                (initCH, initCV) <- readIORef initialCursorPosition&#xD;&#xA;&#xD;&#xA;                adjustmentSetValue hAdj (initAdjH - (newH - initCH) )&#xD;&#xA;                adjustmentSetValue vAdj (initAdjV - (newV - initCV) )&#xD;&#xA;                &#xD;&#xA;                adjustmentValueChanged hAdj&#xD;&#xA;                adjustmentValueChanged vAdj&#xD;&#xA;                return False&#xD;&#xA;&#xD;&#xA;where target is the viewport in a scrolledwindow and itself contains an overlay with an image:&#xD;&#xA;&#xD;&#xA; - scrolledWindow&#xD;&#xA; - viewport&#xD;&#xA; - overlay&#xD;&#xA; - image&#xD;&#xA;&#xD;&#xA;Typical output upon pressing and slowly dragging in one direction looks like this:&#xD;&#xA;&#xD;&#xA;    pressed&#xD;&#xA;    motion at 629.247802734375 , 581.4336242675781&#xD;&#xA;    motion at 629.247802734375 , 582.4336242675781    &#xD;&#xA;    motion at 629.247802734375 , 580.4336242675781    # &#xD;&#xA;    motion at 628.247802734375 , 582.4336242675781    #&#xD;&#xA;    motion at 629.247802734375 , 579.4336242675781    # &#xD;&#xA;    motion at 627.247802734375 , 582.4336242675781&#xD;&#xA;    motion at 629.247802734375 , 578.4336242675781      &#xD;&#xA;&#xD;&#xA;The marked lines are an example of what i refer to as ""jumps""&#xD;&#xA;It seems as if the event was handled twice, but that still does not explain why the widget movement is significantly slower than mouse movement.&#xD;&#xA;&#xD;&#xA;**Edit**:&#xD;&#xA;&#xD;&#xA;XML: ""main.ui""&#xD;&#xA;&#xD;&#xA;    <?xml version=""1.0"" encoding=""UTF-8""?>&#xD;&#xA;    <!-- Generated with glade 3.16.1 -->&#xD;&#xA;    <interface>&#xD;&#xA;      <requires lib=""gtk+"" version=""3.10""/>&#xD;&#xA;      <object class=""GtkApplicationWindow"" id=""mainWindow"">&#xD;&#xA;        <property name=""width_request"">600</property>&#xD;&#xA;        <property name=""height_request"">400</property>&#xD;&#xA;        <property name=""can_focus"">False</property>&#xD;&#xA;        <property name=""window_position"">center-on-parent</property>&#xD;&#xA;        <child>&#xD;&#xA;          <object class=""GtkScrolledWindow"" id=""scrolledWindow"">&#xD;&#xA;            <property name=""visible"">True</property>&#xD;&#xA;            <property name=""can_focus"">True</property>&#xD;&#xA;            <property name=""shadow_type"">in</property>&#xD;&#xA;            <child>&#xD;&#xA;              <object class=""GtkViewport"" id=""viewport"">&#xD;&#xA;                <property name=""visible"">True</property>&#xD;&#xA;                <property name=""can_focus"">False</property>&#xD;&#xA;                <child>&#xD;&#xA;                  <object class=""GtkOverlay"" id=""overlay"">&#xD;&#xA;                    <property name=""visible"">True</property>&#xD;&#xA;                    <property name=""sensitive"">False</property>&#xD;&#xA;                    <property name=""can_focus"">False</property>&#xD;&#xA;                    <property name=""hexpand"">True</property>&#xD;&#xA;                    <property name=""vexpand"">True</property>&#xD;&#xA;                    <child>&#xD;&#xA;                      <placeholder/>&#xD;&#xA;                    </child>&#xD;&#xA;                  </object>&#xD;&#xA;                </child>&#xD;&#xA;              </object>&#xD;&#xA;            </child>&#xD;&#xA;          </object>&#xD;&#xA;        </child>&#xD;&#xA;      </object>&#xD;&#xA;      <object class=""GtkSizeGroup"" id=""sizegroup1"">&#xD;&#xA;        <property name=""mode"">both</property>&#xD;&#xA;        <widgets>&#xD;&#xA;          <widget name=""mainWindow""/>&#xD;&#xA;        </widgets>&#xD;&#xA;      </object>&#xD;&#xA;    </interface>&#xD;&#xA;&#xD;&#xA;http://pastebin.com/pmCS1HDr&#xD;&#xA;&#xD;&#xA;.cabal&#xD;&#xA;&#xD;&#xA;    -- Initial panningMinimal.cabal generated by cabal init.  For further&#xD;&#xA;    -- documentation, see http://haskell.org/cabal/users-guide/&#xD;&#xA; &#xD;&#xA;    name:                panningMinimal&#xD;&#xA;    version:             0.1.0.0&#xD;&#xA;    -- synopsis:            &#xD;&#xA;    -- description:        &#xD;&#xA;    -- license:            &#xD;&#xA;    license-file:        LICENSE&#xD;&#xA;    author:              .&#xD;&#xA;    maintainer:          .&#xD;&#xA;    -- copyright:          &#xD;&#xA;    -- category:            &#xD;&#xA;    build-type:          Simple&#xD;&#xA;    -- extra-source-files:  &#xD;&#xA;    cabal-version:       >=1.10&#xD;&#xA; &#xD;&#xA;    executable panningMinimal&#xD;&#xA;      main-is:             Main.hs&#xD;&#xA;      -- other-modules:      &#xD;&#xA;      other-extensions:    PackageImports, MultiParamTypeClasses, GeneralizedNewtypeDeriving, FlexibleInstances&#xD;&#xA;      build-depends:       base >=4.6 && <4.7, gtk3, cgi >= 3001.2.2.0, cairo      >= 0.13.0.2, transformers >= 0.4.2.0, mtl >= 2.2.1&#xD;&#xA;      -- hs-source-dirs:      &#xD;&#xA;      default-language:    Haskell2010&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Main.hs&#xD;&#xA; &#xD;&#xA;    {-# LANGUAGE PackageImports #-}&#xD;&#xA;    module Main where&#xD;&#xA; &#xD;&#xA;    import Control.Monad&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk.Buttons.Button&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk.General.Enums&#xD;&#xA;    import Network.CGI(liftIO)&#xD;&#xA;    import WidgetBehavior&#xD;&#xA; &#xD;&#xA;    main = do&#xD;&#xA;        initGUI&#xD;&#xA; &#xD;&#xA;        builder <- builderNew&#xD;&#xA;        builderAddFromFile builder ""main.ui""&#xD;&#xA; &#xD;&#xA;        window <- builderGetObject builder castToWindow ""mainWindow""&#xD;&#xA; &#xD;&#xA;        overlay <- builderGetObject builder castToOverlay ""overlay""&#xD;&#xA;        viewport <- builderGetObject builder castToViewport ""viewport""&#xD;&#xA;        scrolledWindow <- builderGetObject builder castToScrolledWindow ""scrolledWindow""&#xD;&#xA; &#xD;&#xA;        initViewportPanning viewport&#xD;&#xA;        image <- imageNewFromFile ""redCat.jpg""&#xD;&#xA; &#xD;&#xA;        containerAdd overlay image&#xD;&#xA;        set overlay [widgetOpacity := 0.9]&#xD;&#xA; &#xD;&#xA;        window `on` deleteEvent $ liftIO mainQuit >> return False&#xD;&#xA; &#xD;&#xA;        -- Display the window&#xD;&#xA;        widgetShowAll window&#xD;&#xA;        mainGUI&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;http://pastebin.com/QKbPuNKe &#xD;&#xA;these 3 files + a large image called ""redCat.jpg"" should work in a cabal sandbox using:&#xD;&#xA;&#xD;&#xA;cabal sandbox init&#xD;&#xA;&#xD;&#xA;cabal install --dependencies-only&#xD;&#xA;&#xD;&#xA;cabal run";;added XML
89750216;30034714;4862811;5;ce94ecc8-0699-4b14-8c1f-179723568cf1;2015-05-05 14:20:23.0;"I'm trying to get panning behavior on a scrolledWindow in gtk3/gtk2hs similar to a map display like google maps (i was told it's called panning, but the tag description defines it as rotation)&#xD;&#xA;&#xD;&#xA;(Cursor in scrolledWindow, M1 down) => object in scrolledwindow ""follows"" mouse cursor&#xD;&#xA;&#xD;&#xA;The general idea is to record the cursor position on buttonPressEvent and, on motionNotifyEvent, use the offset to the current position to update the Adjustment of the viewport.&#xD;&#xA;&#xD;&#xA;Instead of following smoothly, i get flickering behavior that causes the image to jump back and forth and not follow at the correct ""speed"" (proportional offset). &#xD;&#xA;The code below includes my attempts at debugging. The prints show that the onMotionNotify part is executed with ""incorrect"" cursor positions.&#xD;&#xA;&#xD;&#xA;    module WidgetBehavior where&#xD;&#xA; &#xD;&#xA;    import Control.Monad&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk.Buttons.Button&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk.General.Enums&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk.Gdk.EventM&#xD;&#xA;    import Control.Monad.IO.Class(liftIO, MonadIO)&#xD;&#xA;    import Control.Monad.State.Class&#xD;&#xA;    import Control.Monad.Trans.Reader&#xD;&#xA;    import Data.IORef&#xD;&#xA;    import Control.Applicative&#xD;&#xA;    import Control.Monad.Trans.Class&#xD;&#xA;    initViewportPanning :: (WidgetClass target, ViewportClass target) =>&#xD;&#xA;        target -> IO (ConnectId target)&#xD;&#xA;    initViewportPanning target = do&#xD;&#xA;        widgetAddEvents target [Button1MotionMask]&#xD;&#xA;        initialCursorPosition <-newIORef (0, 0)&#xD;&#xA;        initialAdjustment <-newIORef (0, 0)&#xD;&#xA;        on target buttonPressEvent $ do&#xD;&#xA;            newPos <- eventCoordinates&#xD;&#xA;            liftIO $ do &#xD;&#xA;                writeIORef initialCursorPosition newPos&#xD;&#xA;                hAdj <- viewportGetHAdjustment target&#xD;&#xA;                hVal <- adjustmentGetValue hAdj&#xD;&#xA;                vAdj <- viewportGetVAdjustment target&#xD;&#xA;                vVal <- adjustmentGetValue vAdj&#xD;&#xA;                writeIORef initialAdjustment (hVal, vVal)&#xD;&#xA;            liftIO $ putStrLn ""pressed""&#xD;&#xA;            return True&#xD;&#xA;        on target motionNotifyEvent $ do&#xD;&#xA;            (newH, newV) <- eventCoordinates&#xD;&#xA;            liftIO $ do&#xD;&#xA;                putStrLn (""motion at "" ++ show newH ++ "" , ""++ show newV)&#xD;&#xA;                hAdj <- viewportGetHAdjustment target&#xD;&#xA;                vAdj <- viewportGetVAdjustment target&#xD;&#xA;                (initAdjH, initAdjV) <- readIORef initialAdjustment&#xD;&#xA;                (initCH, initCV) <- readIORef initialCursorPosition&#xD;&#xA;&#xD;&#xA;                adjustmentSetValue hAdj (initAdjH - (newH - initCH) )&#xD;&#xA;                adjustmentSetValue vAdj (initAdjV - (newV - initCV) )&#xD;&#xA;                &#xD;&#xA;                adjustmentValueChanged hAdj&#xD;&#xA;                adjustmentValueChanged vAdj&#xD;&#xA;                return False&#xD;&#xA;&#xD;&#xA;where target is the viewport in a scrolledwindow and itself contains an overlay with an image:&#xD;&#xA;&#xD;&#xA; - scrolledWindow&#xD;&#xA; - viewport&#xD;&#xA; - overlay&#xD;&#xA; - image&#xD;&#xA;&#xD;&#xA;Typical output upon pressing and slowly dragging in one direction looks like this:&#xD;&#xA;&#xD;&#xA;    pressed&#xD;&#xA;    motion at 629.247802734375 , 581.4336242675781&#xD;&#xA;    motion at 629.247802734375 , 582.4336242675781    &#xD;&#xA;    motion at 629.247802734375 , 580.4336242675781    # &#xD;&#xA;    motion at 628.247802734375 , 582.4336242675781    #&#xD;&#xA;    motion at 629.247802734375 , 579.4336242675781    # &#xD;&#xA;    motion at 627.247802734375 , 582.4336242675781&#xD;&#xA;    motion at 629.247802734375 , 578.4336242675781      &#xD;&#xA;&#xD;&#xA;The marked lines are an example of what i refer to as ""jumps""&#xD;&#xA;It seems as if the event was handled twice, but that still does not explain why the widget movement is significantly slower than mouse movement.&#xD;&#xA;&#xD;&#xA;**Edit**:&#xD;&#xA;&#xD;&#xA;XML: ""main.ui""&#xD;&#xA;&#xD;&#xA;    <?xml version=""1.0"" encoding=""UTF-8""?>&#xD;&#xA;    <!-- Generated with glade 3.16.1 -->&#xD;&#xA;    <interface>&#xD;&#xA;      <requires lib=""gtk+"" version=""3.10""/>&#xD;&#xA;      <object class=""GtkApplicationWindow"" id=""mainWindow"">&#xD;&#xA;        <property name=""width_request"">600</property>&#xD;&#xA;        <property name=""height_request"">400</property>&#xD;&#xA;        <property name=""can_focus"">False</property>&#xD;&#xA;        <property name=""window_position"">center-on-parent</property>&#xD;&#xA;        <child>&#xD;&#xA;          <object class=""GtkScrolledWindow"" id=""scrolledWindow"">&#xD;&#xA;            <property name=""visible"">True</property>&#xD;&#xA;            <property name=""can_focus"">True</property>&#xD;&#xA;            <property name=""shadow_type"">in</property>&#xD;&#xA;            <child>&#xD;&#xA;              <object class=""GtkViewport"" id=""viewport"">&#xD;&#xA;                <property name=""visible"">True</property>&#xD;&#xA;                <property name=""can_focus"">False</property>&#xD;&#xA;                <child>&#xD;&#xA;                  <object class=""GtkOverlay"" id=""overlay"">&#xD;&#xA;                    <property name=""visible"">True</property>&#xD;&#xA;                    <property name=""sensitive"">False</property>&#xD;&#xA;                    <property name=""can_focus"">False</property>&#xD;&#xA;                    <property name=""hexpand"">True</property>&#xD;&#xA;                    <property name=""vexpand"">True</property>&#xD;&#xA;                    <child>&#xD;&#xA;                      <placeholder/>&#xD;&#xA;                    </child>&#xD;&#xA;                  </object>&#xD;&#xA;                </child>&#xD;&#xA;              </object>&#xD;&#xA;            </child>&#xD;&#xA;          </object>&#xD;&#xA;        </child>&#xD;&#xA;      </object>&#xD;&#xA;      <object class=""GtkSizeGroup"" id=""sizegroup1"">&#xD;&#xA;        <property name=""mode"">both</property>&#xD;&#xA;        <widgets>&#xD;&#xA;          <widget name=""mainWindow""/>&#xD;&#xA;        </widgets>&#xD;&#xA;      </object>&#xD;&#xA;    </interface>&#xD;&#xA;&#xD;&#xA;http://pastebin.com/pmCS1HDr&#xD;&#xA;&#xD;&#xA;.cabal&#xD;&#xA;&#xD;&#xA;    -- Initial panningMinimal.cabal generated by cabal init.  For further&#xD;&#xA;    -- documentation, see http://haskell.org/cabal/users-guide/&#xD;&#xA; &#xD;&#xA;    name:                panningMinimal&#xD;&#xA;    version:             0.1.0.0&#xD;&#xA;    -- synopsis:            &#xD;&#xA;    -- description:        &#xD;&#xA;    -- license:            &#xD;&#xA;    license-file:        LICENSE&#xD;&#xA;    author:              .&#xD;&#xA;    maintainer:          .&#xD;&#xA;    -- copyright:          &#xD;&#xA;    -- category:            &#xD;&#xA;    build-type:          Simple&#xD;&#xA;    -- extra-source-files:  &#xD;&#xA;    cabal-version:       >=1.10&#xD;&#xA; &#xD;&#xA;    executable panningMinimal&#xD;&#xA;      main-is:             Main.hs&#xD;&#xA;      -- other-modules:      &#xD;&#xA;      other-extensions:    PackageImports, MultiParamTypeClasses, GeneralizedNewtypeDeriving, FlexibleInstances&#xD;&#xA;      build-depends:       base >=4.6 && <4.7, gtk3, cairo      >= 0.13.0.2, transformers >= 0.4.2.0, mtl >= 2.2.1&#xD;&#xA;      -- hs-source-dirs:      &#xD;&#xA;      default-language:    Haskell2010&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Main.hs&#xD;&#xA; &#xD;&#xA;    {-# LANGUAGE PackageImports #-}&#xD;&#xA;    module Main where&#xD;&#xA; &#xD;&#xA;    import Control.Monad&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk.Buttons.Button&#xD;&#xA;    import ""gtk3"" Graphics.UI.Gtk.General.Enums&#xD;&#xA;    import Control.Monad.IO.Class(liftIO)&#xD;&#xA;    import WidgetBehavior&#xD;&#xA; &#xD;&#xA;    main = do&#xD;&#xA;        initGUI&#xD;&#xA; &#xD;&#xA;        builder <- builderNew&#xD;&#xA;        builderAddFromFile builder ""main.ui""&#xD;&#xA; &#xD;&#xA;        window <- builderGetObject builder castToWindow ""mainWindow""&#xD;&#xA; &#xD;&#xA;        overlay <- builderGetObject builder castToOverlay ""overlay""&#xD;&#xA;        viewport <- builderGetObject builder castToViewport ""viewport""&#xD;&#xA;        scrolledWindow <- builderGetObject builder castToScrolledWindow ""scrolledWindow""&#xD;&#xA; &#xD;&#xA;        initViewportPanning viewport&#xD;&#xA;        image <- imageNewFromFile ""redCat.jpg""&#xD;&#xA; &#xD;&#xA;        containerAdd overlay image&#xD;&#xA;        set overlay [widgetOpacity := 0.9]&#xD;&#xA; &#xD;&#xA;        window `on` deleteEvent $ liftIO mainQuit >> return False&#xD;&#xA; &#xD;&#xA;        -- Display the window&#xD;&#xA;        widgetShowAll window&#xD;&#xA;        mainGUI&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;http://pastebin.com/QKbPuNKe &#xD;&#xA;these 3 files + a large image called ""redCat.jpg"" should work in a cabal sandbox using:&#xD;&#xA;&#xD;&#xA;cabal sandbox init&#xD;&#xA;&#xD;&#xA;cabal install --dependencies-only&#xD;&#xA;&#xD;&#xA;cabal run";;removed cgi dependency
