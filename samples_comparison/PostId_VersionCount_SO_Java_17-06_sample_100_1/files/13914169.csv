Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
33299068;13914169;613495;2;50ec0248-7c26-46c3-b4ac-e2aaab223dc4;2012-12-17 12:26:30.0;"I believe the problem as guys are saying here is that you are not 'stopping' your threads in the right way - sort of speak.&#xD;&#xA;&#xD;&#xA;The best way in my experience is to store a state in a thread, in a boolean variable e.g. `isRunning`. Then inside your loop you test the state of the `isRunning` flag, i.e. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    //inside the run method&#xD;&#xA;    while(isRunning){&#xD;&#xA;    //your code goes here&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This way on each iteration of the loop you are checking the current state of the flag thus when you will set it to 'false' in, for example, your custom `stop()` method. The next iteration of the loop will cause the thread to exit its `run` method thus ending life of your thread. Well technically now it becomes ready to be garbage collected. It's memory will be deallocated at some point in the near future, considering there is no reference to this threat hanging in some place in your code.&#xD;&#xA;&#xD;&#xA;There is more sources showing this approach, for example, check out [this discussion on LinkedIn][1].&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;*As a side note it would be actually useful to see what exactly is the `newRuntime` or 'result' variables, their classes and inheritance etc. Otherwise we can only try to guess as to what actually is going on in your code.*&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.linkedin.com/groups/Killing-threads-in-java-program-70526.S.191670441?view=&srchtype=discussedNews&gid=70526&item=191670441&type=member&trk=eml-anet_dig-b_pd-ttl-hdp&ut=0AA26BiLWSO5w1";;
33299915;13914169;613495;5;f606ea2e-4e67-4c01-afa3-b07b1968af6a;2012-12-17 12:47:24.0;"I believe the problem as guys are saying here is that you are not 'stopping' your threads in the right way - sort of speak.&#xD;&#xA;&#xD;&#xA;The best way in my experience is to store a state in a thread, in a boolean variable e.g. `isRunning`. Then inside your loop you test the state of the `isRunning` flag, i.e. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    //inside the run method&#xD;&#xA;    while(isRunning){&#xD;&#xA;    //your code goes here&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This way on each iteration of the loop you are checking the current state of the flag thus when you will set it to 'false' in, for example, your custom `stop()` method. The next iteration of the loop will cause the thread to exit its `run` method thus ending life of your thread. Well technically now it becomes ready to be garbage collected. It's memory will be deallocated at some point in the near future, considering there is no reference to this threat hanging in some place in your code.&#xD;&#xA;&#xD;&#xA;There is more sources showing this approach, for example, check out [this discussion on LinkedIn][1].&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;*As a side note it would be actually useful to see what exactly is the `newRuntime` or `result` variables, their classes and inheritance etc. Otherwise we can only try to guess as to what actually is going on in your code.*&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.linkedin.com/groups/Killing-threads-in-java-program-70526.S.191670441?view=&srchtype=discussedNews&gid=70526&item=191670441&type=member&trk=eml-anet_dig-b_pd-ttl-hdp&ut=0AA26BiLWSO5w1";;added 2 characters in body
