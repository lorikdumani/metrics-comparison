Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
88696936;29786253;1475978;2;6dc30921-4517-473e-baef-bdc7db42129e;2015-04-22 01:39:49.0;"Yes, standard library conversion functions are surprisingly slow.&#xD;&#xA;&#xD;&#xA;If portability is not a problem, I'd memory-map the file. Then, something like the following C99 code (untested) could be used to parse the entire memory map:&#xD;&#xA;&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    #include <errno.h>&#xD;&#xA;&#xD;&#xA;    struct pair {&#xD;&#xA;        unsigned long  key;&#xD;&#xA;        unsigned long  value;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    typedef struct {&#xD;&#xA;        size_t       size; /* Maximum number of items */&#xD;&#xA;        size_t       used; /* Number of items used */&#xD;&#xA;        struct pair  item[];&#xD;&#xA;    } items;&#xD;&#xA;&#xD;&#xA;    /* Initial number of items to allocate for */&#xD;&#xA;    #ifndef ITEM_ALLOC_SIZE&#xD;&#xA;    #define ITEM_ALLOC_SIZE 1048576&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;    /* Adjustment to new size (parameter is old size) */&#xD;&#xA;    #ifndef ITEM_REALLOC_SIZE&#xD;&#xA;    #define ITEM_REALLOC_SIZE(from) (((from) | 1048575) + 1048577)&#xD;&#xA;    #endif &#xD;&#xA;&#xD;&#xA;    items *parse_items(const void *const data, const size_t length)&#xD;&#xA;    {&#xD;&#xA;        const unsigned char       *ptr = (const unsigned char *)data;&#xD;&#xA;        const unsigned char *const end = (const unsigned char *)data + length;&#xD;&#xA;        items                  *result;&#xD;&#xA;        size_t                  size = ITEMS_ALLOC_SIZE;&#xD;&#xA;        size_t                  used = 0;&#xD;&#xA;        unsigned long           val1, val2;&#xD;&#xA;&#xD;&#xA;        result = malloc(sizeof (items) + size * sizeof (struct pair));&#xD;&#xA;        if (!result) {&#xD;&#xA;            errno = ENOMEM;&#xD;&#xA;            return NULL;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        while (ptr < end) {&#xD;&#xA;&#xD;&#xA;            /* Skip newlines and whitespace. */&#xD;&#xA;            while (ptr < end && (*ptr == '\\0' || *ptr == '\\t' ||&#xD;&#xA;                                 *ptr == '\\n' || *ptr == '\\v' ||&#xD;&#xA;                                 *ptr == '\\f' || *ptr == '\\r' ||&#xD;&#xA;                                 *ptr == ' '))&#xD;&#xA;                ptr++;&#xD;&#xA;&#xD;&#xA;            /* End of data? */&#xD;&#xA;            if (ptr >= end)&#xD;&#xA;                break;&#xD;&#xA;&#xD;&#xA;            /* Parse first number. */&#xD;&#xA;            if (*ptr >= '0' && *ptr <= '9')&#xD;&#xA;                val1 = *(ptr++) - '0';&#xD;&#xA;            else {&#xD;&#xA;                free(result);&#xD;&#xA;                errno = ECOMM; /* Bad data! */&#xD;&#xA;                return NULL;&#xD;&#xA;            }&#xD;&#xA;            while (ptr < end && *ptr >= '0' && *ptr <= '9') {&#xD;&#xA;                const unsigned long old = val1;&#xD;&#xA;                val1 = 10UL * val1 + (*(ptr++) - '0');&#xD;&#xA;                if (val1 < old) {&#xD;&#xA;                    free(result);&#xD;&#xA;                    errno = EDOM; /* Overflow! */&#xD;&#xA;                    return NULL;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            /* Skip whitespace. */&#xD;&#xA;            while (ptr < end && (*ptr == '\\t' || *ptr == '\\v'&#xD;&#xA;                                 *ptr == '\\f' || *ptr == ' '))&#xD;&#xA;                ptr++;&#xD;&#xA;            if (ptr >= end) {&#xD;&#xA;                free(result);&#xD;&#xA;                errno = ECOMM; /* Bad data! */&#xD;&#xA;                return NULL;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            /* Parse second number. */&#xD;&#xA;            if (*ptr >= '0' && *ptr <= '9')&#xD;&#xA;                val2 = *(ptr++) - '0';&#xD;&#xA;            else {&#xD;&#xA;                free(result);&#xD;&#xA;                errno = ECOMM; /* Bad data! */&#xD;&#xA;                return NULL;&#xD;&#xA;            }&#xD;&#xA;            while (ptr < end && *ptr >= '0' && *ptr <= '9') {&#xD;&#xA;                const unsigned long old = val2;&#xD;&#xA;                val1 = 10UL * val2 + (*(ptr++) - '0');&#xD;&#xA;                if (val2 < old) {&#xD;&#xA;                    free(result);&#xD;&#xA;                    errno = EDOM; /* Overflow! */&#xD;&#xA;                    return NULL;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            if (ptr < end) {&#xD;&#xA;                /* Error unless whitespace or newline. */&#xD;&#xA;                if (*ptr != '\\0' && *ptr != '\\t' && *ptr != '\\n' &&&#xD;&#xA;                    *ptr != '\\v' && *ptr != '\\f' && *ptr != '\\r' &&&#xD;&#xA;                    *ptr != ' ') {&#xD;&#xA;                    free(result);&#xD;&#xA;                    errno = ECOMM; /* Bad data! */&#xD;&#xA;                    return NULL;&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                /* Skip the rest of this line. */&#xD;&#xA;                while (ptr < end && *ptr != '\\n' && *ptr != '\\r')&#xD;&#xA;                    ptr++;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            /* Need to grow result? */&#xD;&#xA;            if (used >= size) {&#xD;&#xA;                items *const old = result;&#xD;&#xA;&#xD;&#xA;                size = ITEMS_REALLOC_SIZE(used);&#xD;&#xA;                result = realloc(result, sizeof (items) + size * sizeof (struct pair));&#xD;&#xA;                if (!result) {&#xD;&#xA;                    free(old);&#xD;&#xA;                    errno = ENOMEM;&#xD;&#xA;                    return NULL;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            result->items[used].key = val1;&#xD;&#xA;            result->items[used].value = val2;&#xD;&#xA;            used++;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        /* Note: we could reallocate result here,&#xD;&#xA;         *       if memory use is an issue.&#xD;&#xA;        */&#xD;&#xA;&#xD;&#xA;        result->size = size;&#xD;&#xA;        result->used = used;&#xD;&#xA;&#xD;&#xA;        errno = 0;&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;If you cannot use a memory map, then the parsing function would be a bit different: it would append to an existing result, and if the final line in the buffer is partial, it would indicate so (and the number of chars not parsed), so that the caller can `memmove()` the buffer, read more data, and continue parsing.&#xD;&#xA;&#xD;&#xA;Questions?";;
88697324;29786253;1475978;5;1565b6ce-272c-44aa-bd53-6a840c928229;2015-04-22 01:52:38.0;"Yes, standard library conversion functions are surprisingly slow.&#xD;&#xA;&#xD;&#xA;If portability is not a problem, I'd memory-map the file. Then, something like the following C99 code (untested) could be used to parse the entire memory map:&#xD;&#xA;&#xD;&#xA;    #include <stdlib.h>&#xD;&#xA;    #include <errno.h>&#xD;&#xA;&#xD;&#xA;    struct pair {&#xD;&#xA;        unsigned long  key;&#xD;&#xA;        unsigned long  value;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    typedef struct {&#xD;&#xA;        size_t       size; /* Maximum number of items */&#xD;&#xA;        size_t       used; /* Number of items used */&#xD;&#xA;        struct pair  item[];&#xD;&#xA;    } items;&#xD;&#xA;&#xD;&#xA;    /* Initial number of items to allocate for */&#xD;&#xA;    #ifndef ITEM_ALLOC_SIZE&#xD;&#xA;    #define ITEM_ALLOC_SIZE 8388608&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;    /* Adjustment to new size (parameter is old number of items) */&#xD;&#xA;    #ifndef ITEM_REALLOC_SIZE&#xD;&#xA;    #define ITEM_REALLOC_SIZE(from) (((from) | 1048575) + 1048577)&#xD;&#xA;    #endif &#xD;&#xA;&#xD;&#xA;    items *parse_items(const void *const data, const size_t length)&#xD;&#xA;    {&#xD;&#xA;        const unsigned char       *ptr = (const unsigned char *)data;&#xD;&#xA;        const unsigned char *const end = (const unsigned char *)data + length;&#xD;&#xA;        items                  *result;&#xD;&#xA;        size_t                  size = ITEMS_ALLOC_SIZE;&#xD;&#xA;        size_t                  used = 0;&#xD;&#xA;        unsigned long           val1, val2;&#xD;&#xA;&#xD;&#xA;        result = malloc(sizeof (items) + size * sizeof (struct pair));&#xD;&#xA;        if (!result) {&#xD;&#xA;            errno = ENOMEM;&#xD;&#xA;            return NULL;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        while (ptr < end) {&#xD;&#xA;&#xD;&#xA;            /* Skip newlines and whitespace. */&#xD;&#xA;            while (ptr < end && (*ptr == '\\0' || *ptr == '\\t' ||&#xD;&#xA;                                 *ptr == '\\n' || *ptr == '\\v' ||&#xD;&#xA;                                 *ptr == '\\f' || *ptr == '\\r' ||&#xD;&#xA;                                 *ptr == ' '))&#xD;&#xA;                ptr++;&#xD;&#xA;&#xD;&#xA;            /* End of data? */&#xD;&#xA;            if (ptr >= end)&#xD;&#xA;                break;&#xD;&#xA;&#xD;&#xA;            /* Parse first number. */&#xD;&#xA;            if (*ptr >= '0' && *ptr <= '9')&#xD;&#xA;                val1 = *(ptr++) - '0';&#xD;&#xA;            else {&#xD;&#xA;                free(result);&#xD;&#xA;                errno = ECOMM; /* Bad data! */&#xD;&#xA;                return NULL;&#xD;&#xA;            }&#xD;&#xA;            while (ptr < end && *ptr >= '0' && *ptr <= '9') {&#xD;&#xA;                const unsigned long old = val1;&#xD;&#xA;                val1 = 10UL * val1 + (*(ptr++) - '0');&#xD;&#xA;                if (val1 < old) {&#xD;&#xA;                    free(result);&#xD;&#xA;                    errno = EDOM; /* Overflow! */&#xD;&#xA;                    return NULL;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            /* Skip whitespace. */&#xD;&#xA;            while (ptr < end && (*ptr == '\\t' || *ptr == '\\v'&#xD;&#xA;                                 *ptr == '\\f' || *ptr == ' '))&#xD;&#xA;                ptr++;&#xD;&#xA;            if (ptr >= end) {&#xD;&#xA;                free(result);&#xD;&#xA;                errno = ECOMM; /* Bad data! */&#xD;&#xA;                return NULL;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            /* Parse second number. */&#xD;&#xA;            if (*ptr >= '0' && *ptr <= '9')&#xD;&#xA;                val2 = *(ptr++) - '0';&#xD;&#xA;            else {&#xD;&#xA;                free(result);&#xD;&#xA;                errno = ECOMM; /* Bad data! */&#xD;&#xA;                return NULL;&#xD;&#xA;            }&#xD;&#xA;            while (ptr < end && *ptr >= '0' && *ptr <= '9') {&#xD;&#xA;                const unsigned long old = val2;&#xD;&#xA;                val1 = 10UL * val2 + (*(ptr++) - '0');&#xD;&#xA;                if (val2 < old) {&#xD;&#xA;                    free(result);&#xD;&#xA;                    errno = EDOM; /* Overflow! */&#xD;&#xA;                    return NULL;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            if (ptr < end) {&#xD;&#xA;                /* Error unless whitespace or newline. */&#xD;&#xA;                if (*ptr != '\\0' && *ptr != '\\t' && *ptr != '\\n' &&&#xD;&#xA;                    *ptr != '\\v' && *ptr != '\\f' && *ptr != '\\r' &&&#xD;&#xA;                    *ptr != ' ') {&#xD;&#xA;                    free(result);&#xD;&#xA;                    errno = ECOMM; /* Bad data! */&#xD;&#xA;                    return NULL;&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                /* Skip the rest of this line. */&#xD;&#xA;                while (ptr < end && *ptr != '\\n' && *ptr != '\\r')&#xD;&#xA;                    ptr++;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            /* Need to grow result? */&#xD;&#xA;            if (used >= size) {&#xD;&#xA;                items *const old = result;&#xD;&#xA;&#xD;&#xA;                size = ITEMS_REALLOC_SIZE(used);&#xD;&#xA;                result = realloc(result, sizeof (items) + size * sizeof (struct pair));&#xD;&#xA;                if (!result) {&#xD;&#xA;                    free(old);&#xD;&#xA;                    errno = ENOMEM;&#xD;&#xA;                    return NULL;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            result->items[used].key = val1;&#xD;&#xA;            result->items[used].value = val2;&#xD;&#xA;            used++;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        /* Note: we could reallocate result here,&#xD;&#xA;         *       if memory use is an issue.&#xD;&#xA;        */&#xD;&#xA;&#xD;&#xA;        result->size = size;&#xD;&#xA;        result->used = used;&#xD;&#xA;&#xD;&#xA;        errno = 0;&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I've used a similar approach to load molecular data for visualization. Such data contains floating-point values, but precision is typically only about seven significant digits, no multiprecision math needed. A custom routine to parse such data beats the standard functions by at least an order of magnitude in speed.&#xD;&#xA;&#xD;&#xA;At least the Linux kernel is pretty good at observing memory/file access patterns; using [`madvise()`](http://man7.org/linux/man-pages/man2/madvise.2.html) also helps.&#xD;&#xA;&#xD;&#xA;If you cannot use a memory map, then the parsing function would be a bit different: it would append to an existing result, and if the final line in the buffer is partial, it would indicate so (and the number of chars not parsed), so that the caller can `memmove()` the buffer, read more data, and continue parsing. (Use 16-byte aligned addresses for reading new data, to maximize copy speeds. You don't necessarily need to move the unread data to the exact beginning of the buffer, you see; just keep the current position in the buffered data.)&#xD;&#xA;&#xD;&#xA;Questions?";;added 732 characters in body
