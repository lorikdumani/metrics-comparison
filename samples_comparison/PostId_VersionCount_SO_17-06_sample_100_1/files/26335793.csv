Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
75401945;26335793;3687048;2;516b290e-2031-4bae-acbe-01378580fabc;2014-10-13 08:34:24.0;"I'm using Parsec to parse some expressions (see [this question](http://stackoverflow.com/questions/26276265/trying-to-program-interactive-session-of-a-toy-language-how-to-use-state-monad) for more context), and most relevant part of my code is:&#xD;&#xA;&#xD;&#xA;    statement :: Parser Stmt&#xD;&#xA;    statement = assignStmt <|> simpleStmt&#xD;&#xA;&#xD;&#xA;    assignStmt :: Parser Stmt&#xD;&#xA;    assignStmt =&#xD;&#xA;        do var  <- identifier&#xD;&#xA;           reservedOp ""=""&#xD;&#xA;           expr <- expression&#xD;&#xA;           return $ Assign var expr&#xD;&#xA;&#xD;&#xA;    simpleStmt :: Parser Stmt&#xD;&#xA;    simpleStmt =&#xD;&#xA;        do expr <- expression&#xD;&#xA;           return $ Simple expr&#xD;&#xA;&#xD;&#xA;In action:&#xD;&#xA;&#xD;&#xA;> **boobla>** foo = 100 + ~100  &#xD;&#xA;167  &#xD;&#xA;**boobla>** foo  &#xD;&#xA;parser error: (line 1, column 4):  &#xD;&#xA;unexpected end of input  &#xD;&#xA;expecting letter or digit or ""=""&#xD;&#xA;&#xD;&#xA;Second expression should have evaluated to `167`, value of `foo`.&#xD;&#xA;&#xD;&#xA;I thought that when Parsec would try to extract token `reservedOp ""=""`, it should have failed because there is no such token in the string, then it was to try second function `simpleStmt` and succeed with it. But it works differently: it expects more input and just throws this exception.&#xD;&#xA;&#xD;&#xA;What should I use to make `assignStmt` fail if there is no more characters in the string (or in current line). `foo = 10` should be parsed with `assignStmt` and `foo` should be parsed with `simpleStmt`.";;
146710100;26335793;-1;5;f9231716-7e4a-4813-b989-453670a23f76;2017-05-23 11:57:09.0;"I'm using Parsec to parse some expressions (see [this question](https://stackoverflow.com/questions/26276265/trying-to-program-interactive-session-of-a-toy-language-how-to-use-state-monad) for more context), and most relevant part of my code is:&#xD;&#xA;&#xD;&#xA;    statement :: Parser Stmt&#xD;&#xA;    statement = assignStmt <|> simpleStmt&#xD;&#xA;&#xD;&#xA;    assignStmt :: Parser Stmt&#xD;&#xA;    assignStmt =&#xD;&#xA;        do var  <- identifier&#xD;&#xA;           reservedOp ""=""&#xD;&#xA;           expr <- expression&#xD;&#xA;           return $ Assign var expr&#xD;&#xA;&#xD;&#xA;    simpleStmt :: Parser Stmt&#xD;&#xA;    simpleStmt =&#xD;&#xA;        do expr <- expression&#xD;&#xA;           return $ Simple expr&#xD;&#xA;&#xD;&#xA;In action:&#xD;&#xA;&#xD;&#xA;> **boobla>** foo = 100 + ~100  &#xD;&#xA;167  &#xD;&#xA;**boobla>** foo  &#xD;&#xA;parser error: (line 1, column 4):  &#xD;&#xA;unexpected end of input  &#xD;&#xA;expecting letter or digit or ""=""&#xD;&#xA;&#xD;&#xA;Second expression should have evaluated to `167`, value of `foo`.&#xD;&#xA;&#xD;&#xA;I thought that when Parsec would try to extract token `reservedOp ""=""`, it should have failed because there is no such token in the string, then it was to try second function `simpleStmt` and succeed with it. But it works differently: it expects more input and just throws this exception.&#xD;&#xA;&#xD;&#xA;What should I use to make `assignStmt` fail if there is no more characters in the string (or in current line). `foo = 10` should be parsed with `assignStmt` and `foo` should be parsed with `simpleStmt`.";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
