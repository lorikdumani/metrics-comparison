Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
31839491;13386986;;2;1a640a5b-1425-431d-9438-14a4a597e45a;2012-11-14 20:43:41.0;"What I'm trying to do is very similar to what `make-local-variable` does except that I don't want variables to be declared for every buffer created (only for those which belong to a particular mode). This is mostly a performance concern, the objects created may be big. AND more importantly I'd need a function like `(get-buffer-property buffer property-name)` to figure out what is the state of the particular buffer.&#xD;&#xA;&#xD;&#xA;Essentially, I'm after something similar to `get-buffer-proccess` except that I need something other than a process.&#xD;&#xA;&#xD;&#xA;Will it make sense to create such objects in the declaration of the major mode and destructing them in a hook for when such buffer is killed, or is there a better way for that?";user797257;
31840367;13386986;;5;ed36983b-d4d5-4305-9dc1-807d2ab06d4d;2012-11-14 21:02:19.0;"What I'm trying to do is very similar to what `make-local-variable` does except that I don't want variables to be declared for every buffer created (only for those which belong to a particular mode). This is mostly a performance concern, the objects created may be big. AND more importantly I'd need a function like `(get-buffer-property buffer property-name)` to figure out what is the state of the particular buffer.&#xD;&#xA;&#xD;&#xA;Essentially, I'm after something similar to `get-buffer-proccess` except that I need something other than a process.&#xD;&#xA;&#xD;&#xA;Will it make sense to create such objects in the declaration of the major mode and destructing them in a hook for when such buffer is killed, or is there a better way for that?&#xD;&#xA;&#xD;&#xA;This is what I have so far:&#xD;&#xA;&#xD;&#xA;    (defun haxe-get-buffer-property (buffer property)&#xD;&#xA;      ""Pops to BUFFER, reads the value of the PROPERTY and returns it.""&#xD;&#xA;      (let ((result&#xD;&#xA;             (save-excursion&#xD;&#xA;               (pop-to-buffer buffer)&#xD;&#xA;               (symbol-value property))))&#xD;&#xA;        result))&#xD;&#xA;    &#xD;&#xA;    (defmacro deflocal (var &rest body)&#xD;&#xA;      (let ((symb var)&#xD;&#xA;            (val (car body))&#xD;&#xA;            (doc (cadr body)))&#xD;&#xA;        `(progn&#xD;&#xA;           (defvar ,symb nil ,doc)&#xD;&#xA;           (unless ,symb (setq ,symb ,val))&#xD;&#xA;           (make-local-variable ',symb))))&#xD;&#xA;&#xD;&#xA;But I don't like that I have to visit buffers because I'm not sure of side effects.";user797257;added 674 characters in body
31840662;13386986;;5;18035673-91d2-432c-9165-3e282ccec7bd;2012-11-14 21:09:56.0;"What I'm trying to do is very similar to what `make-local-variable` does except that I don't want variables to be declared for every buffer created (only for those which belong to a particular mode). This is mostly a performance concern, the objects created may be big. AND more importantly I'd need a function like `(get-buffer-property buffer property-name)` to figure out what is the state of the particular buffer.&#xD;&#xA;&#xD;&#xA;Essentially, I'm after something similar to `get-buffer-proccess` except that I need something other than a process.&#xD;&#xA;&#xD;&#xA;Will it make sense to create such objects in the declaration of the major mode and destructing them in a hook for when such buffer is killed, or is there a better way for that?&#xD;&#xA;&#xD;&#xA;This is what I have so far:&#xD;&#xA;&#xD;&#xA;    (defun haxe-get-buffer-property (buffer property)&#xD;&#xA;      ""Pops to BUFFER, reads the value of the PROPERTY and returns it.""&#xD;&#xA;      (let ((result&#xD;&#xA;             (save-excursion&#xD;&#xA;               (pop-to-buffer buffer)&#xD;&#xA;               (symbol-value property))))&#xD;&#xA;        result))&#xD;&#xA;    (defmacro haxe-buffer-property (buffer property)&#xD;&#xA;    `(haxe-get-buffer-property ,buffer ',property))&#xD;&#xA;&#xD;&#xA;    (defmacro deflocal (var &rest body)&#xD;&#xA;      (let ((symb var)&#xD;&#xA;            (val (car body))&#xD;&#xA;            (doc (cadr body)))&#xD;&#xA;        `(progn&#xD;&#xA;           (defvar ,symb nil ,doc)&#xD;&#xA;           (unless ,symb (setq ,symb ,val))&#xD;&#xA;           (make-local-variable ',symb))))&#xD;&#xA;&#xD;&#xA;But I don't like that I have to visit buffers because I'm not sure of side effects.";user797257;added 103 characters in body
31840946;13386986;;5;69949c5c-448e-4def-a718-3f48c212fe1d;2012-11-14 21:17:22.0;"What I'm trying to do is very similar to what `make-local-variable` does except that I don't want variables to be declared for every buffer created (only for those which belong to a particular mode). This is mostly a performance concern, the objects created may be big. AND more importantly I'd need a function like `(get-buffer-property buffer property-name)` to figure out what is the state of the particular buffer.&#xD;&#xA;&#xD;&#xA;Essentially, I'm after something similar to `get-buffer-proccess` except that I need something other than a process.&#xD;&#xA;&#xD;&#xA;Will it make sense to create such objects in the declaration of the major mode and destructing them in a hook for when such buffer is killed, or is there a better way for that?&#xD;&#xA;&#xD;&#xA;This is what I have so far:&#xD;&#xA;&#xD;&#xA;    (defun haxe-get-buffer-property (buffer property)&#xD;&#xA;      ""Pops to BUFFER, reads the value of the PROPERTY and returns it.""&#xD;&#xA;      (let ((result&#xD;&#xA;             (save-excursion&#xD;&#xA;               (pop-to-buffer buffer)&#xD;&#xA;               (symbol-value property))))&#xD;&#xA;        result))&#xD;&#xA;    (defmacro haxe-buffer-property (buffer property)&#xD;&#xA;    `(haxe-get-buffer-property ,buffer ',property))&#xD;&#xA;&#xD;&#xA;    (defmacro deflocal (var &rest body)&#xD;&#xA;      (let ((symb var)&#xD;&#xA;            (val (car body))&#xD;&#xA;            (doc (cadr body)))&#xD;&#xA;        `(progn&#xD;&#xA;           (defvar ,symb nil ,doc)&#xD;&#xA;           (unless ,symb (setq ,symb ,val))&#xD;&#xA;           (make-local-variable ',symb))))&#xD;&#xA;&#xD;&#xA;But I don't like that I have to visit buffers because I'm not sure of side effects.&#xD;&#xA;&#xD;&#xA;**EDIT:** Some more info.&#xD;&#xA;&#xD;&#xA;What happens is like so, there are multiple buffers which can interact with a network connection process. This process can be shared by groups of buffers (it is important that buffers share this process), but it also may happen that there exist simultaneously multiple buffers that have different processes assigned to each other. Besides the process itself, there's a lot of info to store about the state of the process (how much data was received, what was sent, errors etc.) Similarly this data has to be shared by groups of buffers.";user797257;added 103 characters in body
31845788;13386986;;5;38318f8c-ce24-4c73-820b-ad5c4e11c4c4;2012-11-14 23:39:54.0;"What I'm trying to do is very similar to what `make-local-variable` does except that I don't want variables to be declared for every buffer created (only for those which belong to a particular mode). This is mostly a performance concern, the objects created may be big. AND more importantly I'd need a function like `(get-buffer-property buffer property-name)` to figure out what is the state of the particular buffer.&#xD;&#xA;&#xD;&#xA;Essentially, I'm after something similar to `get-buffer-proccess` except that I need something other than a process.&#xD;&#xA;&#xD;&#xA;Will it make sense to create such objects in the declaration of the major mode and destructing them in a hook for when such buffer is killed, or is there a better way for that?&#xD;&#xA;&#xD;&#xA;This is what I have so far:&#xD;&#xA;&#xD;&#xA;    (defun haxe-get-buffer-property (buffer property)&#xD;&#xA;      ""Pops to BUFFER, reads the value of the PROPERTY and returns it.""&#xD;&#xA;      (let ((result&#xD;&#xA;             (save-excursion&#xD;&#xA;               (pop-to-buffer buffer)&#xD;&#xA;               (symbol-value property))))&#xD;&#xA;        result))&#xD;&#xA;    (defmacro haxe-buffer-property (buffer property)&#xD;&#xA;    `(haxe-get-buffer-property ,buffer ',property))&#xD;&#xA;&#xD;&#xA;    (defmacro deflocal (var &rest body)&#xD;&#xA;      (let ((symb var)&#xD;&#xA;            (val (car body))&#xD;&#xA;            (doc (cadr body)))&#xD;&#xA;        `(progn&#xD;&#xA;           (defvar ,symb nil ,doc)&#xD;&#xA;           (unless ,symb (setq ,symb ,val))&#xD;&#xA;           (make-local-variable ',symb))))&#xD;&#xA;&#xD;&#xA;But I don't like that I have to visit buffers because I'm not sure of side effects.&#xD;&#xA;&#xD;&#xA;**EDIT:** Some more info.&#xD;&#xA;&#xD;&#xA;What happens is like so, there are multiple buffers which can interact with a network connection process. This process can be shared by groups of buffers (it is important that buffers share this process), but it also may happen that there exist simultaneously multiple buffers that have different processes assigned to each other. Besides the process itself, there's a lot of info to store about the state of the process (how much data was received, what was sent, errors etc.) Similarly this data has to be shared by groups of buffers.&#xD;&#xA;&#xD;&#xA;EDIT2: &#xD;&#xA;&#xD;&#xA;This is what become of the code above, just in case anyone will need it.&#xD;&#xA;&#xD;&#xA;    (defmacro deflocal (var &rest body)&#xD;&#xA;      (let ((symb var)&#xD;&#xA;            (val (car body))&#xD;&#xA;            (doc (cadr body)))&#xD;&#xA;        `(progn&#xD;&#xA;           (set (make-local-variable ',symb) ,val)&#xD;&#xA;           (put ',symb 'variable-documentation ,doc))))&#xD;&#xA;    &#xD;&#xA;    (defun haxe-get-buffer-property (buffer property)&#xD;&#xA;      ""Pops to BUFFER, reads the value of the PROPERTY and returns it.""&#xD;&#xA;      (let ((result&#xD;&#xA;             (with-current-buffer buffer&#xD;&#xA;               (symbol-value property))))&#xD;&#xA;        result))&#xD;&#xA;    &#xD;&#xA;    (defun haxe-set-buffer-property (buffer &rest proplist)&#xD;&#xA;      ""Similar to setq sets multiple properties in the left-to right order.""&#xD;&#xA;      (let ((result&#xD;&#xA;             (with-current-buffer buffer&#xD;&#xA;               (loop for (property value) on proplist by #'cddr&#xD;&#xA;                     do (set property value)&#xD;&#xA;                     finally (return value)))))&#xD;&#xA;        result))&#xD;&#xA;    &#xD;&#xA;    (defmacro haxe-buffer-property (buffer property)&#xD;&#xA;      `(haxe-get-buffer-property ,buffer ',property))&#xD;&#xA;    (defalias 'haxe-pbget #'haxe-buffer-property)&#xD;&#xA;    &#xD;&#xA;    (defmacro haxe-buffer-setf-property (buffer &rest proplist)&#xD;&#xA;      `(haxe-set-buffer-property&#xD;&#xA;        ,buffer&#xD;&#xA;        ,@(loop for (key value) on proplist by #'cddr&#xD;&#xA;                nconc (list (list 'quote key) value))))&#xD;&#xA;    (defalias 'haxe-pbset #'haxe-buffer-setf-property)&#xD;&#xA;&#xD;&#xA;";user797257;added 1441 characters in body
31845953;13386986;;5;a948cbdd-3fb0-4dab-b6c7-ea5a8a96e612;2012-11-14 23:45:51.0;"What I'm trying to do is very similar to what `make-local-variable` does except that I don't want variables to be declared for every buffer created (only for those which belong to a particular mode). This is mostly a performance concern, the objects created may be big. AND more importantly I'd need a function like `(get-buffer-property buffer property-name)` to figure out what is the state of the particular buffer.&#xD;&#xA;&#xD;&#xA;Essentially, I'm after something similar to `get-buffer-proccess` except that I need something other than a process.&#xD;&#xA;&#xD;&#xA;Will it make sense to create such objects in the declaration of the major mode and destructing them in a hook for when such buffer is killed, or is there a better way for that?&#xD;&#xA;&#xD;&#xA;This is what I have so far:&#xD;&#xA;&#xD;&#xA;    (defun haxe-get-buffer-property (buffer property)&#xD;&#xA;      ""Pops to BUFFER, reads the value of the PROPERTY and returns it.""&#xD;&#xA;      (let ((result&#xD;&#xA;             (save-excursion&#xD;&#xA;               (pop-to-buffer buffer)&#xD;&#xA;               (symbol-value property))))&#xD;&#xA;        result))&#xD;&#xA;    (defmacro haxe-buffer-property (buffer property)&#xD;&#xA;    `(haxe-get-buffer-property ,buffer ',property))&#xD;&#xA;&#xD;&#xA;    (defmacro deflocal (var &rest body)&#xD;&#xA;      (let ((symb var)&#xD;&#xA;            (val (car body))&#xD;&#xA;            (doc (cadr body)))&#xD;&#xA;        `(progn&#xD;&#xA;           (defvar ,symb nil ,doc)&#xD;&#xA;           (unless ,symb (setq ,symb ,val))&#xD;&#xA;           (make-local-variable ',symb))))&#xD;&#xA;&#xD;&#xA;But I don't like that I have to visit buffers because I'm not sure of side effects.&#xD;&#xA;&#xD;&#xA;**EDIT:** Some more info.&#xD;&#xA;&#xD;&#xA;What happens is like so, there are multiple buffers which can interact with a network connection process. This process can be shared by groups of buffers (it is important that buffers share this process), but it also may happen that there exist simultaneously multiple buffers that have different processes assigned to each other. Besides the process itself, there's a lot of info to store about the state of the process (how much data was received, what was sent, errors etc.) Similarly this data has to be shared by groups of buffers.&#xD;&#xA;&#xD;&#xA;EDIT2: &#xD;&#xA;&#xD;&#xA;This is what become of the code above, just in case anyone will need it.&#xD;&#xA;&#xD;&#xA;    (defmacro deflocal (var &rest body)&#xD;&#xA;      (let ((symb var)&#xD;&#xA;            (val (car body))&#xD;&#xA;            (doc (cadr body)))&#xD;&#xA;        `(progn&#xD;&#xA;           (set (make-local-variable ',symb) ,val)&#xD;&#xA;           (put ',symb 'variable-documentation ,doc))))&#xD;&#xA;    &#xD;&#xA;    (defun haxe-get-buffer-property (buffer property)&#xD;&#xA;      ""Pops to BUFFER, reads the value of the PROPERTY and returns it.""&#xD;&#xA;      (let ((result&#xD;&#xA;             (with-current-buffer buffer&#xD;&#xA;               (symbol-value property))))&#xD;&#xA;        result))&#xD;&#xA;    &#xD;&#xA;    (defun haxe-set-buffer-property (buffer &rest proplist)&#xD;&#xA;      ""Similar to `pset' sets multiple properties in the left-to right order.""&#xD;&#xA;      (let ((result&#xD;&#xA;             (with-current-buffer buffer&#xD;&#xA;               (loop for (property value) on proplist by #'cddr&#xD;&#xA;                     do (set property value)&#xD;&#xA;                     finally (return value)))))&#xD;&#xA;        result))&#xD;&#xA;    &#xD;&#xA;    (defmacro haxe-buffer-property (buffer property)&#xD;&#xA;      `(haxe-get-buffer-property ,buffer ',property))&#xD;&#xA;    (defalias 'haxe-pbget #'haxe-buffer-property)&#xD;&#xA;    &#xD;&#xA;    (defmacro haxe-buffer-setf-property (buffer &rest proplist)&#xD;&#xA;      `(haxe-set-buffer-property&#xD;&#xA;        ,buffer&#xD;&#xA;        ,@(loop for (key value) on proplist by #'cddr&#xD;&#xA;                nconc (list (list 'quote key) value))))&#xD;&#xA;    (defalias 'haxe-pbset #'haxe-buffer-setf-property)&#xD;&#xA;&#xD;&#xA;";user797257;added 2 characters in body
31846367;13386986;;5;b77499b9-cff0-406f-9a38-43e78e1c4935;2012-11-15 00:00:36.0;"What I'm trying to do is very similar to what `make-local-variable` does except that I don't want variables to be declared for every buffer created (only for those which belong to a particular mode). This is mostly a performance concern, the objects created may be big. AND more importantly I'd need a function like `(get-buffer-property buffer property-name)` to figure out what is the state of the particular buffer.&#xD;&#xA;&#xD;&#xA;Essentially, I'm after something similar to `get-buffer-proccess` except that I need something other than a process.&#xD;&#xA;&#xD;&#xA;Will it make sense to create such objects in the declaration of the major mode and destructing them in a hook for when such buffer is killed, or is there a better way for that?&#xD;&#xA;&#xD;&#xA;This is what I have so far:&#xD;&#xA;&#xD;&#xA;    (defun haxe-get-buffer-property (buffer property)&#xD;&#xA;      ""Pops to BUFFER, reads the value of the PROPERTY and returns it.""&#xD;&#xA;      (let ((result&#xD;&#xA;             (save-excursion&#xD;&#xA;               (pop-to-buffer buffer)&#xD;&#xA;               (symbol-value property))))&#xD;&#xA;        result))&#xD;&#xA;    (defmacro haxe-buffer-property (buffer property)&#xD;&#xA;    `(haxe-get-buffer-property ,buffer ',property))&#xD;&#xA;&#xD;&#xA;    (defmacro deflocal (var &rest body)&#xD;&#xA;      (let ((symb var)&#xD;&#xA;            (val (car body))&#xD;&#xA;            (doc (cadr body)))&#xD;&#xA;        `(progn&#xD;&#xA;           (defvar ,symb nil ,doc)&#xD;&#xA;           (unless ,symb (setq ,symb ,val))&#xD;&#xA;           (make-local-variable ',symb))))&#xD;&#xA;&#xD;&#xA;But I don't like that I have to visit buffers because I'm not sure of side effects.&#xD;&#xA;&#xD;&#xA;**EDIT:** Some more info.&#xD;&#xA;&#xD;&#xA;What happens is like so, there are multiple buffers which can interact with a network connection process. This process can be shared by groups of buffers (it is important that buffers share this process), but it also may happen that there exist simultaneously multiple buffers that have different processes assigned to each other. Besides the process itself, there's a lot of info to store about the state of the process (how much data was received, what was sent, errors etc.) Similarly this data has to be shared by groups of buffers.&#xD;&#xA;&#xD;&#xA;EDIT2: &#xD;&#xA;&#xD;&#xA;This is what become of the code above, just in case anyone will need it.&#xD;&#xA;&#xD;&#xA;    (defmacro deflocal (var &rest body)&#xD;&#xA;      (let ((symb var)&#xD;&#xA;            (val (car body))&#xD;&#xA;            (doc (cadr body)))&#xD;&#xA;        `(progn&#xD;&#xA;           (set (make-local-variable ',symb) ,val)&#xD;&#xA;           (put ',symb 'variable-documentation ,doc))))&#xD;&#xA;    &#xD;&#xA;    (defun haxe-get-buffer-property (buffer property)&#xD;&#xA;      ""Pops to BUFFER, reads the value of the PROPERTY and returns it.""&#xD;&#xA;      (let ((result&#xD;&#xA;             (with-current-buffer buffer&#xD;&#xA;               (symbol-value property))))&#xD;&#xA;        result))&#xD;&#xA;    &#xD;&#xA;    (defun haxe-set-buffer-property (buffer &rest proplist)&#xD;&#xA;      ""Pops to BUFFER and sets properties in parallel, similar to `pset'.""&#xD;&#xA;      (let ((result&#xD;&#xA;             (with-current-buffer buffer&#xD;&#xA;               (loop for (property value) on proplist by #'cddr&#xD;&#xA;                     do (set property value)&#xD;&#xA;                     finally (return value)))))&#xD;&#xA;        result))&#xD;&#xA;&#xD;&#xA;    (defmacro haxe-buffer-pset-property (buffer &rest proplist)&#xD;&#xA;      `(haxe-set-buffer-property&#xD;&#xA;        ,buffer&#xD;&#xA;        ,@(loop for (key value) on proplist by #'cddr&#xD;&#xA;                nconc (list (list 'quote key) value))))&#xD;&#xA;    (defalias 'haxe-pbset #'haxe-buffer-pset-property)&#xD;&#xA;    &#xD;&#xA;    (defmacro haxe-buffer-setf-property (buffer &rest proplist)&#xD;&#xA;      `(with-current-buffer ,buffer&#xD;&#xA;         ,@(list (append '(setf) proplist))))&#xD;&#xA;    (defalias 'haxe-pbsetf #'haxe-buffer-setf-property)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;";user797257;added 40 characters in body
