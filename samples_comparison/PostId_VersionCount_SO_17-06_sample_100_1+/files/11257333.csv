Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
26133531;11257333;665240;2;1498a6f1-7f21-4d5d-850a-0f68859f9382;2012-06-29 06:54:01.0;"There seems to be only one real area where memcached continues to have an advantage, and its a huge one: robust clustering. Memcached has been solving the hard problems of managing pools of servers and using their available memory efficiently for a long time.&#xD;&#xA;&#xD;&#xA;Redis clustering is coming though, and it aims to be every bit as clever as memcached while retaining everything that makes redis awesome. This promise of clustering has already taken longer than some had hoped to fulfill, and right now the developers apparently aren't even working on it until 2.6 is fully out the door. The closest thing Redis offers in the mean time is the built in replication. This is no substitute.&#xD;&#xA;&#xD;&#xA;What makes redis otherwise so awesome? I have posted some [thoughts][1] on that before, but here is a quick summary.&#xD;&#xA;&#xD;&#xA;* Persistence, right out of the box. You can choose snapshot or append-only-file along with other options to ensure the best performance for your use case. Defaults are sane though.&#xD;&#xA;* Powerful data types and powerful commands to leverage them. Hashes, Sorted Sets, Lists, and more.&#xD;&#xA;* Transactions with optimistic locking (WATCH/MULTI/EXEC)&#xD;&#xA;* Pub/sub. Extremely fast.&#xD;&#xA;* Lua scripting. The first redis release supporting Lua is already in release candidate stage and should be moved to stable any day now.&#xD;&#xA;* Extremely fast at everything. Benchmarks are often conflicting, but this much is clear: when used like memcached Redis falls somewhere between nearly as fast or maybe even a little faster. Like memcached it is often bound by available memory bandwidth instead of CPU or other bottlenecks and will rarely be the culprit when your app is slowing down.&#xD;&#xA;&#xD;&#xA;Redis is one of the best written pieces of software I have used. If Antirez and team keep up their pace it looks as though they will finally close the one big gap keeping Redis from being at least as good as memcached in virtually every use case for memcached. The use cases for redis, though, are already much more numerous. A great key/value store it is, but that hardly scratches the surface.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/7888880/what-is-redis-and-what-do-i-use-it-for/7897243#7897243";;
26133829;11257333;665240;5;2e43f878-e70c-4551-aabd-657a08fdfe42;2012-06-29 07:02:46.0;"There seems to be only one real area where memcached continues to have an advantage, and its a huge one: robust clustering. Memcached has been solving the hard problems of managing pools of servers and using their available memory efficiently for a long time.&#xD;&#xA;&#xD;&#xA;Redis clustering is coming though, and it aims to be every bit as clever as memcached while retaining everything that makes redis awesome. This promise of clustering has already taken longer than some had hoped to fulfill, and right now the developers apparently aren't even working on it until 2.6 is fully out the door. The closest thing Redis offers in the mean time is the built in replication. This is no substitute.&#xD;&#xA;&#xD;&#xA;What makes redis otherwise so awesome? I have posted some [thoughts][1] on that before, but here is a quick summary.&#xD;&#xA;&#xD;&#xA;* __Powerful data types and powerful commands to leverage them. Hashes, Sorted Sets, Lists, and more.__ This is the big one and allows Redis to do things memcached never could.&#xD;&#xA;* Persistence, right out of the box. You can choose snapshot or append-only-file along with other options to ensure the best performance for your use case. Defaults are sane though.&#xD;&#xA;* Transactions with optimistic locking (WATCH/MULTI/EXEC)&#xD;&#xA;* Pub/sub. Extremely fast.&#xD;&#xA;* Lua scripting. The first redis release supporting Lua is already in release candidate stage and should be moved to stable any day now.&#xD;&#xA;* Extremely fast at everything. Benchmarks are often conflicting, but this much is clear: when used like memcached Redis falls somewhere between nearly as fast or maybe even a little faster. Like memcached it is often bound by available memory bandwidth instead of CPU or other bottlenecks and will rarely be the culprit when your app is slowing down.&#xD;&#xA;&#xD;&#xA;Redis is one of the best written pieces of software I have used. If Antirez and team keep up their pace it looks as though they will finally close the one big gap keeping Redis from being at least as good as memcached in virtually every use case for memcached. The use cases for redis, though, are already much more numerous. A great key/value store it is, but that hardly scratches the surface.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/7888880/what-is-redis-and-what-do-i-use-it-for/7897243#7897243";;"added 73 characters in body; added 4 characters in body"
26134494;11257333;665240;5;f8340e67-0c78-48e1-9fbb-59e1a874449e;2012-06-29 07:21:04.0;"There seems to be only one real area where memcached continues to have an advantage, and its a huge one: robust clustering. Memcached has been solving the hard problems of managing pools of servers and using their available memory efficiently for a long time.&#xD;&#xA;&#xD;&#xA;Redis clustering is coming though, and it aims to be every bit as clever as memcached while retaining everything that makes redis awesome. This promise of clustering has already taken longer than some had hoped to fulfill, and right now the developers apparently aren't even working on it until 2.6 is fully out the door. The closest thing Redis offers in the mean time is the built in replication. This is no substitute.&#xD;&#xA;&#xD;&#xA;What makes redis otherwise so awesome? I have posted some [thoughts][1] on that before, but here is a quick summary.&#xD;&#xA;&#xD;&#xA;* __Powerful data types and powerful commands to leverage them. Hashes, Sorted Sets, Lists, and more.__ This is the big one and allows Redis to do things memcached never could.&#xD;&#xA;* Persistence, right out of the box. You can choose snapshot or append-only-file along with other options to ensure the best performance for your use case. Defaults are sane though.&#xD;&#xA;* Transactions with optimistic locking (WATCH/MULTI/EXEC)&#xD;&#xA;* Pub/sub. Extremely fast.&#xD;&#xA;* Lua scripting. The first redis release supporting Lua is already in release candidate stage and should be moved to stable any day now.&#xD;&#xA;* Extremely fast at everything. Benchmarks are often conflicting, but this much is clear: when used like memcached Redis falls somewhere between nearly as fast or maybe even a little faster. Like memcached it is often bound by available memory bandwidth instead of CPU or other bottlenecks and will rarely be the culprit when your app is slowing down.&#xD;&#xA;&#xD;&#xA;Redis is one of the best written pieces of software I have used. If Antirez and team keep up their pace it looks as though they will finally close the one big gap keeping Redis from being at least as good as memcached in virtually every use case for memcached. The use cases for redis, though, are already much more numerous. A great key/value store it is, but that hardly scratches the surface.&#xD;&#xA;&#xD;&#xA;To answer your original question: The performance and memory usage of Redis compared to memcached should be relatively similar. Close enough that for most uses any performance difference in either direction is academic as neither is likely to be the bottleneck. If you are hitting performance walls you probably need to look at clustering. If you are hitting those walls now, don't wait and use memcached. Otherwise, integrating memcached where you already have Redis working is probably not worth the time, and memcached might not support your use case depending on which Redis features you use.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/7888880/what-is-redis-and-what-do-i-use-it-for/7897243#7897243";;spelling
39077295;11257333;665240;5;f714c766-50c6-4b9d-b422-159443d2edf7;2013-04-13 22:17:37.0;"There seems to be only one real area where memcached continues to have an advantage: clustering support. Memcached doesn't support clustering out of the box either, but there are lots of tools available and lots of memcached clusters in production environments.&#xD;&#xA;&#xD;&#xA;Redis clustering is coming though, and it aims to be even more clever than memcached while retaining everything that makes redis awesome. Redis will eventually support cluster natively, unlike memcached, which should provide a more robust and easier to administer solution. This promise of clustering has already taken longer than some had hoped to fulfill. The community is working hard though, and cluster support appears to be planned for the next major release. The closest thing Redis offers in the mean time is the built in replication. This is no substitute.&#xD;&#xA;&#xD;&#xA;What makes redis otherwise so awesome? I have posted some [thoughts][1] on that before, but here is a quick summary.&#xD;&#xA;&#xD;&#xA;* __Powerful data types and powerful commands to leverage them. Hashes, Sorted Sets, Lists, and more.__ This is the big one and allows Redis to do things memcached never could.&#xD;&#xA;* Persistence, right out of the box. You can choose snapshot or append-only-file along with other options to ensure the best performance for your use case. Defaults are sane though.&#xD;&#xA;* Transactions with optimistic locking (WATCH/MULTI/EXEC)&#xD;&#xA;* Pub/sub. Extremely fast.&#xD;&#xA;* Lua scripting (as of 2.6)&#xD;&#xA;* Extremely fast at everything. Benchmarks are often conflicting, but this much is clear: when used like memcached Redis falls somewhere between nearly as fast or maybe even a little faster. Like memcached it is often bound by available memory bandwidth instead of CPU or other bottlenecks and will rarely be the culprit when your app is slowing down.&#xD;&#xA;&#xD;&#xA;Redis is one of the best written pieces of software I have used. If Antirez and team keep up their pace it looks as though they will finally close the one big gap keeping Redis from being at least as good as memcached in virtually every use case for memcached. The use cases for redis, though, are already much more numerous. A great key/value store it is, but that hardly scratches the surface.&#xD;&#xA;&#xD;&#xA;To answer your original question: The performance and memory usage of Redis compared to memcached should be relatively similar. Close enough that for most uses any performance difference in either direction is academic as neither is likely to be the bottleneck. If you are hitting performance walls you probably need to look at clustering. If you are hitting those walls now consider memcached. Otherwise, integrating memcached where you already have Redis working is probably not worth the time, and memcached might not support your use case depending on which Redis features you use.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/7888880/what-is-redis-and-what-do-i-use-it-for/7897243#7897243";;"""robust"" might be too strong a word when describing memcached's cluster support"
39078984;11257333;665240;5;f990300b-0461-40af-b2b8-f0973a52fff9;2013-04-13 23:45:02.0;"There seems to be only one area where memcached continues to have an advantage: clustering support. Memcached doesn't support clustering out of the box either, but there are lots of tools available and lots of memcached clusters in production environments.&#xD;&#xA;&#xD;&#xA;Redis clustering is coming though, and it aims to be even more clever than memcached while retaining everything that makes redis awesome. Redis will eventually support cluster natively, unlike memcached, which should provide a more robust and easier to administer solution. This promise of clustering has already taken longer than some had hoped to fulfill. The community is working hard though, and cluster support appears to be planned for the next major release. The closest thing Redis offers in the mean time is the built in replication. This is no substitute.&#xD;&#xA;&#xD;&#xA;What makes redis otherwise so awesome? I have posted some [thoughts][1] on that before, but here is a quick summary.&#xD;&#xA;&#xD;&#xA;* __Powerful data types and powerful commands to leverage them. Hashes, Sorted Sets, Lists, and more.__ This is the big one and allows Redis to do things memcached never could.&#xD;&#xA;* Persistence, right out of the box. You can choose snapshot or append-only-file along with other options to ensure the best performance for your use case. Defaults are sane though.&#xD;&#xA;* Transactions with optimistic locking (WATCH/MULTI/EXEC)&#xD;&#xA;* Pub/sub. Extremely fast.&#xD;&#xA;* Lua scripting (as of 2.6)&#xD;&#xA;* Extremely fast at everything. Benchmarks are often conflicting, but this much is clear: when used like memcached Redis falls somewhere between nearly as fast or maybe even a little faster. Like memcached it is often bound by available memory bandwidth instead of CPU or other bottlenecks and will rarely be the culprit when your app is slowing down.&#xD;&#xA;&#xD;&#xA;Redis is one of the best written pieces of software I have used. If Antirez and team keep up their pace it looks as though they will finally close the one big gap keeping Redis from being at least as good as memcached in virtually every use case for memcached. The use cases for redis, though, are already much more numerous. A great key/value store it is, but that hardly scratches the surface.&#xD;&#xA;&#xD;&#xA;To answer your original question: The performance and memory usage of Redis compared to memcached should be relatively similar. Close enough that for most uses any performance difference in either direction is academic as neither is likely to be the bottleneck. If you are hitting performance walls you probably need to look at clustering. If you are hitting those walls now consider memcached. Otherwise, integrating memcached where you already have Redis working is probably not worth the time, and memcached might not support your use case depending on which Redis features you use.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/7888880/what-is-redis-and-what-do-i-use-it-for/7897243#7897243";;deleted 5 characters in body
39496704;11257333;665240;5;db02e6ea-cd3e-4893-8440-870f49de3252;2013-04-22 10:26:56.0;"There seems to be only one area where memcached continues to have an advantage: clustering support. Memcached doesn't support clustering out of the box either, but there are lots of tools available and lots of memcached clusters in production environments.&#xD;&#xA;&#xD;&#xA;Redis clustering is coming though, and it aims to be even more clever than memcached while retaining everything that makes redis awesome. Redis will eventually support cluster natively, unlike memcached, which should provide a more robust and easier to administer solution. This promise of clustering has already taken longer than some had hoped to fulfill. The community is working hard though, and cluster support appears to be planned for the next major release.&#xD;&#xA;&#xD;&#xA;In the meantime redis does offer built in replication. It also includes a utility called Sentinel which helps manage large pools of redis instances. Though not substitutes for clustering, these two features make highly scalable highly available redis pretty straight forward.&#xD;&#xA;&#xD;&#xA;What makes redis otherwise so awesome? I have posted some [thoughts][1] on that before, but here is a quick summary.&#xD;&#xA;&#xD;&#xA;* __Powerful data types and powerful commands to leverage them. Hashes, Sorted Sets, Lists, and more.__ This is the big one and allows Redis to do things memcached never could.&#xD;&#xA;* Persistence, right out of the box. You can choose snapshot or append-only-file along with other options to ensure the best performance for your use case. Defaults are sane though.&#xD;&#xA;* Transactions with optimistic locking (WATCH/MULTI/EXEC)&#xD;&#xA;* Pub/sub. Extremely fast.&#xD;&#xA;* Lua scripting (as of 2.6)&#xD;&#xA;* Extremely fast at everything. Benchmarks are often conflicting, but this much is clear: when used like memcached Redis falls somewhere between nearly as fast or maybe even a little faster. Like memcached it is often bound by available memory bandwidth instead of CPU or other bottlenecks and will rarely be the culprit when your app is slowing down.&#xD;&#xA;&#xD;&#xA;Redis is one of the best written pieces of software I have used. If Antirez and team keep up their pace it looks as though they will finally close the one big gap keeping Redis from being at least as good as memcached in virtually every use case for memcached. The use cases for redis, though, are already much more numerous. A great key/value store it is, but that hardly scratches the surface.&#xD;&#xA;&#xD;&#xA;To answer your original question: The performance and memory usage of Redis compared to memcached should be relatively similar. Close enough that for most uses any performance difference in either direction is academic as neither is likely to be the bottleneck. If you are hitting performance walls you probably need to look at clustering. If you are hitting those walls now consider memcached. Otherwise, integrating memcached where you already have Redis working is probably not worth the time, and memcached might not support your use case depending on which Redis features you use.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/7888880/what-is-redis-and-what-do-i-use-it-for/7897243#7897243";;Updated to highlight redis' admin tool, sentinel.
56897411;11257333;665240;5;2b5b0b14-a535-4d5f-b561-e76b3e1b090e;2014-01-30 22:33:30.0;"The only area memcached might have a distinct advantage is clustering. It doesn't do clustering natively, but there are lots of tools and examples of memcached clusters.&#xD;&#xA;&#xD;&#xA;Redis clustering is coming though, and it aims to be even more clever than memcached while retaining everything that makes redis awesome. Redis will eventually support clustering natively, unlike memcached, which should provide a more robust solution that's easier to administrate. The promise of clustering has already taken longer than some had hoped to fulfill. [Antirez](https://twitter.com/antirez) and others are working hard though, and cluster support appears to be planned for the next major release.&#xD;&#xA;&#xD;&#xA;In the meantime redis does offer built in replication. It also includes a utility called Sentinel which helps manage large pools of redis instances. Though not substitutes for clustering, these two features make highly scalable highly available redis pretty straight forward.&#xD;&#xA;&#xD;&#xA;What makes redis otherwise so awesome?&#xD;&#xA;&#xD;&#xA;* __Powerful data types and powerful commands to leverage them. Hashes, Sorted Sets, Lists, and more.__&#xD;&#xA;* Persistence to disk, by default.&#xD;&#xA;* Transactions with optimistic locking (WATCH/MULTI/EXEC)&#xD;&#xA;* Pub/sub. Extremely fast.&#xD;&#xA;* Values up to 512MB in size (memcached limited to 1MB per key)&#xD;&#xA;* Lua scripting (as of 2.6)&#xD;&#xA;* Extremely fast at everything. Benchmarks are often conflicting, but this much is clear: when used like memcached Redis falls somewhere between nearly as fast or maybe even a little faster. Like memcached it is often bound by available network or even memory bandwidth instead of CPU or other bottlenecks and will rarely be the culprit when your app is slowing down.&#xD;&#xA;&#xD;&#xA;Memcached is a great tool, but it is ultimately a simple volatile key/value cache. Redis can be that if you want it, and will do that job as well as memcached. At its core, redis is a data structure server with the ability to be much more than a simple cache. Its good at that, but it is also the perfect shared queue ([lists](http://redis.io/commands#list)), a great messaging solution ([pub/sub](http://redis.io/commands#pubsub)), good place to put sessions ([hashes](http://redis.io/commands#hash)), and a fine place for high score tracking ([sorted sets](http://redis.io/commands#sorted_set)). This is just scratching the surface.&#xD;&#xA;&#xD;&#xA;To answer your original question: The performance and memory usage of Redis compared to memcached should be relatively similar. Close enough that for most uses any performance difference in either direction is academic as neither is likely to be the bottleneck. If you need robust clustering today without much fuss, look at commercial memcached solutions. Otherwise, integrating memcached where you already have Redis working is not worth the time, and memcached might not support your use case depending on which Redis features you use. Sticking with redis also gives you easier access to using it for more than caching in the future.";;various changes to refresh and provide better info
75208813;11257333;665240;5;547df159-c67e-4a00-ac70-737c62d8846f;2014-10-09 20:13:04.0;"**Updated 10/9/2014**&#xD;&#xA;&#xD;&#xA;Today marks the day that memcached no longer has any significant advantages over redis, while redis continues to have many distinct advantages over memcached. [Today, redis 3.0, which includes Redis Cluster, exited beta and entered the Release Candidate stage](http://antirez.com/news/79). Previously when looking at memcached vs redis you might be inclined to chose memcached due to the 3rd party clustering tools available. Now redis offers clustering, and unlike memcached support is provided out-of-the-box. Being built-in provides a more robust solution that is easier to administrate. Combined with other high availability tools in-the-box like replication and Sentinel (monitoring), redis clearly has the more compelling scaling story today.&#xD;&#xA;&#xD;&#xA;As of today every major feature and strength memcached offers are now a subset of redis' features and strengths. Any use case you might use memcached for redis can solve equally well. They are both lightning fast as volatile caches. While that's *all* that memcached is its only the tip of the redis iceberg.&#xD;&#xA;&#xD;&#xA;Memcached is a volatile in-memory key/value store. Redis can act like one (and do that job as well as memcached), but it is a **data structure server**.&#xD;&#xA;&#xD;&#xA;## The Redis Superset&#xD;&#xA;&#xD;&#xA;Here are a few of the features that redis offers which memcached doesn't and allows redis to be used as a ""real"" data store instead of just a cache.&#xD;&#xA;&#xD;&#xA;* __Powerful data types and powerful commands to leverage them. Hashes, Sorted Sets, Lists, and more.__&#xD;&#xA;* Persistence to disk, by default.&#xD;&#xA;* Transactions with optimistic locking (WATCH/MULTI/EXEC)&#xD;&#xA;* Pub/sub. Extremely fast.&#xD;&#xA;* Values up to 512MB in size (memcached limited to 1MB per key)&#xD;&#xA;* Lua scripting (as of 2.6)&#xD;&#xA;* Built in clustering (as of [3.0](http://antirez.com/news/79))&#xD;&#xA;* Extremely fast at everything. Benchmarks are often conflicting, but this much is clear: when used like memcached Redis falls somewhere between nearly as fast or maybe even a little faster. Like memcached it is often bound by available network or memory bandwidth instead of CPU or other bottlenecks and will rarely be the culprit when your app is slowing down.&#xD;&#xA;&#xD;&#xA;The powerful data types are particularly important. They allow redis to provide a fantastic shared queue ([lists](http://redis.io/commands#list)), a great messaging solution ([pub/sub](http://redis.io/commands#pubsub)), a good place for storing sessions ([hashes](http://redis.io/commands#hash)), and a compelling place for high score tracking ([sorted sets](http://redis.io/commands#sorted_set)). These are just a few examples that scratch the surface.&#xD;&#xA;&#xD;&#xA;## Conclusion&#xD;&#xA;&#xD;&#xA;To answer your original question: The performance and memory usage of Redis compared to memcached should be relatively similar. Close enough that for most uses any performance difference in either direction is academic as neither is likely to be the bottleneck.&#xD;&#xA;&#xD;&#xA;Unless you already have a large investment in memcached, going forward redis is the obvious solution. For solutions both tools would solve, go with the one that offers more flexibility for new use cases and also provides better out-of-the-box availability, scalability, and administration: redis.&#xD;&#xA;&#xD;&#xA;Not only is redis the better option for places you might use memcached, it enables whole new types of use cases and usage patterns.&#xD;&#xA;&#xD;&#xA;Memcached is a fine piece of software that is stable and hardened. If you already have a large investment in memcached then you may want to stick with it. There are many use cases where redis is as-good-as memcached but isn't better. Evaluate the benefits of redis (if any) and compare that to the cost of switching. Make your own determination if moving to redis is worth your time.&#xD;&#xA;&#xD;&#xA;**TL;DR**: For anything new, use Redis.";;added 801 characters in body
77041025;11257333;665240;5;89df3010-97c9-4429-a6f5-158d7cf5d621;2014-11-05 19:37:26.0;"**TL;DR**: For anything new, use Redis.&#xD;&#xA;&#xD;&#xA;**Updated 10/9/2014**&#xD;&#xA;&#xD;&#xA;Today marks the day that memcached no longer has any significant advantages over redis, while redis continues to have many distinct advantages over memcached. [Today, redis 3.0, which includes Redis Cluster, exited beta and entered the Release Candidate stage](http://antirez.com/news/79). Previously when looking at memcached vs redis you might be inclined to chose memcached due to the 3rd party clustering tools available. Now redis offers clustering, and unlike memcached support is provided out-of-the-box. Being built-in provides a more robust solution that is easier to administrate. Combined with other high availability tools in-the-box like replication and Sentinel (monitoring), redis clearly has the more compelling scaling story today.&#xD;&#xA;&#xD;&#xA;As of today every major feature and strength memcached offers are now a subset of redis' features and strengths. Any use case you might use memcached for redis can solve equally well. They are both lightning fast as volatile caches. While that's *all* that memcached is its only the tip of the redis iceberg.&#xD;&#xA;&#xD;&#xA;Memcached is a volatile in-memory key/value store. Redis can act like one (and do that job as well as memcached), but it is a **data structure server**.&#xD;&#xA;&#xD;&#xA;## The Redis Superset&#xD;&#xA;&#xD;&#xA;Here are a few of the features that redis offers which memcached doesn't and allows redis to be used as a ""real"" data store instead of just a cache.&#xD;&#xA;&#xD;&#xA;* __Powerful data types and powerful commands to leverage them. Hashes, Sorted Sets, Lists, and more.__&#xD;&#xA;* Persistence to disk, by default.&#xD;&#xA;* Transactions with optimistic locking (WATCH/MULTI/EXEC)&#xD;&#xA;* Pub/sub. Extremely fast.&#xD;&#xA;* Values up to 512MB in size (memcached limited to 1MB per key)&#xD;&#xA;* Lua scripting (as of 2.6)&#xD;&#xA;* Built in clustering (as of [3.0](http://antirez.com/news/79))&#xD;&#xA;* Extremely fast at everything. Benchmarks are often conflicting, but this much is clear: when used like memcached Redis falls somewhere between nearly as fast or maybe even a little faster. Like memcached it is often bound by available network or memory bandwidth instead of CPU or other bottlenecks and will rarely be the culprit when your app is slowing down.&#xD;&#xA;&#xD;&#xA;The powerful data types are particularly important. They allow redis to provide a fantastic shared queue ([lists](http://redis.io/commands#list)), a great messaging solution ([pub/sub](http://redis.io/commands#pubsub)), a good place for storing sessions ([hashes](http://redis.io/commands#hash)), and a compelling place for high score tracking ([sorted sets](http://redis.io/commands#sorted_set)). These are just a few examples that scratch the surface.&#xD;&#xA;&#xD;&#xA;## Conclusion&#xD;&#xA;&#xD;&#xA;To answer your original question: The performance and memory usage of Redis compared to memcached should be relatively similar. Close enough that for most uses any performance difference in either direction is academic as neither is likely to be the bottleneck.&#xD;&#xA;&#xD;&#xA;Unless you already have a large investment in memcached, going forward redis is the obvious solution. For solutions both tools would solve, go with the one that offers more flexibility for new use cases and also provides better out-of-the-box availability, scalability, and administration: redis.&#xD;&#xA;&#xD;&#xA;Not only is redis the better option for places you might use memcached, it enables whole new types of use cases and usage patterns.&#xD;&#xA;&#xD;&#xA;Memcached is a fine piece of software that is stable and hardened. If you already have a large investment in memcached then you may want to stick with it. There are many use cases where redis is as-good-as memcached but isn't better. Evaluate the benefits of redis (if any) and compare that to the cost of switching. Make your own determination if moving to redis is worth your time.";;edited body
83294833;11257333;;5;55eda237-f2bc-4a5b-9775-840eae580921;2015-02-07 21:31:20.0;"**TL;DR**: For anything new, use Redis.&#xD;&#xA;&#xD;&#xA;**Updated 10/9/2014**&#xD;&#xA;&#xD;&#xA;Today marks the day that memcached no longer has any significant advantages over redis, while redis continues to have many distinct advantages over memcached. [Today, redis 3.0, which includes Redis Cluster, exited beta and entered the Release Candidate stage](http://antirez.com/news/79). Previously when looking at memcached vs redis you might have been inclined to choose memcached due to the 3rd party clustering tools available. Now redis offers clustering, and unlike memcached support is provided out-of-the-box. Being built-in provides a more robust solution that is easier to administrate. Combined with other high availability tools in-the-box like replication and Sentinel (monitoring), redis clearly has the more compelling scaling story today.&#xD;&#xA;&#xD;&#xA;As of today every major feature and strength memcached offers are now a subset of redis' features and strengths. Any use case you might use memcached for redis can solve equally well. They are both lightning fast as volatile caches. While that's *all* that memcached is its only the tip of the redis iceberg.&#xD;&#xA;&#xD;&#xA;Memcached is a volatile in-memory key/value store. Redis can act like one (and do that job as well as memcached), but it is a **data structure server**.&#xD;&#xA;&#xD;&#xA;## The Redis Superset&#xD;&#xA;&#xD;&#xA;Here are a few of the features that redis offers which memcached doesn't and allows redis to be used as a ""real"" data store instead of just a cache.&#xD;&#xA;&#xD;&#xA;* __Powerful data types and powerful commands to leverage them. Hashes, Sorted Sets, Lists, and more.__&#xD;&#xA;* Persistence to disk, by default.&#xD;&#xA;* Transactions with optimistic locking (WATCH/MULTI/EXEC)&#xD;&#xA;* Pub/sub. Extremely fast.&#xD;&#xA;* Values up to 512MB in size (memcached limited to 1MB per key)&#xD;&#xA;* Lua scripting (as of 2.6)&#xD;&#xA;* Built in clustering (as of [3.0](http://antirez.com/news/79))&#xD;&#xA;* Extremely fast at everything. Benchmarks are often conflicting, but this much is clear: when used like memcached Redis falls somewhere between nearly as fast or maybe even a little faster. Like memcached it is often bound by available network or memory bandwidth instead of CPU or other bottlenecks and will rarely be the culprit when your app is slowing down.&#xD;&#xA;&#xD;&#xA;The powerful data types are particularly important. They allow redis to provide a fantastic shared queue ([lists](http://redis.io/commands#list)), a great messaging solution ([pub/sub](http://redis.io/commands#pubsub)), a good place for storing sessions ([hashes](http://redis.io/commands#hash)), and a compelling place for high score tracking ([sorted sets](http://redis.io/commands#sorted_set)). These are just a few examples that scratch the surface.&#xD;&#xA;&#xD;&#xA;## Conclusion&#xD;&#xA;&#xD;&#xA;To answer your original question: The performance and memory usage of Redis compared to memcached should be relatively similar. Close enough that for most uses any performance difference in either direction is academic as neither is likely to be the bottleneck.&#xD;&#xA;&#xD;&#xA;Unless you already have a large investment in memcached, going forward redis is the obvious solution. For solutions both tools would solve, go with the one that offers more flexibility for new use cases and also provides better out-of-the-box availability, scalability, and administration: redis.&#xD;&#xA;&#xD;&#xA;Not only is redis the better option for places you might use memcached, it enables whole new types of use cases and usage patterns.&#xD;&#xA;&#xD;&#xA;Memcached is a fine piece of software that is stable and hardened. If you already have a large investment in memcached then you may want to stick with it. There are many use cases where redis is as-good-as memcached but isn't better. Evaluate the benefits of redis (if any) and compare that to the cost of switching. Make your own determination if moving to redis is worth your time.";user1128272;fixed grammar
84252009;11257333;665240;5;cd0a7958-86e1-4bee-a5e4-7c4567178d1d;2015-02-20 23:35:05.0;"**TL;DR**: For anything new, use Redis.&#xD;&#xA;&#xD;&#xA;**Updated 10/9/2014**&#xD;&#xA;&#xD;&#xA;Today marks the day that memcached no longer has any significant advantages over redis, while redis continues to have many distinct advantages over memcached. [Today, redis 3.0, which includes Redis Cluster, entered the Release Candidate stage](http://antirez.com/news/79). Previously when looking at memcached vs redis you might have been inclined to choose memcached due to the 3rd party clustering tools available. Now redis offers clustering, and unlike memcached support is provided out-of-the-box. Being built-in provides a more robust solution that is easier to administrate. Combined with other high availability tools in-the-box like replication and Sentinel (monitoring), redis clearly has the more compelling scaling story today.&#xD;&#xA;&#xD;&#xA;As of today every major feature and strength memcached offers are now a subset of redis' features and strengths. Any use case you might use memcached for redis can solve equally well. They are both lightning fast as volatile caches. While that's *all* that memcached is its only the tip of the redis iceberg.&#xD;&#xA;&#xD;&#xA;Memcached is a volatile in-memory key/value store. Redis can act like one (and do that job as well as memcached), but it is a **data structure server**.&#xD;&#xA;&#xD;&#xA;## The Redis Superset&#xD;&#xA;&#xD;&#xA;Here are a few of the features that redis offers which memcached doesn't and allows redis to be used as a ""real"" data store instead of just a cache.&#xD;&#xA;&#xD;&#xA;* __Powerful data types and powerful commands to leverage them. Hashes, Sorted Sets, Lists, and more.__&#xD;&#xA;* Persistence to disk, by default.&#xD;&#xA;* Transactions with optimistic locking (WATCH/MULTI/EXEC)&#xD;&#xA;* Pub/sub. Extremely fast.&#xD;&#xA;* Values up to 512MB in size (memcached limited to 1MB per key)&#xD;&#xA;* Lua scripting (as of 2.6)&#xD;&#xA;* Built in clustering (as of [3.0](http://antirez.com/news/79))&#xD;&#xA;* Extremely fast at everything. Benchmarks are often conflicting, but this much is clear: when used like memcached Redis falls somewhere between nearly as fast or maybe even a little faster. Like memcached it is often bound by available network or memory bandwidth instead of CPU or other bottlenecks and will rarely be the culprit when your app is slowing down.&#xD;&#xA;&#xD;&#xA;The powerful data types are particularly important. They allow redis to provide a fantastic shared queue ([lists](http://redis.io/commands#list)), a great messaging solution ([pub/sub](http://redis.io/commands#pubsub)), a good place for storing sessions ([hashes](http://redis.io/commands#hash)), and a compelling place for high score tracking ([sorted sets](http://redis.io/commands#sorted_set)). These are just a few examples that scratch the surface.&#xD;&#xA;&#xD;&#xA;## Conclusion&#xD;&#xA;&#xD;&#xA;To answer your original question: The performance and memory usage of Redis compared to memcached should be relatively similar. Close enough that for most uses any performance difference in either direction is academic as neither is likely to be the bottleneck.&#xD;&#xA;&#xD;&#xA;Unless you already have a large investment in memcached, going forward redis is the obvious solution. For solutions both tools would solve, go with the one that offers more flexibility for new use cases and also provides better out-of-the-box availability, scalability, and administration: redis.&#xD;&#xA;&#xD;&#xA;Not only is redis the better option for places you might use memcached, it enables whole new types of use cases and usage patterns.&#xD;&#xA;&#xD;&#xA;Memcached is a fine piece of software that is stable and hardened. If you already have a large investment in memcached then you may want to stick with it. There are many use cases where redis is as-good-as memcached but isn't better. Evaluate the benefits of redis (if any) and compare that to the cost of switching. Make your own determination if moving to redis is worth your time.";;deleted 16 characters in body
87206088;11257333;665240;5;619d441a-0625-456c-9932-ea295736f5ec;2015-04-02 02:07:29.0;"**TL;DR**: For anything new, use Redis.&#xD;&#xA;&#xD;&#xA;**Updated 4/1/2015**&#xD;&#xA;&#xD;&#xA;Today marks the day that memcached no longer has any significant advantages over redis, while redis continues to have many distinct advantages over memcached. [Today marks the release of redis 3.0, with support for clustering](https://groups.google.com/forum/#!msg/redis-db/dO0bFyD_THQ/Uoo2GjIx6qgJ). Previously when looking at memcached vs redis you might have been inclined to choose memcached due to the 3rd party clustering tools available. Now redis offers clustering, and unlike memcached support is provided out-of-the-box. Being built-in provides a more robust solution that is easier to administrate. Combined with other high availability tools in-the-box like replication and Sentinel (monitoring), redis clearly has the more compelling scaling story today.&#xD;&#xA;&#xD;&#xA;As of today every major feature and strength memcached offers are now a subset of redis' features and strengths. Any use case you might use memcached for redis can solve equally well. They are both lightning fast as volatile caches. While that's *all* that memcached is its only the tip of the redis iceberg.&#xD;&#xA;&#xD;&#xA;Memcached is a volatile in-memory key/value store. Redis can act like one (and do that job as well as memcached), but it is a **data structure server**.&#xD;&#xA;&#xD;&#xA;## The Redis Superset&#xD;&#xA;&#xD;&#xA;Here are a few of the features that redis offers which memcached doesn't and allows redis to be used as a ""real"" data store instead of just a cache.&#xD;&#xA;&#xD;&#xA;* __Powerful data types and powerful commands to leverage them. Hashes, Sorted Sets, Lists, and more.__&#xD;&#xA;* Persistence to disk, by default.&#xD;&#xA;* Transactions with optimistic locking (WATCH/MULTI/EXEC)&#xD;&#xA;* Pub/sub. Extremely fast.&#xD;&#xA;* Values up to 512MB in size (memcached limited to 1MB per key)&#xD;&#xA;* Lua scripting (as of 2.6)&#xD;&#xA;* Built in clustering (as of [3.0](http://antirez.com/news/79))&#xD;&#xA;* Extremely fast at everything. Benchmarks are often conflicting, but this much is clear: when used like memcached Redis falls somewhere between nearly as fast or maybe even a little faster. Like memcached it is often bound by available network or memory bandwidth instead of CPU or other bottlenecks and will rarely be the culprit when your app is slowing down.&#xD;&#xA;&#xD;&#xA;The powerful data types are particularly important. They allow redis to provide a fantastic shared queue ([lists](http://redis.io/commands#list)), a great messaging solution ([pub/sub](http://redis.io/commands#pubsub)), a good place for storing sessions ([hashes](http://redis.io/commands#hash)), and a compelling place for high score tracking ([sorted sets](http://redis.io/commands#sorted_set)). These are just a few examples that scratch the surface.&#xD;&#xA;&#xD;&#xA;## Conclusion&#xD;&#xA;&#xD;&#xA;To answer your original question: The performance and memory usage of Redis compared to memcached should be relatively similar. Close enough that for most uses any performance difference in either direction is academic as neither is likely to be the bottleneck.&#xD;&#xA;&#xD;&#xA;Unless you already have a large investment in memcached, going forward redis is the obvious solution. For solutions both tools would solve, go with the one that offers more flexibility for new use cases and also provides better out-of-the-box availability, scalability, and administration: redis.&#xD;&#xA;&#xD;&#xA;Not only is redis the better option for places you might use memcached, it enables whole new types of use cases and usage patterns.&#xD;&#xA;&#xD;&#xA;Memcached is a fine piece of software that is stable and hardened. If you already have a large investment in memcached then you may want to stick with it. There are many use cases where redis is as-good-as memcached but isn't better. Evaluate the benefits of redis (if any) and compare that to the cost of switching. Make your own determination if moving to redis is worth your time.";;Updated to reflect redis 3.0 stable release
148541895;11257333;665240;5;9c4e8611-ae5f-47fe-9343-8d10ed0f918e;2017-06-03 06:55:19.0;"# Summary (TL;DR)&#xD;&#xA;&#xD;&#xA;__Updated June 3rd, 2017__&#xD;&#xA;&#xD;&#xA;Redis is more powerful, more popular, and better supported than memcached. Memcached can only do a small fraction of the things Redis can do. Redis is better even where their features overlap.&#xD;&#xA;&#xD;&#xA;For anything new, use Redis.&#xD;&#xA;&#xD;&#xA;# Memcached vs Redis: Direct Comparison&#xD;&#xA;&#xD;&#xA;Both tools are powerful, fast, in-memory data stores that are useful as a cache. Both can help speed up your application by caching database results, HTML fragments, or anything else that might be expensive to generate.&#xD;&#xA;&#xD;&#xA;## Points to Consider&#xD;&#xA;&#xD;&#xA;When used for the same thing, here is how they compare using the original question's ""Points to Consider"":&#xD;&#xA;&#xD;&#xA;* __Read/write speed__: Both are extremely fast. Benchmarks vary by workload, versions, and many other factors but generally show redis to be as fast or almost as fast as memcached. I recommend redis, but not because memcached is slow. It's not.&#xD;&#xA;* __Memory usage__: Redis is better.&#xD;&#xA;  * memcached: You specify the cache size and as you insert items the daemon quickly grows to a little more than this size. There is never really a way to reclaim any of that space, short of restarting memcached. All your keys could be expired, you could flush the database, and it would still use the full chunk of RAM you configured it with.&#xD;&#xA;  * redis: Setting a max size is up to you. Redis will never use more than it has to and will give you back memory it is no longer using.&#xD;&#xA;  * I stored 100,000 ~2KB strings (~200MB) of random sentences into both. Memcached RAM usage grew to ~225MB. Redis RAM usage grew to ~228MB. After flushing both, redis dropped to ~29MB and memcached stayed at ~225MB. They are similarly efficient in how they store data, but only one is capable of reclaiming it.&#xD;&#xA;* __Disk I/O dumping__: A clear win for redis since it does this by default and has very configurable persistence. Memcached has no mechanisms for dumping to disk without 3rd party tools.&#xD;&#xA;* __Scaling__: Both give you tons of headroom before you need more than a single instance as a cache. Redis includes tools to help you go beyond that while memcached does not.&#xD;&#xA;&#xD;&#xA;## memcached&#xD;&#xA;&#xD;&#xA;Memcached is a simple volatile cache server. It allows you to store key/value pairs where the value is limited to being a string up to 1MB.&#xD;&#xA;&#xD;&#xA;It's good at this, but that's all it does. You can access those values by their key at extremely high speed, often saturating available network or even memory bandwidth.&#xD;&#xA;&#xD;&#xA;When you restart memcached your data is gone. This is fine for a cache. You shouldn't store anything important there.&#xD;&#xA;&#xD;&#xA;If you need high performance or high availability there are 3rd party tools, products, and services available.&#xD;&#xA;&#xD;&#xA;## redis&#xD;&#xA;&#xD;&#xA;Redis can do the same jobs as memcached can, and can do them better.&#xD;&#xA;&#xD;&#xA;Redis can act as a cache as well. It can store key/value pairs too. In redis they can even be up to 512MB.&#xD;&#xA;&#xD;&#xA;You can turn off persistence and it will happily lose your data on restart too. If you want your cache to survive restarts it lets you do that as well. In fact, that's the default.&#xD;&#xA;&#xD;&#xA;It's super fast too, often limited by network or memory bandwidth.&#xD;&#xA;&#xD;&#xA;If one instance of redis/memcached isn't enough performance for your workload, redis is the clear choice. Redis includes [cluster support][cluster] and comes with high availability tools ([redis-sentinel][sentinel]) right ""in the box"". Over the past few years redis has also emerged as the clear leader in 3rd party tooling. Companies like Redis Labs, Amazon, and others offer many useful redis tools and services. The ecosystem around redis is much larger. The number of large scale deployments is now likely greater than for memcached.&#xD;&#xA;&#xD;&#xA;# The Redis Superset&#xD;&#xA;&#xD;&#xA;Redis is more than a cache. It is an in-memory data structure server. Below you will find a quick overview of things Redis can do beyond being a simple key/value cache like memcached. *Most* of redis' features are things memcached cannot do.&#xD;&#xA;&#xD;&#xA;## Documentation&#xD;&#xA;&#xD;&#xA;Redis is better documented than memcached. While this can be subjective, it seems to be more and more true all the time.&#xD;&#xA;&#xD;&#xA;[redis.io][redis] is a fantastic easily navigated resource. It lets you [try redis in the browser][try_redis] and even gives you live interactive examples with each command in the docs.&#xD;&#xA;&#xD;&#xA;There are now 2x as many stackoverflow results for redis as memcached. 2x as many Google results. More readily accessible examples in more languages. More active development. More active client development. These measurements might not mean much individually, but in combination they paint a clear picture that support and documentation for redis is greater and much more up-to-date.&#xD;&#xA;&#xD;&#xA;## [Persistence][persistence]&#xD;&#xA;&#xD;&#xA;By default redis persists your data to disk using a mechanism called snapshotting. If you have enough RAM available it's able to write all of your data to disk with almost no performance degradation. It's almost free!&#xD;&#xA;&#xD;&#xA;In snapshot mode there is a chance that a sudden crash could result in a small amount of lost data. If you absolutely need to make sure no data is ever lost, don't worry, redis has your back there too with AOF (Append Only File) mode. In this persistence mode data can be synced to disk as it is written. This can reduce maximum write throughput to however fast your disk can write, but should still be quite fast.&#xD;&#xA;&#xD;&#xA;There are many configuration options to fine tune persistence if you need, but the defaults are very sensible.&#xD;&#xA;&#xD;&#xA;## Many Data Types&#xD;&#xA;&#xD;&#xA;Memcached is limited to strings, but Redis is a data structure server that can serve up many different data types. It also provides the commands you need to make the most of those data types.&#xD;&#xA;&#xD;&#xA;### Strings ([commands][string_commands])&#xD;&#xA;&#xD;&#xA;Simple text or binary values that can be up to 512MB in size. This is the only data type redis and memcached share, though memcached strings are limited to 1MB.&#xD;&#xA;&#xD;&#xA;Redis gives you more tools for leveraging this datatype by offering commands for bitwise operations, bit-level manipulation, floating point increment/decrement support, range queries, and multi-key operations. Memcached doesn't support any of that.&#xD;&#xA;&#xD;&#xA;Strings are useful for all sorts of use cases, which is why memcached is fairly useful with this data type alone.&#xD;&#xA;&#xD;&#xA;### Hashes ([commands][hash_commands])&#xD;&#xA;&#xD;&#xA;Hashes are sort of like a key value store within a key value store. They map between string fields and string values. Field->value maps using a hash are slightly more space efficient than key->value maps using regular strings.&#xD;&#xA;&#xD;&#xA;Hashes are useful as a namespace, or when you want to logically group many keys. With a hash you can grab all the members efficiently, expire all the members together, delete all the members together, etc. Great for any use case where you have several key/value pairs that need to grouped.&#xD;&#xA;&#xD;&#xA;One example use of a hash is for storing user profiles between applications. A redis hash stored with the user ID as the key will allow you to store as many bits of data about a user as needed while keeping them stored under a single key. The advantage of using a hash instead of serializing the profile into a string is that you can have different applications read/write different fields within the user profile without having to worry about one app overriding changes made by others (which can happen if you serialize stale data).&#xD;&#xA;&#xD;&#xA;### Lists ([commands][list_commands])&#xD;&#xA;&#xD;&#xA;Redis lists are ordered collections of strings. They are optimized for inserting, reading, or removing values from the top or bottom (aka: left or right) of the list.&#xD;&#xA;&#xD;&#xA;Redis provides many [commands][list_commands] for leveraging lists, including commands to push/pop items, push/pop between lists, truncate lists, perform range queries, etc.&#xD;&#xA;&#xD;&#xA;Lists make great durable, atomic, queues. These work great for job queues, logs, buffers, and many other use cases.&#xD;&#xA;&#xD;&#xA;### Sets ([commands][set_commands])&#xD;&#xA;&#xD;&#xA;Sets are unordered collections of unique values. They are optimized to let you quickly check if a value is in the set, quickly add/remove values, and to measure overlap with other sets.&#xD;&#xA;&#xD;&#xA;These are great for things like access control lists, unique visitor trackers, and many other things. Most programming languages have something similar (usually called a Set). This is like that, only distributed.&#xD;&#xA;&#xD;&#xA;Redis provides several [commands][set_commands] to manage sets. Obvious ones like adding, removing, and checking the set are present. So are less obvious commands like popping/reading a random item and commands for performing unions and intersections with other sets.&#xD;&#xA;&#xD;&#xA;### Sorted Sets ([commands][sorted_set_commands])&#xD;&#xA;&#xD;&#xA;Sorted Sets are also collections of unique values. These ones, as the name implies, are ordered. They are ordered by a score, then lexicographically.&#xD;&#xA;&#xD;&#xA;This data type is optimized for quick lookups by score. Getting the highest, lowest, or any range of values in between is extremely fast.&#xD;&#xA;&#xD;&#xA;If you add users to a sorted set along with their high score, you have yourself a perfect leader-board. As new high scores come in, just add them to the set again with their high score and it will re-order your leader-board. Also great for keeping track of the last time users visited and who is active in your application.&#xD;&#xA;&#xD;&#xA;Storing values with the same score causes them to be ordered lexicographically (think alphabetically). This can be useful for things like auto-complete features.&#xD;&#xA;&#xD;&#xA;Many of the sorted set [commands][sorted_set_commands] are similar to commands for sets, sometimes with an additional score parameter. Also included are commands for managing scores and querying by score.&#xD;&#xA;&#xD;&#xA;### Geo&#xD;&#xA;&#xD;&#xA;Redis has several [commands][geo_commands] for storing, retrieving, and measuring geographic data. This includes radius queries and measuring distances between points.&#xD;&#xA;&#xD;&#xA;Technically geographic data in redis is stored within sorted sets, so this isn't a truly separate data type. It is more of an extension on top of sorted sets.&#xD;&#xA;&#xD;&#xA;### Bitmap and HyperLogLog&#xD;&#xA;&#xD;&#xA;Like geo, these aren't completely separate data types. These are commands that allow you to treat string data as if it's either a bitmap or a hyperloglog.&#xD;&#xA;&#xD;&#xA;Bitmaps are what the bit-level operators I referenced under `Strings` are for. This data type was the basic building block for reddit's recent collaborative art project: [r/Place][rplace].&#xD;&#xA;&#xD;&#xA;HyperLogLog allows you to use a constant extremely small amount of space to count almost unlimited unique values with shocking accuracy. Using only ~16KB you could efficiently count the number of unique visitors to your site, even if that number is in the millions.&#xD;&#xA;&#xD;&#xA;## Transactions and Atomicity&#xD;&#xA;&#xD;&#xA;Commands in redis are atomic, meaning you can be sure that as soon as you write a value to redis that value is visible to all clients connected to redis. There is no wait for that value to propagate. Technically memcached is atomic as well, but with redis adding all this functionality beyond memcached it is worth noting and somewhat impressive that all these additional data types and features are also atomic.&#xD;&#xA;&#xD;&#xA;While not quite the same as transactions in relational databases, redis also has [transactions][] that use ""optimistic locking"" ([WATCH][watch_command]/[MULTI][multi_command]/[EXEC][exec_command]).&#xD;&#xA;&#xD;&#xA;## Pipelining&#xD;&#xA;&#xD;&#xA;Redis provides a feature called '[pipelining][]'. If you have many redis commands you want to execute you can use pipelining to send them to redis all-at-once instead of one-at-a-time.&#xD;&#xA;&#xD;&#xA;Normally when you execute a command to either redis or memcached, each command is a separate request/response cycle. With pipelining, redis can buffer several commands and execute them all at once, responding with all of the responses to all of your commands in a single reply.&#xD;&#xA;&#xD;&#xA;This can allow you to achieve even greater throughput on bulk importing or other actions that involve lots of commands.&#xD;&#xA;&#xD;&#xA;## Pub/Sub&#xD;&#xA;&#xD;&#xA;Redis has [commands][pubsub_commands] dedicated to [pub/sub functionality][pubsub], allowing redis to act as a high speed message broadcaster. This allows a single client to publish messages to many other clients connected to a channel.&#xD;&#xA;&#xD;&#xA;Redis does pub/sub as well as almost any tool. Dedicated message brokers like [RabbitMQ][rabbitmq] may have advantages in certain areas, but the fact that the same server can also give you persistent durable queues and other data structures your pub/sub workloads likely need, Redis will often prove to be the best and most simple tool for the job.&#xD;&#xA;&#xD;&#xA;## Lua Scripting&#xD;&#xA;&#xD;&#xA;You can kind of think of [lua scripts][eval_command] like redis's own SQL or stored procedures. It's both more and less than that, but the analogy mostly works.&#xD;&#xA;&#xD;&#xA;Maybe you have complex calculations you want redis to perform. Maybe you can't afford to have your transactions roll back and need guarantees every step of a complex process will happen atomically. These problems and many more can be solved with lua scripting.&#xD;&#xA;&#xD;&#xA;The entire script is executed atomically, so if you can fit your logic into a lua script you can often avoid messing with optimistic locking transactions.&#xD;&#xA;&#xD;&#xA;## Scaling&#xD;&#xA;&#xD;&#xA;As mentioned above, redis includes built in support for clustering and is bundled with its own high availability tool called `redis-sentinel`.&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;&#xD;&#xA;Without hesitation I would recommend redis over memcached for any new projects, or existing projects that don't already use memcached.&#xD;&#xA;&#xD;&#xA;The above may sound like I don't like memcached. On the contrary: it is a powerful, simple, stable, mature, and hardened tool. There are even some use cases where it's a little faster than redis. I love memcached. I just don't think it makes much sense for future development.&#xD;&#xA;&#xD;&#xA;Redis does everything memcached does, often better. Any performance advantage for memcached is minor and workload specific. There are also workloads for which redis will be faster, and many more workloads that redis can do which memcached simply can't. The tiny performance differences seem minor in the face of the giant gulf in functionality and the fact that both tools are so fast and efficient they may very well be the last piece of your infrastructure you'll ever have to worry about scaling.&#xD;&#xA;&#xD;&#xA;There is only one scenario where memcached makes more sense: where memcached is already in use as a cache. If you are already caching with memcached then keep using it, if it meets your needs. It is likely not worth the effort to move to redis and if you are going to use redis just for caching it may not offer enough benefit to be worth your time. If memcached isn't meeting your needs, then you should probably move to redis. This is true whether you need to scale beyond memcached or you need additional functionality.&#xD;&#xA;&#xD;&#xA;[string_commands]: https://redis.io/commands#string&#xD;&#xA;[hash_commands]: https://redis.io/commands#hash&#xD;&#xA;[list_commands]: https://redis.io/commands#list&#xD;&#xA;[set_commands]: https://redis.io/commands#set&#xD;&#xA;[sorted_set_commands]: https://redis.io/commands#sorted_set&#xD;&#xA;[pubsub_commands]: https://redis.io/commands#pubsub&#xD;&#xA;[geo_commands]: https://redis.io/commands#geo&#xD;&#xA;[persistence]: https://redis.io/topics/persistence&#xD;&#xA;[redis]: https://redis.io/&#xD;&#xA;[try_redis]: https://try.redis.io/&#xD;&#xA;[cluster]: https://redis.io/topics/cluster-tutorial&#xD;&#xA;[sentinel]: https://redis.io/topics/sentinel&#xD;&#xA;[rplace]: https://redditblog.com/2017/04/13/how-we-built-rplace/&#xD;&#xA;[transactions]: https://redis.io/topics/transactions&#xD;&#xA;[watch_command]: https://redis.io/commands/watch&#xD;&#xA;[multi_command]: https://redis.io/commands/multi&#xD;&#xA;[exec_command]: https://redis.io/commands/exec&#xD;&#xA;[eval_command]: https://redis.io/commands/eval&#xD;&#xA;[pubsub]: https://redis.io/topics/pubsub&#xD;&#xA;[rabbitmq]: https://www.rabbitmq.com/&#xD;&#xA;[pipelining]: https://redis.io/topics/pipelining&#xD;&#xA;";;Major updates including providing more up-to-date information and greatly expanding details on many topics
148542314;11257333;665240;5;74b27dcb-bf78-45de-90c4-dc0da75bb48b;2017-06-03 07:08:17.0;"# Summary (TL;DR)&#xD;&#xA;&#xD;&#xA;__Updated June 3rd, 2017__&#xD;&#xA;&#xD;&#xA;Redis is more powerful, more popular, and better supported than memcached. Memcached can only do a small fraction of the things Redis can do. Redis is better even where their features overlap.&#xD;&#xA;&#xD;&#xA;For anything new, use Redis.&#xD;&#xA;&#xD;&#xA;# Memcached vs Redis: Direct Comparison&#xD;&#xA;&#xD;&#xA;Both tools are powerful, fast, in-memory data stores that are useful as a cache. Both can help speed up your application by caching database results, HTML fragments, or anything else that might be expensive to generate.&#xD;&#xA;&#xD;&#xA;## Points to Consider&#xD;&#xA;&#xD;&#xA;When used for the same thing, here is how they compare using the original question's ""Points to Consider"":&#xD;&#xA;&#xD;&#xA;* __Read/write speed__: Both are extremely fast. Benchmarks vary by workload, versions, and many other factors but generally show redis to be as fast or almost as fast as memcached. I recommend redis, but not because memcached is slow. It's not.&#xD;&#xA;* __Memory usage__: Redis is better.&#xD;&#xA;  * memcached: You specify the cache size and as you insert items the daemon quickly grows to a little more than this size. There is never really a way to reclaim any of that space, short of restarting memcached. All your keys could be expired, you could flush the database, and it would still use the full chunk of RAM you configured it with.&#xD;&#xA;  * redis: Setting a max size is up to you. Redis will never use more than it has to and will give you back memory it is no longer using.&#xD;&#xA;  * I stored 100,000 ~2KB strings (~200MB) of random sentences into both. Memcached RAM usage grew to ~225MB. Redis RAM usage grew to ~228MB. After flushing both, redis dropped to ~29MB and memcached stayed at ~225MB. They are similarly efficient in how they store data, but only one is capable of reclaiming it.&#xD;&#xA;* __Disk I/O dumping__: A clear win for redis since it does this by default and has very configurable persistence. Memcached has no mechanisms for dumping to disk without 3rd party tools.&#xD;&#xA;* __Scaling__: Both give you tons of headroom before you need more than a single instance as a cache. Redis includes tools to help you go beyond that while memcached does not.&#xD;&#xA;&#xD;&#xA;## memcached&#xD;&#xA;&#xD;&#xA;Memcached is a simple volatile cache server. It allows you to store key/value pairs where the value is limited to being a string up to 1MB.&#xD;&#xA;&#xD;&#xA;It's good at this, but that's all it does. You can access those values by their key at extremely high speed, often saturating available network or even memory bandwidth.&#xD;&#xA;&#xD;&#xA;When you restart memcached your data is gone. This is fine for a cache. You shouldn't store anything important there.&#xD;&#xA;&#xD;&#xA;If you need high performance or high availability there are 3rd party tools, products, and services available.&#xD;&#xA;&#xD;&#xA;## redis&#xD;&#xA;&#xD;&#xA;Redis can do the same jobs as memcached can, and can do them better.&#xD;&#xA;&#xD;&#xA;Redis can [act as a cache][lru_cache] as well. It can store key/value pairs too. In redis they can even be up to 512MB.&#xD;&#xA;&#xD;&#xA;You can turn off persistence and it will happily lose your data on restart too. If you want your cache to survive restarts it lets you do that as well. In fact, that's the default.&#xD;&#xA;&#xD;&#xA;It's super fast too, often limited by network or memory bandwidth.&#xD;&#xA;&#xD;&#xA;If one instance of redis/memcached isn't enough performance for your workload, redis is the clear choice. Redis includes [cluster support][cluster] and comes with high availability tools ([redis-sentinel][sentinel]) right ""in the box"". Over the past few years redis has also emerged as the clear leader in 3rd party tooling. Companies like Redis Labs, Amazon, and others offer many useful redis tools and services. The ecosystem around redis is much larger. The number of large scale deployments is now likely greater than for memcached.&#xD;&#xA;&#xD;&#xA;# The Redis Superset&#xD;&#xA;&#xD;&#xA;Redis is more than a cache. It is an in-memory data structure server. Below you will find a quick overview of things Redis can do beyond being a simple key/value cache like memcached. *Most* of redis' features are things memcached cannot do.&#xD;&#xA;&#xD;&#xA;## Documentation&#xD;&#xA;&#xD;&#xA;Redis is better documented than memcached. While this can be subjective, it seems to be more and more true all the time.&#xD;&#xA;&#xD;&#xA;[redis.io][redis] is a fantastic easily navigated resource. It lets you [try redis in the browser][try_redis] and even gives you live interactive examples with each command in the docs.&#xD;&#xA;&#xD;&#xA;There are now 2x as many stackoverflow results for redis as memcached. 2x as many Google results. More readily accessible examples in more languages. More active development. More active client development. These measurements might not mean much individually, but in combination they paint a clear picture that support and documentation for redis is greater and much more up-to-date.&#xD;&#xA;&#xD;&#xA;## [Persistence][persistence]&#xD;&#xA;&#xD;&#xA;By default redis persists your data to disk using a mechanism called snapshotting. If you have enough RAM available it's able to write all of your data to disk with almost no performance degradation. It's almost free!&#xD;&#xA;&#xD;&#xA;In snapshot mode there is a chance that a sudden crash could result in a small amount of lost data. If you absolutely need to make sure no data is ever lost, don't worry, redis has your back there too with AOF (Append Only File) mode. In this persistence mode data can be synced to disk as it is written. This can reduce maximum write throughput to however fast your disk can write, but should still be quite fast.&#xD;&#xA;&#xD;&#xA;There are many configuration options to fine tune persistence if you need, but the defaults are very sensible. These options make it easy to setup redis as a safe, redundant place to store data. It is a *real* database.&#xD;&#xA;&#xD;&#xA;## Many Data Types&#xD;&#xA;&#xD;&#xA;Memcached is limited to strings, but Redis is a data structure server that can serve up many different data types. It also provides the commands you need to make the most of those data types.&#xD;&#xA;&#xD;&#xA;### Strings ([commands][string_commands])&#xD;&#xA;&#xD;&#xA;Simple text or binary values that can be up to 512MB in size. This is the only data type redis and memcached share, though memcached strings are limited to 1MB.&#xD;&#xA;&#xD;&#xA;Redis gives you more tools for leveraging this datatype by offering commands for bitwise operations, bit-level manipulation, floating point increment/decrement support, range queries, and multi-key operations. Memcached doesn't support any of that.&#xD;&#xA;&#xD;&#xA;Strings are useful for all sorts of use cases, which is why memcached is fairly useful with this data type alone.&#xD;&#xA;&#xD;&#xA;### Hashes ([commands][hash_commands])&#xD;&#xA;&#xD;&#xA;Hashes are sort of like a key value store within a key value store. They map between string fields and string values. Field->value maps using a hash are slightly more space efficient than key->value maps using regular strings.&#xD;&#xA;&#xD;&#xA;Hashes are useful as a namespace, or when you want to logically group many keys. With a hash you can grab all the members efficiently, expire all the members together, delete all the members together, etc. Great for any use case where you have several key/value pairs that need to grouped.&#xD;&#xA;&#xD;&#xA;One example use of a hash is for storing user profiles between applications. A redis hash stored with the user ID as the key will allow you to store as many bits of data about a user as needed while keeping them stored under a single key. The advantage of using a hash instead of serializing the profile into a string is that you can have different applications read/write different fields within the user profile without having to worry about one app overriding changes made by others (which can happen if you serialize stale data).&#xD;&#xA;&#xD;&#xA;### Lists ([commands][list_commands])&#xD;&#xA;&#xD;&#xA;Redis lists are ordered collections of strings. They are optimized for inserting, reading, or removing values from the top or bottom (aka: left or right) of the list.&#xD;&#xA;&#xD;&#xA;Redis provides many [commands][list_commands] for leveraging lists, including commands to push/pop items, push/pop between lists, truncate lists, perform range queries, etc.&#xD;&#xA;&#xD;&#xA;Lists make great durable, atomic, queues. These work great for job queues, logs, buffers, and many other use cases.&#xD;&#xA;&#xD;&#xA;### Sets ([commands][set_commands])&#xD;&#xA;&#xD;&#xA;Sets are unordered collections of unique values. They are optimized to let you quickly check if a value is in the set, quickly add/remove values, and to measure overlap with other sets.&#xD;&#xA;&#xD;&#xA;These are great for things like access control lists, unique visitor trackers, and many other things. Most programming languages have something similar (usually called a Set). This is like that, only distributed.&#xD;&#xA;&#xD;&#xA;Redis provides several [commands][set_commands] to manage sets. Obvious ones like adding, removing, and checking the set are present. So are less obvious commands like popping/reading a random item and commands for performing unions and intersections with other sets.&#xD;&#xA;&#xD;&#xA;### Sorted Sets ([commands][sorted_set_commands])&#xD;&#xA;&#xD;&#xA;Sorted Sets are also collections of unique values. These ones, as the name implies, are ordered. They are ordered by a score, then lexicographically.&#xD;&#xA;&#xD;&#xA;This data type is optimized for quick lookups by score. Getting the highest, lowest, or any range of values in between is extremely fast.&#xD;&#xA;&#xD;&#xA;If you add users to a sorted set along with their high score, you have yourself a perfect leader-board. As new high scores come in, just add them to the set again with their high score and it will re-order your leader-board. Also great for keeping track of the last time users visited and who is active in your application.&#xD;&#xA;&#xD;&#xA;Storing values with the same score causes them to be ordered lexicographically (think alphabetically). This can be useful for things like auto-complete features.&#xD;&#xA;&#xD;&#xA;Many of the sorted set [commands][sorted_set_commands] are similar to commands for sets, sometimes with an additional score parameter. Also included are commands for managing scores and querying by score.&#xD;&#xA;&#xD;&#xA;### Geo&#xD;&#xA;&#xD;&#xA;Redis has several [commands][geo_commands] for storing, retrieving, and measuring geographic data. This includes radius queries and measuring distances between points.&#xD;&#xA;&#xD;&#xA;Technically geographic data in redis is stored within sorted sets, so this isn't a truly separate data type. It is more of an extension on top of sorted sets.&#xD;&#xA;&#xD;&#xA;### Bitmap and HyperLogLog&#xD;&#xA;&#xD;&#xA;Like geo, these aren't completely separate data types. These are commands that allow you to treat string data as if it's either a bitmap or a hyperloglog.&#xD;&#xA;&#xD;&#xA;Bitmaps are what the bit-level operators I referenced under `Strings` are for. This data type was the basic building block for reddit's recent collaborative art project: [r/Place][rplace].&#xD;&#xA;&#xD;&#xA;HyperLogLog allows you to use a constant extremely small amount of space to count almost unlimited unique values with shocking accuracy. Using only ~16KB you could efficiently count the number of unique visitors to your site, even if that number is in the millions.&#xD;&#xA;&#xD;&#xA;## Transactions and Atomicity&#xD;&#xA;&#xD;&#xA;Commands in redis are atomic, meaning you can be sure that as soon as you write a value to redis that value is visible to all clients connected to redis. There is no wait for that value to propagate. Technically memcached is atomic as well, but with redis adding all this functionality beyond memcached it is worth noting and somewhat impressive that all these additional data types and features are also atomic.&#xD;&#xA;&#xD;&#xA;While not quite the same as transactions in relational databases, redis also has [transactions][] that use ""optimistic locking"" ([WATCH][watch_command]/[MULTI][multi_command]/[EXEC][exec_command]).&#xD;&#xA;&#xD;&#xA;## Pipelining&#xD;&#xA;&#xD;&#xA;Redis provides a feature called '[pipelining][]'. If you have many redis commands you want to execute you can use pipelining to send them to redis all-at-once instead of one-at-a-time.&#xD;&#xA;&#xD;&#xA;Normally when you execute a command to either redis or memcached, each command is a separate request/response cycle. With pipelining, redis can buffer several commands and execute them all at once, responding with all of the responses to all of your commands in a single reply.&#xD;&#xA;&#xD;&#xA;This can allow you to achieve even greater throughput on bulk importing or other actions that involve lots of commands.&#xD;&#xA;&#xD;&#xA;## Pub/Sub&#xD;&#xA;&#xD;&#xA;Redis has [commands][pubsub_commands] dedicated to [pub/sub functionality][pubsub], allowing redis to act as a high speed message broadcaster. This allows a single client to publish messages to many other clients connected to a channel.&#xD;&#xA;&#xD;&#xA;Redis does pub/sub as well as almost any tool. Dedicated message brokers like [RabbitMQ][rabbitmq] may have advantages in certain areas, but the fact that the same server can also give you persistent durable queues and other data structures your pub/sub workloads likely need, Redis will often prove to be the best and most simple tool for the job.&#xD;&#xA;&#xD;&#xA;## Lua Scripting&#xD;&#xA;&#xD;&#xA;You can kind of think of [lua scripts][eval_command] like redis's own SQL or stored procedures. It's both more and less than that, but the analogy mostly works.&#xD;&#xA;&#xD;&#xA;Maybe you have complex calculations you want redis to perform. Maybe you can't afford to have your transactions roll back and need guarantees every step of a complex process will happen atomically. These problems and many more can be solved with lua scripting.&#xD;&#xA;&#xD;&#xA;The entire script is executed atomically, so if you can fit your logic into a lua script you can often avoid messing with optimistic locking transactions.&#xD;&#xA;&#xD;&#xA;## Scaling&#xD;&#xA;&#xD;&#xA;As mentioned above, redis includes built in support for clustering and is bundled with its own high availability tool called `redis-sentinel`.&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;&#xD;&#xA;Without hesitation I would recommend redis over memcached for any new projects, or existing projects that don't already use memcached.&#xD;&#xA;&#xD;&#xA;The above may sound like I don't like memcached. On the contrary: it is a powerful, simple, stable, mature, and hardened tool. There are even some use cases where it's a little faster than redis. I love memcached. I just don't think it makes much sense for future development.&#xD;&#xA;&#xD;&#xA;Redis does everything memcached does, often better. Any performance advantage for memcached is minor and workload specific. There are also workloads for which redis will be faster, and many more workloads that redis can do which memcached simply can't. The tiny performance differences seem minor in the face of the giant gulf in functionality and the fact that both tools are so fast and efficient they may very well be the last piece of your infrastructure you'll ever have to worry about scaling.&#xD;&#xA;&#xD;&#xA;There is only one scenario where memcached makes more sense: where memcached is already in use as a cache. If you are already caching with memcached then keep using it, if it meets your needs. It is likely not worth the effort to move to redis and if you are going to use redis just for caching it may not offer enough benefit to be worth your time. If memcached isn't meeting your needs, then you should probably move to redis. This is true whether you need to scale beyond memcached or you need additional functionality.&#xD;&#xA;&#xD;&#xA;[string_commands]: https://redis.io/commands#string&#xD;&#xA;[hash_commands]: https://redis.io/commands#hash&#xD;&#xA;[list_commands]: https://redis.io/commands#list&#xD;&#xA;[set_commands]: https://redis.io/commands#set&#xD;&#xA;[sorted_set_commands]: https://redis.io/commands#sorted_set&#xD;&#xA;[pubsub_commands]: https://redis.io/commands#pubsub&#xD;&#xA;[geo_commands]: https://redis.io/commands#geo&#xD;&#xA;[persistence]: https://redis.io/topics/persistence&#xD;&#xA;[redis]: https://redis.io/&#xD;&#xA;[try_redis]: https://try.redis.io/&#xD;&#xA;[cluster]: https://redis.io/topics/cluster-tutorial&#xD;&#xA;[sentinel]: https://redis.io/topics/sentinel&#xD;&#xA;[rplace]: https://redditblog.com/2017/04/13/how-we-built-rplace/&#xD;&#xA;[transactions]: https://redis.io/topics/transactions&#xD;&#xA;[watch_command]: https://redis.io/commands/watch&#xD;&#xA;[multi_command]: https://redis.io/commands/multi&#xD;&#xA;[exec_command]: https://redis.io/commands/exec&#xD;&#xA;[eval_command]: https://redis.io/commands/eval&#xD;&#xA;[pubsub]: https://redis.io/topics/pubsub&#xD;&#xA;[rabbitmq]: https://www.rabbitmq.com/&#xD;&#xA;[pipelining]: https://redis.io/topics/pipelining&#xD;&#xA;[lru_cache]: https://redis.io/topics/lru-cache&#xD;&#xA;";;Add note to persistence about it making redis safe for database use
