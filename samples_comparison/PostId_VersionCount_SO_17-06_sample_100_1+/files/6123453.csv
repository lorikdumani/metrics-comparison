Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
13262851;6123453;304345;2;457d2f37-d7eb-4358-88bf-4f044b0e8aeb;2011-05-25 11:06:11.0;"I've implemented an IHttpAsyncHandler that client applications ""poll"" to wait for server notifications. Notifications are generated by other ""activities"" on the server and the Async Handler does no work at all.&#xD;&#xA;&#xD;&#xA;The execution steps are:&#xD;&#xA;&#xD;&#xA;    IHttpAsyncHandler.BeginProcessRequest&#xD;&#xA;&#xD;&#xA;        Create AsyncResult instance and add it to a ""registered clients"" collection&#xD;&#xA;&#xD;&#xA;        return the AsyncResult&#xD;&#xA;&#xD;&#xA;<i>...other server activity will generate notifications to be sent to registered clients...</i>&#xD;&#xA;&#xD;&#xA;    AsyncResult.CompleteCall called as a result of the generated notification(s).&#xD;&#xA;&#xD;&#xA;    IHttpAsyncHandler.EndProcessRequest is called&#xD;&#xA;&#xD;&#xA;        The notification(s) attached to the AsyncResult are written to the response stream.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<b>The problem:</b>&#xD;&#xA;&#xD;&#xA;I've tested this on IIS7 on a VM with Windows Server 2008 SP2 and 1 cpu core. After 12 clients register for notifications (using an HTTP GET on the Async.ashx) the performance is degraded to the point that subsequent clients cannot connect.&#xD;&#xA;&#xD;&#xA;When I check the ASP.NET performance counters the ""Requests Executing"" counter goes up with each client registration and stays at 12 (which appears to be its maximum value - probably a thread pool size per CPU). &#xD;&#xA;&#xD;&#xA;I find this very confusing. I though the whole point of async handlers is to free up threads for other connections. It appears that this is not the case so I must be doing something wrong!&#xD;&#xA;&#xD;&#xA;Why is ASP.NET consuming a thread while waiting for my AsyncResult to complete? Is this a config issue? Do I need to do something specific to indicate that this is an Async Handler?&#xD;&#xA;&#xD;&#xA;Thank you,&#xD;&#xA;Nikos.&#xD;&#xA;";;
13264467;6123453;304345;5;0b088d45-7e29-400c-b730-0ea64b0f26df;2011-05-25 12:01:14.0;"I've implemented an IHttpAsyncHandler that client applications ""poll"" to wait for server notifications. Notifications are generated by other ""activities"" on the server and the Async Handler does no work at all.&#xD;&#xA;&#xD;&#xA;The execution steps are:&#xD;&#xA;&#xD;&#xA;    IHttpAsyncHandler.BeginProcessRequest&#xD;&#xA;&#xD;&#xA;        Create AsyncResult instance and add it to a ""registered clients"" collection&#xD;&#xA;&#xD;&#xA;        return the AsyncResult&#xD;&#xA;&#xD;&#xA;<i>...other server activity will generate notifications to be sent to registered clients...</i>&#xD;&#xA;&#xD;&#xA;    AsyncResult.CompleteCall called as a result of the generated notification(s).&#xD;&#xA;&#xD;&#xA;    IHttpAsyncHandler.EndProcessRequest is called&#xD;&#xA;&#xD;&#xA;        The notification(s) attached to the AsyncResult are written to the response stream.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<b>The problem:</b>&#xD;&#xA;&#xD;&#xA;I've tested this on IIS7 on a VM with Windows Server 2008 SP2 and 1 cpu core. After 12 clients register for notifications (using an HTTP GET on the Async.ashx) the performance is degraded to the point that subsequent clients cannot connect.&#xD;&#xA;&#xD;&#xA;When I check the ASP.NET performance counters the ""Requests Executing"" counter goes up with each client registration and stays at 12 (which appears to be its maximum value - probably a thread pool size per CPU). &#xD;&#xA;&#xD;&#xA;I find this very confusing. I though the whole point of async handlers is to free up threads for other connections. It appears that this is not the case so I must be doing something wrong!&#xD;&#xA;&#xD;&#xA;Why is ASP.NET consuming a thread while waiting for my AsyncResult to complete? Is this a config issue? Do I need to do something specific to indicate that this is an Async Handler?&#xD;&#xA;&#xD;&#xA;Thank you,&#xD;&#xA;Nikos.&#xD;&#xA;&#xD;&#xA;<b>Edit: Added code below:</b><br>&#xD;&#xA;<pre>&#xD;&#xA;&#xD;&#xA;        public class AsyncResult : IAsyncResult&#xD;&#xA;        {&#xD;&#xA;            private AsyncCallback _cb;&#xD;&#xA;            private object _state;&#xD;&#xA;            private ManualResetEvent _event;&#xD;&#xA;            private bool _completed;&#xD;&#xA;            private bool _completedsynchronously;&#xD;&#xA;            private HttpContext _context;&#xD;&#xA;            private byte[] _data;&#xD;&#xA;            private int _datalength;&#xD;&#xA;            private object _lock = new object();&#xD;&#xA;&#xD;&#xA;            public AsyncWaitResult(AsyncCallback cb, object state, HttpContext context)&#xD;&#xA;            {&#xD;&#xA;                _context = context;&#xD;&#xA;                _cb = cb;&#xD;&#xA;                _state = state;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public void Close()&#xD;&#xA;            {&#xD;&#xA;                if (_event != null)&#xD;&#xA;                {&#xD;&#xA;                    _event.Close();&#xD;&#xA;                    _event = null;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public HttpContext Context { get { return _context; } }&#xD;&#xA;            public Object AsyncState { get { return _state; } }&#xD;&#xA;            public bool CompletedSynchronously { get { return _completedsynchronously; } }&#xD;&#xA;            public bool IsCompleted { get { return _completed; } }&#xD;&#xA;            public byte[] Data { get { return _data; } }&#xD;&#xA;            public int DataLength { get { return _datalength; } }&#xD;&#xA;&#xD;&#xA;            public WaitHandle AsyncWaitHandle&#xD;&#xA;            {&#xD;&#xA;                get&#xD;&#xA;                {&#xD;&#xA;                    lock (_lock)&#xD;&#xA;                    {&#xD;&#xA;                        if (_event == null)&#xD;&#xA;                            _event = new ManualResetEvent(_completed);&#xD;&#xA;                        return _event;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            public void CompleteCall(byte[] data, int length, bool completedsynchronously)&#xD;&#xA;            {&#xD;&#xA;                _data = data;&#xD;&#xA;                _datalength = length;&#xD;&#xA;                _completedsynchronously = completedsynchronously;&#xD;&#xA;&#xD;&#xA;                lock (_lock)&#xD;&#xA;                {&#xD;&#xA;                    _completed = true;&#xD;&#xA;                    if (_event != null)&#xD;&#xA;                        _event.Set();&#xD;&#xA;                }&#xD;&#xA;&#xD;&#xA;                if (_cb != null)&#xD;&#xA;                    _cb(this);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    public class Outbound : IHttpAsyncHandler&#xD;&#xA;    {&#xD;&#xA;        public IAsyncResult BeginProcessRequest(HttpContext context, AsyncCallback cb, object state)&#xD;&#xA;        {&#xD;&#xA;                AsyncResult asyncresult = new AsyncResult(cb, state, context);&#xD;&#xA;                &#xD;&#xA;                RegisteredClients.Instance.Add(asyncresult);&#xD;&#xA;&#xD;&#xA;                return asyncresult;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public void EndProcessRequest(IAsyncResult ar)&#xD;&#xA;        {&#xD;&#xA;            AsyncResult result = (AsyncResult)ar;&#xD;&#xA;            if (result != null)&#xD;&#xA;            {&#xD;&#xA;                result.Context.Response.Cache.SetCacheability(HttpCacheability.NoCache);&#xD;&#xA;                result.Context.Response.ContentType = ""application/octet-stream"";&#xD;&#xA;                result.Context.Response.AddHeader(""Connection"", ""keep-alive"");&#xD;&#xA;&#xD;&#xA;                if (result.Data != null)&#xD;&#xA;                    result.Context.Response.OutputStream.Write(result.Data, 0, result.DataLength);&#xD;&#xA;&#xD;&#xA;                result.Close();&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        public void ProcessRequest(HttpContext context){}&#xD;&#xA;&#xD;&#xA;        public bool IsReusable { get { return true; } }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;</pre>&#xD;&#xA;";;added 3389 characters in body
13264971;6123453;304345;5;8eaa07a2-2827-4a89-be59-461717b3223d;2011-05-25 12:18:47.0;"I've implemented an IHttpAsyncHandler that client applications ""poll"" to wait for server notifications. Notifications are generated by other ""activities"" on the server and the Async Handler does no work at all.&#xD;&#xA;&#xD;&#xA;The execution steps are:&#xD;&#xA;&#xD;&#xA;    IHttpAsyncHandler.BeginProcessRequest&#xD;&#xA;&#xD;&#xA;        Create AsyncResult instance and add it to a ""registered clients"" collection&#xD;&#xA;&#xD;&#xA;        return the AsyncResult&#xD;&#xA;&#xD;&#xA;<i>...other server activity will generate notifications to be sent to registered clients...</i>&#xD;&#xA;&#xD;&#xA;    AsyncResult.CompleteCall called as a result of the generated notification(s).&#xD;&#xA;&#xD;&#xA;    IHttpAsyncHandler.EndProcessRequest is called&#xD;&#xA;&#xD;&#xA;        The notification(s) attached to the AsyncResult are written to the response stream.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<b>The problem:</b>&#xD;&#xA;&#xD;&#xA;I've tested this on IIS7 on a VM with Windows Server 2008 SP2 and 1 cpu core. After 12 clients register for notifications (using an HTTP GET on the Async.ashx) the performance is degraded to the point that subsequent clients cannot connect.&#xD;&#xA;&#xD;&#xA;When I check the ASP.NET performance counters the ""Requests Executing"" counter goes up with each client registration and stays at 12 (which appears to be its maximum value - probably a thread pool size per CPU). &#xD;&#xA;&#xD;&#xA;I find this very confusing. I though the whole point of async handlers is to free up threads for other connections. It appears that this is not the case so I must be doing something wrong!&#xD;&#xA;&#xD;&#xA;Why is ASP.NET consuming a thread while waiting for my AsyncResult to complete? Is this a config issue? Do I need to do something specific to indicate that this is an Async Handler?&#xD;&#xA;&#xD;&#xA;Thank you,&#xD;&#xA;Nikos.&#xD;&#xA;&#xD;&#xA;<b>Edit: Added code below:</b><br>&#xD;&#xA;	&#xD;&#xA;	public class AsyncResult : IAsyncResult&#xD;&#xA;	{&#xD;&#xA;		private AsyncCallback _cb;&#xD;&#xA;		private object _state;&#xD;&#xA;		private ManualResetEvent _event;&#xD;&#xA;		private bool _completed;&#xD;&#xA;		private bool _completedsynchronously;&#xD;&#xA;		private HttpContext _context;&#xD;&#xA;		private byte[] _data;&#xD;&#xA;		private int _datalength;&#xD;&#xA;		private object _lock = new object();&#xD;&#xA;		&#xD;&#xA;		public AsyncWaitResult(AsyncCallback cb, object state, HttpContext context)&#xD;&#xA;		{&#xD;&#xA;			_context = context;&#xD;&#xA;			_cb = cb;&#xD;&#xA;			_state = state;&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public void Close()&#xD;&#xA;		{&#xD;&#xA;			if (_event != null)&#xD;&#xA;			{&#xD;&#xA;				_event.Close();&#xD;&#xA;				_event = null;&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public HttpContext Context { get { return _context; } }&#xD;&#xA;		public Object AsyncState { get { return _state; } }&#xD;&#xA;		public bool CompletedSynchronously { get { return _completedsynchronously; } }&#xD;&#xA;		public bool IsCompleted { get { return _completed; } }&#xD;&#xA;		public byte[] Data { get { return _data; } }&#xD;&#xA;		public int DataLength { get { return _datalength; } }&#xD;&#xA;		&#xD;&#xA;		public WaitHandle AsyncWaitHandle&#xD;&#xA;		{&#xD;&#xA;			get&#xD;&#xA;			{&#xD;&#xA;				lock (_lock)&#xD;&#xA;				{&#xD;&#xA;					if (_event == null)&#xD;&#xA;						_event = new ManualResetEvent(_completed);&#xD;&#xA;					return _event;&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public void CompleteCall(byte[] data, int length, bool completedsynchronously)&#xD;&#xA;		{&#xD;&#xA;			_data = data;&#xD;&#xA;			_datalength = length;&#xD;&#xA;			_completedsynchronously = completedsynchronously;&#xD;&#xA;		&#xD;&#xA;			lock (_lock)&#xD;&#xA;			{&#xD;&#xA;				_completed = true;&#xD;&#xA;				if (_event != null)&#xD;&#xA;					_event.Set();&#xD;&#xA;			}&#xD;&#xA;		&#xD;&#xA;			if (_cb != null)&#xD;&#xA;				_cb(this);&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	&#xD;&#xA;	public class Outbound : IHttpAsyncHandler&#xD;&#xA;	{&#xD;&#xA;		public IAsyncResult BeginProcessRequest(HttpContext context, AsyncCallback cb, object state)&#xD;&#xA;		{&#xD;&#xA;				AsyncResult asyncresult = new AsyncResult(cb, state, context);&#xD;&#xA;				&#xD;&#xA;				RegisteredClients.Instance.Add(asyncresult);&#xD;&#xA;	&#xD;&#xA;				return asyncresult;&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void EndProcessRequest(IAsyncResult ar)&#xD;&#xA;		{&#xD;&#xA;			AsyncResult result = (AsyncResult)ar;&#xD;&#xA;			if (result != null)&#xD;&#xA;			{&#xD;&#xA;				result.Context.Response.Cache.SetCacheability(HttpCacheability.NoCache);&#xD;&#xA;				result.Context.Response.ContentType = ""application/octet-stream"";&#xD;&#xA;				result.Context.Response.AddHeader(""Connection"", ""keep-alive"");&#xD;&#xA;	&#xD;&#xA;				if (result.Data != null)&#xD;&#xA;					result.Context.Response.OutputStream.Write(result.Data, 0, result.DataLength);&#xD;&#xA;	&#xD;&#xA;				result.Close();&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void ProcessRequest(HttpContext context){}&#xD;&#xA;	&#xD;&#xA;		public bool IsReusable { get { return true; } }&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;";;Fixed code highlight
13273364;6123453;304345;5;6e688a94-9a5e-4656-951f-ab7d04046e1b;2011-05-25 16:42:40.0;"<h1>Edit:</h1><b>I found the solution to this. Not sure why it happens but switching the application pool type to 'classic' from 'integrated' solves the problem. Now the 'Requests Executing' keeps going up, the actual application pool process thread remains low (~31 threads) and the app is *very* responsive (as it should be).&#xD;&#xA;<br><br>I'm using .Net 2.0 so maybe there is an issue there - tried to google it but no luck.&#xD;&#xA;</b>&#xD;&#xA;<br/><br/>Thank you all again.&#xD;&#xA;<br/><br/><i>ps. the code is use for playing pool (billiards) online - windows (free) version [here](http://poolrebel.com) for anyone curious and brave enough to try :)</i>&#xD;&#xA;<hr/>&#xD;&#xA;&#xD;&#xA;Hello,&#xD;&#xA;&#xD;&#xA;I've implemented an IHttpAsyncHandler that client applications ""poll"" to wait for server notifications. Notifications are generated by other ""activities"" on the server and the Async Handler does no work at all.&#xD;&#xA;&#xD;&#xA;The execution steps are:&#xD;&#xA;&#xD;&#xA;    IHttpAsyncHandler.BeginProcessRequest&#xD;&#xA;&#xD;&#xA;        Create AsyncResult instance and add it to a ""registered clients"" collection&#xD;&#xA;&#xD;&#xA;        return the AsyncResult&#xD;&#xA;&#xD;&#xA;<i>...other server activity will generate notifications to be sent to registered clients...</i>&#xD;&#xA;&#xD;&#xA;    AsyncResult.CompleteCall called as a result of the generated notification(s).&#xD;&#xA;&#xD;&#xA;    IHttpAsyncHandler.EndProcessRequest is called&#xD;&#xA;&#xD;&#xA;        The notification(s) attached to the AsyncResult are written to the response stream.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<b>The problem:</b>&#xD;&#xA;&#xD;&#xA;I've tested this on IIS7 on a VM with Windows Server 2008 SP2 and 1 cpu core. After 12 clients register for notifications (using an HTTP GET on the Async.ashx) the performance is degraded to the point that subsequent clients cannot connect.&#xD;&#xA;&#xD;&#xA;When I check the ASP.NET performance counters the ""Requests Executing"" counter goes up with each client registration and stays at 12 (which appears to be its maximum value - probably a thread pool size per CPU). &#xD;&#xA;&#xD;&#xA;I find this very confusing. I though the whole point of async handlers is to free up threads for other connections. It appears that this is not the case so I must be doing something wrong!&#xD;&#xA;&#xD;&#xA;Why is ASP.NET consuming a thread while waiting for my AsyncResult to complete? Is this a config issue? Do I need to do something specific to indicate that this is an Async Handler?&#xD;&#xA;&#xD;&#xA;Thank you,&#xD;&#xA;Nikos.&#xD;&#xA;&#xD;&#xA;<b>Edit: Added code below:</b><br>&#xD;&#xA;	&#xD;&#xA;	public class AsyncResult : IAsyncResult&#xD;&#xA;	{&#xD;&#xA;		private AsyncCallback _cb;&#xD;&#xA;		private object _state;&#xD;&#xA;		private ManualResetEvent _event;&#xD;&#xA;		private bool _completed;&#xD;&#xA;		private bool _completedsynchronously;&#xD;&#xA;		private HttpContext _context;&#xD;&#xA;		private byte[] _data;&#xD;&#xA;		private int _datalength;&#xD;&#xA;		private object _lock = new object();&#xD;&#xA;		&#xD;&#xA;		public AsyncWaitResult(AsyncCallback cb, object state, HttpContext context)&#xD;&#xA;		{&#xD;&#xA;			_context = context;&#xD;&#xA;			_cb = cb;&#xD;&#xA;			_state = state;&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public void Close()&#xD;&#xA;		{&#xD;&#xA;			if (_event != null)&#xD;&#xA;			{&#xD;&#xA;				_event.Close();&#xD;&#xA;				_event = null;&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public HttpContext Context { get { return _context; } }&#xD;&#xA;		public Object AsyncState { get { return _state; } }&#xD;&#xA;		public bool CompletedSynchronously { get { return _completedsynchronously; } }&#xD;&#xA;		public bool IsCompleted { get { return _completed; } }&#xD;&#xA;		public byte[] Data { get { return _data; } }&#xD;&#xA;		public int DataLength { get { return _datalength; } }&#xD;&#xA;		&#xD;&#xA;		public WaitHandle AsyncWaitHandle&#xD;&#xA;		{&#xD;&#xA;			get&#xD;&#xA;			{&#xD;&#xA;				lock (_lock)&#xD;&#xA;				{&#xD;&#xA;					if (_event == null)&#xD;&#xA;						_event = new ManualResetEvent(_completed);&#xD;&#xA;					return _event;&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public void CompleteCall(byte[] data, int length, bool completedsynchronously)&#xD;&#xA;		{&#xD;&#xA;			_data = data;&#xD;&#xA;			_datalength = length;&#xD;&#xA;			_completedsynchronously = completedsynchronously;&#xD;&#xA;		&#xD;&#xA;			lock (_lock)&#xD;&#xA;			{&#xD;&#xA;				_completed = true;&#xD;&#xA;				if (_event != null)&#xD;&#xA;					_event.Set();&#xD;&#xA;			}&#xD;&#xA;		&#xD;&#xA;			if (_cb != null)&#xD;&#xA;				_cb(this);&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	&#xD;&#xA;	public class Outbound : IHttpAsyncHandler&#xD;&#xA;	{&#xD;&#xA;		public IAsyncResult BeginProcessRequest(HttpContext context, AsyncCallback cb, object state)&#xD;&#xA;		{&#xD;&#xA;				AsyncResult asyncresult = new AsyncResult(cb, state, context);&#xD;&#xA;				&#xD;&#xA;				RegisteredClients.Instance.Add(asyncresult);&#xD;&#xA;	&#xD;&#xA;				return asyncresult;&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void EndProcessRequest(IAsyncResult ar)&#xD;&#xA;		{&#xD;&#xA;			AsyncResult result = (AsyncResult)ar;&#xD;&#xA;			if (result != null)&#xD;&#xA;			{&#xD;&#xA;				result.Context.Response.Cache.SetCacheability(HttpCacheability.NoCache);&#xD;&#xA;				result.Context.Response.ContentType = ""application/octet-stream"";&#xD;&#xA;				result.Context.Response.AddHeader(""Connection"", ""keep-alive"");&#xD;&#xA;	&#xD;&#xA;				if (result.Data != null)&#xD;&#xA;					result.Context.Response.OutputStream.Write(result.Data, 0, result.DataLength);&#xD;&#xA;	&#xD;&#xA;				result.Close();&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void ProcessRequest(HttpContext context){}&#xD;&#xA;	&#xD;&#xA;		public bool IsReusable { get { return true; } }&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;";;Problem solved but not understood.
13274254;6123453;304345;5;012538f4-b2a4-40b4-bf9c-2a677ea45b0f;2011-05-25 17:12:33.0;"<h1>Solved:</h1><b>I found the solution to this. Not sure why it happens but switching the application pool type to 'classic' from 'integrated' solves the problem. Now the 'Requests Executing' keeps going up, the actual application pool process thread remains low (~31 threads) and the app is *very* responsive (as it should be).&#xD;&#xA;<br><br>I'm using .Net 2.0 so maybe there is an issue there - tried to google it but no luck.&#xD;&#xA;</b>&#xD;&#xA;<br/><br/>Thank you all again.&#xD;&#xA;<br/><br/><i>ps. the code is use for playing pool (billiards) online - windows (free) version [here](http://poolrebel.com) for anyone curious and brave enough to try :)</i>&#xD;&#xA;<hr/>&#xD;&#xA;&#xD;&#xA;Hello,&#xD;&#xA;&#xD;&#xA;I've implemented an IHttpAsyncHandler that client applications ""poll"" to wait for server notifications. Notifications are generated by other ""activities"" on the server and the Async Handler does no work at all.&#xD;&#xA;&#xD;&#xA;The execution steps are:&#xD;&#xA;&#xD;&#xA;    IHttpAsyncHandler.BeginProcessRequest&#xD;&#xA;&#xD;&#xA;        Create AsyncResult instance and add it to a ""registered clients"" collection&#xD;&#xA;&#xD;&#xA;        return the AsyncResult&#xD;&#xA;&#xD;&#xA;<i>...other server activity will generate notifications to be sent to registered clients...</i>&#xD;&#xA;&#xD;&#xA;    AsyncResult.CompleteCall called as a result of the generated notification(s).&#xD;&#xA;&#xD;&#xA;    IHttpAsyncHandler.EndProcessRequest is called&#xD;&#xA;&#xD;&#xA;        The notification(s) attached to the AsyncResult are written to the response stream.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<b>The problem:</b>&#xD;&#xA;&#xD;&#xA;I've tested this on IIS7 on a VM with Windows Server 2008 SP2 and 1 cpu core. After 12 clients register for notifications (using an HTTP GET on the Async.ashx) the performance is degraded to the point that subsequent clients cannot connect.&#xD;&#xA;&#xD;&#xA;When I check the ASP.NET performance counters the ""Requests Executing"" counter goes up with each client registration and stays at 12 (which appears to be its maximum value - probably a thread pool size per CPU). &#xD;&#xA;&#xD;&#xA;I find this very confusing. I though the whole point of async handlers is to free up threads for other connections. It appears that this is not the case so I must be doing something wrong!&#xD;&#xA;&#xD;&#xA;Why is ASP.NET consuming a thread while waiting for my AsyncResult to complete? Is this a config issue? Do I need to do something specific to indicate that this is an Async Handler?&#xD;&#xA;&#xD;&#xA;Thank you,&#xD;&#xA;Nikos.&#xD;&#xA;&#xD;&#xA;<b>Edit: Added code below:</b><br>&#xD;&#xA;	&#xD;&#xA;	public class AsyncResult : IAsyncResult&#xD;&#xA;	{&#xD;&#xA;		private AsyncCallback _cb;&#xD;&#xA;		private object _state;&#xD;&#xA;		private ManualResetEvent _event;&#xD;&#xA;		private bool _completed;&#xD;&#xA;		private bool _completedsynchronously;&#xD;&#xA;		private HttpContext _context;&#xD;&#xA;		private byte[] _data;&#xD;&#xA;		private int _datalength;&#xD;&#xA;		private object _lock = new object();&#xD;&#xA;		&#xD;&#xA;		public AsyncWaitResult(AsyncCallback cb, object state, HttpContext context)&#xD;&#xA;		{&#xD;&#xA;			_context = context;&#xD;&#xA;			_cb = cb;&#xD;&#xA;			_state = state;&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public void Close()&#xD;&#xA;		{&#xD;&#xA;			if (_event != null)&#xD;&#xA;			{&#xD;&#xA;				_event.Close();&#xD;&#xA;				_event = null;&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public HttpContext Context { get { return _context; } }&#xD;&#xA;		public Object AsyncState { get { return _state; } }&#xD;&#xA;		public bool CompletedSynchronously { get { return _completedsynchronously; } }&#xD;&#xA;		public bool IsCompleted { get { return _completed; } }&#xD;&#xA;		public byte[] Data { get { return _data; } }&#xD;&#xA;		public int DataLength { get { return _datalength; } }&#xD;&#xA;		&#xD;&#xA;		public WaitHandle AsyncWaitHandle&#xD;&#xA;		{&#xD;&#xA;			get&#xD;&#xA;			{&#xD;&#xA;				lock (_lock)&#xD;&#xA;				{&#xD;&#xA;					if (_event == null)&#xD;&#xA;						_event = new ManualResetEvent(_completed);&#xD;&#xA;					return _event;&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public void CompleteCall(byte[] data, int length, bool completedsynchronously)&#xD;&#xA;		{&#xD;&#xA;			_data = data;&#xD;&#xA;			_datalength = length;&#xD;&#xA;			_completedsynchronously = completedsynchronously;&#xD;&#xA;		&#xD;&#xA;			lock (_lock)&#xD;&#xA;			{&#xD;&#xA;				_completed = true;&#xD;&#xA;				if (_event != null)&#xD;&#xA;					_event.Set();&#xD;&#xA;			}&#xD;&#xA;		&#xD;&#xA;			if (_cb != null)&#xD;&#xA;				_cb(this);&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	&#xD;&#xA;	public class Outbound : IHttpAsyncHandler&#xD;&#xA;	{&#xD;&#xA;		public IAsyncResult BeginProcessRequest(HttpContext context, AsyncCallback cb, object state)&#xD;&#xA;		{&#xD;&#xA;				AsyncResult asyncresult = new AsyncResult(cb, state, context);&#xD;&#xA;				&#xD;&#xA;				RegisteredClients.Instance.Add(asyncresult);&#xD;&#xA;	&#xD;&#xA;				return asyncresult;&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void EndProcessRequest(IAsyncResult ar)&#xD;&#xA;		{&#xD;&#xA;			AsyncResult result = (AsyncResult)ar;&#xD;&#xA;			if (result != null)&#xD;&#xA;			{&#xD;&#xA;				result.Context.Response.Cache.SetCacheability(HttpCacheability.NoCache);&#xD;&#xA;				result.Context.Response.ContentType = ""application/octet-stream"";&#xD;&#xA;				result.Context.Response.AddHeader(""Connection"", ""keep-alive"");&#xD;&#xA;	&#xD;&#xA;				if (result.Data != null)&#xD;&#xA;					result.Context.Response.OutputStream.Write(result.Data, 0, result.DataLength);&#xD;&#xA;	&#xD;&#xA;				result.Close();&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void ProcessRequest(HttpContext context){}&#xD;&#xA;	&#xD;&#xA;		public bool IsReusable { get { return true; } }&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;";;added 2 characters in body
13274837;6123453;304345;5;6c028bf5-d4d4-45d7-8d51-bebca2e47ea5;2011-05-25 17:38:06.0;"<h1>Solved:</h1><b>I found the solution to this. Not sure why it happens but switching the application pool type to 'classic' from 'integrated' solves the problem. Now the 'Requests Executing' keeps going up, the actual application pool process thread remains low (~31 threads) and the app is *very* responsive (as it should be).&#xD;&#xA;<br><br>I'm using .Net 2.0 so maybe there is an issue there - tried to google it but no luck.&#xD;&#xA;</b>&#xD;&#xA;<br/><br/>Thank you all again.&#xD;&#xA;<br/><br/><i>ps. the code is used for playing pool (billiards) online - windows (free) version [here](http://poolrebel.com) for anyone curious and brave enough to try :)</i>&#xD;&#xA;<hr/>&#xD;&#xA;&#xD;&#xA;Hello,&#xD;&#xA;&#xD;&#xA;I've implemented an IHttpAsyncHandler that client applications ""poll"" to wait for server notifications. Notifications are generated by other ""activities"" on the server and the Async Handler does no work at all.&#xD;&#xA;&#xD;&#xA;The execution steps are:&#xD;&#xA;&#xD;&#xA;    IHttpAsyncHandler.BeginProcessRequest&#xD;&#xA;&#xD;&#xA;        Create AsyncResult instance and add it to a ""registered clients"" collection&#xD;&#xA;&#xD;&#xA;        return the AsyncResult&#xD;&#xA;&#xD;&#xA;<i>...other server activity will generate notifications to be sent to registered clients...</i>&#xD;&#xA;&#xD;&#xA;    AsyncResult.CompleteCall called as a result of the generated notification(s).&#xD;&#xA;&#xD;&#xA;    IHttpAsyncHandler.EndProcessRequest is called&#xD;&#xA;&#xD;&#xA;        The notification(s) attached to the AsyncResult are written to the response stream.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<b>The problem:</b>&#xD;&#xA;&#xD;&#xA;I've tested this on IIS7 on a VM with Windows Server 2008 SP2 and 1 cpu core. After 12 clients register for notifications (using an HTTP GET on the Async.ashx) the performance is degraded to the point that subsequent clients cannot connect.&#xD;&#xA;&#xD;&#xA;When I check the ASP.NET performance counters the ""Requests Executing"" counter goes up with each client registration and stays at 12 (which appears to be its maximum value - probably a thread pool size per CPU). &#xD;&#xA;&#xD;&#xA;I find this very confusing. I though the whole point of async handlers is to free up threads for other connections. It appears that this is not the case so I must be doing something wrong!&#xD;&#xA;&#xD;&#xA;Why is ASP.NET consuming a thread while waiting for my AsyncResult to complete? Is this a config issue? Do I need to do something specific to indicate that this is an Async Handler?&#xD;&#xA;&#xD;&#xA;Thank you,&#xD;&#xA;Nikos.&#xD;&#xA;&#xD;&#xA;<b>Edit: Added code below:</b><br>&#xD;&#xA;	&#xD;&#xA;	public class AsyncResult : IAsyncResult&#xD;&#xA;	{&#xD;&#xA;		private AsyncCallback _cb;&#xD;&#xA;		private object _state;&#xD;&#xA;		private ManualResetEvent _event;&#xD;&#xA;		private bool _completed;&#xD;&#xA;		private bool _completedsynchronously;&#xD;&#xA;		private HttpContext _context;&#xD;&#xA;		private byte[] _data;&#xD;&#xA;		private int _datalength;&#xD;&#xA;		private object _lock = new object();&#xD;&#xA;		&#xD;&#xA;		public AsyncWaitResult(AsyncCallback cb, object state, HttpContext context)&#xD;&#xA;		{&#xD;&#xA;			_context = context;&#xD;&#xA;			_cb = cb;&#xD;&#xA;			_state = state;&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public void Close()&#xD;&#xA;		{&#xD;&#xA;			if (_event != null)&#xD;&#xA;			{&#xD;&#xA;				_event.Close();&#xD;&#xA;				_event = null;&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public HttpContext Context { get { return _context; } }&#xD;&#xA;		public Object AsyncState { get { return _state; } }&#xD;&#xA;		public bool CompletedSynchronously { get { return _completedsynchronously; } }&#xD;&#xA;		public bool IsCompleted { get { return _completed; } }&#xD;&#xA;		public byte[] Data { get { return _data; } }&#xD;&#xA;		public int DataLength { get { return _datalength; } }&#xD;&#xA;		&#xD;&#xA;		public WaitHandle AsyncWaitHandle&#xD;&#xA;		{&#xD;&#xA;			get&#xD;&#xA;			{&#xD;&#xA;				lock (_lock)&#xD;&#xA;				{&#xD;&#xA;					if (_event == null)&#xD;&#xA;						_event = new ManualResetEvent(_completed);&#xD;&#xA;					return _event;&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public void CompleteCall(byte[] data, int length, bool completedsynchronously)&#xD;&#xA;		{&#xD;&#xA;			_data = data;&#xD;&#xA;			_datalength = length;&#xD;&#xA;			_completedsynchronously = completedsynchronously;&#xD;&#xA;		&#xD;&#xA;			lock (_lock)&#xD;&#xA;			{&#xD;&#xA;				_completed = true;&#xD;&#xA;				if (_event != null)&#xD;&#xA;					_event.Set();&#xD;&#xA;			}&#xD;&#xA;		&#xD;&#xA;			if (_cb != null)&#xD;&#xA;				_cb(this);&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	&#xD;&#xA;	public class Outbound : IHttpAsyncHandler&#xD;&#xA;	{&#xD;&#xA;		public IAsyncResult BeginProcessRequest(HttpContext context, AsyncCallback cb, object state)&#xD;&#xA;		{&#xD;&#xA;				AsyncResult asyncresult = new AsyncResult(cb, state, context);&#xD;&#xA;				&#xD;&#xA;				RegisteredClients.Instance.Add(asyncresult);&#xD;&#xA;	&#xD;&#xA;				return asyncresult;&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void EndProcessRequest(IAsyncResult ar)&#xD;&#xA;		{&#xD;&#xA;			AsyncResult result = (AsyncResult)ar;&#xD;&#xA;			if (result != null)&#xD;&#xA;			{&#xD;&#xA;				result.Context.Response.Cache.SetCacheability(HttpCacheability.NoCache);&#xD;&#xA;				result.Context.Response.ContentType = ""application/octet-stream"";&#xD;&#xA;				result.Context.Response.AddHeader(""Connection"", ""keep-alive"");&#xD;&#xA;	&#xD;&#xA;				if (result.Data != null)&#xD;&#xA;					result.Context.Response.OutputStream.Write(result.Data, 0, result.DataLength);&#xD;&#xA;	&#xD;&#xA;				result.Close();&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void ProcessRequest(HttpContext context){}&#xD;&#xA;	&#xD;&#xA;		public bool IsReusable { get { return true; } }&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;";;added 1 characters in body
13277253;6123453;304345;5;f3d82129-818c-4c46-8e45-62ce90cc3e4f;2011-05-25 19:09:15.0;"<h1>Solved:</h1><b>I found the solution to this. </b><s>Not sure why it happens but</s><b> Switching the application pool type to 'classic' from 'integrated' solves the problem. Now the 'Requests Executing' keeps going up, the actual application pool process thread remains low (~31 threads) and the app is *very* responsive (as it should be).&#xD;&#xA;<br><br><s>I'm using .Net 2.0 so maybe there is an issue there - tried to google it but no luck.</s>&#xD;&#xA;</b>&#xD;&#xA;<hr>&#xD;&#xA;<b>See [Joe Enzminger's reply for an explanation](http://stackoverflow.com/questions/6123453/problem-with-ihttpasynchandler-and-asp-net-requests-executing-counter/6128861#6128861)&#xD;&#xA;</b>&#xD;&#xA;<hr>&#xD;&#xA;Thank you all again.&#xD;&#xA;<br/><br/><i>ps. the code is used for playing pool (billiards) online - windows (free) version [here](http://poolrebel.com) for anyone curious and brave enough to try :)</i>&#xD;&#xA;<hr/>&#xD;&#xA;&#xD;&#xA;Hello,&#xD;&#xA;&#xD;&#xA;I've implemented an IHttpAsyncHandler that client applications ""poll"" to wait for server notifications. Notifications are generated by other ""activities"" on the server and the Async Handler does no work at all.&#xD;&#xA;&#xD;&#xA;The execution steps are:&#xD;&#xA;&#xD;&#xA;    IHttpAsyncHandler.BeginProcessRequest&#xD;&#xA;&#xD;&#xA;        Create AsyncResult instance and add it to a ""registered clients"" collection&#xD;&#xA;&#xD;&#xA;        return the AsyncResult&#xD;&#xA;&#xD;&#xA;<i>...other server activity will generate notifications to be sent to registered clients...</i>&#xD;&#xA;&#xD;&#xA;    AsyncResult.CompleteCall called as a result of the generated notification(s).&#xD;&#xA;&#xD;&#xA;    IHttpAsyncHandler.EndProcessRequest is called&#xD;&#xA;&#xD;&#xA;        The notification(s) attached to the AsyncResult are written to the response stream.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<b>The problem:</b>&#xD;&#xA;&#xD;&#xA;I've tested this on IIS7 on a VM with Windows Server 2008 SP2 and 1 cpu core. After 12 clients register for notifications (using an HTTP GET on the Async.ashx) the performance is degraded to the point that subsequent clients cannot connect.&#xD;&#xA;&#xD;&#xA;When I check the ASP.NET performance counters the ""Requests Executing"" counter goes up with each client registration and stays at 12 (which appears to be its maximum value - probably a thread pool size per CPU). &#xD;&#xA;&#xD;&#xA;I find this very confusing. I though the whole point of async handlers is to free up threads for other connections. It appears that this is not the case so I must be doing something wrong!&#xD;&#xA;&#xD;&#xA;Why is ASP.NET consuming a thread while waiting for my AsyncResult to complete? Is this a config issue? Do I need to do something specific to indicate that this is an Async Handler?&#xD;&#xA;&#xD;&#xA;Thank you,&#xD;&#xA;Nikos.&#xD;&#xA;&#xD;&#xA;<b>Edit: Added code below:</b><br>&#xD;&#xA;	&#xD;&#xA;	public class AsyncResult : IAsyncResult&#xD;&#xA;	{&#xD;&#xA;		private AsyncCallback _cb;&#xD;&#xA;		private object _state;&#xD;&#xA;		private ManualResetEvent _event;&#xD;&#xA;		private bool _completed;&#xD;&#xA;		private bool _completedsynchronously;&#xD;&#xA;		private HttpContext _context;&#xD;&#xA;		private byte[] _data;&#xD;&#xA;		private int _datalength;&#xD;&#xA;		private object _lock = new object();&#xD;&#xA;		&#xD;&#xA;		public AsyncWaitResult(AsyncCallback cb, object state, HttpContext context)&#xD;&#xA;		{&#xD;&#xA;			_context = context;&#xD;&#xA;			_cb = cb;&#xD;&#xA;			_state = state;&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public void Close()&#xD;&#xA;		{&#xD;&#xA;			if (_event != null)&#xD;&#xA;			{&#xD;&#xA;				_event.Close();&#xD;&#xA;				_event = null;&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public HttpContext Context { get { return _context; } }&#xD;&#xA;		public Object AsyncState { get { return _state; } }&#xD;&#xA;		public bool CompletedSynchronously { get { return _completedsynchronously; } }&#xD;&#xA;		public bool IsCompleted { get { return _completed; } }&#xD;&#xA;		public byte[] Data { get { return _data; } }&#xD;&#xA;		public int DataLength { get { return _datalength; } }&#xD;&#xA;		&#xD;&#xA;		public WaitHandle AsyncWaitHandle&#xD;&#xA;		{&#xD;&#xA;			get&#xD;&#xA;			{&#xD;&#xA;				lock (_lock)&#xD;&#xA;				{&#xD;&#xA;					if (_event == null)&#xD;&#xA;						_event = new ManualResetEvent(_completed);&#xD;&#xA;					return _event;&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public void CompleteCall(byte[] data, int length, bool completedsynchronously)&#xD;&#xA;		{&#xD;&#xA;			_data = data;&#xD;&#xA;			_datalength = length;&#xD;&#xA;			_completedsynchronously = completedsynchronously;&#xD;&#xA;		&#xD;&#xA;			lock (_lock)&#xD;&#xA;			{&#xD;&#xA;				_completed = true;&#xD;&#xA;				if (_event != null)&#xD;&#xA;					_event.Set();&#xD;&#xA;			}&#xD;&#xA;		&#xD;&#xA;			if (_cb != null)&#xD;&#xA;				_cb(this);&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	&#xD;&#xA;	public class Outbound : IHttpAsyncHandler&#xD;&#xA;	{&#xD;&#xA;		public IAsyncResult BeginProcessRequest(HttpContext context, AsyncCallback cb, object state)&#xD;&#xA;		{&#xD;&#xA;				AsyncResult asyncresult = new AsyncResult(cb, state, context);&#xD;&#xA;				&#xD;&#xA;				RegisteredClients.Instance.Add(asyncresult);&#xD;&#xA;	&#xD;&#xA;				return asyncresult;&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void EndProcessRequest(IAsyncResult ar)&#xD;&#xA;		{&#xD;&#xA;			AsyncResult result = (AsyncResult)ar;&#xD;&#xA;			if (result != null)&#xD;&#xA;			{&#xD;&#xA;				result.Context.Response.Cache.SetCacheability(HttpCacheability.NoCache);&#xD;&#xA;				result.Context.Response.ContentType = ""application/octet-stream"";&#xD;&#xA;				result.Context.Response.AddHeader(""Connection"", ""keep-alive"");&#xD;&#xA;	&#xD;&#xA;				if (result.Data != null)&#xD;&#xA;					result.Context.Response.OutputStream.Write(result.Data, 0, result.DataLength);&#xD;&#xA;	&#xD;&#xA;				result.Close();&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void ProcessRequest(HttpContext context){}&#xD;&#xA;	&#xD;&#xA;		public bool IsReusable { get { return true; } }&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;";;added 210 characters in body
146666003;6123453;-1;5;e0e9fe53-e336-4415-8e1d-ed286925c287;2017-05-23 11:55:37.0;"<h1>Solved:</h1><b>I found the solution to this. </b><s>Not sure why it happens but</s><b> Switching the application pool type to 'classic' from 'integrated' solves the problem. Now the 'Requests Executing' keeps going up, the actual application pool process thread remains low (~31 threads) and the app is *very* responsive (as it should be).&#xD;&#xA;<br><br><s>I'm using .Net 2.0 so maybe there is an issue there - tried to google it but no luck.</s>&#xD;&#xA;</b>&#xD;&#xA;<hr>&#xD;&#xA;<b>See [Joe Enzminger's reply for an explanation](https://stackoverflow.com/questions/6123453/problem-with-ihttpasynchandler-and-asp-net-requests-executing-counter/6128861#6128861)&#xD;&#xA;</b>&#xD;&#xA;<hr>&#xD;&#xA;Thank you all again.&#xD;&#xA;<br/><br/><i>ps. the code is used for playing pool (billiards) online - windows (free) version [here](http://poolrebel.com) for anyone curious and brave enough to try :)</i>&#xD;&#xA;<hr/>&#xD;&#xA;&#xD;&#xA;Hello,&#xD;&#xA;&#xD;&#xA;I've implemented an IHttpAsyncHandler that client applications ""poll"" to wait for server notifications. Notifications are generated by other ""activities"" on the server and the Async Handler does no work at all.&#xD;&#xA;&#xD;&#xA;The execution steps are:&#xD;&#xA;&#xD;&#xA;    IHttpAsyncHandler.BeginProcessRequest&#xD;&#xA;&#xD;&#xA;        Create AsyncResult instance and add it to a ""registered clients"" collection&#xD;&#xA;&#xD;&#xA;        return the AsyncResult&#xD;&#xA;&#xD;&#xA;<i>...other server activity will generate notifications to be sent to registered clients...</i>&#xD;&#xA;&#xD;&#xA;    AsyncResult.CompleteCall called as a result of the generated notification(s).&#xD;&#xA;&#xD;&#xA;    IHttpAsyncHandler.EndProcessRequest is called&#xD;&#xA;&#xD;&#xA;        The notification(s) attached to the AsyncResult are written to the response stream.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;<b>The problem:</b>&#xD;&#xA;&#xD;&#xA;I've tested this on IIS7 on a VM with Windows Server 2008 SP2 and 1 cpu core. After 12 clients register for notifications (using an HTTP GET on the Async.ashx) the performance is degraded to the point that subsequent clients cannot connect.&#xD;&#xA;&#xD;&#xA;When I check the ASP.NET performance counters the ""Requests Executing"" counter goes up with each client registration and stays at 12 (which appears to be its maximum value - probably a thread pool size per CPU). &#xD;&#xA;&#xD;&#xA;I find this very confusing. I though the whole point of async handlers is to free up threads for other connections. It appears that this is not the case so I must be doing something wrong!&#xD;&#xA;&#xD;&#xA;Why is ASP.NET consuming a thread while waiting for my AsyncResult to complete? Is this a config issue? Do I need to do something specific to indicate that this is an Async Handler?&#xD;&#xA;&#xD;&#xA;Thank you,&#xD;&#xA;Nikos.&#xD;&#xA;&#xD;&#xA;<b>Edit: Added code below:</b><br>&#xD;&#xA;	&#xD;&#xA;	public class AsyncResult : IAsyncResult&#xD;&#xA;	{&#xD;&#xA;		private AsyncCallback _cb;&#xD;&#xA;		private object _state;&#xD;&#xA;		private ManualResetEvent _event;&#xD;&#xA;		private bool _completed;&#xD;&#xA;		private bool _completedsynchronously;&#xD;&#xA;		private HttpContext _context;&#xD;&#xA;		private byte[] _data;&#xD;&#xA;		private int _datalength;&#xD;&#xA;		private object _lock = new object();&#xD;&#xA;		&#xD;&#xA;		public AsyncWaitResult(AsyncCallback cb, object state, HttpContext context)&#xD;&#xA;		{&#xD;&#xA;			_context = context;&#xD;&#xA;			_cb = cb;&#xD;&#xA;			_state = state;&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public void Close()&#xD;&#xA;		{&#xD;&#xA;			if (_event != null)&#xD;&#xA;			{&#xD;&#xA;				_event.Close();&#xD;&#xA;				_event = null;&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public HttpContext Context { get { return _context; } }&#xD;&#xA;		public Object AsyncState { get { return _state; } }&#xD;&#xA;		public bool CompletedSynchronously { get { return _completedsynchronously; } }&#xD;&#xA;		public bool IsCompleted { get { return _completed; } }&#xD;&#xA;		public byte[] Data { get { return _data; } }&#xD;&#xA;		public int DataLength { get { return _datalength; } }&#xD;&#xA;		&#xD;&#xA;		public WaitHandle AsyncWaitHandle&#xD;&#xA;		{&#xD;&#xA;			get&#xD;&#xA;			{&#xD;&#xA;				lock (_lock)&#xD;&#xA;				{&#xD;&#xA;					if (_event == null)&#xD;&#xA;						_event = new ManualResetEvent(_completed);&#xD;&#xA;					return _event;&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;		&#xD;&#xA;		public void CompleteCall(byte[] data, int length, bool completedsynchronously)&#xD;&#xA;		{&#xD;&#xA;			_data = data;&#xD;&#xA;			_datalength = length;&#xD;&#xA;			_completedsynchronously = completedsynchronously;&#xD;&#xA;		&#xD;&#xA;			lock (_lock)&#xD;&#xA;			{&#xD;&#xA;				_completed = true;&#xD;&#xA;				if (_event != null)&#xD;&#xA;					_event.Set();&#xD;&#xA;			}&#xD;&#xA;		&#xD;&#xA;			if (_cb != null)&#xD;&#xA;				_cb(this);&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;	&#xD;&#xA;	&#xD;&#xA;	public class Outbound : IHttpAsyncHandler&#xD;&#xA;	{&#xD;&#xA;		public IAsyncResult BeginProcessRequest(HttpContext context, AsyncCallback cb, object state)&#xD;&#xA;		{&#xD;&#xA;				AsyncResult asyncresult = new AsyncResult(cb, state, context);&#xD;&#xA;				&#xD;&#xA;				RegisteredClients.Instance.Add(asyncresult);&#xD;&#xA;	&#xD;&#xA;				return asyncresult;&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void EndProcessRequest(IAsyncResult ar)&#xD;&#xA;		{&#xD;&#xA;			AsyncResult result = (AsyncResult)ar;&#xD;&#xA;			if (result != null)&#xD;&#xA;			{&#xD;&#xA;				result.Context.Response.Cache.SetCacheability(HttpCacheability.NoCache);&#xD;&#xA;				result.Context.Response.ContentType = ""application/octet-stream"";&#xD;&#xA;				result.Context.Response.AddHeader(""Connection"", ""keep-alive"");&#xD;&#xA;	&#xD;&#xA;				if (result.Data != null)&#xD;&#xA;					result.Context.Response.OutputStream.Write(result.Data, 0, result.DataLength);&#xD;&#xA;	&#xD;&#xA;				result.Close();&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void ProcessRequest(HttpContext context){}&#xD;&#xA;	&#xD;&#xA;		public bool IsReusable { get { return true; } }&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
