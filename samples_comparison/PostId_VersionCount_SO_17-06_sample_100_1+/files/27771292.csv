Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
80918994;27771292;2547229;2;ec0b162a-ec73-445c-9950-6542a5fc57c1;2015-01-04 22:58:35.0;"I spent a while looking for a robust algorithm to do this on the sphere and didn't even find good pseudocode, let alone working c code.&#xD;&#xA;&#xD;&#xA;The problem is known as [""Point in Polygon""](http://en.wikipedia.org/wiki/Point_in_polygon). &#xD;&#xA;&#xD;&#xA;Most versions rely on a point at infinity, but this doesn't exist for a sphere. You can get away with this if you have a known point either inside or outside of any given query polygon. Given your dataset, this isn't an onerous requirement. You can easily pick any point in the sea, and this will be outside of all of the land polygons.&#xD;&#xA;&#xD;&#xA;The ""winding number"" approach also fails (as far as I can see) because you can approach any edge in two directions.&#xD;&#xA;&#xD;&#xA;I wanted an approach that would work without any auxiliary point. The approach that I came up with works like this…&#xD;&#xA;&#xD;&#xA; * You'll need to loop through your polygons yourself. For each polygon…&#xD;&#xA; * Find a great circle through your query point and through at least one _edge_ of your polygon (a mid point between two corners will do).&#xD;&#xA; * Intersect the great circle with your polygon's edges.&#xD;&#xA; * The inside of the polygon is to your right as you walk its edges in sequence (or to the left, if you prefer). This gives each intersection point sufficient information to know on which side is the inside or outside.&#xD;&#xA; * From this, you can determine if your query point is inside or outside.&#xD;&#xA;&#xD;&#xA;If you plan on implementing this, _don't_ try to work in sine or cosine. Represent your points (polygon corners & query point) as unit vectors. Represent your great circles (polygon edges and the circle the query point is on) as unit vectors to the normal. Use the dot product and cross product. Don't think in angles. Think in vectors.&#xD;&#xA;&#xD;&#xA;It shouldn't be too hard – I didn't need it quite enough to be bothered implementing it. Good luck! Get in contact if you'd like it written freelance!";;
80919346;27771292;2547229;5;cdc15aea-72c1-492a-b70a-9e1d3bf9ef7f;2015-01-04 23:10:06.0;"I spent a while looking for a robust algorithm to do this on the sphere and didn't even find good pseudocode, let alone working c code that I was happy with.&#xD;&#xA;&#xD;&#xA;The problem is known as [""Point in Polygon""](http://en.wikipedia.org/wiki/Point_in_polygon). &#xD;&#xA;&#xD;&#xA;Most versions rely on a point at infinity, but this doesn't exist for a sphere. You can get away with this if you have a known point either inside or outside of any given query polygon. Given your dataset, this isn't an onerous requirement. You can easily pick any point in the sea, and this will be outside of all of the land polygons.&#xD;&#xA;&#xD;&#xA;The ""winding number"" approach also fails (as far as I can see) because you can approach any edge in two directions.&#xD;&#xA;&#xD;&#xA;#An Algorithm&#xD;&#xA;I wanted an approach that would work without any auxiliary point. The approach that I came up with works like this…&#xD;&#xA;&#xD;&#xA; * You'll need to loop through your polygons yourself. For each polygon…&#xD;&#xA; * Find a great circle through your query point and through at least one _edge_ of your polygon (a mid point between two corners will do).&#xD;&#xA; * Intersect the great circle with your polygon's edges.&#xD;&#xA; * The inside of the polygon is to your right as you walk its edges in sequence (or to the left, if you prefer). This gives each intersection point sufficient information to know on which side is the inside or outside.&#xD;&#xA; * From this, you can determine if your query point is inside or outside.&#xD;&#xA;&#xD;&#xA;If you plan on implementing this, _don't_ try to work in sine or cosine. Represent your points (polygon corners & query point) as unit vectors. Represent your great circles (polygon edges and the circle the query point is on) as unit vectors to the normal. Use the dot product and cross product. Don't think in angles. Think in vectors.&#xD;&#xA;&#xD;&#xA;It shouldn't be too hard – I didn't need it quite enough to be bothered implementing it. Good luck! Get in contact if you'd like it written freelance!&#xD;&#xA;&#xD;&#xA;# Maybe Handy Links.&#xD;&#xA;Oh, here're [some algorithms by NASA](http://trs-new.jpl.nasa.gov/dspace/bitstream/2014/40409/3/JPL%20Pub%2007-3%20%20w%20Errata.pdf) for points and spheres (I didn't like there POP though.&#xD;&#xA;&#xD;&#xA;The c++ boost library has a [POP implementation](http://barendgehrels.blogspot.co.uk/2011/06/spherical-side-formula.html)&#xD;&#xA;&#xD;&#xA;The [tz_world](http://efele.net/maps/tz/world/) database contains polygons for land masses, and there is a [GeoJSON variant](https://github.com/straup/whereonearth-timezone) of it.";;added 561 characters in body
80919506;27771292;2547229;5;d59a0284-0321-4796-9481-62491495f580;2015-01-04 23:16:03.0;"I spent a while looking for a robust algorithm to do this on the sphere and didn't even find good pseudocode, let alone working c code that I was happy with.&#xD;&#xA;&#xD;&#xA;The problem is known as [""Point in Polygon""](http://en.wikipedia.org/wiki/Point_in_polygon). &#xD;&#xA;&#xD;&#xA;The flat version of POP relies on a point at infinity, but this doesn't exist for a sphere. You can get away with this if you have a known point either inside or outside of any given query polygon. Given your use case, this is not an onerous requirement. You can easily pick any point in the sea, and this will be outside of all of the land polygons.&#xD;&#xA;&#xD;&#xA;The ""winding number"" approach also fails (as far as I can see) because you can approach any edge in two directions.&#xD;&#xA;&#xD;&#xA;#An Algorithm&#xD;&#xA;I wanted an approach that would work without an auxiliary point and without heuristics (used to generate an auxiliary point from the edge data). If I'm _honest_, I wanted this because I was convinced it should be possible, rather than because I genuinely needed it. &#xD;&#xA;&#xD;&#xA;For your use case, you can get away with the usual implementation and a single point known to be in the ocean.&#xD;&#xA;&#xD;&#xA;The approach that I came up with works like this…&#xD;&#xA;&#xD;&#xA; * You'll need to loop through your polygons yourself. For each polygon…&#xD;&#xA; * Find a great circle through your query point and through at least one _edge_ of your polygon (a mid point between two corners will do).&#xD;&#xA; * Intersect the great circle with your polygon's edges.&#xD;&#xA; * The inside of the polygon is to your right as you walk its edges in sequence (or to the left, if you prefer). This gives each intersection point sufficient information to know on which side is the inside or outside.&#xD;&#xA; * From this, you can determine if your query point is inside or outside.&#xD;&#xA;&#xD;&#xA;#Implementation Tips&#xD;&#xA;If you plan on implementing this (or any of the other POP algorithms), _don't_ try to work in sine or cosine.&#xD;&#xA;&#xD;&#xA;Represent your points (polygon corners & query point) as unit vectors. Represent your great circles (polygon edges and the circle the query point is on) as unit vectors to the normal of the plane that the circle is on. Use the dot product and cross product. Don't think in angles. Think in vectors.&#xD;&#xA;&#xD;&#xA;It shouldn't be too hard – I didn't need it quite enough to be bothered implementing anything. Get in contact if you'd like it written freelance!&#xD;&#xA;&#xD;&#xA;# Maybe Handy Links.&#xD;&#xA;Oh, here're [some algorithms by NASA](http://trs-new.jpl.nasa.gov/dspace/bitstream/2014/40409/3/JPL%20Pub%2007-3%20%20w%20Errata.pdf) for points and spheres (I didn't like their POP though).&#xD;&#xA;&#xD;&#xA;The c++ boost library has a [POP implementation](http://barendgehrels.blogspot.co.uk/2011/06/spherical-side-formula.html) that I also didn't like.&#xD;&#xA;&#xD;&#xA;The [tz_world](http://efele.net/maps/tz/world/) database contains polygons for land masses, and there is a [GeoJSON variant](https://github.com/straup/whereonearth-timezone) of it.";;added 561 characters in body
80919745;27771292;2547229;5;b09275b2-ed4a-4590-8612-f6e43c381a18;2015-01-04 23:25:35.0;"I spent a while looking for a robust algorithm to do this on the sphere and didn't even find good pseudocode, let alone working c code that I was happy with.&#xD;&#xA;&#xD;&#xA;#It's Easy. On the Plane.&#xD;&#xA;The problem is known as [""Point in Polygon""](http://en.wikipedia.org/wiki/Point_in_polygon). &#xD;&#xA;&#xD;&#xA;The most usual POP algorithm is [""Ray Casting""](http://en.wikipedia.org/wiki/Point_in_polygon#Ray_casting_algorithm). POP on the 2D plane relies on a point at infinity. On the plane this is very easy. There are an infinite number of points at infinity. Pick any one! But there is no such point on the sphere.&#xD;&#xA;&#xD;&#xA;You can get away with this if you have a known point either inside or outside of any given query polygon. Given your use case, this is not an onerous requirement: you can easily pick any _single_ point in the sea, and this will be outside of _all_ of the land polygons.&#xD;&#xA;&#xD;&#xA;The [""Winding Number""](http://en.wikipedia.org/wiki/Point_in_polygon#Winding_number_algorithm) POP algorithm also fails (as far as I can see) because on the sphere you can approach any edge in either of two directions.&#xD;&#xA;&#xD;&#xA;#An Algorithm&#xD;&#xA;I wanted an approach that would work without an auxiliary point and without heuristics (used to generate an auxiliary point from the edge data). If I'm _honest_, I wanted this because I was convinced it _should_ be possible, no because I genuinely needed it.&#xD;&#xA;&#xD;&#xA;For your use case, you can get away with the usual ray casting algorithm and a single point known to be in the ocean.&#xD;&#xA;&#xD;&#xA;The approach that I came up with works like this…&#xD;&#xA;&#xD;&#xA; * You'll need to loop through your polygons yourself. For each polygon…&#xD;&#xA; * Find a great circle through your query point and through at least one _edge_ of your polygon (a mid point between two corners will do).&#xD;&#xA; * Intersect the great circle with your polygon's edges.&#xD;&#xA; * The inside of the polygon is to your right as you walk its edges in sequence (or to the left, if you prefer). This gives each intersection point sufficient information to know on which side is the inside or outside.&#xD;&#xA; * From the nearest intersection point, you can determine if your query point is inside or outside.&#xD;&#xA;&#xD;&#xA;#Implementation Tips&#xD;&#xA;If you plan on implementing this (or any of the other POP algorithms), _don't_ try to work in sine or cosine.&#xD;&#xA;&#xD;&#xA;Represent your points (polygon corners & query point) as unit vectors. Represent your great circles (polygon edges and the circle the query point is on) as unit vectors normal to the plane that the great is on. Use the dot product and cross product. Don't think in angles. Think in vectors.&#xD;&#xA;&#xD;&#xA;It shouldn't be too hard – I didn't need it quite enough to implement it. Get in contact if you'd like it written freelance!&#xD;&#xA;&#xD;&#xA;# Maybe Handy Links.&#xD;&#xA;Oh, here are some [algorithms by NASA](http://trs-new.jpl.nasa.gov/dspace/bitstream/2014/40409/3/JPL%20Pub%2007-3%20%20w%20Errata.pdf) for points and spheres (I didn't like their POP though).&#xD;&#xA;&#xD;&#xA;The c++ boost library has a [POP implementation](http://barendgehrels.blogspot.co.uk/2011/06/spherical-side-formula.html) that I also didn't like.&#xD;&#xA;&#xD;&#xA;The [tz_world](http://efele.net/maps/tz/world/) database contains polygons for land masses, and there is a [GeoJSON variant](https://github.com/straup/whereonearth-timezone) of it.";;added 561 characters in body
80920106;27771292;2547229;5;7da20eae-a859-4b8b-9fc4-0fe5c82d4fc8;2015-01-04 23:39:29.0;"I spent a while looking for a robust algorithm to do this on the sphere and didn't even find good pseudocode, let alone working c code that I was happy with.&#xD;&#xA;&#xD;&#xA;#It's Easy …On the Plane&#xD;&#xA;The problem is known as [""Point in Polygon""](http://en.wikipedia.org/wiki/Point_in_polygon). &#xD;&#xA;&#xD;&#xA;A frequently used and simple POP algorithm is [""Ray Casting""](http://en.wikipedia.org/wiki/Point_in_polygon#Ray_casting_algorithm). POP on the 2D plane relies on a point at infinity. On the plane this is very easy. There are an infinite number of points at infinity. Pick any one! But there is no such point on the sphere.&#xD;&#xA;&#xD;&#xA;You can get away with this if you have a known point either inside or outside of any given query polygon. Given your use case, this is not an onerous requirement: you can easily pick any _single_ point in the sea, and this will be outside of _all_ of the land polygons.&#xD;&#xA;&#xD;&#xA;The [""Winding Number""](http://en.wikipedia.org/wiki/Point_in_polygon#Winding_number_algorithm) POP algorithm also fails (as far as I can see) because on the sphere you can approach any edge in either of two directions.&#xD;&#xA;&#xD;&#xA;#An Algorithm&#xD;&#xA;I wanted an approach that would work without an auxiliary point and without heuristics (used to generate an auxiliary point from the edge data). If I'm _honest_, I wanted this because I was convinced it _should_ be possible, no because I genuinely needed it.&#xD;&#xA;&#xD;&#xA;For your use case, you can get away with the usual ray casting algorithm and a single point known to be in the ocean.&#xD;&#xA;&#xD;&#xA;The approach that I came up with works like this…&#xD;&#xA;&#xD;&#xA; * You'll need to loop through your polygons yourself. For each polygon…&#xD;&#xA; * Find a great circle through your query point and through at least one _edge_ of your polygon (a mid point between two corners will do).&#xD;&#xA; * Intersect the great circle with your polygon's edges.&#xD;&#xA; * The inside of the polygon is to your right as you walk its edges in sequence (or to the left, if you prefer). This gives each intersection point sufficient information to know on which side is the inside or outside.&#xD;&#xA; * From the nearest intersection point, you can determine if your query point is inside or outside.&#xD;&#xA;&#xD;&#xA;#Implementation Tips&#xD;&#xA;If you plan on implementing this (or any of the other POP algorithms), _don't_ try to work in sine or cosine.&#xD;&#xA;&#xD;&#xA;Represent your points (polygon corners & query point) as unit vectors. Represent your great circles (polygon edges and the circle the query point is on) as unit vectors normal to the plane that the great is on. Use the dot product and cross product. Don't think in angles. Think in vectors.&#xD;&#xA;&#xD;&#xA;It shouldn't be too hard – I didn't need it quite enough to implement it. Get in contact if you'd like it written freelance!&#xD;&#xA;&#xD;&#xA;# Maybe Handy Links&#xD;&#xA;Here are some [algorithms by NASA](http://trs-new.jpl.nasa.gov/dspace/bitstream/2014/40409/3/JPL%20Pub%2007-3%20%20w%20Errata.pdf) for points and spheres (I didn't like their POP though).&#xD;&#xA;&#xD;&#xA;The c++ boost library has a [POP implementation](http://barendgehrels.blogspot.co.uk/2011/06/spherical-side-formula.html) that I also didn't like.&#xD;&#xA;&#xD;&#xA;The [tz_world](http://efele.net/maps/tz/world/) database contains polygons for land masses, and there is a [GeoJSON variant](https://github.com/straup/whereonearth-timezone) of it.";;deleted 4 characters in body
81243985;27771292;2547229;5;28b80fb6-c85b-40c0-a6a3-c15d3264989b;2015-01-09 09:27:29.0;"I spent a while looking for a robust algorithm to do this on the sphere and didn't even find good pseudocode, let alone working c code that I was happy with.&#xD;&#xA;&#xD;&#xA;#It's Easy …On the Plane&#xD;&#xA;The problem is known as [""Point in Polygon""](http://en.wikipedia.org/wiki/Point_in_polygon). &#xD;&#xA;&#xD;&#xA;A frequently used and simple POP algorithm is [""Ray Casting""](http://en.wikipedia.org/wiki/Point_in_polygon#Ray_casting_algorithm). POP on the 2D plane relies on a point at infinity. On the plane this is very easy. There are an infinite number of points at infinity. Pick any one! But there is no such point on the sphere.&#xD;&#xA;&#xD;&#xA;You can get away with this if you have a known point either inside or outside of any given query polygon. Given your use case, this is not an onerous requirement: you can easily pick any _single_ point in the sea, and this will be outside of _all_ of the land polygons.&#xD;&#xA;&#xD;&#xA;The [""Winding Number""](http://en.wikipedia.org/wiki/Point_in_polygon#Winding_number_algorithm) POP algorithm also fails (as far as I can see) because on the sphere you can approach any edge in either of two directions.&#xD;&#xA;&#xD;&#xA;#An Algorithm&#xD;&#xA;I wanted an approach that would work without an auxiliary point and without heuristics (used to generate an auxiliary point from the edge data). If I'm _honest_, I wanted this because I was convinced it _should_ be possible, no because I genuinely needed it.&#xD;&#xA;&#xD;&#xA;For your use case, you can get away with the usual ray casting algorithm and a single point known to be in the ocean.&#xD;&#xA;&#xD;&#xA;The approach that I came up with works like this…&#xD;&#xA;&#xD;&#xA; * You'll need to loop through your polygons yourself. For each polygon…&#xD;&#xA; * Find a great circle through your query point and through at least one _edge_ of your polygon (a mid point between two corners will do).&#xD;&#xA; * Intersect the great circle with your polygon's edges.&#xD;&#xA; * The inside of the polygon is to your right as you walk its edges in sequence (or to the left, if you prefer). This gives each intersection point sufficient information to know on which side is the inside or outside.&#xD;&#xA; * From the nearest intersection point, you can determine if your query point is inside or outside.&#xD;&#xA;&#xD;&#xA;#Implementation Tips&#xD;&#xA;If you plan on implementing this (or any of the other POP algorithm on the sphere), _don't_ try to work in sine or cosine.&#xD;&#xA;&#xD;&#xA;Represent your points (polygon corners & query point) as unit vectors. Represent your great circles (polygon edges and the circle the query point is on) as unit vectors normal to the plane that the great is on. Use the dot product and cross product. Don't think in angles. Think in vectors.&#xD;&#xA;&#xD;&#xA;It shouldn't be too hard – I didn't need it quite enough to implement it. Get in contact if you'd like it written freelance!&#xD;&#xA;&#xD;&#xA;# Maybe Handy Links&#xD;&#xA;Here are some [algorithms by NASA](http://trs-new.jpl.nasa.gov/dspace/bitstream/2014/40409/3/JPL%20Pub%2007-3%20%20w%20Errata.pdf) for points and spheres (I didn't like their POP though).&#xD;&#xA;&#xD;&#xA;The c++ boost library has a [POP implementation](http://barendgehrels.blogspot.co.uk/2011/06/spherical-side-formula.html) that I also didn't like.&#xD;&#xA;&#xD;&#xA;The [tz_world](http://efele.net/maps/tz/world/) database contains polygons for land masses, and there is a [GeoJSON variant](https://github.com/straup/whereonearth-timezone) of it.";;added 13 characters in body
81244655;27771292;2547229;5;47aec557-5d49-40e1-a233-b16deecb2981;2015-01-09 09:35:47.0;"I spent a while looking for a robust algorithm to do this on the sphere and didn't even find good pseudocode, let alone c / c++ _I was entirely happy with_. I'm going to run through what I found. I'll finish with resources that could be used to put this together fairly easily.&#xD;&#xA;&#xD;&#xA;#It's Easy …On the Plane&#xD;&#xA;The problem is known as [""Point in Polygon""](http://en.wikipedia.org/wiki/Point_in_polygon). &#xD;&#xA;&#xD;&#xA;A frequently used and simple POP algorithm is [""Ray Casting""](http://en.wikipedia.org/wiki/Point_in_polygon#Ray_casting_algorithm). POP on the 2D plane relies on a point at infinity. On the plane this is very easy. There are an infinite number of points at infinity. Pick any one! But there is no such point on the sphere.&#xD;&#xA;&#xD;&#xA;You can get away with this if you have a known point either inside or outside of any given query polygon. Given your use case, this is not an onerous requirement: you can easily pick any _single_ point in the sea, and this will be outside of _all_ of the land polygons.&#xD;&#xA;&#xD;&#xA;The [""Winding Number""](http://en.wikipedia.org/wiki/Point_in_polygon#Winding_number_algorithm) POP algorithm also fails (as far as I can see) because on the sphere you can approach any edge in either of two directions.&#xD;&#xA;&#xD;&#xA;#An Algorithm&#xD;&#xA;I wanted an approach that would work without an auxiliary point and without heuristics (used to generate an auxiliary point from the edge data). If I'm _honest_, I wanted this because I was convinced it _should_ be possible, no because I genuinely needed it.&#xD;&#xA;&#xD;&#xA;For your use case, you can get away with the usual ray casting algorithm and a single point known to be in the ocean.&#xD;&#xA;&#xD;&#xA;The approach that I came up with works like this…&#xD;&#xA;&#xD;&#xA; * You'll need to loop through your polygons yourself. For each polygon…&#xD;&#xA; * Find a great circle through your query point and through at least one _edge_ of your polygon (a mid point between two corners will do).&#xD;&#xA; * Intersect the great circle with your polygon's edges.&#xD;&#xA; * The inside of the polygon is to your right as you walk its edges in sequence (or to the left, if you prefer). This gives each intersection point sufficient information to know on which side is the inside or outside.&#xD;&#xA; * From the nearest intersection point, you can determine if your query point is inside or outside.&#xD;&#xA;&#xD;&#xA;#Implementation Tips&#xD;&#xA;If you plan on implementing this (or any of the other POP algorithms), _don't_ try to work in sine or cosine.&#xD;&#xA;&#xD;&#xA;Represent your points (polygon corners & query point) as unit vectors. Represent your great circles (polygon edges and the circle the query point is on) as unit vectors normal to the plane that the circle is on. Use the dot product and cross product. Don't think in angles. Think in vectors.&#xD;&#xA;&#xD;&#xA;It shouldn't be too hard – I didn't need it quite enough to implement it. Get in contact if you'd like it written freelance!&#xD;&#xA;&#xD;&#xA;# Links From Which You Could Build a Solution&#xD;&#xA;The c++ boost library has a [POP implementation](http://barendgehrels.blogspot.co.uk/2011/06/spherical-side-formula.html) that I also didn't like but this is largely because I'm a perfectionist – I imagine it will serve the purpose in nearly all cases.&#xD;&#xA;&#xD;&#xA;The [tz_world](http://efele.net/maps/tz/world/) database contains polygons for land masses, and there is a [GeoJSON variant](https://github.com/straup/whereonearth-timezone) of it. You could parse this nicely with the built in [`NSJSONSerialization`](http://stackoverflow.com/q/8356842/2547229) class.&#xD;&#xA;&#xD;&#xA;Here are some [algorithms by NASA](http://trs-new.jpl.nasa.gov/dspace/bitstream/2014/40409/3/JPL%20Pub%2007-3%20%20w%20Errata.pdf) for points and spheres (I didn't like their POP though).&#xD;&#xA;&#xD;&#xA;";;added 377 characters in body
81245045;27771292;2547229;5;e2127a7c-5fb6-4f22-9ba0-981acd1d18f3;2015-01-09 09:41:16.0;"I spent a while looking for a robust algorithm to do this on the sphere and didn't even find good pseudocode, let alone c / c++ _I was entirely happy with_. I'm going to run through what I found. I'll finish with resources that could be used to put this together fairly easily.&#xD;&#xA;&#xD;&#xA;#It's Easy …On the Plane&#xD;&#xA;The problem is known as [""Point in Polygon""](http://en.wikipedia.org/wiki/Point_in_polygon). &#xD;&#xA;&#xD;&#xA;A frequently used and simple POP algorithm is [""Ray Casting""](http://en.wikipedia.org/wiki/Point_in_polygon#Ray_casting_algorithm). POP on the 2D plane relies on a point at infinity. On the plane this is very easy. There are an infinite number of points at infinity. Pick any one! But there is no such point on the sphere.&#xD;&#xA;&#xD;&#xA;You can get away with this if you have a known point either inside or outside of any given query polygon. Given your use case, this is not an onerous requirement: you can easily pick any _single_ point in the sea, and this will be outside of _all_ of the land polygons.&#xD;&#xA;&#xD;&#xA;The [""Winding Number""](http://en.wikipedia.org/wiki/Point_in_polygon#Winding_number_algorithm) POP algorithm also fails (as far as I can see) because on the sphere you can approach any edge in either of two directions.&#xD;&#xA;&#xD;&#xA;#An Algorithm&#xD;&#xA;I wanted an approach that would work without an auxiliary point and without heuristics (used to generate an auxiliary point from the edge data). If I'm _honest_, I wanted this because I was convinced it _should_ be possible, no because I genuinely needed it.&#xD;&#xA;&#xD;&#xA;**For your use case, you can get away with the usual ray casting algorithm and a single point known to be in the ocean,** so you don't need to rely on heuristics, although they probably work fairly well anyway.&#xD;&#xA;&#xD;&#xA;The approach that I came up with works like this…&#xD;&#xA;&#xD;&#xA; * You'll need to loop through your polygons yourself. For each polygon…&#xD;&#xA; * Find a great circle through your query point and through at least one _edge_ of your polygon (a mid point between two corners will do).&#xD;&#xA; * Intersect the great circle with your polygon's edges.&#xD;&#xA; * The inside of the polygon is to your right as you walk its edges in sequence (or to the left, if you prefer). This gives each intersection point sufficient information to know on which side is the inside or outside.&#xD;&#xA; * From the nearest intersection point, you can determine if your query point is inside or outside.&#xD;&#xA;&#xD;&#xA;#Implementation Tips&#xD;&#xA;If you plan on implementing this (or any of the other POP algorithms), _don't_ try to work in sine or cosine.&#xD;&#xA;&#xD;&#xA;Represent your points (polygon corners & query point) as unit vectors. Represent your great circles (polygon edges and the circle the query point is on) as unit vectors normal to the plane that the great is on. Use the dot product and cross product. Don't think in angles. Think in vectors.&#xD;&#xA;&#xD;&#xA;It shouldn't be too hard – I didn't need it quite enough to implement it. Get in contact if you'd like it written freelance!&#xD;&#xA;&#xD;&#xA;# Links From Which You Could Build a Solution&#xD;&#xA;The c++ boost library has a [POP implementation](http://barendgehrels.blogspot.co.uk/2011/06/spherical-side-formula.html) that I also didn't like but this is largely because I'm a perfectionist – I imagine it will serve the purpose in nearly all cases.&#xD;&#xA;&#xD;&#xA;The [tz_world](http://efele.net/maps/tz/world/) database contains polygons for land masses, and there is a [GeoJSON variant](https://github.com/straup/whereonearth-timezone) of it. You could parse this nicely with the built in [`NSJSONSerialization`](http://stackoverflow.com/q/8356842/2547229) class.&#xD;&#xA;&#xD;&#xA;Here are some [algorithms by NASA](http://trs-new.jpl.nasa.gov/dspace/bitstream/2014/40409/3/JPL%20Pub%2007-3%20%20w%20Errata.pdf) for points and spheres (I didn't like their POP though).&#xD;&#xA;&#xD;&#xA;";;added 377 characters in body
81334561;27771292;2547229;5;7530dfe3-37d1-439b-8c9c-a0fb8056615c;2015-01-10 17:38:02.0;"I spent a while looking for a robust algorithm to do this on the sphere for time zone look up and didn't even find good pseudocode, let alone c / c++ _I was entirely happy with_. I'm going to run through what I found. I'll finish with resources that could be used to put this together fairly easily.&#xD;&#xA;&#xD;&#xA;#It's Easy …On the Plane&#xD;&#xA;The problem is known as [""Point in Polygon""](http://en.wikipedia.org/wiki/Point_in_polygon). &#xD;&#xA;&#xD;&#xA;A frequently used and simple POP algorithm is [""Ray Casting""](http://en.wikipedia.org/wiki/Point_in_polygon#Ray_casting_algorithm). POP on the 2D plane relies on a point at infinity. On the plane this is very easy. There are an infinite number of points at infinity. Pick any one! But there is no such point on the sphere.&#xD;&#xA;&#xD;&#xA;You can get away with this if you have a known point either inside or outside of any given query polygon. Given your use case, this is not an onerous requirement: you can easily pick any _single_ point in the sea, and this will be outside of _all_ of the land polygons.&#xD;&#xA;&#xD;&#xA;The [""Winding Number""](http://en.wikipedia.org/wiki/Point_in_polygon#Winding_number_algorithm) POP algorithm also fails (as far as I can see) because on the sphere you can approach any edge in either of two directions.&#xD;&#xA;&#xD;&#xA;#An Algorithm&#xD;&#xA;I wanted an approach that would work without an auxiliary point and without heuristics (used to generate an auxiliary point from the edge data). If I'm _honest_, I wanted this because I was convinced it _should_ be possible, no because I genuinely needed it.&#xD;&#xA;&#xD;&#xA;**For your use case, you can get away with the usual ray casting algorithm and a single point known to be in the ocean,** so you don't need to rely on heuristics, although they probably work fairly well anyway.&#xD;&#xA;&#xD;&#xA;The approach that I came up with works like this…&#xD;&#xA;&#xD;&#xA; * You'll need to loop through your polygons yourself. For each polygon…&#xD;&#xA; * Find a great circle through your query point and through at least one _edge_ of your polygon (a mid point between two corners will do).&#xD;&#xA; * Intersect the great circle with your polygon's edges.&#xD;&#xA; * The inside of the polygon is to your right as you walk its edges in sequence (or to the left, if you prefer). This gives each intersection point sufficient information to know on which side is the inside or outside.&#xD;&#xA; * From the nearest intersection point, you can determine if your query point is inside or outside.&#xD;&#xA;&#xD;&#xA;#Implementation Tips&#xD;&#xA;If you plan on implementing this (or any of the other POP algorithms), _don't_ try to work in sine or cosine.&#xD;&#xA;&#xD;&#xA;Represent your points (polygon corners & query point) as unit vectors. Represent your great circles (polygon edges and the circle the query point is on) as unit vectors normal to the plane that the great is on. Use the dot product and cross product. Don't think in angles. Think in vectors.&#xD;&#xA;&#xD;&#xA;It shouldn't be too hard – I didn't need it quite enough to implement it. Get in contact if you'd like it written freelance!&#xD;&#xA;&#xD;&#xA;# Links From Which You Could Build a Solution&#xD;&#xA;The c++ boost library has a [POP implementation](http://barendgehrels.blogspot.co.uk/2011/06/spherical-side-formula.html) that I also didn't like but this is largely because I'm a perfectionist – I imagine it will serve the purpose in nearly all cases.&#xD;&#xA;&#xD;&#xA;The [tz_world](http://efele.net/maps/tz/world/) database contains polygons for land masses, and there is a [GeoJSON variant](https://github.com/straup/whereonearth-timezone) of it. You could parse this nicely with the built in [`NSJSONSerialization`](http://stackoverflow.com/q/8356842/2547229) class.&#xD;&#xA;&#xD;&#xA;Here are some [algorithms by NASA](http://trs-new.jpl.nasa.gov/dspace/bitstream/2014/40409/3/JPL%20Pub%2007-3%20%20w%20Errata.pdf) for points and spheres (I didn't like their POP though).&#xD;&#xA;&#xD;&#xA;";;added 22 characters in body
147463274;27771292;-1;5;518833f8-a159-4e10-a4d1-05f9533ae760;2017-05-23 12:25:08.0;"I spent a while looking for a robust algorithm to do this on the sphere for time zone look up and didn't even find good pseudocode, let alone c / c++ _I was entirely happy with_. I'm going to run through what I found. I'll finish with resources that could be used to put this together fairly easily.&#xD;&#xA;&#xD;&#xA;#It's Easy …On the Plane&#xD;&#xA;The problem is known as [""Point in Polygon""](http://en.wikipedia.org/wiki/Point_in_polygon). &#xD;&#xA;&#xD;&#xA;A frequently used and simple POP algorithm is [""Ray Casting""](http://en.wikipedia.org/wiki/Point_in_polygon#Ray_casting_algorithm). POP on the 2D plane relies on a point at infinity. On the plane this is very easy. There are an infinite number of points at infinity. Pick any one! But there is no such point on the sphere.&#xD;&#xA;&#xD;&#xA;You can get away with this if you have a known point either inside or outside of any given query polygon. Given your use case, this is not an onerous requirement: you can easily pick any _single_ point in the sea, and this will be outside of _all_ of the land polygons.&#xD;&#xA;&#xD;&#xA;The [""Winding Number""](http://en.wikipedia.org/wiki/Point_in_polygon#Winding_number_algorithm) POP algorithm also fails (as far as I can see) because on the sphere you can approach any edge in either of two directions.&#xD;&#xA;&#xD;&#xA;#An Algorithm&#xD;&#xA;I wanted an approach that would work without an auxiliary point and without heuristics (used to generate an auxiliary point from the edge data). If I'm _honest_, I wanted this because I was convinced it _should_ be possible, no because I genuinely needed it.&#xD;&#xA;&#xD;&#xA;**For your use case, you can get away with the usual ray casting algorithm and a single point known to be in the ocean,** so you don't need to rely on heuristics, although they probably work fairly well anyway.&#xD;&#xA;&#xD;&#xA;The approach that I came up with works like this…&#xD;&#xA;&#xD;&#xA; * You'll need to loop through your polygons yourself. For each polygon…&#xD;&#xA; * Find a great circle through your query point and through at least one _edge_ of your polygon (a mid point between two corners will do).&#xD;&#xA; * Intersect the great circle with your polygon's edges.&#xD;&#xA; * The inside of the polygon is to your right as you walk its edges in sequence (or to the left, if you prefer). This gives each intersection point sufficient information to know on which side is the inside or outside.&#xD;&#xA; * From the nearest intersection point, you can determine if your query point is inside or outside.&#xD;&#xA;&#xD;&#xA;#Implementation Tips&#xD;&#xA;If you plan on implementing this (or any of the other POP algorithms), _don't_ try to work in sine or cosine.&#xD;&#xA;&#xD;&#xA;Represent your points (polygon corners & query point) as unit vectors. Represent your great circles (polygon edges and the circle the query point is on) as unit vectors normal to the plane that the great is on. Use the dot product and cross product. Don't think in angles. Think in vectors.&#xD;&#xA;&#xD;&#xA;It shouldn't be too hard – I didn't need it quite enough to implement it. Get in contact if you'd like it written freelance!&#xD;&#xA;&#xD;&#xA;# Links From Which You Could Build a Solution&#xD;&#xA;The c++ boost library has a [POP implementation](http://barendgehrels.blogspot.co.uk/2011/06/spherical-side-formula.html) that I also didn't like but this is largely because I'm a perfectionist – I imagine it will serve the purpose in nearly all cases.&#xD;&#xA;&#xD;&#xA;The [tz_world](http://efele.net/maps/tz/world/) database contains polygons for land masses, and there is a [GeoJSON variant](https://github.com/straup/whereonearth-timezone) of it. You could parse this nicely with the built in [`NSJSONSerialization`](https://stackoverflow.com/q/8356842/2547229) class.&#xD;&#xA;&#xD;&#xA;Here are some [algorithms by NASA](http://trs-new.jpl.nasa.gov/dspace/bitstream/2014/40409/3/JPL%20Pub%2007-3%20%20w%20Errata.pdf) for points and spheres (I didn't like their POP though).&#xD;&#xA;&#xD;&#xA;";;replaced http://stackoverflow.com/ with https://stackoverflow.com/
